#using < System.Runtime.dll>
#using < System.Runtime.Extensions.dll>
#using < System.Runtime.InteropServices.dll>
#using < System.Runtime.CompilerServices.VisualC.dll>

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma region Input Buffer SAL 1 compatibility macros

#pragma endregion Input Buffer SAL 1 compatibility macros

extern "C"
{
}

#pragma once

extern "C"
{
}

#pragma once

#pragma pack(push, 8)

#pragma warning(push)
#pragma warning(disable : 4514 4820)

extern "C"
{
    typedef unsigned __int64 uintptr_t;

    typedef char* va_list;

    void __cdecl __va_start(va_list*, ...);
    void* __cdecl __va_arg(va_list*, ...);
    void __cdecl __va_end(va_list*);
}

extern "C++"
{
    template <typename _Ty> struct __vcrt_va_list_is_reference
    {
        enum : bool
        {
            __the_value = false
        };
    };

    template <typename _Ty> struct __vcrt_va_list_is_reference<_Ty&>
    {
        enum : bool
        {
            __the_value = true
        };
    };

    template <typename _Ty> struct __vcrt_va_list_is_reference<_Ty&&>
    {
        enum : bool
        {
            __the_value = true
        };
    };

    template <typename _Ty> struct __vcrt_assert_va_start_is_not_reference
    {
        static_assert(!__vcrt_va_list_is_reference<_Ty>::__the_value,
                      "va_start argument must not have reference type and must not be parenthesized");
    };
}

#pragma warning(pop)
#pragma pack(pop)

#pragma warning(push)
#pragma warning(disable : 4514 4820)

__pragma(pack(push, 8)) extern "C"
{
    typedef unsigned __int64 size_t;
    typedef __int64 ptrdiff_t;
    typedef __int64 intptr_t;

    typedef bool __vcrt_bool;

    extern "C++"
    {
        template <typename _CountofType, size_t _SizeOfArray>
        char (*__countof_helper(__unaligned _CountofType (&_Array)[_SizeOfArray]))[_SizeOfArray];
    }

    extern uintptr_t __security_cookie;
}
__pragma(pack(pop))

#pragma warning(pop)

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma warning(push)
#pragma warning(disable : 4514 4820)

__pragma(pack(push, 8)) extern "C"
{
}
__pragma(pack(pop))

#pragma warning(pop)

#pragma once

#pragma once

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    extern "C++"
    {
        template <bool _Enable, typename _Ty> struct _CrtEnableIf;

        template <typename _Ty> struct _CrtEnableIf<true, _Ty>
        {
            typedef _Ty _Type;
        };
    }

    typedef bool __crt_bool;

    __declspec(dllimport) void __cdecl _invalid_parameter_noinfo(void);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _invalid_parameter_noinfo_noreturn(void);

    __declspec(noreturn) __declspec(dllimport) void __cdecl _invoke_watson(
    wchar_t const* _Expression, wchar_t const* _FunctionName, wchar_t const* _FileName, unsigned int _LineNo, uintptr_t _Reserved);

    typedef int errno_t;
    typedef unsigned short wint_t;
    typedef unsigned short wctype_t;
    typedef long __time32_t;
    typedef __int64 __time64_t;

    typedef struct __crt_locale_data_public
    {
        unsigned short const* _locale_pctype;
        int _locale_mb_cur_max;
        unsigned int _locale_lc_codepage;
    } __crt_locale_data_public;

    typedef struct __crt_locale_pointers
    {
        struct __crt_locale_data* locinfo;
        struct __crt_multibyte_data* mbcinfo;
    } __crt_locale_pointers;

    typedef __crt_locale_pointers* _locale_t;

    typedef struct _Mbstatet
    {
        unsigned long _Wchar;
        unsigned short _Byte, _State;
    } _Mbstatet;

    typedef _Mbstatet mbstate_t;

    typedef __time64_t time_t;

    typedef size_t rsize_t;
}
__pragma(pack(pop))

#pragma once

#pragma once

#pragma warning(push)
#pragma warning(disable : 4514 4820)
#pragma warning(disable : 4985)

extern "C++"
{
#pragma pack(push, 8)

    namespace std
    {
        struct nothrow_t
        {
            explicit nothrow_t() = default;
        };

        extern nothrow_t const nothrow;
    }// namespace std

    [[nodiscard]] __declspec(allocator) void* __cdecl operator new(size_t _Size);

    [[nodiscard]] __declspec(allocator) void* __cdecl operator new(size_t _Size, std::nothrow_t const&) noexcept;

    [[nodiscard]] __declspec(allocator) void* __cdecl operator new[](size_t _Size);

    [[nodiscard]] __declspec(allocator) void* __cdecl operator new[](size_t _Size, std::nothrow_t const&) noexcept;

    void __cdecl operator delete(void* _Block) noexcept;

    void __cdecl operator delete(void* _Block, std::nothrow_t const&) noexcept;

    void __cdecl operator delete[](void* _Block) noexcept;

    void __cdecl operator delete[](void* _Block, std::nothrow_t const&) noexcept;

    void __cdecl operator delete(void* _Block, size_t _Size) noexcept;

    void __cdecl operator delete[](void* _Block, size_t _Size) noexcept;

#pragma warning(push)
#pragma warning(disable : 4577)
#pragma warning(disable : 4514)

    [[nodiscard]] inline void* __cdecl operator new(size_t _Size, void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete(void*, void*) noexcept
    {
        return;
    }

    [[nodiscard]] inline void* __cdecl operator new[](size_t _Size, void* _Where) noexcept
    {
        (void)_Size;
        return _Where;
    }

    inline void __cdecl operator delete[](void*, void*) noexcept
    {
    }
#pragma warning(pop)

#pragma pack(pop)
}

#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4514 4820)

extern "C++"
{
#pragma pack(push, 8)

    [[nodiscard]] __declspec(allocator) void* __cdecl operator new(size_t _Size, int _BlockUse, char const* _FileName, int _LineNumber);

    [[nodiscard]] __declspec(allocator) void* __cdecl operator new[](size_t _Size, int _BlockUse, char const* _FileName, int _LineNumber);

    void __cdecl operator delete(void* _Block, int _BlockUse, char const* _FileName, int _LineNumber) noexcept;

    void __cdecl operator delete[](void* _Block, int _BlockUse, char const* _FileName, int _LineNumber) noexcept;

#pragma pack(pop)
}

#pragma warning(pop)

__pragma(pack(push, 8)) extern "C"
{
    typedef void* _HFILE;

    typedef int(__cdecl * _CRT_REPORT_HOOK)(int, char*, int*);
    typedef int(__cdecl * _CRT_REPORT_HOOKW)(int, wchar_t*, int*);

    typedef int(__cdecl * _CRT_ALLOC_HOOK)(int, void*, size_t, int, long, unsigned char const*, int);

    typedef int(__clrcall * _CRT_ALLOC_HOOK_M)(int, void*, size_t, int, long, unsigned char const*, int);

    typedef void(__cdecl * _CRT_DUMP_CLIENT)(void*, size_t);

    typedef void(__clrcall * _CRT_DUMP_CLIENT_M)(void*, size_t);

    struct _CrtMemBlockHeader;

    typedef struct _CrtMemState
    {
        struct _CrtMemBlockHeader* pBlockHeader;
        size_t lCounts[5];
        size_t lSizes[5];
        size_t lHighWaterCount;
        size_t lTotalCount;
    } _CrtMemState;
}
__pragma(pack(pop))

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

#pragma detect_mismatch("_MSC_VER", "1900")

#pragma detect_mismatch("_ITERATOR_DEBUG_LEVEL", "0")

#pragma detect_mismatch("RuntimeLibrary", "MD_DynamicRelease")

#pragma once

#pragma comment(lib, "msvcprt" \
                     ""        \
                     "")

namespace std
{
    enum _Uninitialized
    {
        _Noinit
    };

    class __declspec(dllimport) _Lockit
    {
    public:
        __thiscall _Lockit() noexcept;
        explicit __thiscall _Lockit(int) noexcept;
        __thiscall ~_Lockit() noexcept;

        static void __cdecl _Lockit_ctor(int) noexcept;
        static void __cdecl _Lockit_dtor(int) noexcept;

    private:
        static void __cdecl _Lockit_ctor(_Lockit*) noexcept;
        static void __cdecl _Lockit_ctor(_Lockit*, int) noexcept;
        static void __cdecl _Lockit_dtor(_Lockit*) noexcept;

    public:
        _Lockit(const _Lockit&) = delete;
        _Lockit& operator=(const _Lockit&) = delete;

    private:
        int _Locktype;
    };

    class __declspec(dllimport) _EmptyLockit
    {
    private:
        int _Locktype;
    };

    class __declspec(dllimport) _Init_locks
    {
    public:
        __thiscall _Init_locks() noexcept;
        __thiscall ~_Init_locks() noexcept;

    private:
        static void __cdecl _Init_locks_ctor(_Init_locks*) noexcept;
        static void __cdecl _Init_locks_dtor(_Init_locks*) noexcept;
    };
}

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4738)
#pragma warning(disable : 4820)

    struct _exception
    {
        int type;
        char* name;
        double arg1;
        double arg2;
        double retval;
    };

    struct _complex
    {
        double x, y;
    };

    typedef float float_t;
    typedef double double_t;

    extern double const _HUGE;

    void __cdecl _fperrraise(int _Except);

    __declspec(dllimport) short __cdecl _dclass(double _X);
    __declspec(dllimport) short __cdecl _ldclass(long double _X);
    __declspec(dllimport) short __cdecl _fdclass(float _X);

    __declspec(dllimport) int __cdecl _dsign(double _X);
    __declspec(dllimport) int __cdecl _ldsign(long double _X);
    __declspec(dllimport) int __cdecl _fdsign(float _X);

    __declspec(dllimport) int __cdecl _dpcomp(double _X, double _Y);
    __declspec(dllimport) int __cdecl _ldpcomp(long double _X, long double _Y);
    __declspec(dllimport) int __cdecl _fdpcomp(float _X, float _Y);

    __declspec(dllimport) short __cdecl _dtest(double* _Px);
    __declspec(dllimport) short __cdecl _ldtest(long double* _Px);
    __declspec(dllimport) short __cdecl _fdtest(float* _Px);

    __declspec(dllimport) short __cdecl _d_int(double* _Px, short _Xexp);
    __declspec(dllimport) short __cdecl _ld_int(long double* _Px, short _Xexp);
    __declspec(dllimport) short __cdecl _fd_int(float* _Px, short _Xexp);

    __declspec(dllimport) short __cdecl _dscale(double* _Px, long _Lexp);
    __declspec(dllimport) short __cdecl _ldscale(long double* _Px, long _Lexp);
    __declspec(dllimport) short __cdecl _fdscale(float* _Px, long _Lexp);

    __declspec(dllimport) short __cdecl _dunscale(short* _Pex, double* _Px);
    __declspec(dllimport) short __cdecl _ldunscale(short* _Pex, long double* _Px);
    __declspec(dllimport) short __cdecl _fdunscale(short* _Pex, float* _Px);

    __declspec(dllimport) short __cdecl _dexp(double* _Px, double _Y, long _Eoff);
    __declspec(dllimport) short __cdecl _ldexp(long double* _Px, long double _Y, long _Eoff);
    __declspec(dllimport) short __cdecl _fdexp(float* _Px, float _Y, long _Eoff);

    __declspec(dllimport) short __cdecl _dnorm(unsigned short* _Ps);
    __declspec(dllimport) short __cdecl _fdnorm(unsigned short* _Ps);

    __declspec(dllimport) double __cdecl _dpoly(double _X, double const* _Tab, int _N);
    __declspec(dllimport) long double __cdecl _ldpoly(long double _X, long double const* _Tab, int _N);
    __declspec(dllimport) float __cdecl _fdpoly(float _X, float const* _Tab, int _N);

    __declspec(dllimport) double __cdecl _dlog(double _X, int _Baseflag);
    __declspec(dllimport) long double __cdecl _ldlog(long double _X, int _Baseflag);
    __declspec(dllimport) float __cdecl _fdlog(float _X, int _Baseflag);

    __declspec(dllimport) double __cdecl _dsin(double _X, unsigned int _Qoff);
    __declspec(dllimport) long double __cdecl _ldsin(long double _X, unsigned int _Qoff);
    __declspec(dllimport) float __cdecl _fdsin(float _X, unsigned int _Qoff);

    typedef union
    {
        unsigned short _Sh[4];
        double _Val;
    } _double_val;

    typedef union
    {
        unsigned short _Sh[2];
        float _Val;
    } _float_val;

    typedef union
    {
        unsigned short _Sh[4];
        long double _Val;
    } _ldouble_val;

    typedef union
    {
        unsigned short _Word[4];
        float _Float;
        double _Double;
        long double _Long_double;
    } _float_const;

    extern const _float_const _Denorm_C, _Inf_C, _Nan_C, _Snan_C, _Hugeval_C;
    extern const _float_const _FDenorm_C, _FInf_C, _FNan_C, _FSnan_C;
    extern const _float_const _LDenorm_C, _LInf_C, _LNan_C, _LSnan_C;

    extern const _float_const _Eps_C, _Rteps_C;
    extern const _float_const _FEps_C, _FRteps_C;
    extern const _float_const _LEps_C, _LRteps_C;

    extern const double _Zero_C, _Xbig_C;
    extern const float _FZero_C, _FXbig_C;
    extern const long double _LZero_C, _LXbig_C;

    extern "C++"
    {
        inline int fpclassify(float _X) throw()
        {
            return _fdtest(&_X);
        }

        inline int fpclassify(double _X) throw()
        {
            return _dtest(&_X);
        }

        inline int fpclassify(long double _X) throw()
        {
            return _ldtest(&_X);
        }

        inline bool signbit(float _X) throw()
        {
            return _fdsign(_X) != 0;
        }

        inline bool signbit(double _X) throw()
        {
            return _dsign(_X) != 0;
        }

        inline bool signbit(long double _X) throw()
        {
            return _ldsign(_X) != 0;
        }

        inline int _fpcomp(float _X, float _Y) throw()
        {
            return _fdpcomp(_X, _Y);
        }

        inline int _fpcomp(double _X, double _Y) throw()
        {
            return _dpcomp(_X, _Y);
        }

        inline int _fpcomp(long double _X, long double _Y) throw()
        {
            return _ldpcomp(_X, _Y);
        }

        template <class _Trc, class _Tre> struct _Combined_type
        {
            typedef float _Type;
        };

        template <> struct _Combined_type<float, double>
        {
            typedef double _Type;
        };

        template <> struct _Combined_type<float, long double>
        {
            typedef long double _Type;
        };

        template <class _Ty, class _T2> struct _Real_widened
        {
            typedef long double _Type;
        };

        template <> struct _Real_widened<float, float>
        {
            typedef float _Type;
        };

        template <> struct _Real_widened<float, double>
        {
            typedef double _Type;
        };

        template <> struct _Real_widened<double, float>
        {
            typedef double _Type;
        };

        template <> struct _Real_widened<double, double>
        {
            typedef double _Type;
        };

        template <class _Ty> struct _Real_type
        {
            typedef double _Type;
        };

        template <> struct _Real_type<float>
        {
            typedef float _Type;
        };

        template <> struct _Real_type<long double>
        {
            typedef long double _Type;
        };

        template <class _T1, class _T2> inline int _fpcomp(_T1 _X, _T2 _Y) throw()
        {
            typedef
            typename _Combined_type<float, typename _Real_widened<typename _Real_type<_T1>::_Type, typename _Real_type<_T2>::_Type>::_Type>::_Type _Tw;
            return _fpcomp((_Tw)_X, (_Tw)_Y);
        }

        template <class _Ty> inline bool isfinite(_Ty _X) throw()
        {
            return fpclassify(_X) <= 0;
        }

        template <class _Ty> inline bool isinf(_Ty _X) throw()
        {
            return fpclassify(_X) == 1;
        }

        template <class _Ty> inline bool isnan(_Ty _X) throw()
        {
            return fpclassify(_X) == 2;
        }

        template <class _Ty> inline bool isnormal(_Ty _X) throw()
        {
            return fpclassify(_X) == (-1);
        }

        template <class _Ty1, class _Ty2> inline bool isgreater(_Ty1 _X, _Ty2 _Y) throw()
        {
            return (_fpcomp(_X, _Y) & 4) != 0;
        }

        template <class _Ty1, class _Ty2> inline bool isgreaterequal(_Ty1 _X, _Ty2 _Y) throw()
        {
            return (_fpcomp(_X, _Y) & (2 | 4)) != 0;
        }

        template <class _Ty1, class _Ty2> inline bool isless(_Ty1 _X, _Ty2 _Y) throw()
        {
            return (_fpcomp(_X, _Y) & 1) != 0;
        }

        template <class _Ty1, class _Ty2> inline bool islessequal(_Ty1 _X, _Ty2 _Y) throw()
        {
            return (_fpcomp(_X, _Y) & (1 | 2)) != 0;
        }

        template <class _Ty1, class _Ty2> inline bool islessgreater(_Ty1 _X, _Ty2 _Y) throw()
        {
            return (_fpcomp(_X, _Y) & (1 | 4)) != 0;
        }

        template <class _Ty1, class _Ty2> inline bool isunordered(_Ty1 _X, _Ty2 _Y) throw()
        {
            return _fpcomp(_X, _Y) == 0;
        }
    }

    int __cdecl abs(int _X);
    long __cdecl labs(long _X);
    long long __cdecl llabs(long long _X);

    double __cdecl acos(double _X);
    double __cdecl asin(double _X);
    double __cdecl atan(double _X);
    double __cdecl atan2(double _Y, double _X);

    double __cdecl cos(double _X);
    double __cdecl cosh(double _X);
    double __cdecl exp(double _X);
    __declspec(jitintrinsic) double __cdecl fabs(double _X);
    double __cdecl fmod(double _X, double _Y);
    double __cdecl log(double _X);
    double __cdecl log10(double _X);
    double __cdecl pow(double _X, double _Y);
    double __cdecl sin(double _X);
    double __cdecl sinh(double _X);
    __declspec(jitintrinsic) double __cdecl sqrt(double _X);
    double __cdecl tan(double _X);
    double __cdecl tanh(double _X);

    __declspec(dllimport) double __cdecl acosh(double _X);
    __declspec(dllimport) double __cdecl asinh(double _X);
    __declspec(dllimport) double __cdecl atanh(double _X);
    __declspec(dllimport) double __cdecl atof(char const* _String);
    __declspec(dllimport) double __cdecl _atof_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) double __cdecl _cabs(struct _complex _Complex_value);
    __declspec(dllimport) double __cdecl cbrt(double _X);
    __declspec(dllimport) double __cdecl ceil(double _X);
    __declspec(dllimport) double __cdecl _chgsign(double _X);
    __declspec(dllimport) double __cdecl copysign(double _Number, double _Sign);
    __declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign);
    __declspec(dllimport) double __cdecl erf(double _X);
    __declspec(dllimport) double __cdecl erfc(double _X);
    __declspec(dllimport) double __cdecl exp2(double _X);
    __declspec(dllimport) double __cdecl expm1(double _X);
    __declspec(dllimport) double __cdecl fdim(double _X, double _Y);
    __declspec(dllimport) double __cdecl floor(double _X);
    __declspec(dllimport) double __cdecl fma(double _X, double _Y, double _Z);
    __declspec(dllimport) double __cdecl fmax(double _X, double _Y);
    __declspec(dllimport) double __cdecl fmin(double _X, double _Y);
    __declspec(dllimport) double __cdecl frexp(double _X, int* _Y);
    __declspec(dllimport) double __cdecl hypot(double _X, double _Y);
    __declspec(dllimport) double __cdecl _hypot(double _X, double _Y);
    __declspec(dllimport) int __cdecl ilogb(double _X);
    __declspec(dllimport) double __cdecl ldexp(double _X, int _Y);
    __declspec(dllimport) double __cdecl lgamma(double _X);
    __declspec(dllimport) long long __cdecl llrint(double _X);
    __declspec(dllimport) long long __cdecl llround(double _X);
    __declspec(dllimport) double __cdecl log1p(double _X);
    __declspec(dllimport) double __cdecl log2(double _X);
    __declspec(dllimport) double __cdecl logb(double _X);
    __declspec(dllimport) long __cdecl lrint(double _X);
    __declspec(dllimport) long __cdecl lround(double _X);

    int __cdecl _matherr(struct _exception * _Except);

    __declspec(dllimport) double __cdecl modf(double _X, double* _Y);
    __declspec(dllimport) double __cdecl nan(char const* _X);
    __declspec(dllimport) double __cdecl nearbyint(double _X);
    __declspec(dllimport) double __cdecl nextafter(double _X, double _Y);
    __declspec(dllimport) double __cdecl nexttoward(double _X, long double _Y);
    __declspec(dllimport) double __cdecl remainder(double _X, double _Y);
    __declspec(dllimport) double __cdecl remquo(double _X, double _Y, int* _Z);
    __declspec(dllimport) double __cdecl rint(double _X);
    __declspec(dllimport) double __cdecl round(double _X);
    __declspec(dllimport) double __cdecl scalbln(double _X, long _Y);
    __declspec(dllimport) double __cdecl scalbn(double _X, int _Y);
    __declspec(dllimport) double __cdecl tgamma(double _X);
    __declspec(dllimport) double __cdecl trunc(double _X);
    __declspec(dllimport) double __cdecl _j0(double _X);
    __declspec(dllimport) double __cdecl _j1(double _X);
    __declspec(dllimport) double __cdecl _jn(int _X, double _Y);
    __declspec(dllimport) double __cdecl _y0(double _X);
    __declspec(dllimport) double __cdecl _y1(double _X);
    __declspec(dllimport) double __cdecl _yn(int _X, double _Y);

    __declspec(dllimport) float __cdecl acoshf(float _X);
    __declspec(dllimport) float __cdecl asinhf(float _X);
    __declspec(dllimport) float __cdecl atanhf(float _X);
    __declspec(dllimport) float __cdecl cbrtf(float _X);
    __declspec(dllimport) float __cdecl _chgsignf(float _X);
    __declspec(dllimport) float __cdecl copysignf(float _Number, float _Sign);
    __declspec(dllimport) float __cdecl _copysignf(float _Number, float _Sign);
    __declspec(dllimport) float __cdecl erff(float _X);
    __declspec(dllimport) float __cdecl erfcf(float _X);
    __declspec(dllimport) float __cdecl expm1f(float _X);
    __declspec(dllimport) float __cdecl exp2f(float _X);
    __declspec(dllimport) float __cdecl fdimf(float _X, float _Y);
    __declspec(dllimport) float __cdecl fmaf(float _X, float _Y, float _Z);
    __declspec(dllimport) float __cdecl fmaxf(float _X, float _Y);
    __declspec(dllimport) float __cdecl fminf(float _X, float _Y);
    __declspec(dllimport) float __cdecl _hypotf(float _X, float _Y);
    __declspec(dllimport) int __cdecl ilogbf(float _X);
    __declspec(dllimport) float __cdecl lgammaf(float _X);
    __declspec(dllimport) long long __cdecl llrintf(float _X);
    __declspec(dllimport) long long __cdecl llroundf(float _X);
    __declspec(dllimport) float __cdecl log1pf(float _X);
    __declspec(dllimport) float __cdecl log2f(float _X);
    __declspec(dllimport) float __cdecl logbf(float _X);
    __declspec(dllimport) long __cdecl lrintf(float _X);
    __declspec(dllimport) long __cdecl lroundf(float _X);
    __declspec(dllimport) float __cdecl nanf(char const* _X);
    __declspec(dllimport) float __cdecl nearbyintf(float _X);
    __declspec(dllimport) float __cdecl nextafterf(float _X, float _Y);
    __declspec(dllimport) float __cdecl nexttowardf(float _X, long double _Y);
    __declspec(dllimport) float __cdecl remainderf(float _X, float _Y);
    __declspec(dllimport) float __cdecl remquof(float _X, float _Y, int* _Z);
    __declspec(dllimport) float __cdecl rintf(float _X);
    __declspec(dllimport) float __cdecl roundf(float _X);
    __declspec(dllimport) float __cdecl scalblnf(float _X, long _Y);
    __declspec(dllimport) float __cdecl scalbnf(float _X, int _Y);
    __declspec(dllimport) float __cdecl tgammaf(float _X);
    __declspec(dllimport) float __cdecl truncf(float _X);

    __declspec(dllimport) float __cdecl _logbf(float _X);
    __declspec(dllimport) float __cdecl _nextafterf(float _X, float _Y);
    __declspec(dllimport) int __cdecl _finitef(float _X);
    __declspec(dllimport) int __cdecl _isnanf(float _X);
    __declspec(dllimport) int __cdecl _fpclassf(float _X);

    __declspec(dllimport) int __cdecl _set_FMA3_enable(int _Flag);
    __declspec(dllimport) int __cdecl _get_FMA3_enable(void);

    __declspec(dllimport) float __cdecl acosf(float _X);
    __declspec(dllimport) float __cdecl asinf(float _X);
    __declspec(dllimport) float __cdecl atan2f(float _Y, float _X);
    __declspec(dllimport) float __cdecl atanf(float _X);
    __declspec(dllimport) float __cdecl ceilf(float _X);
    __declspec(dllimport) float __cdecl cosf(float _X);
    __declspec(dllimport) float __cdecl coshf(float _X);
    __declspec(dllimport) float __cdecl expf(float _X);

    __inline float __cdecl fabsf(float _X)
    {
        return (float)fabs(_X);
    }

    __declspec(dllimport) float __cdecl floorf(float _X);
    __declspec(dllimport) float __cdecl fmodf(float _X, float _Y);

    __inline float __cdecl frexpf(float _X, int* _Y)
    {
        return (float)frexp(_X, _Y);
    }

    __inline float __cdecl hypotf(float _X, float _Y)
    {
        return _hypotf(_X, _Y);
    }

    __inline float __cdecl ldexpf(float _X, int _Y)
    {
        return (float)ldexp(_X, _Y);
    }

    __declspec(dllimport) float __cdecl log10f(float _X);
    __declspec(dllimport) float __cdecl logf(float _X);
    __declspec(dllimport) float __cdecl modff(float _X, float* _Y);
    __declspec(dllimport) float __cdecl powf(float _X, float _Y);
    __declspec(dllimport) float __cdecl sinf(float _X);
    __declspec(dllimport) float __cdecl sinhf(float _X);
    __declspec(dllimport) float __cdecl sqrtf(float _X);
    __declspec(dllimport) float __cdecl tanf(float _X);
    __declspec(dllimport) float __cdecl tanhf(float _X);

    __declspec(dllimport) long double __cdecl acoshl(long double _X);

    __inline long double __cdecl acosl(long double _X)
    {
        return acos((double)_X);
    }

    __declspec(dllimport) long double __cdecl asinhl(long double _X);

    __inline long double __cdecl asinl(long double _X)
    {
        return asin((double)_X);
    }

    __inline long double __cdecl atan2l(long double _Y, long double _X)
    {
        return atan2((double)_Y, (double)_X);
    }

    __declspec(dllimport) long double __cdecl atanhl(long double _X);

    __inline long double __cdecl atanl(long double _X)
    {
        return atan((double)_X);
    }

    __declspec(dllimport) long double __cdecl cbrtl(long double _X);

    __inline long double __cdecl ceill(long double _X)
    {
        return ceil((double)_X);
    }

    __inline long double __cdecl _chgsignl(long double _X)
    {
        return _chgsign((double)_X);
    }

    __declspec(dllimport) long double __cdecl copysignl(long double _Number, long double _Sign);

    __inline long double __cdecl _copysignl(long double _Number, long double _Sign)
    {
        return _copysign((double)_Number, (double)_Sign);
    }

    __inline long double __cdecl coshl(long double _X)
    {
        return cosh((double)_X);
    }

    __inline long double __cdecl cosl(long double _X)
    {
        return cos((double)_X);
    }

    __declspec(dllimport) long double __cdecl erfl(long double _X);
    __declspec(dllimport) long double __cdecl erfcl(long double _X);

    __inline long double __cdecl expl(long double _X)
    {
        return exp((double)_X);
    }

    __declspec(dllimport) long double __cdecl exp2l(long double _X);
    __declspec(dllimport) long double __cdecl expm1l(long double _X);

    __inline long double __cdecl fabsl(long double _X)
    {
        return fabs((double)_X);
    }

    __declspec(dllimport) long double __cdecl fdiml(long double _X, long double _Y);

    __inline long double __cdecl floorl(long double _X)
    {
        return floor((double)_X);
    }

    __declspec(dllimport) long double __cdecl fmal(long double _X, long double _Y, long double _Z);
    __declspec(dllimport) long double __cdecl fmaxl(long double _X, long double _Y);
    __declspec(dllimport) long double __cdecl fminl(long double _X, long double _Y);

    __inline long double __cdecl fmodl(long double _X, long double _Y)
    {
        return fmod((double)_X, (double)_Y);
    }

    __inline long double __cdecl frexpl(long double _X, int* _Y)
    {
        return frexp((double)_X, _Y);
    }

    __declspec(dllimport) int __cdecl ilogbl(long double _X);

    __inline long double __cdecl _hypotl(long double _X, long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

    __inline long double __cdecl hypotl(long double _X, long double _Y)
    {
        return _hypot((double)_X, (double)_Y);
    }

    __inline long double __cdecl ldexpl(long double _X, int _Y)
    {
        return ldexp((double)_X, _Y);
    }

    __declspec(dllimport) long double __cdecl lgammal(long double _X);
    __declspec(dllimport) long long __cdecl llrintl(long double _X);
    __declspec(dllimport) long long __cdecl llroundl(long double _X);

    __inline long double __cdecl logl(long double _X)
    {
        return log((double)_X);
    }

    __inline long double __cdecl log10l(long double _X)
    {
        return log10((double)_X);
    }

    __declspec(dllimport) long double __cdecl log1pl(long double _X);
    __declspec(dllimport) long double __cdecl log2l(long double _X);
    __declspec(dllimport) long double __cdecl logbl(long double _X);
    __declspec(dllimport) long __cdecl lrintl(long double _X);
    __declspec(dllimport) long __cdecl lroundl(long double _X);

    __inline long double __cdecl modfl(long double _X, long double* _Y)
    {
        double _F, _I;
        _F = modf((double)_X, &_I);
        *_Y = _I;
        return _F;
    }

    __declspec(dllimport) long double __cdecl nanl(char const* _X);
    __declspec(dllimport) long double __cdecl nearbyintl(long double _X);
    __declspec(dllimport) long double __cdecl nextafterl(long double _X, long double _Y);
    __declspec(dllimport) long double __cdecl nexttowardl(long double _X, long double _Y);

    __inline long double __cdecl powl(long double _X, long double _Y)
    {
        return pow((double)_X, (double)_Y);
    }

    __declspec(dllimport) long double __cdecl remainderl(long double _X, long double _Y);
    __declspec(dllimport) long double __cdecl remquol(long double _X, long double _Y, int* _Z);
    __declspec(dllimport) long double __cdecl rintl(long double _X);
    __declspec(dllimport) long double __cdecl roundl(long double _X);
    __declspec(dllimport) long double __cdecl scalblnl(long double _X, long _Y);
    __declspec(dllimport) long double __cdecl scalbnl(long double _X, int _Y);

    __inline long double __cdecl sinhl(long double _X)
    {
        return sinh((double)_X);
    }

    __inline long double __cdecl sinl(long double _X)
    {
        return sin((double)_X);
    }

    __inline long double __cdecl sqrtl(long double _X)
    {
        return sqrt((double)_X);
    }

    __inline long double __cdecl tanhl(long double _X)
    {
        return tanh((double)_X);
    }

    __inline long double __cdecl tanl(long double _X)
    {
        return tan((double)_X);
    }

    __declspec(dllimport) long double __cdecl tgammal(long double _X);
    __declspec(dllimport) long double __cdecl truncl(long double _X);

    extern double HUGE;

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_j0"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl j0(double _X);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_j1"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl j1(double _X);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_jn"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl jn(int _X, double _Y);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_y0"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl y0(double _X);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_y1"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl y1(double _X);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_yn"
                          ". See online help for details.")) __declspec(dllimport) double __cdecl yn(int _X, double _Y);

#pragma warning(pop)
}
__pragma(pack(pop))

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _calloc_base(size_t _Count, size_t _Size);

    __declspec(dllimport) __declspec(jitintrinsic) __declspec(allocator) __declspec(restrict) void* __cdecl calloc(
    size_t _Count, size_t _Size);

    __declspec(dllimport) int __cdecl _callnewh(size_t _Size);

    __declspec(dllimport) __declspec(allocator) void* __cdecl _expand(void* _Block, size_t _Size);

    __declspec(dllimport) void __cdecl _free_base(void* _Block);

    __declspec(dllimport) void __cdecl free(void* _Block);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _malloc_base(size_t _Size);

    __declspec(dllimport) __declspec(allocator) __declspec(jitintrinsic) __declspec(restrict) void* __cdecl malloc(size_t _Size);

    __declspec(dllimport) size_t __cdecl _msize_base(void* _Block);

    __declspec(dllimport) size_t __cdecl _msize(void* _Block);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _realloc_base(void* _Block, size_t _Size);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl realloc(void* _Block, size_t _Size);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _recalloc_base(void* _Block, size_t _Count,
                                                                                                  size_t _Size);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _recalloc(void* _Block, size_t _Count, size_t _Size);

    __declspec(dllimport) void __cdecl _aligned_free(void* _Block);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_malloc(size_t _Size, size_t _Alignment);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_offset_malloc(
    size_t _Size, size_t _Alignment, size_t _Offset);

    __declspec(dllimport) size_t __cdecl _aligned_msize(void* _Block, size_t _Alignment, size_t _Offset);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_offset_realloc(
    void* _Block, size_t _Size, size_t _Alignment, size_t _Offset);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_offset_recalloc(
    void* _Block, size_t _Count, size_t _Size, size_t _Alignment, size_t _Offset);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_realloc(void* _Block, size_t _Size,
                                                                                                    size_t _Alignment);

    __declspec(dllimport) __declspec(allocator) __declspec(restrict) void* __cdecl _aligned_recalloc(
    void* _Block, size_t _Count, size_t _Size, size_t _Alignment);
}
__pragma(pack(pop))

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    namespace std
    {
        typedef decltype(__nullptr) nullptr_t;
    }

    using ::std::nullptr_t;

    __declspec(dllimport) int* __cdecl _errno(void);

    __declspec(dllimport) errno_t __cdecl _set_errno(int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(int* _Value);

    __declspec(dllimport) extern unsigned long __cdecl __threadid(void);

    __declspec(dllimport) extern uintptr_t __cdecl __threadhandle(void);
}
__pragma(pack(pop))

__pragma(pack(push, 8)) extern "C"
{
    typedef int(__cdecl * _CoreCrtSecureSearchSortCompareFunction)(void*, void const*, void const*);
    typedef int(__cdecl * _CoreCrtNonSecureSearchSortCompareFunction)(void const*, void const*);

    __declspec(dllimport) void* __cdecl bsearch_s(void const* _Key, void const* _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements,
                                                  _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void* _Context);

    __declspec(dllimport) void __cdecl qsort_s(void* _Base, rsize_t _NumOfElements, rsize_t _SizeOfElements,
                                               _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void* _Context);

    __declspec(dllimport) void* __cdecl bsearch(void const* _Key, void const* _Base, size_t _NumOfElements, size_t _SizeOfElements,
                                                _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);

    __declspec(dllimport) void __cdecl qsort(void* _Base, size_t _NumOfElements, size_t _SizeOfElements,
                                             _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);

    __declspec(dllimport) void* __cdecl _lfind_s(void const* _Key, void const* _Base, unsigned int* _NumOfElements, size_t _SizeOfElements,
                                                 _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void* _Context);

    __declspec(dllimport) void* __cdecl _lfind(void const* _Key, void const* _Base, unsigned int* _NumOfElements,
                                               unsigned int _SizeOfElements,
                                               _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);

    __declspec(dllimport) void* __cdecl _lsearch_s(void const* _Key, void* _Base, unsigned int* _NumOfElements, size_t _SizeOfElements,
                                                   _CoreCrtSecureSearchSortCompareFunction _CompareFunction, void* _Context);

    __declspec(dllimport) void* __cdecl _lsearch(void const* _Key, void* _Base, unsigned int* _NumOfElements, unsigned int _SizeOfElements,
                                                 _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);

    extern "C++"
    {
        typedef int(__clrcall* _CoreCrtMgdSecureSearchSortCompareFunction)(void*, void const*, void const*);
        typedef int(__clrcall* _CoreCrtMgdNonSecureSearchSortCompareFunction)(void const*, void const*);

        void* __clrcall bsearch_s(void const* _Key,
                                  void const* _Base,
                                  rsize_t _NumOfElements,
                                  rsize_t _SizeOfElements,
                                  _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
                                  void* _Context);

        void __clrcall qsort_s(void* _Base,
                               rsize_t _NumOfElements,
                               rsize_t _SizeOfElements,
                               _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
                               void* _Context);

        void* __clrcall bsearch(void const* _Key,
                                void const* _Base,
                                size_t _NumOfElements,
                                size_t _SizeOfElements,
                                _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction);

        void* __clrcall _lfind_s(void const* _Key,
                                 void const* _Base,
                                 unsigned int* _NumOfElements,
                                 size_t _SizeOfElements,
                                 _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
                                 void* _Context);

        void* __clrcall _lfind(void const* _Key,
                               void const* _Base,
                               unsigned int* _NumOfElements,
                               unsigned int _SizeOfElements,
                               _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction);

        void* __clrcall _lsearch_s(void const* _Key,
                                   void* _Base,
                                   unsigned int* _NumOfElements,
                                   size_t _SizeOfElements,
                                   _CoreCrtMgdSecureSearchSortCompareFunction _CompareFunction,
                                   void* _Context);

        void* __clrcall _lsearch(void const* _Key,
                                 void* _Base,
                                 unsigned int* _NumOfElements,
                                 unsigned int _SizeOfElements,
                                 _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction);

        void __clrcall qsort(void* _Base, size_t _NumOfElements, size_t _SizeOfElements, _CoreCrtMgdNonSecureSearchSortCompareFunction _CompareFunction);
    }

    __declspec(deprecated(
    "The POSIX name for this item is deprecated. Instead, use the ISO C "
    "and C++ conformant name: "
    "_lfind"
    ". See online help for details.")) __declspec(dllimport) void* __cdecl lfind(void const* _Key, void const* _Base,
                                                                                 unsigned int* _NumOfElements,
                                                                                 unsigned int _SizeOfElements,
                                                                                 _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);

    __declspec(deprecated(
    "The POSIX name for this item is deprecated. Instead, use the ISO C "
    "and C++ conformant name: "
    "_lsearch"
    ". See online help for details.")) __declspec(dllimport) void* __cdecl lsearch(void const* _Key, void* _Base,
                                                                                   unsigned int* _NumOfElements,
                                                                                   unsigned int _SizeOfElements,
                                                                                   _CoreCrtNonSecureSearchSortCompareFunction _CompareFunction);
}
__pragma(pack(pop))

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) errno_t __cdecl _itow_s(int _Value, wchar_t* _Buffer, size_t _BufferCount, int _Radix);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _itow_s(int _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw()
        {
            return _itow_s(_Value, _Buffer, _Size, _Radix);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_itow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _itow(int _Value, wchar_t* _Buffer, int _Radix);

    __declspec(dllimport) errno_t __cdecl _ltow_s(long _Value, wchar_t* _Buffer, size_t _BufferCount, int _Radix);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _ltow_s(long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw()
        {
            return _ltow_s(_Value, _Buffer, _Size, _Radix);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ltow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _ltow(long _Value, wchar_t* _Buffer, int _Radix);

    __declspec(dllimport) errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t* _Buffer, size_t _BufferCount, int _Radix);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _ultow_s(unsigned long _Value, wchar_t (&_Buffer)[_Size], int _Radix) throw()
        {
            return _ultow_s(_Value, _Buffer, _Size, _Radix);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ultow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _ultow(unsigned long _Value, wchar_t* _Buffer, int _Radix);

    __declspec(dllimport) double __cdecl wcstod(wchar_t const* _String, wchar_t** _EndPtr);

    __declspec(dllimport) double __cdecl _wcstod_l(wchar_t const* _String, wchar_t** _EndPtr, _locale_t _Locale);

    __declspec(dllimport) long __cdecl wcstol(wchar_t const* _String, wchar_t** _EndPtr, int _Radix);

    __declspec(dllimport) long __cdecl _wcstol_l(wchar_t const* _String, wchar_t** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) long long __cdecl wcstoll(wchar_t const* _String, wchar_t** _EndPtr, int _Radix);

    __declspec(dllimport) long long __cdecl _wcstoll_l(wchar_t const* _String, wchar_t** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) unsigned long __cdecl wcstoul(wchar_t const* _String, wchar_t** _EndPtr, int _Radix);

    __declspec(dllimport) unsigned long __cdecl _wcstoul_l(wchar_t const* _String, wchar_t** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) unsigned long long __cdecl wcstoull(wchar_t const* _String, wchar_t** _EndPtr, int _Radix);

    __declspec(dllimport) unsigned long long __cdecl _wcstoull_l(wchar_t const* _String, wchar_t** _EndPtr, int _Radix,
                                                                 _locale_t _Locale);

    __declspec(dllimport) long double __cdecl wcstold(wchar_t const* _String, wchar_t** _EndPtr);

    __declspec(dllimport) long double __cdecl _wcstold_l(wchar_t const* _String, wchar_t** _EndPtr, _locale_t _Locale);

    __declspec(dllimport) float __cdecl wcstof(wchar_t const* _String, wchar_t** _EndPtr);

    __declspec(dllimport) float __cdecl _wcstof_l(wchar_t const* _String, wchar_t** _EndPtr, _locale_t _Locale);

    __declspec(dllimport) double __cdecl _wtof(wchar_t const* _String);

    __declspec(dllimport) double __cdecl _wtof_l(wchar_t const* _String, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _wtoi(wchar_t const* _String);

    __declspec(dllimport) int __cdecl _wtoi_l(wchar_t const* _String, _locale_t _Locale);

    __declspec(dllimport) long __cdecl _wtol(wchar_t const* _String);

    __declspec(dllimport) long __cdecl _wtol_l(wchar_t const* _String, _locale_t _Locale);

    __declspec(dllimport) long long __cdecl _wtoll(wchar_t const* _String);

    __declspec(dllimport) long long __cdecl _wtoll_l(wchar_t const* _String, _locale_t _Locale);

    __declspec(dllimport) errno_t __cdecl _i64tow_s(__int64 _Value, wchar_t* _Buffer, size_t _BufferCount, int _Radix);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_i64tow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _i64tow(__int64 _Value, wchar_t* _Buffer, int _Radix);

    __declspec(dllimport) errno_t __cdecl _ui64tow_s(unsigned __int64 _Value, wchar_t* _Buffer, size_t _BufferCount, int _Radix);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ui64tow_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _ui64tow(unsigned __int64 _Value, wchar_t* _Buffer, int _Radix);

    __declspec(dllimport) __int64 __cdecl _wtoi64(wchar_t const* _String);

    __declspec(dllimport) __int64 __cdecl _wtoi64_l(wchar_t const* _String, _locale_t _Locale);

    __declspec(dllimport) __int64 __cdecl _wcstoi64(wchar_t const* _String, wchar_t** _EndPtr, int _Radix);

    __declspec(dllimport) __int64 __cdecl _wcstoi64_l(wchar_t const* _String, wchar_t** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64(wchar_t const* _String, wchar_t** _EndPtr, int _Radix);

    __declspec(dllimport) unsigned __int64 __cdecl _wcstoui64_l(wchar_t const* _String, wchar_t** _EndPtr, int _Radix,
                                                                _locale_t _Locale);

    __declspec(dllimport) __declspec(allocator)
    wchar_t* __cdecl _wfullpath(wchar_t * _Buffer, wchar_t const* _Path, size_t _BufferCount);

    __declspec(dllimport) errno_t __cdecl _wmakepath_s(wchar_t * _Buffer, size_t _BufferCount, wchar_t const* _Drive,
                                                       wchar_t const* _Dir, wchar_t const* _Filename, wchar_t const* _Ext);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _wmakepath_s(wchar_t (&_Buffer)[_Size],
                                            wchar_t const* _Drive,
                                            wchar_t const* _Dir,
                                            wchar_t const* _Filename,
                                            wchar_t const* _Ext) throw()
        {
            return _wmakepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext);
        }
    }

#pragma warning(push)
#pragma warning(disable : 28719)
#pragma warning(disable : 28726)
    __declspec(deprecated(
    "This function or variable may be unsafe. Consider using "
    "_wmakepath_s"
    " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
    "See online help for details.")) __declspec(dllimport) void __cdecl _wmakepath(wchar_t * _Buffer, wchar_t const* _Drive,
                                                                                   wchar_t const* _Dir, wchar_t const* _Filename,
                                                                                   wchar_t const* _Ext);
#pragma warning(pop)

    __declspec(dllimport) void __cdecl _wperror(wchar_t const* _ErrorMessage);

    __declspec(deprecated(
    "This function or variable may be unsafe. Consider using "
    "_wsplitpath_s"
    " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
    "See online help for details.")) __declspec(dllimport) void __cdecl _wsplitpath(wchar_t const* _FullPath,
                                                                                    wchar_t* _Drive, wchar_t* _Dir,
                                                                                    wchar_t* _Filename, wchar_t* _Ext);

    __declspec(dllimport) errno_t __cdecl _wsplitpath_s(wchar_t const* _FullPath, wchar_t* _Drive, size_t _DriveCount,
                                                        wchar_t* _Dir, size_t _DirCount, wchar_t* _Filename,
                                                        size_t _FilenameCount, wchar_t* _Ext, size_t _ExtCount);

    extern "C++"
    {
        template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>
        inline errno_t __cdecl _wsplitpath_s(wchar_t const* _Path,
                                             wchar_t (&_Drive)[_DriveSize],
                                             wchar_t (&_Dir)[_DirSize],
                                             wchar_t (&_Name)[_NameSize],
                                             wchar_t (&_Ext)[_ExtSize]) throw()
        {
            return _wsplitpath_s(_Path, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize);
        }
    }

    __declspec(dllimport) errno_t __cdecl _wdupenv_s(wchar_t * *_Buffer, size_t * _BufferCount, wchar_t const* _VarName);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wdupenv_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wgetenv(wchar_t const* _VarName);

    __declspec(dllimport)
    errno_t __cdecl _wgetenv_s(size_t * _RequiredCount, wchar_t * _Buffer, size_t _BufferCount, wchar_t const* _VarName);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _wgetenv_s(size_t* _RequiredCount, wchar_t (&_Buffer)[_Size], wchar_t const* _VarName) throw()
        {
            return _wgetenv_s(_RequiredCount, _Buffer, _Size, _VarName);
        }
    }

    __declspec(dllimport) int __cdecl _wputenv(wchar_t const* _EnvString);

    __declspec(dllimport) errno_t __cdecl _wputenv_s(wchar_t const* _Name, wchar_t const* _Value);

    __declspec(dllimport)
    errno_t __cdecl _wsearchenv_s(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t* _Buffer, size_t _BufferCount);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _wsearchenv_s(wchar_t const* _Filename, wchar_t const* _VarName, wchar_t (&_ResultPath)[_Size]) throw()
        {
            return _wsearchenv_s(_Filename, _VarName, _ResultPath, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wsearchenv_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl _wsearchenv(wchar_t const* _Filename,
                                                                                                          wchar_t const* _VarName,
                                                                                                          wchar_t* _ResultPath);

    __declspec(dllimport) int __cdecl _wsystem(wchar_t const* _Command);
}
__pragma(pack(pop))

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) void __cdecl _swab(char* _Buf1, char* _Buf2, int _SizeInBytes);

    __declspec(dllimport) __declspec(noreturn) void __cdecl exit(int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _exit(int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl _Exit(int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl quick_exit(int _Code);
    __declspec(dllimport) __declspec(noreturn) void __cdecl abort(void);

    __declspec(dllimport) unsigned int __cdecl _set_abort_behavior(unsigned int _Flags, unsigned int _Mask);

    typedef int(__cdecl * _onexit_t)(void);

    typedef int(__clrcall * _onexit_m_t)(void);

#pragma warning(push)
#pragma warning(disable : 4985)

    int __clrcall _atexit_m_appdomain(void(__clrcall * _Function)(void));

    _onexit_m_t __clrcall _onexit_m_appdomain(_onexit_m_t _Function);

    [System::Security::SecurityCritical] int __clrcall _atexit_m(void(__clrcall * _Function)(void));

    _onexit_m_t __clrcall _onexit_m(_onexit_m_t _Function);

#pragma warning(pop)

    int __cdecl atexit(void(__cdecl*)(void));
    _onexit_t __cdecl _onexit(_onexit_t _Func);

    int __cdecl at_quick_exit(void(__cdecl*)(void));

    typedef void(__cdecl * _purecall_handler)(void);

    typedef void(__cdecl * _invalid_parameter_handler)(wchar_t const*, wchar_t const*, wchar_t const*, unsigned int, uintptr_t);

    _purecall_handler __cdecl _set_purecall_handler(_purecall_handler _Handler);

    _purecall_handler __cdecl _get_purecall_handler(void);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _set_invalid_parameter_handler(_invalid_parameter_handler _Handler);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_invalid_parameter_handler(void);

    __declspec(dllimport)
    _invalid_parameter_handler __cdecl _set_thread_local_invalid_parameter_handler(_invalid_parameter_handler _Handler);

    __declspec(dllimport) _invalid_parameter_handler __cdecl _get_thread_local_invalid_parameter_handler(void);

    __declspec(dllimport) int __cdecl _set_error_mode(int _Mode);

    __declspec(dllimport) int* __cdecl _errno(void);

    __declspec(dllimport) errno_t __cdecl _set_errno(int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);

    __declspec(dllimport) errno_t __cdecl _set_doserrno(unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(unsigned long* _Value);

    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                "strerror"
                                                " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                "See online help for details.")) char** __cdecl __sys_errlist(void);

    __declspec(dllimport) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                "strerror"
                                                " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                "See online help for details.")) int* __cdecl __sys_nerr(void);

    __declspec(dllimport) void __cdecl perror(char const* _ErrMsg);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_pgmptr"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char** __cdecl __p__pgmptr(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_wpgmptr"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t** __cdecl __p__wpgmptr(void);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_fmode"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int* __cdecl __p__fmode(void);

    __declspec(dllimport) errno_t __cdecl _get_pgmptr(char** _Value);

    __declspec(dllimport) errno_t __cdecl _get_wpgmptr(wchar_t * *_Value);

    __declspec(dllimport) errno_t __cdecl _set_fmode(int _Mode);

    __declspec(dllimport) errno_t __cdecl _get_fmode(int* _PMode);

    typedef struct _div_t
    {
        int quot;
        int rem;
    } div_t;

    typedef struct _ldiv_t
    {
        long quot;
        long rem;
    } ldiv_t;

    typedef struct _lldiv_t
    {
        long long quot;
        long long rem;
    } lldiv_t;

    int __cdecl abs(int _Number);
    long __cdecl labs(long _Number);
    long long __cdecl llabs(long long _Number);
    __int64 __cdecl _abs64(__int64 _Number);

    unsigned short __cdecl _byteswap_ushort(unsigned short _Number);
    unsigned long __cdecl _byteswap_ulong(unsigned long _Number);
    unsigned __int64 __cdecl _byteswap_uint64(unsigned __int64 _Number);

    __declspec(dllimport) div_t __cdecl div(int _Numerator, int _Denominator);
    __declspec(dllimport) ldiv_t __cdecl ldiv(long _Numerator, long _Denominator);
    __declspec(dllimport) lldiv_t __cdecl lldiv(long long _Numerator, long long _Denominator);

#pragma warning(push)
#pragma warning(disable : 6540)

    unsigned int __cdecl _rotl(unsigned int _Value, int _Shift);

    unsigned long __cdecl _lrotl(unsigned long _Value, int _Shift);

    unsigned __int64 __cdecl _rotl64(unsigned __int64 _Value, int _Shift);

    unsigned int __cdecl _rotr(unsigned int _Value, int _Shift);

    unsigned long __cdecl _lrotr(unsigned long _Value, int _Shift);

    unsigned __int64 __cdecl _rotr64(unsigned __int64 _Value, int _Shift);

#pragma warning(pop)

    __declspec(dllimport) void __cdecl srand(unsigned int _Seed);

    __declspec(dllimport) int __cdecl rand(void);

    extern "C++"
    {
        inline long abs(long const _X) throw()
        {
            return labs(_X);
        }

        inline long long abs(long long const _X) throw()
        {
            return llabs(_X);
        }

        inline ldiv_t div(long const _A1, long const _A2) throw()
        {
            return ldiv(_A1, _A2);
        }

        inline lldiv_t div(long long const _A1, long long const _A2) throw()
        {
            return lldiv(_A1, _A2);
        }
    }

#pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld[10];
    } _LDOUBLE;
#pragma pack(pop)

    typedef struct
    {
        double x;
    } _CRT_DOUBLE;

    typedef struct
    {
        float f;
    } _CRT_FLOAT;

    typedef struct
    {
        long double x;
    } _LONGDOUBLE;

#pragma pack(push, 4)
    typedef struct
    {
        unsigned char ld12[12];
    } _LDBL12;
#pragma pack(pop)

    __declspec(dllimport) double __cdecl atof(char const* _String);
    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl atoi(char const* _String);
    __declspec(dllimport) long __cdecl atol(char const* _String);
    __declspec(dllimport) long long __cdecl atoll(char const* _String);
    __declspec(dllimport) __int64 __cdecl _atoi64(char const* _String);

    __declspec(dllimport) double __cdecl _atof_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _atoi_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) long __cdecl _atol_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) long long __cdecl _atoll_l(char const* _String, _locale_t _Locale);
    __declspec(dllimport) __int64 __cdecl _atoi64_l(char const* _String, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _atoflt(_CRT_FLOAT * _Result, char const* _String);
    __declspec(dllimport) int __cdecl _atodbl(_CRT_DOUBLE * _Result, char* _String);
    __declspec(dllimport) int __cdecl _atoldbl(_LDOUBLE * _Result, char* _String);

    __declspec(dllimport) int __cdecl _atoflt_l(_CRT_FLOAT * _Result, char const* _String, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _atodbl_l(_CRT_DOUBLE * _Result, char* _String, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _atoldbl_l(_LDOUBLE * _Result, char* _String, _locale_t _Locale);

    __declspec(dllimport) float __cdecl strtof(char const* _String, char** _EndPtr);

    __declspec(dllimport) float __cdecl _strtof_l(char const* _String, char** _EndPtr, _locale_t _Locale);

    __declspec(dllimport) double __cdecl strtod(char const* _String, char** _EndPtr);

    __declspec(dllimport) double __cdecl _strtod_l(char const* _String, char** _EndPtr, _locale_t _Locale);

    __declspec(dllimport) long double __cdecl strtold(char const* _String, char** _EndPtr);

    __declspec(dllimport) long double __cdecl _strtold_l(char const* _String, char** _EndPtr, _locale_t _Locale);

    __declspec(dllimport) long __cdecl strtol(char const* _String, char** _EndPtr, int _Radix);

    __declspec(dllimport) long __cdecl _strtol_l(char const* _String, char** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) long long __cdecl strtoll(char const* _String, char** _EndPtr, int _Radix);

    __declspec(dllimport) long long __cdecl _strtoll_l(char const* _String, char** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) unsigned long __cdecl strtoul(char const* _String, char** _EndPtr, int _Radix);

    __declspec(dllimport) unsigned long __cdecl _strtoul_l(char const* _String, char** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) unsigned long long __cdecl strtoull(char const* _String, char** _EndPtr, int _Radix);

    __declspec(dllimport) unsigned long long __cdecl _strtoull_l(char const* _String, char** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) __int64 __cdecl _strtoi64(char const* _String, char** _EndPtr, int _Radix);

    __declspec(dllimport) __int64 __cdecl _strtoi64_l(char const* _String, char** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) unsigned __int64 __cdecl _strtoui64(char const* _String, char** _EndPtr, int _Radix);

    __declspec(dllimport) unsigned __int64 __cdecl _strtoui64_l(char const* _String, char** _EndPtr, int _Radix, _locale_t _Locale);

    __declspec(dllimport) errno_t __cdecl _itoa_s(int _Value, char* _Buffer, size_t _BufferCount, int _Radix);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _itoa_s(int _Value, char (&_Buffer)[_Size], int _Radix) throw()
        {
            return _itoa_s(_Value, _Buffer, _Size, _Radix);
        }
    }

#pragma warning(push)
#pragma warning(disable : 28719)
#pragma warning(disable : 28726)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_itoa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _itoa(int _Value, char* _Buffer,
                                                                                                     int _Radix);
#pragma warning(pop)

    __declspec(dllimport) errno_t __cdecl _ltoa_s(long _Value, char* _Buffer, size_t _BufferCount, int _Radix);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _ltoa_s(long _Value, char (&_Buffer)[_Size], int _Radix) throw()
        {
            return _ltoa_s(_Value, _Buffer, _Size, _Radix);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ltoa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ltoa(long _Value, char* _Buffer,
                                                                                                     int _Radix);

    __declspec(dllimport) errno_t __cdecl _ultoa_s(unsigned long _Value, char* _Buffer, size_t _BufferCount, int _Radix);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _ultoa_s(unsigned long _Value, char (&_Buffer)[_Size], int _Radix) throw()
        {
            return _ultoa_s(_Value, _Buffer, _Size, _Radix);
        }
    }

#pragma warning(push)
#pragma warning(disable : 28726)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ultoa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ultoa(unsigned long _Value,
                                                                                                      char* _Buffer, int _Radix);
#pragma warning(pop)

    __declspec(dllimport) errno_t __cdecl _i64toa_s(__int64 _Value, char* _Buffer, size_t _BufferCount, int _Radix);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_i64toa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _i64toa(__int64 _Value,
                                                                                                       char* _Buffer, int _Radix);

    __declspec(dllimport) errno_t __cdecl _ui64toa_s(unsigned __int64 _Value, char* _Buffer, size_t _BufferCount, int _Radix);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ui64toa_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ui64toa(unsigned __int64 _Value,
                                                                                                        char* _Buffer, int _Radix);

    __declspec(dllimport)
    errno_t __cdecl _ecvt_s(char* _Buffer, size_t _BufferCount, double _Value, int _DigitCount, int* _PtDec, int* _PtSign);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _ecvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount, int* _PtDec, int* _PtSign) throw()
        {
            return _ecvt_s(_Buffer, _Size, _Value, _DigitCount, _PtDec, _PtSign);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ecvt_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ecvt(double _Value, int _DigitCount,
                                                                                                     int* _PtDec, int* _PtSign);

    __declspec(dllimport) errno_t __cdecl _fcvt_s(char* _Buffer, size_t _BufferCount, double _Value,
                                                  int _FractionalDigitCount, int* _PtDec, int* _PtSign);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _fcvt_s(char (&_Buffer)[_Size], double _Value, int _FractionalDigitCount, int* _PtDec, int* _PtSign) throw()
        {
            return _fcvt_s(_Buffer, _Size, _Value, _FractionalDigitCount, _PtDec, _PtSign);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_fcvt_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _fcvt(double _Value, int _FractionalDigitCount,
                                                                                                     int* _PtDec, int* _PtSign);

    __declspec(dllimport) errno_t __cdecl _gcvt_s(char* _Buffer, size_t _BufferCount, double _Value, int _DigitCount);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _gcvt_s(char (&_Buffer)[_Size], double _Value, int _DigitCount) throw()
        {
            return _gcvt_s(_Buffer, _Size, _Value, _DigitCount);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_gcvt_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _gcvt(double _Value, int _DigitCount,
                                                                                                     char* _Buffer);

    __declspec(dllimport) int __cdecl ___mb_cur_max_func(void);

    __declspec(dllimport) int __cdecl ___mb_cur_max_l_func(_locale_t _Locale);

    __declspec(dllimport) int __cdecl mblen(char const* _Ch, size_t _MaxCount);

    __declspec(dllimport) int __cdecl _mblen_l(char const* _Ch, size_t _MaxCount, _locale_t _Locale);

    __declspec(dllimport) size_t __cdecl _mbstrlen(char const* _String);

    __declspec(dllimport) size_t __cdecl _mbstrlen_l(char const* _String, _locale_t _Locale);

    __declspec(dllimport) size_t __cdecl _mbstrnlen(char const* _String, size_t _MaxCount);

    __declspec(dllimport) size_t __cdecl _mbstrnlen_l(char const* _String, size_t _MaxCount, _locale_t _Locale);

    __declspec(dllimport) int __cdecl mbtowc(wchar_t * _DstCh, char const* _SrcCh, size_t _SrcSizeInBytes);

    __declspec(dllimport) int __cdecl _mbtowc_l(wchar_t * _DstCh, char const* _SrcCh, size_t _SrcSizeInBytes, _locale_t _Locale);

    __declspec(dllimport) errno_t __cdecl mbstowcs_s(size_t * _PtNumOfCharConverted, wchar_t * _DstBuf,
                                                     size_t _SizeInWords, char const* _SrcBuf, size_t _MaxCount);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl mbstowcs_s(size_t* _PtNumOfCharConverted, wchar_t (&_Dest)[_Size], char const* _Source, size_t _MaxCount) throw()
        {
            return mbstowcs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "mbstowcs_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    size_t __cdecl mbstowcs(wchar_t * _Dest, char const* _Source, size_t _MaxCount);

    __declspec(dllimport) errno_t __cdecl _mbstowcs_s_l(size_t * _PtNumOfCharConverted, wchar_t * _DstBuf, size_t _SizeInWords,
                                                        char const* _SrcBuf, size_t _MaxCount, _locale_t _Locale);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _mbstowcs_s_l(size_t* _PtNumOfCharConverted,
                                             wchar_t (&_Dest)[_Size],
                                             char const* _Source,
                                             size_t _MaxCount,
                                             _locale_t _Locale) throw()
        {
            return _mbstowcs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_mbstowcs_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    size_t __cdecl _mbstowcs_l(wchar_t * _Dest, char const* _Source, size_t _MaxCount, _locale_t _Locale);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wctomb_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int __cdecl wctomb(char* _MbCh, wchar_t _WCh);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wctomb_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int __cdecl _wctomb_l(char* _MbCh, wchar_t _WCh,
                                                                                                       _locale_t _Locale);

    __declspec(dllimport) errno_t __cdecl wctomb_s(int* _SizeConverted, char* _MbCh, rsize_t _SizeInBytes, wchar_t _WCh);

    __declspec(dllimport)
    errno_t __cdecl _wctomb_s_l(int* _SizeConverted, char* _MbCh, size_t _SizeInBytes, wchar_t _WCh, _locale_t _Locale);

    __declspec(dllimport) errno_t __cdecl wcstombs_s(size_t * _PtNumOfCharConverted, char* _Dst, size_t _DstSizeInBytes,
                                                     wchar_t const* _Src, size_t _MaxCountInBytes);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl wcstombs_s(size_t* _PtNumOfCharConverted, char (&_Dest)[_Size], wchar_t const* _Source, size_t _MaxCount) throw()
        {
            return wcstombs_s(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcstombs_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    size_t __cdecl wcstombs(char* _Dest, wchar_t const* _Source, size_t _MaxCount);

    __declspec(dllimport) errno_t __cdecl _wcstombs_s_l(size_t * _PtNumOfCharConverted, char* _Dst, size_t _DstSizeInBytes,
                                                        wchar_t const* _Src, size_t _MaxCountInBytes, _locale_t _Locale);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _wcstombs_s_l(size_t* _PtNumOfCharConverted,
                                             char (&_Dest)[_Size],
                                             wchar_t const* _Source,
                                             size_t _MaxCount,
                                             _locale_t _Locale) throw()
        {
            return _wcstombs_s_l(_PtNumOfCharConverted, _Dest, _Size, _Source, _MaxCount, _Locale);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcstombs_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    size_t __cdecl _wcstombs_l(char* _Dest, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);

    __declspec(dllimport) __declspec(allocator) char* __cdecl _fullpath(char* _Buffer, char const* _Path, size_t _BufferCount);

    __declspec(dllimport) errno_t __cdecl _makepath_s(char* _Buffer, size_t _BufferCount, char const* _Drive,
                                                      char const* _Dir, char const* _Filename, char const* _Ext);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _makepath_s(
        char (&_Buffer)[_Size], char const* _Drive, char const* _Dir, char const* _Filename, char const* _Ext) throw()
        {
            return _makepath_s(_Buffer, _Size, _Drive, _Dir, _Filename, _Ext);
        }
    }

#pragma warning(push)
#pragma warning(disable : 28719)
#pragma warning(disable : 28726)
    __declspec(deprecated(
    "This function or variable may be unsafe. Consider using "
    "_makepath_s"
    " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
    "See online help for details.")) __declspec(dllimport) void __cdecl _makepath(char* _Buffer, char const* _Drive,
                                                                                  char const* _Dir, char const* _Filename,
                                                                                  char const* _Ext);
#pragma warning(pop)

    __declspec(deprecated(
    "This function or variable may be unsafe. Consider using "
    "_splitpath_s"
    " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
    "See online help for details.")) __declspec(dllimport) void __cdecl _splitpath(char const* _FullPath, char* _Drive,
                                                                                   char* _Dir, char* _Filename, char* _Ext);

    __declspec(dllimport)
    errno_t __cdecl _splitpath_s(char const* _FullPath, char* _Drive, size_t _DriveCount, char* _Dir, size_t _DirCount,
                                 char* _Filename, size_t _FilenameCount, char* _Ext, size_t _ExtCount);

    extern "C++"
    {
        template <size_t _DriveSize, size_t _DirSize, size_t _NameSize, size_t _ExtSize>
        inline errno_t __cdecl _splitpath_s(char const* _Dest,
                                            char (&_Drive)[_DriveSize],
                                            char (&_Dir)[_DirSize],
                                            char (&_Name)[_NameSize],
                                            char (&_Ext)[_ExtSize]) throw()
        {
            return _splitpath_s(_Dest, _Drive, _DriveSize, _Dir, _DirSize, _Name, _NameSize, _Ext, _ExtSize);
        }
    }

    __declspec(dllimport)
    errno_t __cdecl getenv_s(size_t * _RequiredCount, char* _Buffer, rsize_t _BufferCount, char const* _VarName);

    __declspec(dllimport) int* __cdecl __p___argc(void);
    __declspec(dllimport) char*** __cdecl __p___argv(void);
    __declspec(dllimport) wchar_t*** __cdecl __p___wargv(void);

    __declspec(dllimport) char*** __cdecl __p__environ(void);
    __declspec(dllimport) wchar_t*** __cdecl __p__wenviron(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_dupenv_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl getenv(char const* _VarName);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl getenv_s(size_t* _RequiredCount, char (&_Buffer)[_Size], char const* _VarName) throw()
        {
            return getenv_s(_RequiredCount, _Buffer, _Size, _VarName);
        }
    }

    __declspec(dllimport) errno_t __cdecl _dupenv_s(char** _Buffer, size_t* _BufferCount, char const* _VarName);

    __declspec(dllimport) int __cdecl system(char const* _Command);

#pragma warning(push)
#pragma warning(disable : 6540)

    __declspec(dllimport) int __cdecl _putenv(char const* _EnvString);

    __declspec(dllimport) errno_t __cdecl _putenv_s(char const* _Name, char const* _Value);

#pragma warning(pop)

    __declspec(dllimport)
    errno_t __cdecl _searchenv_s(char const* _Filename, char const* _VarName, char* _Buffer, size_t _BufferCount);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _searchenv_s(char const* _Filename, char const* _VarName, char (&_Buffer)[_Size]) throw()
        {
            return _searchenv_s(_Filename, _VarName, _Buffer, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_searchenv_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl _searchenv(char const* _Filename,
                                                                                                         char const* _VarName,
                                                                                                         char* _Buffer);

    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "SetErrorMode"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) void __cdecl _seterrormode(int _Mode);

    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "Beep"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) void __cdecl _beep(unsigned _Frequency,
                                                                                                             unsigned _Duration);

    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "Sleep"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) void __cdecl _sleep(unsigned long _Duration);

#pragma warning(push)
#pragma warning(disable : 4141)

    __declspec(deprecated(
    "The POSIX name for this item is deprecated. Instead, use the ISO C "
    "and C++ conformant name: "
    "_ecvt"
    ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                             "_ecvt_s"
                                                             " instead. To disable deprecation, use "
                                                             "_CRT_SECURE_NO_WARNINGS. "
                                                             "See online help for details.")) __declspec(dllimport) char* __cdecl ecvt(double _Value,
                                                                                                                                       int _DigitCount,
                                                                                                                                       int* _PtDec,
                                                                                                                                       int* _PtSign);

    __declspec(deprecated(
    "The POSIX name for this item is deprecated. Instead, use the ISO C "
    "and C++ conformant name: "
    "_fcvt"
    ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                             "_fcvt_s"
                                                             " instead. To disable deprecation, use "
                                                             "_CRT_SECURE_NO_WARNINGS. "
                                                             "See online help for details.")) __declspec(dllimport) char* __cdecl fcvt(double _Value,
                                                                                                                                       int _FractionalDigitCount,
                                                                                                                                       int* _PtDec,
                                                                                                                                       int* _PtSign);

    __declspec(deprecated(
    "The POSIX name for this item is deprecated. Instead, use the ISO C "
    "and C++ conformant name: "
    "_gcvt"
    ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                             "_fcvt_s"
                                                             " instead. To disable deprecation, use "
                                                             "_CRT_SECURE_NO_WARNINGS. "
                                                             "See online help for details.")) __declspec(dllimport) char* __cdecl gcvt(double _Value,
                                                                                                                                       int _DigitCount,
                                                                                                                                       char* _DstBuf);

    __declspec(deprecated(
    "The POSIX name for this item is deprecated. Instead, use the ISO C "
    "and C++ conformant name: "
    "_itoa"
    ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                             "_itoa_s"
                                                             " instead. To disable deprecation, use "
                                                             "_CRT_SECURE_NO_WARNINGS. "
                                                             "See online help for details.")) __declspec(dllimport) char* __cdecl itoa(int _Value,
                                                                                                                                       char* _Buffer,
                                                                                                                                       int _Radix);

    __declspec(deprecated(
    "The POSIX name for this item is deprecated. Instead, use the ISO C "
    "and C++ conformant name: "
    "_ltoa"
    ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                             "_ltoa_s"
                                                             " instead. To disable deprecation, use "
                                                             "_CRT_SECURE_NO_WARNINGS. "
                                                             "See online help for details.")) __declspec(dllimport) char* __cdecl ltoa(long _Value,
                                                                                                                                       char* _Buffer,
                                                                                                                                       int _Radix);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_swab"
                          ". See online help for details.")) __declspec(dllimport) void __cdecl swab(char* _Buf1, char* _Buf2,
                                                                                                     int _SizeInBytes);

    __declspec(deprecated(
    "The POSIX name for this item is deprecated. Instead, use the ISO C "
    "and C++ conformant name: "
    "_ultoa"
    ". See online help for details.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                             "_ultoa_s"
                                                             " instead. To disable deprecation, use "
                                                             "_CRT_SECURE_NO_WARNINGS. "
                                                             "See online help for details.")) __declspec(dllimport) char* __cdecl ultoa(unsigned long _Value,
                                                                                                                                        char* _Buffer,
                                                                                                                                        int _Radix);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_putenv"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl putenv(char const* _EnvString);

#pragma warning(pop)

    _onexit_t __cdecl onexit(_onexit_t _Func);
}
__pragma(pack(pop))

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

[[nodiscard]] inline double abs(double _Xx) noexcept
{
    return ::fabs(_Xx);
}

[[nodiscard]] inline float abs(float _Xx) noexcept
{
    return ::fabsf(_Xx);
}

[[nodiscard]] inline long double abs(long double _Xx) noexcept
{
    return ::fabsl(_Xx);
}

namespace std
{
    using ::abort;
    using ::abs;
    using ::atexit;
    using ::atof;
    using ::atoi;
    using ::atol;
    using ::bsearch;
    using ::calloc;
    using ::div;
    using ::div_t;
    using ::exit;
    using ::free;
    using ::labs;
    using ::ldiv;
    using ::ldiv_t;
    using ::malloc;
    using ::mblen;
    using ::mbstowcs;
    using ::mbtowc;
    using ::qsort;
    using ::rand;
    using ::realloc;
    using ::size_t;
    using ::srand;
    using ::strtod;
    using ::strtol;
    using ::strtoul;
    using ::wcstombs;
    using ::wctomb;

    using ::lldiv_t;

    using ::getenv;
    using ::system;

    using ::atoll;
    using ::llabs;
    using ::lldiv;
    using ::strtof;
    using ::strtold;
    using ::strtoll;
    using ::strtoull;

    using ::_Exit;
    using ::at_quick_exit;
    using ::quick_exit;
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Ty, _Ty _Val> struct integral_constant
    {
        static constexpr _Ty value = _Val;

        using value_type = _Ty;
        using type = integral_constant;

        constexpr operator value_type() const noexcept
        {
            return value;
        }

        [[nodiscard]] constexpr value_type operator()() const noexcept
        {
            return value;
        }
    };

    template <bool _Val> using bool_constant = integral_constant<bool, _Val>;

    using true_type = bool_constant<true>;
    using false_type = bool_constant<false>;

    template <bool _Test, class _Ty = void> struct enable_if
    {
    };

    template <class _Ty> struct enable_if<true, _Ty>
    {
        using type = _Ty;
    };

    template <bool _Test, class _Ty = void> using enable_if_t = typename enable_if<_Test, _Ty>::type;

    template <bool _Test, class _Ty1, class _Ty2> struct conditional
    {
        using type = _Ty1;
    };

    template <class _Ty1, class _Ty2> struct conditional<false, _Ty1, _Ty2>
    {
        using type = _Ty2;
    };

    template <bool _Test, class _Ty1, class _Ty2> using conditional_t = typename conditional<_Test, _Ty1, _Ty2>::type;

    template <class, class> constexpr bool is_same_v = false;
    template <class _Ty> constexpr bool is_same_v<_Ty, _Ty> = true;

    template <class _Ty1, class _Ty2> struct is_same : bool_constant<is_same_v<_Ty1, _Ty2>>
    {
    };

    template <class _Ty> struct remove_const
    {
        using type = _Ty;
    };

    template <class _Ty> struct remove_const<const _Ty>
    {
        using type = _Ty;
    };

    template <class _Ty> using remove_const_t = typename remove_const<_Ty>::type;

    template <class _Ty> struct remove_volatile
    {
        using type = _Ty;
    };

    template <class _Ty> struct remove_volatile<volatile _Ty>
    {
        using type = _Ty;
    };

    template <class _Ty> using remove_volatile_t = typename remove_volatile<_Ty>::type;

    template <class _Ty> struct remove_cv
    {
        using type = _Ty;

        template <template <class> class _Fn> using _Apply = _Fn<_Ty>;
    };

    template <class _Ty> struct remove_cv<const _Ty>
    {
        using type = _Ty;

        template <template <class> class _Fn> using _Apply = const _Fn<_Ty>;
    };

    template <class _Ty> struct remove_cv<volatile _Ty>
    {
        using type = _Ty;

        template <template <class> class _Fn> using _Apply = volatile _Fn<_Ty>;
    };

    template <class _Ty> struct remove_cv<const volatile _Ty>
    {
        using type = _Ty;

        template <template <class> class _Fn> using _Apply = const volatile _Fn<_Ty>;
    };

    template <class _Ty> using remove_cv_t = typename remove_cv<_Ty>::type;

    template <bool _First_value, class _First, class... _Rest> struct _Disjunction
    {
        using type = _First;
    };

    template <class _False, class _Next, class... _Rest> struct _Disjunction<false, _False, _Next, _Rest...>
    {
        using type = typename _Disjunction<_Next::value, _Next, _Rest...>::type;
    };

    template <class... _Traits> struct disjunction : false_type
    {
    };

    template <class _First, class... _Rest>
    struct disjunction<_First, _Rest...> : _Disjunction<_First::value, _First, _Rest...>::type
    {
    };

    template <class... _Traits> constexpr bool disjunction_v = disjunction<_Traits...>::value;

    template <class _Ty, class... _Types> constexpr bool _Is_any_of_v = disjunction_v<is_same<_Ty, _Types>...>;

    template <class _Ty>
    constexpr bool is_integral_v = _Is_any_of_v<remove_cv_t<_Ty>,
                                                bool,
                                                char,
                                                signed char,
                                                unsigned char,
                                                wchar_t,

                                                char16_t,
                                                char32_t,
                                                short,
                                                unsigned short,
                                                int,
                                                unsigned int,
                                                long,
                                                unsigned long,
                                                long long,
                                                unsigned long long>;

    template <class _Ty> struct is_integral : bool_constant<is_integral_v<_Ty>>
    {
    };

    template <class _Ty>
    constexpr bool is_floating_point_v = _Is_any_of_v<remove_cv_t<_Ty>, float, double, long double>;

    template <class _Ty> struct is_floating_point : bool_constant<is_floating_point_v<_Ty>>
    {
    };

    template <class _Ty> constexpr bool is_arithmetic_v = is_integral_v<_Ty> || is_floating_point_v<_Ty>;

    template <class _Ty> struct is_arithmetic : bool_constant<is_arithmetic_v<_Ty>>
    {
    };

    template <class _Ty> struct remove_reference
    {
        using type = _Ty;
        using _Const_thru_ref_type = const _Ty;
    };

    template <class _Ty> struct remove_reference<_Ty&>
    {
        using type = _Ty;
        using _Const_thru_ref_type = const _Ty&;
    };

    template <class _Ty> struct remove_reference<_Ty&&>
    {
        using type = _Ty;
        using _Const_thru_ref_type = const _Ty&&;
    };

    template <class _Ty> using remove_reference_t = typename remove_reference<_Ty>::type;

    template <class _Ty> using _Const_thru_ref = typename remove_reference<_Ty>::_Const_thru_ref_type;

    template <class _Ty> using _Remove_cvref_t = remove_cv_t<remove_reference_t<_Ty>>;

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

[[nodiscard]] inline double pow(double _Xx, int _Yx) noexcept
{
    if(_Yx == 2)
    {
        return _Xx * _Xx;
    }

    return ::pow(_Xx, static_cast<double>(_Yx));
}

[[nodiscard]] inline float acos(float _Xx) noexcept
{
    return ::acosf(_Xx);
}

[[nodiscard]] inline float acosh(float _Xx) noexcept
{
    return ::acoshf(_Xx);
}

[[nodiscard]] inline float asin(float _Xx) noexcept
{
    return ::asinf(_Xx);
}

[[nodiscard]] inline float asinh(float _Xx) noexcept
{
    return ::asinhf(_Xx);
}

[[nodiscard]] inline float atan(float _Xx) noexcept
{
    return ::atanf(_Xx);
}

[[nodiscard]] inline float atanh(float _Xx) noexcept
{
    return ::atanhf(_Xx);
}

[[nodiscard]] inline float atan2(float _Yx, float _Xx) noexcept
{
    return ::atan2f(_Yx, _Xx);
}

[[nodiscard]] inline float cbrt(float _Xx) noexcept
{
    return ::cbrtf(_Xx);
}

[[nodiscard]] inline float ceil(float _Xx) noexcept
{
    return ::ceilf(_Xx);
}

[[nodiscard]] inline float copysign(float _Number, float _Sign) noexcept
{
    return ::copysignf(_Number, _Sign);
}

[[nodiscard]] inline float cos(float _Xx) noexcept
{
    return ::cosf(_Xx);
}

[[nodiscard]] inline float cosh(float _Xx) noexcept
{
    return ::coshf(_Xx);
}

[[nodiscard]] inline float erf(float _Xx) noexcept
{
    return ::erff(_Xx);
}

[[nodiscard]] inline float erfc(float _Xx) noexcept
{
    return ::erfcf(_Xx);
}

[[nodiscard]] inline float exp(float _Xx) noexcept
{
    return ::expf(_Xx);
}

[[nodiscard]] inline float exp2(float _Xx) noexcept
{
    return ::exp2f(_Xx);
}

[[nodiscard]] inline float expm1(float _Xx) noexcept
{
    return ::expm1f(_Xx);
}

[[nodiscard]] inline float fabs(float _Xx) noexcept
{
    return ::fabsf(_Xx);
}

[[nodiscard]] inline float fdim(float _Xx, float _Yx) noexcept
{
    return ::fdimf(_Xx, _Yx);
}

[[nodiscard]] inline float floor(float _Xx) noexcept
{
    return ::floorf(_Xx);
}

[[nodiscard]] inline float fma(float _Xx, float _Yx, float _Zx) noexcept
{
    return ::fmaf(_Xx, _Yx, _Zx);
}

[[nodiscard]] inline float fmax(float _Xx, float _Yx) noexcept
{
    return ::fmaxf(_Xx, _Yx);
}

[[nodiscard]] inline float fmin(float _Xx, float _Yx) noexcept
{
    return ::fminf(_Xx, _Yx);
}

[[nodiscard]] inline float fmod(float _Xx, float _Yx) noexcept
{
    return ::fmodf(_Xx, _Yx);
}

inline float frexp(float _Xx, int* _Yx) noexcept
{
    return ::frexpf(_Xx, _Yx);
}

[[nodiscard]] inline float hypot(float _Xx, float _Yx) noexcept
{
    return ::hypotf(_Xx, _Yx);
}

[[nodiscard]] inline int ilogb(float _Xx) noexcept
{
    return ::ilogbf(_Xx);
}

[[nodiscard]] inline float ldexp(float _Xx, int _Yx) noexcept
{
    return ::ldexpf(_Xx, _Yx);
}

[[nodiscard]] inline float lgamma(float _Xx) noexcept
{
    return ::lgammaf(_Xx);
}

[[nodiscard]] inline long long llrint(float _Xx) noexcept
{
    return ::llrintf(_Xx);
}

[[nodiscard]] inline long long llround(float _Xx) noexcept
{
    return ::llroundf(_Xx);
}

[[nodiscard]] inline float log(float _Xx) noexcept
{
    return ::logf(_Xx);
}

[[nodiscard]] inline float log10(float _Xx) noexcept
{
    return ::log10f(_Xx);
}

[[nodiscard]] inline float log1p(float _Xx) noexcept
{
    return ::log1pf(_Xx);
}

[[nodiscard]] inline float log2(float _Xx) noexcept
{
    return ::log2f(_Xx);
}

[[nodiscard]] inline float logb(float _Xx) noexcept
{
    return ::logbf(_Xx);
}

[[nodiscard]] inline long lrint(float _Xx) noexcept
{
    return ::lrintf(_Xx);
}

[[nodiscard]] inline long lround(float _Xx) noexcept
{
    return ::lroundf(_Xx);
}

inline float modf(float _Xx, float* _Yx) noexcept
{
    return ::modff(_Xx, _Yx);
}

[[nodiscard]] inline float nearbyint(float _Xx) noexcept
{
    return ::nearbyintf(_Xx);
}

[[nodiscard]] inline float nextafter(float _Xx, float _Yx) noexcept
{
    return ::nextafterf(_Xx, _Yx);
}

[[nodiscard]] inline float nexttoward(float _Xx, long double _Yx) noexcept
{
    return ::nexttowardf(_Xx, _Yx);
}

[[nodiscard]] inline float pow(float _Xx, float _Yx) noexcept
{
    return ::powf(_Xx, _Yx);
}

[[nodiscard]] inline float pow(float _Xx, int _Yx) noexcept
{
    if(_Yx == 2)
    {
        return _Xx * _Xx;
    }

    return ::powf(_Xx, static_cast<float>(_Yx));
}

[[nodiscard]] inline float remainder(float _Xx, float _Yx) noexcept
{
    return ::remainderf(_Xx, _Yx);
}

inline float remquo(float _Xx, float _Yx, int* _Zx) noexcept
{
    return ::remquof(_Xx, _Yx, _Zx);
}

[[nodiscard]] inline float rint(float _Xx) noexcept
{
    return ::rintf(_Xx);
}

[[nodiscard]] inline float round(float _Xx) noexcept
{
    return ::roundf(_Xx);
}

[[nodiscard]] inline float scalbln(float _Xx, long _Yx) noexcept
{
    return ::scalblnf(_Xx, _Yx);
}

[[nodiscard]] inline float scalbn(float _Xx, int _Yx) noexcept
{
    return ::scalbnf(_Xx, _Yx);
}

[[nodiscard]] inline float sin(float _Xx) noexcept
{
    return ::sinf(_Xx);
}

[[nodiscard]] inline float sinh(float _Xx) noexcept
{
    return ::sinhf(_Xx);
}

[[nodiscard]] inline float sqrt(float _Xx) noexcept
{
    return ::sqrtf(_Xx);
}

[[nodiscard]] inline float tan(float _Xx) noexcept
{
    return ::tanf(_Xx);
}

[[nodiscard]] inline float tanh(float _Xx) noexcept
{
    return ::tanhf(_Xx);
}

[[nodiscard]] inline float tgamma(float _Xx) noexcept
{
    return ::tgammaf(_Xx);
}

[[nodiscard]] inline float trunc(float _Xx) noexcept
{
    return ::truncf(_Xx);
}

[[nodiscard]] inline long double acos(long double _Xx) noexcept
{
    return ::acosl(_Xx);
}

[[nodiscard]] inline long double acosh(long double _Xx) noexcept
{
    return ::acoshl(_Xx);
}

[[nodiscard]] inline long double asin(long double _Xx) noexcept
{
    return ::asinl(_Xx);
}

[[nodiscard]] inline long double asinh(long double _Xx) noexcept
{
    return ::asinhl(_Xx);
}

[[nodiscard]] inline long double atan(long double _Xx) noexcept
{
    return ::atanl(_Xx);
}

[[nodiscard]] inline long double atanh(long double _Xx) noexcept
{
    return ::atanhl(_Xx);
}

[[nodiscard]] inline long double atan2(long double _Yx, long double _Xx) noexcept
{
    return ::atan2l(_Yx, _Xx);
}

[[nodiscard]] inline long double cbrt(long double _Xx) noexcept
{
    return ::cbrtl(_Xx);
}

[[nodiscard]] inline long double ceil(long double _Xx) noexcept
{
    return ::ceill(_Xx);
}

[[nodiscard]] inline long double copysign(long double _Number, long double _Sign) noexcept
{
    return ::copysignl(_Number, _Sign);
}

[[nodiscard]] inline long double cos(long double _Xx) noexcept
{
    return ::cosl(_Xx);
}

[[nodiscard]] inline long double cosh(long double _Xx) noexcept
{
    return ::coshl(_Xx);
}

[[nodiscard]] inline long double erf(long double _Xx) noexcept
{
    return ::erfl(_Xx);
}

[[nodiscard]] inline long double erfc(long double _Xx) noexcept
{
    return ::erfcl(_Xx);
}

[[nodiscard]] inline long double exp(long double _Xx) noexcept
{
    return ::expl(_Xx);
}

[[nodiscard]] inline long double exp2(long double _Xx) noexcept
{
    return ::exp2l(_Xx);
}

[[nodiscard]] inline long double expm1(long double _Xx) noexcept
{
    return ::expm1l(_Xx);
}

[[nodiscard]] inline long double fabs(long double _Xx) noexcept
{
    return ::fabsl(_Xx);
}

[[nodiscard]] inline long double fdim(long double _Xx, long double _Yx) noexcept
{
    return ::fdiml(_Xx, _Yx);
}

[[nodiscard]] inline long double floor(long double _Xx) noexcept
{
    return ::floorl(_Xx);
}

[[nodiscard]] inline long double fma(long double _Xx, long double _Yx, long double _Zx) noexcept
{
    return ::fmal(_Xx, _Yx, _Zx);
}

[[nodiscard]] inline long double fmax(long double _Xx, long double _Yx) noexcept
{
    return ::fmaxl(_Xx, _Yx);
}

[[nodiscard]] inline long double fmin(long double _Xx, long double _Yx) noexcept
{
    return ::fminl(_Xx, _Yx);
}

[[nodiscard]] inline long double fmod(long double _Xx, long double _Yx) noexcept
{
    return ::fmodl(_Xx, _Yx);
}

inline long double frexp(long double _Xx, int* _Yx) noexcept
{
    return ::frexpl(_Xx, _Yx);
}

[[nodiscard]] inline long double hypot(long double _Xx, long double _Yx) noexcept
{
    return ::hypotl(_Xx, _Yx);
}

[[nodiscard]] inline int ilogb(long double _Xx) noexcept
{
    return ::ilogbl(_Xx);
}

[[nodiscard]] inline long double ldexp(long double _Xx, int _Yx) noexcept
{
    return ::ldexpl(_Xx, _Yx);
}

[[nodiscard]] inline long double lgamma(long double _Xx) noexcept
{
    return ::lgammal(_Xx);
}

[[nodiscard]] inline long long llrint(long double _Xx) noexcept
{
    return ::llrintl(_Xx);
}

[[nodiscard]] inline long long llround(long double _Xx) noexcept
{
    return ::llroundl(_Xx);
}

[[nodiscard]] inline long double log(long double _Xx) noexcept
{
    return ::logl(_Xx);
}

[[nodiscard]] inline long double log10(long double _Xx) noexcept
{
    return ::log10l(_Xx);
}

[[nodiscard]] inline long double log1p(long double _Xx) noexcept
{
    return ::log1pl(_Xx);
}

[[nodiscard]] inline long double log2(long double _Xx) noexcept
{
    return ::log2l(_Xx);
}

[[nodiscard]] inline long double logb(long double _Xx) noexcept
{
    return ::logbl(_Xx);
}

[[nodiscard]] inline long lrint(long double _Xx) noexcept
{
    return ::lrintl(_Xx);
}

[[nodiscard]] inline long lround(long double _Xx) noexcept
{
    return ::lroundl(_Xx);
}

inline long double modf(long double _Xx, long double* _Yx) noexcept
{
    return ::modfl(_Xx, _Yx);
}

[[nodiscard]] inline long double nearbyint(long double _Xx) noexcept
{
    return ::nearbyintl(_Xx);
}

[[nodiscard]] inline long double nextafter(long double _Xx, long double _Yx) noexcept
{
    return ::nextafterl(_Xx, _Yx);
}

[[nodiscard]] inline long double nexttoward(long double _Xx, long double _Yx) noexcept
{
    return ::nexttowardl(_Xx, _Yx);
}

[[nodiscard]] inline long double pow(long double _Xx, long double _Yx) noexcept
{
    return ::powl(_Xx, _Yx);
}

[[nodiscard]] inline long double pow(long double _Xx, int _Yx) noexcept
{
    if(_Yx == 2)
    {
        return _Xx * _Xx;
    }

    return ::powl(_Xx, static_cast<long double>(_Yx));
}

[[nodiscard]] inline long double remainder(long double _Xx, long double _Yx) noexcept
{
    return ::remainderl(_Xx, _Yx);
}

inline long double remquo(long double _Xx, long double _Yx, int* _Zx) noexcept
{
    return ::remquol(_Xx, _Yx, _Zx);
}

[[nodiscard]] inline long double rint(long double _Xx) noexcept
{
    return ::rintl(_Xx);
}

[[nodiscard]] inline long double round(long double _Xx) noexcept
{
    return ::roundl(_Xx);
}

[[nodiscard]] inline long double scalbln(long double _Xx, long _Yx) noexcept
{
    return ::scalblnl(_Xx, _Yx);
}

[[nodiscard]] inline long double scalbn(long double _Xx, int _Yx) noexcept
{
    return ::scalbnl(_Xx, _Yx);
}

[[nodiscard]] inline long double sin(long double _Xx) noexcept
{
    return ::sinl(_Xx);
}

[[nodiscard]] inline long double sinh(long double _Xx) noexcept
{
    return ::sinhl(_Xx);
}

[[nodiscard]] inline long double sqrt(long double _Xx) noexcept
{
    return ::sqrtl(_Xx);
}

[[nodiscard]] inline long double tan(long double _Xx) noexcept
{
    return ::tanl(_Xx);
}

[[nodiscard]] inline long double tanh(long double _Xx) noexcept
{
    return ::tanhl(_Xx);
}

[[nodiscard]] inline long double tgamma(long double _Xx) noexcept
{
    return ::tgammal(_Xx);
}

[[nodiscard]] inline long double trunc(long double _Xx) noexcept
{
    return ::truncl(_Xx);
}

namespace std
{
    template <class _Ty1, class _Ty2>
    using _Common_float_type_t = conditional_t<is_same_v<_Ty1, long double> || is_same_v<_Ty2, long double>,
                                               long double,
                                               conditional_t<is_same_v<_Ty1, float> && is_same_v<_Ty2, float>, float, double>>;
}

template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
double frexp(_Ty _Value, int* const _Exp) noexcept
{
    return ::frexp(static_cast<double>(_Value), _Exp);
}

template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> pow(const _Ty1 _Left, const _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::pow(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}

template <class _Ty1, class _Ty2, class _Ty3, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>&& ::std::is_arithmetic_v<_Ty3>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, ::std::_Common_float_type_t<_Ty2, _Ty3>>
fma(_Ty1 _Left, _Ty2 _Middle, _Ty3 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, ::std::_Common_float_type_t<_Ty2, _Ty3>>;

    if constexpr(::std::is_same_v<_Common, float>)
    {
        return ::fmaf(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
    else if constexpr(::std::is_same_v<_Common, double>)
    {
        return ::fma(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
    else
    {
        return ::fmal(static_cast<_Common>(_Left), static_cast<_Common>(_Middle), static_cast<_Common>(_Right));
    }
}

template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
::std::_Common_float_type_t<_Ty1, _Ty2> remquo(_Ty1 _Left, _Ty2 _Right, int* _Pquo) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;

    if constexpr(::std::is_same_v<_Common, float>)
    {
        return ::remquof(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
    else if constexpr(::std::is_same_v<_Common, double>)
    {
        return ::remquo(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
    else
    {
        return ::remquol(static_cast<_Common>(_Left), static_cast<_Common>(_Right), _Pquo);
    }
}

template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double acos(_Ty _Left) noexcept
{
    return ::acos(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double asin(_Ty _Left) noexcept
{
    return ::asin(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double atan(_Ty _Left) noexcept
{
    return ::atan(static_cast<double>(_Left));
}
template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> atan2(_Ty1 _Left, _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::atan2(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>[[nodiscard]] double cos(_Ty _Left) noexcept
{
    return ::cos(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>[[nodiscard]] double sin(_Ty _Left) noexcept
{
    return ::sin(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>[[nodiscard]] double tan(_Ty _Left) noexcept
{
    return ::tan(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double acosh(_Ty _Left) noexcept
{
    return ::acosh(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double asinh(_Ty _Left) noexcept
{
    return ::asinh(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double atanh(_Ty _Left) noexcept
{
    return ::atanh(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double cosh(_Ty _Left) noexcept
{
    return ::cosh(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double sinh(_Ty _Left) noexcept
{
    return ::sinh(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double tanh(_Ty _Left) noexcept
{
    return ::tanh(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>[[nodiscard]] double exp(_Ty _Left) noexcept
{
    return ::exp(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double exp2(_Ty _Left) noexcept
{
    return ::exp2(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double expm1(_Ty _Left) noexcept
{
    return ::expm1(static_cast<double>(_Left));
}

template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>[[nodiscard]] int ilogb(_Ty _Left) noexcept
{
    return ::ilogb(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double ldexp(_Ty _Left, int _Arg2) noexcept
{
    return ::ldexp(static_cast<double>(_Left), _Arg2);
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>[[nodiscard]] double log(_Ty _Left) noexcept
{
    return ::log(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double log10(_Ty _Left) noexcept
{
    return ::log10(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double log1p(_Ty _Left) noexcept
{
    return ::log1p(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double log2(_Ty _Left) noexcept
{
    return ::log2(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double logb(_Ty _Left) noexcept
{
    return ::logb(static_cast<double>(_Left));
}

template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double scalbn(_Ty _Left, int _Arg2) noexcept
{
    return ::scalbn(static_cast<double>(_Left), _Arg2);
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double scalbln(_Ty _Left, long _Arg2) noexcept
{
    return ::scalbln(static_cast<double>(_Left), _Arg2);
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double cbrt(_Ty _Left) noexcept
{
    return ::cbrt(static_cast<double>(_Left));
}

template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double fabs(_Ty _Left) noexcept
{
    return ::fabs(static_cast<double>(_Left));
}
template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> hypot(_Ty1 _Left, _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::hypot(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}

template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double sqrt(_Ty _Left) noexcept
{
    return ::sqrt(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>[[nodiscard]] double erf(_Ty _Left) noexcept
{
    return ::erf(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double erfc(_Ty _Left) noexcept
{
    return ::erfc(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double lgamma(_Ty _Left) noexcept
{
    return ::lgamma(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double tgamma(_Ty _Left) noexcept
{
    return ::tgamma(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double ceil(_Ty _Left) noexcept
{
    return ::ceil(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double floor(_Ty _Left) noexcept
{
    return ::floor(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double nearbyint(_Ty _Left) noexcept
{
    return ::nearbyint(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double rint(_Ty _Left) noexcept
{
    return ::rint(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>[[nodiscard]] long lrint(_Ty _Left) noexcept
{
    return ::lrint(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] long long llrint(_Ty _Left) noexcept
{
    return ::llrint(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double round(_Ty _Left) noexcept
{
    return ::round(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] long lround(_Ty _Left) noexcept
{
    return ::lround(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] long long llround(_Ty _Left) noexcept
{
    return ::llround(static_cast<double>(_Left));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double trunc(_Ty _Left) noexcept
{
    return ::trunc(static_cast<double>(_Left));
}
template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> fmod(_Ty1 _Left, _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::fmod(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}
template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> remainder(_Ty1 _Left, _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::remainder(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}

template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> copysign(_Ty1 _Left, _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::copysign(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}

template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> nextafter(_Ty1 _Left, _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::nextafter(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}
template <class _Ty, ::std::enable_if_t<::std::is_integral_v<_Ty>, int> = 0>
[[nodiscard]] double nexttoward(_Ty _Left, long double _Arg2) noexcept
{
    return ::nexttoward(static_cast<double>(_Left), _Arg2);
}
template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> fdim(_Ty1 _Left, _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::fdim(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}
template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> fmax(_Ty1 _Left, _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::fmax(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}
template <class _Ty1, class _Ty2, ::std::enable_if_t<::std::is_arithmetic_v<_Ty1>&& ::std::is_arithmetic_v<_Ty2>, int> = 0>
[[nodiscard]] ::std::_Common_float_type_t<_Ty1, _Ty2> fmin(_Ty1 _Left, _Ty2 _Right) noexcept
{
    using _Common = ::std::_Common_float_type_t<_Ty1, _Ty2>;
    return ::fmin(static_cast<_Common>(_Left), static_cast<_Common>(_Right));
}

namespace std
{
    using ::abs;
    using ::acos;
    using ::asin;
    using ::atan;
    using ::atan2;
    using ::ceil;
    using ::cos;
    using ::cosh;
    using ::exp;
    using ::fabs;
    using ::floor;
    using ::fmod;
    using ::frexp;
    using ::ldexp;
    using ::log;
    using ::log10;
    using ::modf;
    using ::pow;
    using ::sin;
    using ::sinh;
    using ::sqrt;
    using ::tan;
    using ::tanh;

    using ::acosf;
    using ::asinf;
    using ::atan2f;
    using ::atanf;
    using ::ceilf;
    using ::cosf;
    using ::coshf;
    using ::expf;
    using ::fabsf;
    using ::floorf;
    using ::fmodf;
    using ::frexpf;
    using ::ldexpf;
    using ::log10f;
    using ::logf;
    using ::modff;
    using ::powf;
    using ::sinf;
    using ::sinhf;
    using ::sqrtf;
    using ::tanf;
    using ::tanhf;

    using ::acosl;
    using ::asinl;
    using ::atan2l;
    using ::atanl;
    using ::ceill;
    using ::coshl;
    using ::cosl;
    using ::expl;
    using ::fabsl;
    using ::floorl;
    using ::fmodl;
    using ::frexpl;
    using ::ldexpl;
    using ::log10l;
    using ::logl;
    using ::modfl;
    using ::powl;
    using ::sinhl;
    using ::sinl;
    using ::sqrtl;
    using ::tanhl;
    using ::tanl;

    using ::double_t;
    using ::float_t;

    using ::acosh;
    using ::asinh;
    using ::atanh;
    using ::cbrt;
    using ::copysign;
    using ::erf;
    using ::erfc;
    using ::exp2;
    using ::expm1;
    using ::fdim;
    using ::fma;
    using ::fmax;
    using ::fmin;
    using ::hypot;
    using ::ilogb;
    using ::lgamma;
    using ::llrint;
    using ::llround;
    using ::log1p;
    using ::log2;
    using ::logb;
    using ::lrint;
    using ::lround;
    using ::nan;
    using ::nearbyint;
    using ::nextafter;
    using ::nexttoward;
    using ::remainder;
    using ::remquo;
    using ::rint;
    using ::round;
    using ::scalbln;
    using ::scalbn;
    using ::tgamma;
    using ::trunc;

    using ::acoshf;
    using ::asinhf;
    using ::atanhf;
    using ::cbrtf;
    using ::copysignf;
    using ::erfcf;
    using ::erff;
    using ::exp2f;
    using ::expm1f;
    using ::fdimf;
    using ::fmaf;
    using ::fmaxf;
    using ::fminf;
    using ::hypotf;
    using ::ilogbf;
    using ::lgammaf;
    using ::llrintf;
    using ::llroundf;
    using ::log1pf;
    using ::log2f;
    using ::logbf;
    using ::lrintf;
    using ::lroundf;
    using ::nanf;
    using ::nearbyintf;
    using ::nextafterf;
    using ::nexttowardf;
    using ::remainderf;
    using ::remquof;
    using ::rintf;
    using ::roundf;
    using ::scalblnf;
    using ::scalbnf;
    using ::tgammaf;
    using ::truncf;

    using ::acoshl;
    using ::asinhl;
    using ::atanhl;
    using ::cbrtl;
    using ::copysignl;
    using ::erfcl;
    using ::erfl;
    using ::exp2l;
    using ::expm1l;
    using ::fdiml;
    using ::fmal;
    using ::fmaxl;
    using ::fminl;
    using ::hypotl;
    using ::ilogbl;
    using ::lgammal;
    using ::llrintl;
    using ::llroundl;
    using ::log1pl;
    using ::log2l;
    using ::logbl;
    using ::lrintl;
    using ::lroundl;
    using ::nanl;
    using ::nearbyintl;
    using ::nextafterl;
    using ::nexttowardl;
    using ::remainderl;
    using ::remquol;
    using ::rintl;
    using ::roundl;
    using ::scalblnl;
    using ::scalbnl;
    using ::tgammal;
    using ::truncl;

    using ::fpclassify;
    using ::isfinite;
    using ::isgreater;
    using ::isgreaterequal;
    using ::isinf;
    using ::isless;
    using ::islessequal;
    using ::islessgreater;
    using ::isnan;
    using ::isnormal;
    using ::isunordered;
    using ::signbit;
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C" {

#pragma detect_mismatch("_CRT_STDIO_ISO_WIDE_SPECIFIERS", "0")

#pragma managed(push, off)

    __declspec(noinline) __inline unsigned __int64 * __cdecl __local_stdio_printf_options(void){ static unsigned __int64 _OptionsStorage;
return &_OptionsStorage;
}

__declspec(noinline) __inline unsigned __int64* __cdecl __local_stdio_scanf_options(void)
{
    static unsigned __int64 _OptionsStorage;
    return &_OptionsStorage;
}

#pragma managed(pop)
}
__pragma(pack(pop))

__pragma(pack(push, 8)) extern "C"
{
    typedef struct _iobuf
    {
        void* _Placeholder;
    } FILE;

    __declspec(dllimport) FILE* __cdecl __acrt_iob_func(unsigned _Ix);

    __declspec(dllimport) wint_t __cdecl fgetwc(FILE * _Stream);

    __declspec(dllimport) wint_t __cdecl _fgetwchar(void);

    __declspec(dllimport) wint_t __cdecl fputwc(wchar_t _Character, FILE * _Stream);

    __declspec(dllimport) wint_t __cdecl _fputwchar(wchar_t _Character);

    __declspec(dllimport) wint_t __cdecl getwc(FILE * _Stream);

    __declspec(dllimport) wint_t __cdecl getwchar(void);

    __declspec(dllimport) wchar_t* __cdecl fgetws(wchar_t * _Buffer, int _BufferCount, FILE* _Stream);

    __declspec(dllimport) int __cdecl fputws(wchar_t const* _Buffer, FILE* _Stream);

    __declspec(dllimport) wchar_t* __cdecl _getws_s(wchar_t * _Buffer, size_t _BufferCount);

    extern "C++"
    {
        template <size_t _Size> inline wchar_t* __cdecl _getws_s(wchar_t (&_Buffer)[_Size]) throw()
        {
            return _getws_s(_Buffer, _Size);
        }
    }

    __declspec(dllimport) wint_t __cdecl putwc(wchar_t _Character, FILE * _Stream);

    __declspec(dllimport) wint_t __cdecl putwchar(wchar_t _Character);

    __declspec(dllimport) int __cdecl _putws(wchar_t const* _Buffer);

    __declspec(dllimport) wint_t __cdecl ungetwc(wint_t _Character, FILE * _Stream);

    __declspec(dllimport) FILE* __cdecl _wfdopen(int _FileHandle, wchar_t const* _Mode);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wfopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    FILE* __cdecl _wfopen(wchar_t const* _FileName, wchar_t const* _Mode);

    __declspec(dllimport) errno_t __cdecl _wfopen_s(FILE * *_Stream, wchar_t const* _FileName, wchar_t const* _Mode);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wfreopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    FILE* __cdecl _wfreopen(wchar_t const* _FileName, wchar_t const* _Mode, FILE* _OldStream);

    __declspec(dllimport)
    errno_t __cdecl _wfreopen_s(FILE * *_Stream, wchar_t const* _FileName, wchar_t const* _Mode, FILE* _OldStream);

    __declspec(dllimport) FILE* __cdecl _wfsopen(wchar_t const* _FileName, wchar_t const* _Mode, int _ShFlag);

    __declspec(dllimport) void __cdecl _wperror(wchar_t const* _ErrorMessage);

    __declspec(dllimport) FILE* __cdecl _wpopen(wchar_t const* _Command, wchar_t const* _Mode);

    __declspec(dllimport) int __cdecl _wremove(wchar_t const* _FileName);

    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wtempnam(wchar_t const* _Directory, wchar_t const* _FilePrefix);

    __declspec(dllimport) errno_t __cdecl _wtmpnam_s(wchar_t * _Buffer, size_t _BufferCount);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wtmpnam_s(wchar_t (&_Buffer)[_Size]) throw()
        {
            return _wtmpnam_s(_Buffer, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wtmpnam_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wtmpnam(wchar_t * _Buffer);

    __declspec(dllimport) wint_t __cdecl _fgetwc_nolock(FILE * _Stream);

    __declspec(dllimport) wint_t __cdecl _fputwc_nolock(wchar_t _Character, FILE * _Stream);

    __declspec(dllimport) wint_t __cdecl _getwc_nolock(FILE * _Stream);

    __declspec(dllimport) wint_t __cdecl _putwc_nolock(wchar_t _Character, FILE * _Stream);

    __declspec(dllimport) wint_t __cdecl _ungetwc_nolock(wint_t _Character, FILE * _Stream);

#pragma managed(push, off)

    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf(unsigned __int64 _Options, FILE* _Stream,
                                                               wchar_t const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_s(unsigned __int64 _Options, FILE* _Stream,
                                                                 wchar_t const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vfwprintf_p(unsigned __int64 _Options, FILE* _Stream,
                                                                 wchar_t const* _Format, _locale_t _Locale, va_list _ArgList);

    __inline int __cdecl _vfwprintf_l(FILE* const _Stream, wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfwprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vfwprintf(FILE* const _Stream, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwprintf_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vfwprintf_s_l(FILE* const _Stream, wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfwprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vfwprintf_s(FILE* const _Stream, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vfwprintf_p_l(FILE* const _Stream, wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfwprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vfwprintf_p(FILE* const _Stream, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vwprintf_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vwprintf(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }

    __inline int __cdecl _vwprintf_s_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vwprintf_s(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }

    __inline int __cdecl _vwprintf_p_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vwprintf_p(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }

    __inline int __cdecl _fwprintf_l(FILE* const _Stream, wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl fwprintf(FILE* const _Stream, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _fwprintf_s_l(FILE* const _Stream, wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl fwprintf_s(FILE* const _Stream, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _fwprintf_p_l(FILE* const _Stream, wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _fwprintf_p(FILE* const _Stream, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _wprintf_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl wprintf(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _wprintf_s_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl wprintf_s(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _wprintf_p_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _wprintf_p(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(dllimport) int __cdecl __stdio_common_vfwscanf(unsigned __int64 _Options, FILE* _Stream,
                                                              wchar_t const* _Format, _locale_t _Locale, va_list _ArgList);

    __inline int __cdecl _vfwscanf_l(FILE* const _Stream, wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfwscanf((*__local_stdio_scanf_options()), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vfwscanf(FILE* const _Stream, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwscanf_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vfwscanf_s_l(FILE* const _Stream, wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfwscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vfwscanf_s(FILE* const _Stream, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vwscanf_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vwscanf(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }

    __inline int __cdecl _vwscanf_s_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vwscanf_s(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_fwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _fwscanf_l(FILE* const _Stream,
                                                                                           wchar_t const* const _Format,
                                                                                           _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "fwscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl fwscanf(FILE* const _Stream,
                                                                                        wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _fwscanf_s_l(FILE* const _Stream, wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl fwscanf_s(FILE* const _Stream, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _wscanf_l(wchar_t const* const _Format,
                                                                                          _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl wscanf(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _wscanf_s_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl wscanf_s(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfwscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(dllimport) int __cdecl __stdio_common_vswprintf(unsigned __int64 _Options, wchar_t* _Buffer, size_t _BufferCount,
                                                               wchar_t const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_s(unsigned __int64 _Options, wchar_t* _Buffer, size_t _BufferCount,
                                                                 wchar_t const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vsnwprintf_s(unsigned __int64 _Options, wchar_t* _Buffer,
                                                                  size_t _BufferCount, size_t _MaxCount, wchar_t const* _Format,
                                                                  _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vswprintf_p(unsigned __int64 _Options, wchar_t* _Buffer, size_t _BufferCount,
                                                                 wchar_t const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(deprecated(
    "This function or variable may be unsafe. Consider using "
    "_vsnwprintf_s_l"
    " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
    "See online help for details.")) __inline int __cdecl _vsnwprintf_l(wchar_t* const _Buffer, size_t const _BufferCount,
                                                                        wchar_t const* const _Format,
                                                                        _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1ULL << 0), _Buffer,
                                                     _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

#pragma warning(push)
#pragma warning(disable : 4793)

    __inline int __cdecl _vsnwprintf_s_l(wchar_t* const _Buffer, size_t const _BufferCount, size_t const _MaxCount,
                                         wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result = __stdio_common_vsnwprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount,
                                                        _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vsnwprintf_s(wchar_t* const _Buffer, size_t const _BufferCount, size_t const _MaxCount,
                                       wchar_t const* const _Format, va_list _ArgList)

    {
        return _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snwprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snwprintf(wchar_t * _Buffer, size_t _BufferCount,
                                                                                           wchar_t const* _Format, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnwprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsnwprintf(wchar_t * _Buffer, size_t _BufferCount,
                                                                                            wchar_t const* _Format, va_list _Args);

#pragma warning(pop)

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnwprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsnwprintf(wchar_t * _Buffer, size_t _BufferCount,
                                                                                            wchar_t const* _Format, va_list _ArgList)

    {
#pragma warning(push)
#pragma warning(disable : 4996)
        return _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)
    }

    extern "C++"
    {
        template <size_t _Size>
        inline int __cdecl _vsnwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, va_list _ArgList) throw()
        {
            return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
    }

    __inline int __cdecl _vswprintf_c_l(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format,
                                        _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vswprintf((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vswprintf_c(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vswprintf_l(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format,
                                      _locale_t const _Locale, va_list _ArgList)

    {
#pragma warning(push)
#pragma warning(disable : 4996)
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)
    }

    __inline int __cdecl __vswprintf_l(wchar_t* const _Buffer, wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vswprintf(wchar_t* const _Buffer, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
    }

    __inline int __cdecl vswprintf(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vswprintf_s_l(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format,
                                        _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vswprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl vswprintf_s(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }

    extern "C++"
    {
        template <size_t _Size>
        inline int __cdecl vswprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw()
        {
            return vswprintf_s(_Buffer, _Size, _Format, _ArgList);
        }
    }

    __inline int __cdecl _vswprintf_p_l(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format,
                                        _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vswprintf_p((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vswprintf_p(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vscwprintf_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vswprintf((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vscwprintf(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vscwprintf_l(_Format, 0, _ArgList);
    }

    __inline int __cdecl _vscwprintf_p_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vswprintf_p((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vscwprintf_p(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vscwprintf_p_l(_Format, 0, _ArgList);
    }

    __inline int __cdecl __swprintf_l(wchar_t* const _Buffer, wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = __vswprintf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _swprintf_l(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format,
                                     _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _swprintf(wchar_t* const _Buffer, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = __vswprintf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl swprintf(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

#pragma warning(push)

#pragma warning(disable : 4793 4996)

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "__swprintf_l_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl __swprintf_l(wchar_t * _Buffer, wchar_t const* _Format,
                                                                                             _locale_t _Locale, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vswprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl __vswprintf_l(wchar_t * _Buffer,
                                                                                              wchar_t const* _Format,
                                                                                              _locale_t _Locale, va_list _Args);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "swprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _swprintf(wchar_t * _Buffer,
                                                                                          wchar_t const* _Format, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "vswprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vswprintf(wchar_t * _Buffer,
                                                                                           wchar_t const* _Format, va_list _Args);

#pragma warning(pop)

    __inline int __cdecl _swprintf_s_l(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format,
                                       _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl swprintf_s(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vswprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    extern "C++"
    {
        __pragma(warning(push));
        __pragma(warning(disable : 4793));
        template <size_t _Size>
        inline int __cdecl swprintf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, ...) throw()
        {
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                    ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))),
                                       (sizeof(_Format)), __alignof(_Format),
                                       (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
            return vswprintf_s(_Buffer, _Size, _Format, _ArgList);
        }
        __pragma(warning(pop));
    }

    __inline int __cdecl _swprintf_p_l(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format,
                                       _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _swprintf_p(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vswprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _swprintf_c_l(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format,
                                       _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _swprintf_c(wchar_t* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vswprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snwprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snwprintf_l(wchar_t* const _Buffer,
                                                                                             size_t const _BufferCount,
                                                                                             wchar_t const* const _Format,
                                                                                             _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snwprintf(wchar_t * _Buffer, size_t _BufferCount, wchar_t const* _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = _vsnwprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snwprintf_s_l(wchar_t* const _Buffer, size_t const _BufferCount, size_t const _MaxCount,
                                        wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snwprintf_s(wchar_t* const _Buffer, size_t const _BufferCount, size_t const _MaxCount,
                                      wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vsnwprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    extern "C++"
    {
        __pragma(warning(push));
        __pragma(warning(disable : 4793));
        template <size_t _Size>
        inline int __cdecl _snwprintf_s(wchar_t (&_Buffer)[_Size], size_t _BufferCount, wchar_t const* _Format, ...) throw()
        {
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                    ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))),
                                       (sizeof(_Format)), __alignof(_Format),
                                       (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
            return _vsnwprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
        __pragma(warning(pop));
    }

    __inline int __cdecl _scwprintf_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vscwprintf_l(_Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _scwprintf(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vscwprintf_l(_Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _scwprintf_p_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vscwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _scwprintf_p(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vscwprintf_p_l(_Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

#pragma warning(push)
#pragma warning(disable : 4141 4412 4793 4996 6054)

    extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, "
                                       "adding an extra character count parameter. To use the traditional "
                                       "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                                                       "swprintf_s"
                                                                                                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                                                       "See online help for details.")) inline int
    swprintf(wchar_t* const _Buffer, wchar_t const* const _Format, ...) throw()
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
#pragma warning(suppress : 28719)
        _Result = vswprintf(_Buffer, 2147483647, _Format, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    extern "C++" __declspec(deprecated(
    "function has been changed to conform with the ISO C standard, "
    "adding an extra character count parameter. To use the traditional "
    "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be "
                                                                                    "unsafe. Consider using "
                                                                                    "vswprintf_s"
                                                                                    " instead. To disable deprecation, "
                                                                                    "use _CRT_SECURE_NO_WARNINGS. "
                                                                                    "See online help for "
                                                                                    "details"
                                                                                    ".")) inline int __cdecl vswprintf(wchar_t* const _Buffer,
                                                                                                                       wchar_t const* const _Format,
                                                                                                                       va_list _ArgList) throw()
    {
#pragma warning(suppress : 28719)
        return vswprintf(_Buffer, 2147483647, _Format, _ArgList);
    }

    extern "C++" __declspec(deprecated("function has been changed to conform with the ISO C standard, "
                                       "adding an extra character count parameter. To use the traditional "
                                       "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                                                                                                       "_swprintf_s_l"
                                                                                                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                                                                                                       "See online help for details.")) inline int
    _swprintf_l(wchar_t* const _Buffer, wchar_t const* const _Format, _locale_t const _Locale, ...) throw()
    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    extern "C++" __declspec(deprecated(
    "function has been changed to conform with the ISO C standard, "
    "adding an extra character count parameter. To use the traditional "
    "Microsoft version, set _CRT_NON_CONFORMING_SWPRINTFS.")) __declspec(deprecated("This function or variable may be "
                                                                                    "unsafe. Consider using "
                                                                                    "_vswprintf_s_l"
                                                                                    " instead. To disable deprecation, "
                                                                                    "use _CRT_SECURE_NO_WARNINGS. "
                                                                                    "See online help for "
                                                                                    "details"
                                                                                    ".")) inline int __cdecl _vswprintf_l(wchar_t* const _Buffer,
                                                                                                                          wchar_t const* const _Format,
                                                                                                                          _locale_t const _Locale,
                                                                                                                          va_list _ArgList) throw()
    {
        return _vswprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }

#pragma warning(pop)

    __declspec(dllimport) int __cdecl __stdio_common_vswscanf(unsigned __int64 _Options, wchar_t const* _Buffer, size_t _BufferCount,
                                                              wchar_t const* _Format, _locale_t _Locale, va_list _ArgList);

    __inline int __cdecl _vswscanf_l(wchar_t const* const _Buffer, wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vswscanf(wchar_t const* _Buffer, wchar_t const* _Format, va_list _ArgList)

    {
        return _vswscanf_l(_Buffer, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vswscanf_s_l(wchar_t const* const _Buffer, wchar_t const* const _Format,
                                       _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vswscanf_s(wchar_t const* const _Buffer, wchar_t const* const _Format, va_list _ArgList)

    {
        return _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }

    extern "C++"
    {
        template <size_t _Size>
        inline int __cdecl vswscanf_s(wchar_t (&_Buffer)[_Size], wchar_t const* _Format, va_list _ArgList) throw()
        {
            return vswscanf_s(_Buffer, _Size, _Format, _ArgList);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsnwscanf_l(wchar_t const* const _Buffer,
                                                                                             size_t const _BufferCount,
                                                                                             wchar_t const* const _Format,
                                                                                             _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vsnwscanf_s_l(wchar_t const* const _Buffer, size_t const _BufferCount,
                                        wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vswscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format,
                                       _Locale, _ArgList);
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_swscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _swscanf_l(wchar_t const* const _Buffer,
                                                                                           wchar_t const* const _Format,
                                                                                           _locale_t _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vswscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "swscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl swscanf(wchar_t const* const _Buffer,
                                                                                        wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vswscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _swscanf_s_l(wchar_t const* const _Buffer, wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vswscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl swscanf_s(wchar_t const* const _Buffer, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vswscanf_s_l(_Buffer, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snwscanf_l(wchar_t const* const _Buffer,
                                                                                            size_t const _BufferCount,
                                                                                            wchar_t const* const _Format,
                                                                                            _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snwscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snwscanf(wchar_t const* const _Buffer,
                                                                                          size_t const _BufferCount,
                                                                                          wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = _vsnwscanf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snwscanf_s_l(wchar_t const* const _Buffer, size_t const _BufferCount,
                                       wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snwscanf_s(wchar_t const* const _Buffer, size_t const _BufferCount, wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vsnwscanf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

#pragma managed(pop)
}
__pragma(pack(pop))

__pragma(pack(push, 8)) extern "C"
{
    typedef __int64 fpos_t;

    __declspec(dllimport)
    errno_t __cdecl _get_stream_buffer_pointers(FILE * _Stream, char*** _Base, char*** _Pointer, int** _Count);

    __declspec(dllimport) errno_t __cdecl clearerr_s(FILE * _Stream);

    __declspec(dllimport) errno_t __cdecl fopen_s(FILE * *_Stream, char const* _FileName, char const* _Mode);

    __declspec(dllimport)
    size_t __cdecl fread_s(void* _Buffer, size_t _BufferSize, size_t _ElementSize, size_t _ElementCount, FILE* _Stream);

    __declspec(dllimport) errno_t __cdecl freopen_s(FILE * *_Stream, char const* _FileName, char const* _Mode, FILE* _OldStream);

    __declspec(dllimport) char* __cdecl gets_s(char* _Buffer, rsize_t _Size);

    __declspec(dllimport) errno_t __cdecl tmpfile_s(FILE * *_Stream);

    __declspec(dllimport) errno_t __cdecl tmpnam_s(char* _Buffer, rsize_t _Size);

    __declspec(dllimport) void __cdecl clearerr(FILE * _Stream);

    __declspec(dllimport) int __cdecl fclose(FILE * _Stream);

    __declspec(dllimport) int __cdecl _fcloseall(void);

    __declspec(dllimport) FILE* __cdecl _fdopen(int _FileHandle, char const* _Mode);

    __declspec(dllimport) int __cdecl feof(FILE * _Stream);

    __declspec(dllimport) int __cdecl ferror(FILE * _Stream);

    __declspec(dllimport) int __cdecl fflush(FILE * _Stream);

    __declspec(dllimport) int __cdecl fgetc(FILE * _Stream);

    __declspec(dllimport) int __cdecl _fgetchar(void);

    __declspec(dllimport) int __cdecl fgetpos(FILE * _Stream, fpos_t * _Position);

    __declspec(dllimport) char* __cdecl fgets(char* _Buffer, int _MaxCount, FILE* _Stream);

    __declspec(dllimport) int __cdecl _fileno(FILE * _Stream);

    __declspec(dllimport) int __cdecl _flushall(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "fopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    FILE* __cdecl fopen(char const* _FileName, char const* _Mode);

    __declspec(dllimport) int __cdecl fputc(int _Character, FILE* _Stream);

    __declspec(dllimport) int __cdecl _fputchar(int _Character);

    __declspec(dllimport) int __cdecl fputs(char const* _Buffer, FILE* _Stream);

    __declspec(dllimport) size_t __cdecl fread(void* _Buffer, size_t _ElementSize, size_t _ElementCount, FILE* _Stream);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "freopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    FILE* __cdecl freopen(char const* _FileName, char const* _Mode, FILE* _Stream);

    __declspec(dllimport) FILE* __cdecl _fsopen(char const* _FileName, char const* _Mode, int _ShFlag);

    __declspec(dllimport) int __cdecl fsetpos(FILE * _Stream, fpos_t const* _Position);

    __declspec(dllimport) int __cdecl fseek(FILE * _Stream, long _Offset, int _Origin);

    __declspec(dllimport) int __cdecl _fseeki64(FILE * _Stream, __int64 _Offset, int _Origin);

    __declspec(dllimport) long __cdecl ftell(FILE * _Stream);

    __declspec(dllimport) __int64 __cdecl _ftelli64(FILE * _Stream);

    __declspec(dllimport) size_t __cdecl fwrite(void const* _Buffer, size_t _ElementSize, size_t _ElementCount, FILE* _Stream);

    __declspec(dllimport) int __cdecl getc(FILE * _Stream);

    __declspec(dllimport) int __cdecl getchar(void);

    __declspec(dllimport) int __cdecl _getmaxstdio(void);

    extern "C++"
    {
        template <size_t _Size> inline char* __cdecl gets_s(char (&_Buffer)[_Size]) throw()
        {
            return gets_s(_Buffer, _Size);
        }
    }

    __declspec(dllimport) int __cdecl _getw(FILE * _Stream);

    __declspec(dllimport) void __cdecl perror(char const* _ErrorMessage);

    __declspec(dllimport) int __cdecl _pclose(FILE * _Stream);

    __declspec(dllimport) FILE* __cdecl _popen(char const* _Command, char const* _Mode);

    __declspec(dllimport) int __cdecl putc(int _Character, FILE* _Stream);

    __declspec(dllimport) int __cdecl putchar(int _Character);

    __declspec(dllimport) int __cdecl puts(char const* _Buffer);

    __declspec(dllimport) int __cdecl _putw(int _Word, FILE* _Stream);

    __declspec(dllimport) int __cdecl remove(char const* _FileName);

    __declspec(dllimport) int __cdecl rename(char const* _OldFileName, char const* _NewFileName);

    __declspec(dllimport) int __cdecl _unlink(char const* _FileName);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_unlink"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl unlink(char const* _FileName);

    __declspec(dllimport) void __cdecl rewind(FILE * _Stream);

    __declspec(dllimport) int __cdecl _rmtmp(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "setvbuf"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) void __cdecl setbuf(FILE * _Stream, char* _Buffer);

    __declspec(dllimport) int __cdecl _setmaxstdio(int _Maximum);

    __declspec(dllimport) int __cdecl setvbuf(FILE * _Stream, char* _Buffer, int _Mode, size_t _Size);

    __declspec(dllimport) __declspec(allocator) char* __cdecl _tempnam(char const* _DirectoryName, char const* _FilePrefix);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "tmpfile_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) FILE* __cdecl tmpfile(void);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl tmpnam_s(char (&_Buffer)[_Size]) throw()
        {
            return tmpnam_s(_Buffer, _Size);
        }
    }

#pragma warning(push)
#pragma warning(disable : 28726)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "tmpnam_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl tmpnam(char* _Buffer);
#pragma warning(pop)

    __declspec(dllimport) int __cdecl ungetc(int _Character, FILE* _Stream);

    __declspec(dllimport) void __cdecl _lock_file(FILE * _Stream);

    __declspec(dllimport) void __cdecl _unlock_file(FILE * _Stream);

    __declspec(dllimport) int __cdecl _fclose_nolock(FILE * _Stream);

    __declspec(dllimport) int __cdecl _fflush_nolock(FILE * _Stream);

    __declspec(dllimport) int __cdecl _fgetc_nolock(FILE * _Stream);

    __declspec(dllimport) int __cdecl _fputc_nolock(int _Character, FILE* _Stream);

    __declspec(dllimport) size_t __cdecl _fread_nolock(void* _Buffer, size_t _ElementSize, size_t _ElementCount, FILE* _Stream);

    __declspec(dllimport) size_t __cdecl _fread_nolock_s(void* _Buffer, size_t _BufferSize, size_t _ElementSize,
                                                         size_t _ElementCount, FILE* _Stream);

    __declspec(dllimport) int __cdecl _fseek_nolock(FILE * _Stream, long _Offset, int _Origin);

    __declspec(dllimport) int __cdecl _fseeki64_nolock(FILE * _Stream, __int64 _Offset, int _Origin);

    __declspec(dllimport) long __cdecl _ftell_nolock(FILE * _Stream);

    __declspec(dllimport) __int64 __cdecl _ftelli64_nolock(FILE * _Stream);

    __declspec(dllimport)
    size_t __cdecl _fwrite_nolock(void const* _Buffer, size_t _ElementSize, size_t _ElementCount, FILE* _Stream);

    __declspec(dllimport) int __cdecl _getc_nolock(FILE * _Stream);

    __declspec(dllimport) int __cdecl _putc_nolock(int _Character, FILE* _Stream);

    __declspec(dllimport) int __cdecl _ungetc_nolock(int _Character, FILE* _Stream);

    __declspec(dllimport) int* __cdecl __p__commode(void);

#pragma managed(push, off)

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf(unsigned __int64 _Options, FILE* _Stream,
                                                              char const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_s(unsigned __int64 _Options, FILE* _Stream,
                                                                char const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vfprintf_p(unsigned __int64 _Options, FILE* _Stream,
                                                                char const* _Format, _locale_t _Locale, va_list _ArgList);

    __inline int __cdecl _vfprintf_l(FILE* const _Stream, char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfprintf((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vfprintf(FILE* const _Stream, char const* const _Format, va_list _ArgList)

    {
        return _vfprintf_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vfprintf_s_l(FILE* const _Stream, char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfprintf_s((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vfprintf_s(FILE* const _Stream, char const* const _Format, va_list _ArgList)

    {
        return _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vfprintf_p_l(FILE* const _Stream, char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfprintf_p((*__local_stdio_printf_options()), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vfprintf_p(FILE* const _Stream, char const* const _Format, va_list _ArgList)

    {
        return _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vprintf_l(char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vprintf(char const* const _Format, va_list _ArgList)

    {
        return _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }

    __inline int __cdecl _vprintf_s_l(char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vprintf_s(char const* const _Format, va_list _ArgList)

    {
        return _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }

    __inline int __cdecl _vprintf_p_l(char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vprintf_p(char const* const _Format, va_list _ArgList)

    {
        return _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
    }

    __inline int __cdecl _fprintf_l(FILE* const _Stream, char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfprintf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl fprintf(FILE* const _Stream, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfprintf_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(dllimport) int __cdecl _set_printf_count_output(int _Value);

    __declspec(dllimport) int __cdecl _get_printf_count_output(void);

    __inline int __cdecl _fprintf_s_l(FILE* const _Stream, char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfprintf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl fprintf_s(FILE* const _Stream, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfprintf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _fprintf_p_l(FILE* const _Stream, char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfprintf_p_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _fprintf_p(FILE* const _Stream, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfprintf_p_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _printf_l(char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl printf(char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfprintf_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _printf_s_l(char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl printf_s(char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfprintf_s_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _printf_p_l(char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _printf_p(char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfprintf_p_l((__acrt_iob_func(1)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(dllimport) int __cdecl __stdio_common_vfscanf(unsigned __int64 _Options, FILE* _Stream,
                                                             char const* _Format, _locale_t _Locale, va_list _Arglist);

    __inline int __cdecl _vfscanf_l(FILE* const _Stream, char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfscanf((*__local_stdio_scanf_options()), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vfscanf(FILE* const _Stream, char const* const _Format, va_list _ArgList)

    {
        return _vfscanf_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vfscanf_s_l(FILE* const _Stream, char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vfscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Stream, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vfscanf_s(FILE* const _Stream, char const* const _Format, va_list _ArgList)

    {
        return _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vscanf_l(char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vscanf(char const* const _Format, va_list _ArgList)

    {
        return _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }

    __inline int __cdecl _vscanf_s_l(char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vscanf_s(char const* const _Format, va_list _ArgList)

    {
        return _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_fscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _fscanf_l(FILE* const _Stream,
                                                                                          char const* const _Format,
                                                                                          _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfscanf_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "fscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl fscanf(FILE* const _Stream,
                                                                                       char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfscanf_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _fscanf_s_l(FILE* const _Stream, char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfscanf_s_l(_Stream, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl fscanf_s(FILE* const _Stream, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfscanf_s_l(_Stream, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_scanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _scanf_l(char const* const _Format,
                                                                                         _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "scanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl scanf(char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfscanf_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _scanf_s_l(char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl scanf_s(char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vfscanf_s_l((__acrt_iob_func(0)), _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(dllimport) int __cdecl __stdio_common_vsprintf(unsigned __int64 _Options, char* _Buffer, size_t _BufferCount,
                                                              char const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_s(unsigned __int64 _Options, char* _Buffer, size_t _BufferCount,
                                                                char const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vsnprintf_s(unsigned __int64 _Options, char* _Buffer,
                                                                 size_t _BufferCount, size_t _MaxCount,
                                                                 char const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __stdio_common_vsprintf_p(unsigned __int64 _Options, char* _Buffer, size_t _BufferCount,
                                                                char const* _Format, _locale_t _Locale, va_list _ArgList);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsnprintf_l(char* const _Buffer,
                                                                                             size_t const _BufferCount,
                                                                                             char const* const _Format,
                                                                                             _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1ULL << 0), _Buffer,
                                                    _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vsnprintf(char* const _Buffer, size_t const _BufferCount, char const* const _Format, va_list _ArgList)

    {
#pragma warning(push)
#pragma warning(disable : 4996)
        return _vsnprintf_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
#pragma warning(pop)
    }

    __inline int __cdecl vsnprintf(char* const _Buffer, size_t const _BufferCount, char const* const _Format, va_list _ArgList)

    {
        int const _Result = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1ULL << 1), _Buffer,
                                                    _BufferCount, _Format, 0, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vsprintf_l(char* const _Buffer,
                                                                                            char const* const _Format,
                                                                                            _locale_t const _Locale, va_list _ArgList)

    {
#pragma warning(push)
#pragma warning(disable : 4996)
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, _Locale, _ArgList);
#pragma warning(pop)
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "vsprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl vsprintf(char* const _Buffer,
                                                                                         char const* const _Format, va_list _ArgList)

    {
#pragma warning(push)
#pragma warning(disable : 4996)
        return _vsnprintf_l(_Buffer, (size_t)-1, _Format, 0, _ArgList);
#pragma warning(pop)
    }

    __inline int __cdecl _vsprintf_s_l(char* const _Buffer, size_t const _BufferCount, char const* const _Format,
                                       _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vsprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl vsprintf_s(char* const _Buffer, size_t const _BufferCount, char const* const _Format, va_list _ArgList)

    {
        return _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }

    extern "C++"
    {
        template <size_t _Size>
        inline int __cdecl vsprintf_s(char (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw()
        {
            return vsprintf_s(_Buffer, _Size, _Format, _ArgList);
        }
    }

    __inline int __cdecl _vsprintf_p_l(char* const _Buffer, size_t const _BufferCount, char const* const _Format,
                                       _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vsprintf_p((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vsprintf_p(char* const _Buffer, size_t const _BufferCount, char const* const _Format, va_list _ArgList)

    {
        return _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vsnprintf_s_l(char* const _Buffer, size_t const _BufferCount, size_t const _MaxCount,
                                        char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result = __stdio_common_vsnprintf_s((*__local_stdio_printf_options()), _Buffer, _BufferCount,
                                                       _MaxCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vsnprintf_s(char* const _Buffer, size_t const _BufferCount, size_t const _MaxCount,
                                      char const* const _Format, va_list _ArgList)

    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }

    extern "C++"
    {
        template <size_t _Size>
        inline int __cdecl _vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw()
        {
            return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
    }

    __inline int __cdecl vsnprintf_s(char* const _Buffer, size_t const _BufferCount, size_t const _MaxCount,
                                     char const* const _Format, va_list _ArgList)

    {
        return _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
    }

    extern "C++"
    {
        template <size_t _Size>
        inline int __cdecl vsnprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, va_list _ArgList) throw()
        {
            return vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
    }

    __inline int __cdecl _vscprintf_l(char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vsprintf((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vscprintf(char const* const _Format, va_list _ArgList)

    {
        return _vscprintf_l(_Format, 0, _ArgList);
    }

    __inline int __cdecl _vscprintf_p_l(char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vsprintf_p((*__local_stdio_printf_options()) | (1ULL << 1), 0, 0, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vscprintf_p(char const* const _Format, va_list _ArgList)

    {
        return _vscprintf_p_l(_Format, 0, _ArgList);
    }

    __inline int __cdecl _vsnprintf_c_l(char* const _Buffer, size_t const _BufferCount, char const* const _Format,
                                        _locale_t const _Locale, va_list _ArgList)

    {
        int const _Result
        = __stdio_common_vsprintf((*__local_stdio_printf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        return _Result < 0 ? -1 : _Result;
    }

    __inline int __cdecl _vsnprintf_c(char* const _Buffer, size_t const _BufferCount, char const* const _Format, va_list _ArgList)

    {
        return _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_sprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _sprintf_l(char* const _Buffer,
                                                                                           char const* const _Format,
                                                                                           _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = _vsprintf_l(_Buffer, _Format, _Locale, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl sprintf(char* const _Buffer, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = _vsprintf_l(_Buffer, _Format, 0, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

#pragma warning(push)
#pragma warning(disable : 4996)
#pragma warning(disable : 28719)
#pragma warning(disable : 28726)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "sprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) int __cdecl sprintf(char* _Buffer, char const* _Format, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "vsprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) int __cdecl vsprintf(char* _Buffer, char const* _Format, va_list _Args);
#pragma warning(pop)

    __inline int __cdecl _sprintf_s_l(char* const _Buffer, size_t const _BufferCount, char const* const _Format,
                                      _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl sprintf_s(char* const _Buffer, size_t const _BufferCount, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vsprintf_s_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    extern "C++"
    {
        __pragma(warning(push));
        __pragma(warning(disable : 4793));
        template <size_t _Size> inline int __cdecl sprintf_s(char (&_Buffer)[_Size], char const* _Format, ...) throw()
        {
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                    ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))),
                                       (sizeof(_Format)), __alignof(_Format),
                                       (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
            return vsprintf_s(_Buffer, _Size, _Format, _ArgList);
        }
        __pragma(warning(pop));
    }

    __inline int __cdecl _sprintf_p_l(char* const _Buffer, size_t const _BufferCount, char const* const _Format,
                                      _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _sprintf_p(char* const _Buffer, size_t const _BufferCount, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vsprintf_p_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snprintf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snprintf_l(char* const _Buffer,
                                                                                            size_t const _BufferCount,
                                                                                            char const* const _Format,
                                                                                            _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = _vsnprintf_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl snprintf(char* const _Buffer, size_t const _BufferCount, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
#pragma warning(suppress : 28719)
        _Result = vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snprintf(char* const _Buffer, size_t const _BufferCount, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
#pragma warning(suppress : 28719)
        _Result = _vsnprintf(_Buffer, _BufferCount, _Format, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) int __cdecl _snprintf(char* _Buffer, size_t _BufferCount,
                                                                                 char const* _Format, ...);
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vsnprintf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) int __cdecl _vsnprintf(char* _Buffer, size_t _BufferCount,
                                                                                  char const* _Format, va_list _Args);

    __inline int __cdecl _snprintf_c_l(char* const _Buffer, size_t const _BufferCount, char const* const _Format,
                                       _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snprintf_c(char* const _Buffer, size_t const _BufferCount, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vsnprintf_c_l(_Buffer, _BufferCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snprintf_s_l(char* const _Buffer, size_t const _BufferCount, size_t const _MaxCount,
                                       char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snprintf_s(char* const _Buffer, size_t const _BufferCount, size_t const _MaxCount,
                                     char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vsnprintf_s_l(_Buffer, _BufferCount, _MaxCount, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    extern "C++"
    {
        __pragma(warning(push));
        __pragma(warning(disable : 4793));
        template <size_t _Size>
        inline int __cdecl _snprintf_s(char (&_Buffer)[_Size], size_t _BufferCount, char const* _Format, ...) throw()
        {
            va_list _ArgList;
            ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                    ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))),
                                       (sizeof(_Format)), __alignof(_Format),
                                       (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
            return _vsnprintf_s(_Buffer, _Size, _BufferCount, _Format, _ArgList);
        }
        __pragma(warning(pop));
    }

    __inline int __cdecl _scprintf_l(char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vscprintf_l(_Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _scprintf(char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vscprintf_l(_Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _scprintf_p_l(char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vscprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _scprintf_p(char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vscprintf_p(_Format, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(dllimport) int __cdecl __stdio_common_vsscanf(unsigned __int64 _Options, char const* _Buffer, size_t _BufferCount,
                                                             char const* _Format, _locale_t _Locale, va_list _ArgList);

    __inline int __cdecl _vsscanf_l(char const* const _Buffer, char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vsscanf((*__local_stdio_scanf_options()), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }

    __inline int __cdecl vsscanf(char const* const _Buffer, char const* const _Format, va_list _ArgList)

    {
        return _vsscanf_l(_Buffer, _Format, 0, _ArgList);
    }

    __inline int __cdecl _vsscanf_s_l(char const* const _Buffer, char const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, (size_t)-1, _Format, _Locale, _ArgList);
    }

#pragma warning(push)
#pragma warning(disable : 6530)

    __inline int __cdecl vsscanf_s(char const* const _Buffer, char const* const _Format, va_list _ArgList)

    {
        return _vsscanf_s_l(_Buffer, _Format, 0, _ArgList);
    }

    extern "C++"
    {
        template <size_t _Size>
        inline int __cdecl vsscanf_s(char const (&_Buffer)[_Size], char const* _Format, va_list _ArgList) throw()
        {
            return vsscanf_s(_Buffer, _Size, _Format, _ArgList);
        }
    }

#pragma warning(pop)

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_sscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _sscanf_l(char const* const _Buffer,
                                                                                          char const* const _Format,
                                                                                          _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vsscanf_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "sscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl sscanf(char const* const _Buffer,
                                                                                       char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vsscanf_l(_Buffer, _Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _sscanf_s_l(char const* const _Buffer, char const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vsscanf_s_l(_Buffer, _Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl sscanf_s(char const* const _Buffer, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = vsscanf_s(_Buffer, _Format, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

#pragma warning(push)
#pragma warning(disable : 6530)

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snscanf_l(char const* const _Buffer,
                                                                                           size_t const _BufferCount,
                                                                                           char const* const _Format,
                                                                                           _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));

        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()), _Buffer, _BufferCount, _Format, _Locale, _ArgList);

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_snscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _snscanf(char const* const _Buffer,
                                                                                         size_t const _BufferCount,
                                                                                         char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));

        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()), _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snscanf_s_l(char const* const _Buffer, size_t const _BufferCount, char const* const _Format,
                                      _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));

        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format,
                                         _Locale, _ArgList);

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _snscanf_s(char const* const _Buffer, size_t const _BufferCount, char const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));

        _Result = __stdio_common_vsscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Buffer, _BufferCount, _Format, 0, _ArgList);

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

#pragma warning(pop)

#pragma managed(pop)

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_tempnam"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl tempnam(char const* _Directory,
                                                                                                         char const* _FilePrefix);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fcloseall"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl fcloseall(void);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fdopen"
                          ". See online help for details.")) __declspec(dllimport)
    FILE* __cdecl fdopen(int _FileHandle, char const* _Format);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fgetchar"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl fgetchar(void);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fileno"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl fileno(FILE * _Stream);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_flushall"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl flushall(void);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_fputchar"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl fputchar(int _Ch);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_getw"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl getw(FILE * _Stream);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_putw"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl putw(int _Ch, FILE* _Stream);
    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_rmtmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl rmtmp(void);
}
__pragma(pack(pop))

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
#pragma warning(push)
#pragma warning(disable : 4995)

    using ::_Mbstatet;
    using ::FILE;

    using ::clearerr;
    using ::fclose;
    using ::feof;
    using ::ferror;
    using ::fflush;
    using ::fgetc;
    using ::fgetpos;
    using ::fgets;
    using ::FILE;
    using ::fopen;
    using ::fpos_t;
    using ::fprintf;
    using ::fputc;
    using ::fputs;
    using ::fread;
    using ::freopen;
    using ::fscanf;
    using ::fseek;
    using ::fsetpos;
    using ::ftell;
    using ::fwrite;
    using ::getc;
    using ::getchar;
    using ::perror;
    using ::printf;
    using ::putc;
    using ::putchar;
    using ::puts;
    using ::remove;
    using ::rename;
    using ::rewind;
    using ::scanf;
    using ::setbuf;
    using ::setvbuf;
    using ::size_t;
    using ::sprintf;
    using ::sscanf;
    using ::tmpfile;
    using ::tmpnam;
    using ::ungetc;
    using ::vfprintf;
    using ::vprintf;
    using ::vsprintf;

    using ::snprintf;
    using ::vfscanf;
    using ::vscanf;
    using ::vsnprintf;
    using ::vsscanf;

#pragma warning(pop)
}

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) int* __cdecl _errno(void);

    __declspec(dllimport) errno_t __cdecl _set_errno(int _Value);
    __declspec(dllimport) errno_t __cdecl _get_errno(int* _Value);

    __declspec(dllimport) unsigned long* __cdecl __doserrno(void);

    __declspec(dllimport) errno_t __cdecl _set_doserrno(unsigned long _Value);
    __declspec(dllimport) errno_t __cdecl _get_doserrno(unsigned long* _Value);
}
__pragma(pack(pop))

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    using ::ptrdiff_t;
    using ::size_t;
    using max_align_t = double;
}

using ::std::max_align_t;

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Elem> class initializer_list
    {
    public:
        using value_type = _Elem;
        using reference = const _Elem&;
        using const_reference = const _Elem&;
        using size_type = size_t;

        using iterator = const _Elem*;
        using const_iterator = const _Elem*;

        constexpr initializer_list() noexcept : _First(nullptr), _Last(nullptr)
        {
        }

        constexpr initializer_list(const _Elem* _First_arg, const _Elem* _Last_arg) noexcept
        : _First(_First_arg), _Last(_Last_arg)
        {
        }

        [[nodiscard]] constexpr const _Elem* begin() const noexcept
        {
            return _First;
        }

        [[nodiscard]] constexpr const _Elem* end() const noexcept
        {
            return _Last;
        }

        [[nodiscard]] constexpr size_t size() const noexcept
        {
            return static_cast<size_t>(_Last - _First);
        }

    private:
        const _Elem* _First;
        const _Elem* _Last;
    };

    template <class _Elem>[[nodiscard]] constexpr const _Elem* begin(initializer_list<_Elem> _Ilist) noexcept
    {
        return _Ilist.begin();
    }

    template <class _Elem>[[nodiscard]] constexpr const _Elem* end(initializer_list<_Elem> _Ilist) noexcept
    {
        return _Ilist.end();
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class>

    constexpr bool _Always_false = false;

    template <class _Arg, class _Result> struct unary_function
    {
        using argument_type = _Arg;
        using result_type = _Result;
    };

    template <class _Arg1, class _Arg2, class _Result> struct binary_function
    {
        using first_argument_type = _Arg1;
        using second_argument_type = _Arg2;
        using result_type = _Result;
    };

    template <class _Ty = void> struct plus
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left + _Right;
        }
    };

    template <class _Ty = void> struct minus
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left - _Right;
        }
    };

    template <class _Ty = void> struct multiplies
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left * _Right;
        }
    };

    template <class _Ty = void> struct equal_to
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;

        constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left == _Right;
        }
    };

    template <class _Ty = void> struct not_equal_to
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;

        constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left != _Right;
        }
    };

    template <class _Ty = void> struct greater
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;

        constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left > _Right;
        }
    };

    template <class _Ty = void> struct less
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;

        constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left < _Right;
        }
    };

    template <class _Ty = void> struct greater_equal
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;

        constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left >= _Right;
        }
    };

    template <class _Ty = void> struct less_equal
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;

        constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left <= _Right;
        }
    };

    template <> struct plus<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right)))
        -> decltype(static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right))
        {
            return static_cast<_Ty1&&>(_Left) + static_cast<_Ty2&&>(_Right);
        }
    };

    template <> struct minus<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right)))
        -> decltype(static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right))
        {
            return static_cast<_Ty1&&>(_Left) - static_cast<_Ty2&&>(_Right);
        }
    };

    template <> struct multiplies<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right)))
        -> decltype(static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right))
        {
            return static_cast<_Ty1&&>(_Left) * static_cast<_Ty2&&>(_Right);
        }
    };

    template <> struct equal_to<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right)))
        -> decltype(static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right))
        {
            return static_cast<_Ty1&&>(_Left) == static_cast<_Ty2&&>(_Right);
        }
    };

    template <> struct not_equal_to<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right)))
        -> decltype(static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right))
        {
            return static_cast<_Ty1&&>(_Left) != static_cast<_Ty2&&>(_Right);
        }
    };

    template <> struct greater<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right)))
        -> decltype(static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right))
        {
            return static_cast<_Ty1&&>(_Left) > static_cast<_Ty2&&>(_Right);
        }
    };

    template <> struct less<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right)))
        -> decltype(static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right))
        {
            return static_cast<_Ty1&&>(_Left) < static_cast<_Ty2&&>(_Right);
        }
    };

    template <> struct greater_equal<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right)))
        -> decltype(static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right))
        {
            return static_cast<_Ty1&&>(_Left) >= static_cast<_Ty2&&>(_Right);
        }
    };

    template <> struct less_equal<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        noexcept(noexcept(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right)))
        -> decltype(static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right))
        {
            return static_cast<_Ty1&&>(_Left) <= static_cast<_Ty2&&>(_Right);
        }
    };

    template <class _Ty>[[nodiscard]] constexpr _Ty* addressof(_Ty& _Val) noexcept
    {
        return __builtin_addressof(_Val);
    }

    template <class _Ty> const _Ty* addressof(const _Ty&&) = delete;

    template <class _Ptrty>[[nodiscard]] constexpr auto _Unfancy(_Ptrty _Ptr) noexcept
    {
        return ::std::addressof(*_Ptr);
    }

    template <class _Ty>[[nodiscard]] constexpr _Ty* _Unfancy(_Ty* _Ptr) noexcept
    {
        return _Ptr;
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Ty, _Ty... _Vals> struct integer_sequence
    {
        static_assert(is_integral_v<_Ty>, "integer_sequence<T, I...> requires T to be an integral type.");

        using value_type = _Ty;

        [[nodiscard]] static constexpr size_t size() noexcept
        {
            return sizeof...(_Vals);
        }
    };

    template <class _Ty, _Ty _Size> using make_integer_sequence = __make_integer_seq<integer_sequence, _Ty, _Size>;

    template <size_t... _Vals> using index_sequence = integer_sequence<size_t, _Vals...>;

    template <size_t _Size> using make_index_sequence = make_integer_sequence<size_t, _Size>;

    template <class... _Types> using index_sequence_for = make_index_sequence<sizeof...(_Types)>;

    template <bool _First_value, class _First, class... _Rest> struct _Conjunction
    {
        using type = _First;
    };

    template <class _True, class _Next, class... _Rest> struct _Conjunction<true, _True, _Next, _Rest...>
    {
        using type = typename _Conjunction<_Next::value, _Next, _Rest...>::type;
    };

    template <class... _Traits> struct conjunction : true_type
    {
    };

    template <class _First, class... _Rest>
    struct conjunction<_First, _Rest...> : _Conjunction<_First::value, _First, _Rest...>::type
    {
    };

    template <class... _Traits> constexpr bool conjunction_v = conjunction<_Traits...>::value;

    template <class _Trait> struct negation : bool_constant<!static_cast<bool>(_Trait::value)>
    {
    };

    template <class _Trait> constexpr bool negation_v = negation<_Trait>::value;

    template <class... _Types> struct _Arg_types
    {
    };

    template <class _Ty1> struct _Arg_types<_Ty1>
    {
        typedef _Ty1 argument_type;
    };

    template <class _Ty1, class _Ty2> struct _Arg_types<_Ty1, _Ty2>
    {
        typedef _Ty1 first_argument_type;
        typedef _Ty2 second_argument_type;
    };

    template <class _Ty> struct _Is_function
    {
        using _Bool_type = false_type;
    };

    template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __clrcall(_Types...)> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __clrcall(_Types...) const> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) volatile> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __clrcall(_Types...) volatile> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __cdecl(_Types...) const volatile> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __clrcall(_Types...) const volatile> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...)&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __clrcall(_Types...)&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __clrcall(_Types...) const&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __cdecl(_Types...) volatile&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __clrcall(_Types...) volatile&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __cdecl(_Types...) const volatile&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __clrcall(_Types...) const volatile&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) &&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __clrcall(_Types...) &&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret __cdecl(_Types...) const&&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __clrcall(_Types...) const&&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __cdecl(_Types...) volatile&&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __clrcall(_Types...) volatile&&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __cdecl(_Types...) const volatile&&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types>
    struct _Is_function<_Ret __clrcall(_Types...) const volatile&&> : _Arg_types<_Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };

    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...)>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...)&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) &&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const&&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) volatile&&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };
    template <class _Ret, class... _Types> struct _Is_function<_Ret(_Types..., ...) const volatile&&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
    };

    template <class _Ty> struct is_function : _Is_function<_Ty>::_Bool_type
    {
    };

    template <class _Ty> constexpr bool is_function_v = _Is_function<_Ty>::_Bool_type::value;

    template <class _Ty> struct _Is_memfunptr
    {
        using _Bool_type = false_type;
    };

    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)> : _Arg_types<_Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...)> : _Arg_types<_Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const> : _Arg_types<const _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) const> : _Arg_types<const _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile> : _Arg_types<volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) volatile> : _Arg_types<volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile> : _Arg_types<const volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) const volatile> : _Arg_types<const volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...)&> : _Arg_types<_Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...)&> : _Arg_types<_Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const&> : _Arg_types<const _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) const&> : _Arg_types<const _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile&> : _Arg_types<volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) volatile&> : _Arg_types<volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile&> : _Arg_types<const volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) const volatile&> : _Arg_types<const volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) &&> : _Arg_types<_Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) &&> : _Arg_types<_Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const&&> : _Arg_types<const _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) const&&> : _Arg_types<const _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) volatile&&> : _Arg_types<volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) volatile&&> : _Arg_types<volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__cdecl _Arg0::*)(_Types...) const volatile&&> : _Arg_types<const volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (__clrcall _Arg0::*)(_Types...) const volatile&&> : _Arg_types<const volatile _Arg0*, _Types...>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<!is_same_v<int&&, int&&>, _Ret(_Types...)>;
    };

    template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...)&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) &&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const&&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types> struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) volatile&&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };
    template <class _Ret, class _Arg0, class... _Types>
    struct _Is_memfunptr<_Ret (_Arg0::*)(_Types..., ...) const volatile&&>
    {
        using _Bool_type = true_type;
        typedef _Ret result_type;
        using _Class_type = _Arg0;
        using _Guide_type = enable_if<false>;
    };

    template <class _Ty> constexpr bool is_void_v = is_same_v<remove_cv_t<_Ty>, void>;

    template <class _Ty> struct is_void : bool_constant<is_void_v<_Ty>>
    {
    };

    template <class... _Types> using void_t = void;

    template <class _Ty> struct add_const
    {
        using type = const _Ty;
    };

    template <class _Ty> using add_const_t = typename add_const<_Ty>::type;

    template <class _Ty> struct add_volatile
    {
        using type = volatile _Ty;
    };

    template <class _Ty> using add_volatile_t = typename add_volatile<_Ty>::type;

    template <class _Ty> struct add_cv
    {
        using type = const volatile _Ty;
    };

    template <class _Ty> using add_cv_t = typename add_cv<_Ty>::type;

    template <class _Ty, class = void> struct _Add_reference
    {
        using _Lvalue = _Ty;
        using _Rvalue = _Ty;
    };

    template <class _Ty> struct _Add_reference<_Ty, void_t<_Ty&>>
    {
        using _Lvalue = _Ty&;
        using _Rvalue = _Ty&&;
    };

    template <class _Ty> struct add_lvalue_reference
    {
        using type = typename _Add_reference<_Ty>::_Lvalue;
    };

    template <class _Ty> using add_lvalue_reference_t = typename _Add_reference<_Ty>::_Lvalue;

    template <class _Ty> struct add_rvalue_reference
    {
        using type = typename _Add_reference<_Ty>::_Rvalue;
    };

    template <class _Ty> using add_rvalue_reference_t = typename _Add_reference<_Ty>::_Rvalue;

    template <class _Ty> add_rvalue_reference_t<_Ty> declval() noexcept;

    template <class _Ty> struct remove_extent
    {
        using type = _Ty;
    };

    template <class _Ty, size_t _Ix> struct remove_extent<_Ty[_Ix]>
    {
        using type = _Ty;
    };

    template <class _Ty> struct remove_extent<_Ty[]>
    {
        using type = _Ty;
    };

    template <class _Ty> using remove_extent_t = typename remove_extent<_Ty>::type;

    template <class _Ty> struct remove_all_extents
    {
        using type = _Ty;
    };

    template <class _Ty, size_t _Ix> struct remove_all_extents<_Ty[_Ix]>
    {
        using type = typename remove_all_extents<_Ty>::type;
    };

    template <class _Ty> struct remove_all_extents<_Ty[]>
    {
        using type = typename remove_all_extents<_Ty>::type;
    };

    template <class _Ty> using remove_all_extents_t = typename remove_all_extents<_Ty>::type;

    template <class _Ty> struct remove_pointer
    {
        using type = _Ty;
    };

    template <class _Ty> struct remove_pointer<_Ty*>
    {
        using type = _Ty;
    };

    template <class _Ty> struct remove_pointer<_Ty* const>
    {
        using type = _Ty;
    };

    template <class _Ty> struct remove_pointer<_Ty* volatile>
    {
        using type = _Ty;
    };

    template <class _Ty> struct remove_pointer<_Ty* const volatile>
    {
        using type = _Ty;
    };

    template <class _Ty> using remove_pointer_t = typename remove_pointer<_Ty>::type;

    template <class _Ty, class = void> struct _Add_pointer
    {
        using type = _Ty;
    };

    template <class _Ty> struct _Add_pointer<_Ty, void_t<remove_reference_t<_Ty>*>>
    {
        using type = remove_reference_t<_Ty>*;
    };

    template <class _Ty> struct add_pointer
    {
        using type = typename _Add_pointer<_Ty>::type;
    };

    template <class _Ty> using add_pointer_t = typename _Add_pointer<_Ty>::type;

    template <class> constexpr bool is_array_v = false;

    template <class _Ty, size_t _Nx> constexpr bool is_array_v<_Ty[_Nx]> = true;

    template <class _Ty> constexpr bool is_array_v<_Ty[]> = true;

    template <class _Ty> struct is_array : bool_constant<is_array_v<_Ty>>
    {
    };

    template <class> constexpr bool is_lvalue_reference_v = false;

    template <class _Ty> constexpr bool is_lvalue_reference_v<_Ty&> = true;

    template <class _Ty> struct is_lvalue_reference : bool_constant<is_lvalue_reference_v<_Ty>>
    {
    };

    template <class> constexpr bool is_rvalue_reference_v = false;

    template <class _Ty> constexpr bool is_rvalue_reference_v<_Ty&&> = true;

    template <class _Ty> struct is_rvalue_reference : bool_constant<is_rvalue_reference_v<_Ty>>
    {
    };

    template <class> constexpr bool is_reference_v = false;

    template <class _Ty> constexpr bool is_reference_v<_Ty&> = true;

    template <class _Ty> constexpr bool is_reference_v<_Ty&&> = true;

    template <class _Ty> struct is_reference : bool_constant<is_reference_v<_Ty>>
    {
    };

    template <class _Ty, bool _Pmf = _Is_memfunptr<_Ty>::_Bool_type::value> struct _Is_member_object_pointer
    {
        static constexpr bool value = false;
    };

    template <class _Ty1, class _Ty2> struct _Is_member_object_pointer<_Ty1 _Ty2::*, false>
    {
        static constexpr bool value = true;
        using _Class_type = _Ty2;
    };

    template <class _Ty> constexpr bool is_member_object_pointer_v = _Is_member_object_pointer<remove_cv_t<_Ty>>::value;

    template <class _Ty> struct is_member_object_pointer : bool_constant<is_member_object_pointer_v<_Ty>>
    {
    };

    template <class _Ty>
    constexpr bool is_member_function_pointer_v = _Is_memfunptr<remove_cv_t<_Ty>>::_Bool_type::value;

    template <class _Ty> struct is_member_function_pointer : bool_constant<is_member_function_pointer_v<_Ty>>
    {
    };

    template <class> constexpr bool is_pointer_v = false;

    template <class _Ty> constexpr bool is_pointer_v<_Ty*> = true;

    template <class _Ty> constexpr bool is_pointer_v<_Ty* const> = true;

    template <class _Ty> constexpr bool is_pointer_v<_Ty* volatile> = true;

    template <class _Ty> constexpr bool is_pointer_v<_Ty* const volatile> = true;

    template <class _Ty> struct is_pointer : bool_constant<is_pointer_v<_Ty>>
    {
    };

    template <class _Ty> constexpr bool is_null_pointer_v = is_same_v<remove_cv_t<_Ty>, nullptr_t>;

    template <class _Ty> struct is_null_pointer : bool_constant<is_null_pointer_v<_Ty>>
    {
    };

    template <class _Ty> struct is_union : bool_constant<__is_union(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_union_v = __is_union(_Ty);

    template <class _Ty> struct is_class : bool_constant<__is_class(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_class_v = __is_class(_Ty);

    template <class _Ty>
    constexpr bool is_fundamental_v = is_arithmetic_v<_Ty> || is_void_v<_Ty> || is_null_pointer_v<_Ty>;

    template <class _Ty> struct is_fundamental : bool_constant<is_fundamental_v<_Ty>>
    {
    };

    template <class _Ty> constexpr bool is_object_v = !is_function_v<_Ty> && !is_reference_v<_Ty> && !is_void_v<_Ty>;

    template <class _Ty> struct is_object : bool_constant<is_object_v<_Ty>>
    {
    };

    template <class _From, class _To> struct is_convertible : bool_constant<__is_convertible_to(_From, _To)>
    {
    };

    template <class _From, class _To> constexpr bool is_convertible_v = __is_convertible_to(_From, _To);

    template <class _Ty> struct is_enum : bool_constant<__is_enum(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_enum_v = __is_enum(_Ty);

    template <class _Ty> struct is_compound : bool_constant<!is_fundamental_v<_Ty>>
    {
    };

    template <class _Ty> constexpr bool is_compound_v = !is_fundamental_v<_Ty>;

    template <class _Ty>
    constexpr bool is_member_pointer_v = is_member_object_pointer_v<_Ty> || is_member_function_pointer_v<_Ty>;

    template <class _Ty> struct is_member_pointer : bool_constant<is_member_pointer_v<_Ty>>
    {
    };

    template <class _Ty>
    constexpr bool is_scalar_v
    = is_arithmetic_v<_Ty> || is_enum_v<_Ty> || is_pointer_v<_Ty> || is_member_pointer_v<_Ty> || is_null_pointer_v<_Ty>;

    template <class _Ty> struct is_scalar : bool_constant<is_scalar_v<_Ty>>
    {
    };

    template <class> constexpr bool is_const_v = false;

    template <class _Ty> constexpr bool is_const_v<const _Ty> = true;

    template <class _Ty> struct is_const : bool_constant<is_const_v<_Ty>>
    {
    };

    template <class> constexpr bool is_volatile_v = false;

    template <class _Ty> constexpr bool is_volatile_v<volatile _Ty> = true;

    template <class _Ty> struct is_volatile : bool_constant<is_volatile_v<_Ty>>
    {
    };

    template <class _Ty> struct is_pod : bool_constant<__is_pod(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_pod_v = __is_pod(_Ty);

    template <class _Ty> struct is_empty : bool_constant<__is_empty(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_empty_v = __is_empty(_Ty);

    template <class _Ty> struct is_polymorphic : bool_constant<__is_polymorphic(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_polymorphic_v = __is_polymorphic(_Ty);

    template <class _Ty> struct is_abstract : bool_constant<__is_abstract(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_abstract_v = __is_abstract(_Ty);

    template <class _Ty> struct is_final : bool_constant<__is_final(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_final_v = __is_final(_Ty);

    template <class _Ty> struct is_standard_layout : bool_constant<__is_standard_layout(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_standard_layout_v = __is_standard_layout(_Ty);

    template <class _Ty> struct is_literal_type : bool_constant<__is_literal_type(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_literal_type_v = __is_literal_type(_Ty);

    template <class _Ty>
    struct is_trivial : bool_constant<__is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty)>
    {
    };

    template <class _Ty>
    constexpr bool is_trivial_v = __is_trivially_constructible(_Ty) && __is_trivially_copyable(_Ty);

    template <class _Ty> struct is_trivially_copyable : bool_constant<__is_trivially_copyable(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_trivially_copyable_v = __is_trivially_copyable(_Ty);

    template <class _Ty> struct has_virtual_destructor : bool_constant<__has_virtual_destructor(_Ty)>
    {
    };

    template <class _Ty> constexpr bool has_virtual_destructor_v = __has_virtual_destructor(_Ty);

    template <class _Ty, class... _Args> struct is_constructible : bool_constant<__is_constructible(_Ty, _Args...)>
    {
    };

    template <class _Ty, class... _Args> constexpr bool is_constructible_v = __is_constructible(_Ty, _Args...);

    template <class _Ty>
    struct is_copy_constructible : bool_constant<__is_constructible(_Ty, add_lvalue_reference_t<const _Ty>)>
    {
    };

    template <class _Ty>
    constexpr bool is_copy_constructible_v = __is_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

    template <class _Ty> struct is_default_constructible : bool_constant<__is_constructible(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_default_constructible_v = __is_constructible(_Ty);

    template <class _Ty, class = void> struct _Is_implicitly_default_constructible : false_type
    {
    };

    template <class _Ty> void _Implicitly_default_construct(const _Ty&);

    template <class _Ty>
    struct _Is_implicitly_default_constructible<_Ty, void_t<decltype(_Implicitly_default_construct<_Ty>({}))>> : true_type
    {
    };

    template <class _Ty> struct is_move_constructible : bool_constant<__is_constructible(_Ty, _Ty)>
    {
    };

    template <class _Ty> constexpr bool is_move_constructible_v = __is_constructible(_Ty, _Ty);

    template <class _To, class _From> struct is_assignable : bool_constant<__is_assignable(_To, _From)>
    {
    };

    template <class _To, class _From> constexpr bool is_assignable_v = __is_assignable(_To, _From);

    template <class _Ty>
    struct is_copy_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)>
    {
    };

    template <class _Ty>
    constexpr bool is_copy_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

    template <class _Ty>
    struct _Is_copy_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)>
    {
    };

    template <class _Ty>
    constexpr bool _Is_copy_assignable_unchecked_v
    = __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

    template <class _Ty> struct is_move_assignable : bool_constant<__is_assignable(add_lvalue_reference_t<_Ty>, _Ty)>
    {
    };

    template <class _Ty> constexpr bool is_move_assignable_v = __is_assignable(add_lvalue_reference_t<_Ty>, _Ty);

    template <class _Ty>
    struct _Is_move_assignable_no_precondition_check
    : bool_constant<__is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty)>
    {
    };

    template <class _Ty>
    constexpr bool _Is_move_assignable_unchecked_v = __is_assignable_no_precondition_check(add_lvalue_reference_t<_Ty>, _Ty);

    template <class _Ty> struct is_destructible : bool_constant<__is_destructible(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_destructible_v = __is_destructible(_Ty);

    template <class _Ty, class... _Args>
    struct is_trivially_constructible : bool_constant<__is_trivially_constructible(_Ty, _Args...)>
    {
    };

    template <class _Ty, class... _Args>
    constexpr bool is_trivially_constructible_v = __is_trivially_constructible(_Ty, _Args...);

    template <class _Ty>
    struct is_trivially_copy_constructible
    : bool_constant<__is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>)>
    {
    };

    template <class _Ty>
    constexpr bool is_trivially_copy_constructible_v = __is_trivially_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

    template <class _Ty> struct is_trivially_default_constructible : bool_constant<__is_trivially_constructible(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_trivially_default_constructible_v = __is_trivially_constructible(_Ty);

    template <class _Ty> struct is_trivially_move_constructible : bool_constant<__is_trivially_constructible(_Ty, _Ty)>
    {
    };

    template <class _Ty> constexpr bool is_trivially_move_constructible_v = __is_trivially_constructible(_Ty, _Ty);

    template <class _To, class _From>
    struct is_trivially_assignable : bool_constant<__is_trivially_assignable(_To, _From)>
    {
    };

    template <class _To, class _From> constexpr bool is_trivially_assignable_v = __is_trivially_assignable(_To, _From);

    template <class _Ty>
    struct is_trivially_copy_assignable
    : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)>
    {
    };

    template <class _Ty>
    constexpr bool is_trivially_copy_assignable_v
    = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

    template <class _Ty>
    struct is_trivially_move_assignable : bool_constant<__is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty)>
    {
    };

    template <class _Ty>
    constexpr bool is_trivially_move_assignable_v = __is_trivially_assignable(add_lvalue_reference_t<_Ty>, _Ty);

    template <class _Ty> struct is_trivially_destructible : bool_constant<__is_trivially_destructible(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_trivially_destructible_v = __is_trivially_destructible(_Ty);

    template <class _Ty, class... _Args>
    struct is_nothrow_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Args...)>
    {
    };

    template <class _Ty, class... _Args>
    constexpr bool is_nothrow_constructible_v = __is_nothrow_constructible(_Ty, _Args...);

    template <class _Ty>
    struct is_nothrow_copy_constructible : bool_constant<__is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>)>
    {
    };

    template <class _Ty>
    constexpr bool is_nothrow_copy_constructible_v = __is_nothrow_constructible(_Ty, add_lvalue_reference_t<const _Ty>);

    template <class _Ty> struct is_nothrow_default_constructible : bool_constant<__is_nothrow_constructible(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_nothrow_default_constructible_v = __is_nothrow_constructible(_Ty);

    template <class _Ty> struct is_nothrow_move_constructible : bool_constant<__is_nothrow_constructible(_Ty, _Ty)>
    {
    };

    template <class _Ty> constexpr bool is_nothrow_move_constructible_v = __is_nothrow_constructible(_Ty, _Ty);

    template <class _To, class _From> struct is_nothrow_assignable : bool_constant<__is_nothrow_assignable(_To, _From)>
    {
    };

    template <class _To, class _From> constexpr bool is_nothrow_assignable_v = __is_nothrow_assignable(_To, _From);

    template <class _Ty>
    struct is_nothrow_copy_assignable
    : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>)>
    {
    };

    template <class _Ty>
    constexpr bool is_nothrow_copy_assignable_v
    = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<const _Ty>);

    template <class _Ty>
    struct is_nothrow_move_assignable : bool_constant<__is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty)>
    {
    };

    template <class _Ty>
    constexpr bool is_nothrow_move_assignable_v = __is_nothrow_assignable(add_lvalue_reference_t<_Ty>, _Ty);

    template <class _Ty> struct is_nothrow_destructible : bool_constant<__is_nothrow_destructible(_Ty)>
    {
    };

    template <class _Ty> constexpr bool is_nothrow_destructible_v = __is_nothrow_destructible(_Ty);

    template <class _Ty, bool = is_integral_v<_Ty>> struct _Sign_base
    {
        using _Uty = remove_cv_t<_Ty>;

        static constexpr bool _Signed = _Uty(-1) < _Uty(0);
        static constexpr bool _Unsigned = !_Signed;
    };

    template <class _Ty> struct _Sign_base<_Ty, false>
    {
        static constexpr bool _Signed = is_floating_point_v<_Ty>;
        static constexpr bool _Unsigned = false;
    };

    template <class _Ty> struct is_signed : bool_constant<_Sign_base<_Ty>::_Signed>
    {
    };

    template <class _Ty> constexpr bool is_signed_v = _Sign_base<_Ty>::_Signed;

    template <class _Ty> struct is_unsigned : bool_constant<_Sign_base<_Ty>::_Unsigned>
    {
    };

    template <class _Ty> constexpr bool is_unsigned_v = _Sign_base<_Ty>::_Unsigned;

    template <class _Ty> constexpr bool _Is_nonbool_integral = is_integral_v<_Ty> && !is_same_v<remove_cv_t<_Ty>, bool>;

    template <bool> struct _Select
    {
        template <class _Ty1, class> using _Apply = _Ty1;
    };

    template <> struct _Select<false>
    {
        template <class, class _Ty2> using _Apply = _Ty2;
    };

    template <size_t> struct _Make_signed2;

    template <> struct _Make_signed2<1>
    {
        template <class> using _Apply = signed char;
    };

    template <> struct _Make_signed2<2>
    {
        template <class> using _Apply = short;
    };

    template <> struct _Make_signed2<4>
    {
        template <class _Ty>
        using _Apply = typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<long, int>;
    };

    template <> struct _Make_signed2<8>
    {
        template <class> using _Apply = long long;
    };

    template <class _Ty> using _Make_signed1 = typename _Make_signed2<sizeof(_Ty)>::template _Apply<_Ty>;

    template <class _Ty> struct make_signed
    {
        static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
                      "make_signed<T> requires that T shall be a (possibly cv-qualified) "
                      "integral type or enumeration but not a bool type.");

        using type = typename remove_cv<_Ty>::template _Apply<_Make_signed1>;
    };

    template <class _Ty> using make_signed_t = typename make_signed<_Ty>::type;

    template <size_t> struct _Make_unsigned2;

    template <> struct _Make_unsigned2<1>
    {
        template <class> using _Apply = unsigned char;
    };

    template <> struct _Make_unsigned2<2>
    {
        template <class> using _Apply = unsigned short;
    };

    template <> struct _Make_unsigned2<4>
    {
        template <class _Ty>
        using _Apply =
        typename _Select<is_same_v<_Ty, long> || is_same_v<_Ty, unsigned long>>::template _Apply<unsigned long, unsigned int>;
    };

    template <> struct _Make_unsigned2<8>
    {
        template <class> using _Apply = unsigned long long;
    };

    template <class _Ty> using _Make_unsigned1 = typename _Make_unsigned2<sizeof(_Ty)>::template _Apply<_Ty>;

    template <class _Ty> struct make_unsigned
    {
        static_assert(_Is_nonbool_integral<_Ty> || is_enum_v<_Ty>,
                      "make_unsigned<T> requires that T shall be a (possibly cv-qualified) "
                      "integral type or enumeration but not a bool type.");

        using type = typename remove_cv<_Ty>::template _Apply<_Make_unsigned1>;
    };

    template <class _Ty> using make_unsigned_t = typename make_unsigned<_Ty>::type;

    template <class _Rep> constexpr make_unsigned_t<_Rep> _Unsigned_value(_Rep _Val)
    {
        return static_cast<make_unsigned_t<_Rep>>(_Val);
    }

    template <class _Ty> struct alignment_of : integral_constant<size_t, alignof(_Ty)>
    {
    };

    template <class _Ty> constexpr size_t alignment_of_v = alignof(_Ty);

    template <class _Ty, size_t _Len> union _Align_type
    {
        _Ty _Val;
        char _Pad[_Len];
    };

    template <size_t _Len, size_t _Align, class _Ty, bool _Ok> struct _Aligned;

    template <size_t _Len, size_t _Align, class _Ty> struct _Aligned<_Len, _Align, _Ty, true>
    {
        using type = _Align_type<_Ty, _Len>;
    };

    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, double, false>
    {
        static_assert(_Always_false<_Aligned>,
                      "You've instantiated std::aligned_storage<Len, Align> with an extended alignment (in other "
                      "words, Align > alignof(max_align_t)). Before VS 2017 15.8, the member \"type\" would "
                      "non-conformingly have an alignment of only alignof(max_align_t). VS 2017 15.8 was fixed to "
                      "handle this correctly, but the fix inherently changes layout and breaks binary compatibility "
                      "(*only* for uses of aligned_storage with extended alignments). "
                      "Please define either "
                      "(1) _ENABLE_EXTENDED_ALIGNED_STORAGE to acknowledge that you understand this message and "
                      "that you actually want a type with an extended alignment, or "
                      "(2) _DISABLE_EXTENDED_ALIGNED_STORAGE to silence this message and get the old non-conforming "
                      "behavior.");
        using type = _Align_type<max_align_t, _Len>;
    };

    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, int, false>
    {
        using _Next = double;
        static constexpr bool _Fits = _Align <= alignof(_Next);
        using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
    };

    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, short, false>
    {
        using _Next = int;
        static constexpr bool _Fits = _Align <= alignof(_Next);
        using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
    };

    template <size_t _Len, size_t _Align> struct _Aligned<_Len, _Align, char, false>
    {
        using _Next = short;
        static constexpr bool _Fits = _Align <= alignof(_Next);
        using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
    };

    template <size_t _Len, size_t _Align = alignof(max_align_t)> struct aligned_storage
    {
        using _Next = char;
        static constexpr bool _Fits = _Align <= alignof(_Next);
        using type = typename _Aligned<_Len, _Align, _Next, _Fits>::type;
    };

    template <size_t _Len, size_t _Align = alignof(max_align_t)>
    using aligned_storage_t = typename aligned_storage<_Len, _Align>::type;

    template <size_t... _Vals> struct _Maximum;

    template <> struct _Maximum<> : integral_constant<size_t, 0>
    {
    };

    template <size_t _Val> struct _Maximum<_Val> : integral_constant<size_t, _Val>
    {
    };

    template <size_t _First, size_t _Second, size_t... _Rest>
    struct _Maximum<_First, _Second, _Rest...> : _Maximum<(_First < _Second ? _Second : _First), _Rest...>::type
    {
    };

    template <size_t _Len, class... _Types> struct aligned_union
    {
        static constexpr size_t _Max_len = _Maximum<_Len, sizeof(_Types)...>::value;
        static constexpr size_t alignment_value = _Maximum<alignof(_Types)...>::value;

        using type = aligned_storage_t<_Max_len, alignment_value>;
    };

    template <size_t _Len, class... _Types> using aligned_union_t = typename aligned_union<_Len, _Types...>::type;

    template <class _Ty, bool = is_enum_v<_Ty>> struct _Underlying_type
    {
        using type = __underlying_type(_Ty);
    };

    template <class _Ty> struct _Underlying_type<_Ty, false>
    {
    };

    template <class _Ty> struct underlying_type : _Underlying_type<_Ty>
    {
    };

    template <class _Ty> using underlying_type_t = typename _Underlying_type<_Ty>::type;

    template <class _Ty> constexpr size_t rank_v = 0;

    template <class _Ty, size_t _Nx> constexpr size_t rank_v<_Ty[_Nx]> = rank_v<_Ty> + 1;

    template <class _Ty> constexpr size_t rank_v<_Ty[]> = rank_v<_Ty> + 1;

    template <class _Ty> struct rank : integral_constant<size_t, rank_v<_Ty>>
    {
    };

    template <class _Ty, unsigned int _Ix = 0> constexpr size_t extent_v = 0;

    template <class _Ty, size_t _Nx> constexpr size_t extent_v<_Ty[_Nx], 0> = _Nx;

    template <class _Ty, unsigned int _Ix, size_t _Nx>
    constexpr size_t extent_v<_Ty[_Nx], _Ix> = extent_v<_Ty, _Ix - 1>;

    template <class _Ty, unsigned int _Ix> constexpr size_t extent_v<_Ty[], _Ix> = extent_v<_Ty, _Ix - 1>;

    template <class _Ty, unsigned int _Ix = 0> struct extent : integral_constant<size_t, extent_v<_Ty, _Ix>>
    {
    };

    template <class _Base, class _Derived> struct is_base_of : bool_constant<__is_base_of(_Base, _Derived)>
    {
    };

    template <class _Base, class _Derived> constexpr bool is_base_of_v = __is_base_of(_Base, _Derived);

    template <class _Ty> struct decay
    {
        using _Ty1 = remove_reference_t<_Ty>;
        using _Ty2 = typename _Select<is_function_v<_Ty1>>::template _Apply<add_pointer<_Ty1>, remove_cv<_Ty1>>;
        using type = typename _Select<is_array_v<_Ty1>>::template _Apply<add_pointer<remove_extent_t<_Ty1>>, _Ty2>::type;
    };

    template <class _Ty> using decay_t = typename decay<_Ty>::type;

    template <class _Ty1, class _Ty2>
    using _Conditional_type = decltype(false ? ::std::declval<_Ty1>() : ::std::declval<_Ty2>());

    template <class _Ty1, class _Ty2, class = void> struct _Decayed_cond_oper
    {
    };

    template <class _Ty1, class _Ty2> struct _Decayed_cond_oper<_Ty1, _Ty2, void_t<_Conditional_type<_Ty1, _Ty2>>>
    {
        using type = decay_t<_Conditional_type<_Ty1, _Ty2>>;
    };

    template <class... _Ty> struct common_type;

    template <class... _Ty> using common_type_t = typename common_type<_Ty...>::type;

    template <> struct common_type<>
    {
    };

    template <class _Ty1> struct common_type<_Ty1> : common_type<_Ty1, _Ty1>
    {
    };

    template <class _Ty1, class _Ty2, class _Decayed1 = decay_t<_Ty1>, class _Decayed2 = decay_t<_Ty2>>
    struct _Common_type2 : common_type<_Decayed1, _Decayed2>
    {
    };

    template <class _Ty1, class _Ty2> struct _Common_type2<_Ty1, _Ty2, _Ty1, _Ty2> : _Decayed_cond_oper<_Ty1, _Ty2>
    {
    };

    template <class _Ty1, class _Ty2> struct common_type<_Ty1, _Ty2> : _Common_type2<_Ty1, _Ty2>
    {
    };

    template <class _Void, class _Ty1, class _Ty2, class... _Rest> struct _Common_type3
    {
    };

    template <class _Ty1, class _Ty2, class... _Rest>
    struct _Common_type3<void_t<common_type_t<_Ty1, _Ty2>>, _Ty1, _Ty2, _Rest...>
    : common_type<common_type_t<_Ty1, _Ty2>, _Rest...>
    {
    };

    template <class _Ty1, class _Ty2, class... _Rest>
    struct common_type<_Ty1, _Ty2, _Rest...> : _Common_type3<void, _Ty1, _Ty2, _Rest...>
    {
    };

    template <class _Ty> struct _Identity
    {
        using type = _Ty;
    };
    template <class _Ty> using _Identity_t = typename _Identity<_Ty>::type;

    template <class _Type, template <class...> class _Template> constexpr bool _Is_specialization_v = false;
    template <template <class...> class _Template, class... _Types>
    constexpr bool _Is_specialization_v<_Template<_Types...>, _Template> = true;

    template <class _Type, template <class...> class _Template>
    struct _Is_specialization : bool_constant<_Is_specialization_v<_Type, _Template>>
    {
    };

    template <class _Ty>[[nodiscard]] constexpr _Ty&& forward(remove_reference_t<_Ty>& _Arg) noexcept
    {
        return static_cast<_Ty&&>(_Arg);
    }

    template <class _Ty>[[nodiscard]] constexpr _Ty&& forward(remove_reference_t<_Ty>&& _Arg) noexcept
    {
        static_assert(!is_lvalue_reference_v<_Ty>, "bad forward call");
        return static_cast<_Ty&&>(_Arg);
    }

    template <class _Ty>[[nodiscard]] constexpr remove_reference_t<_Ty>&& move(_Ty&& _Arg) noexcept
    {
        return static_cast<remove_reference_t<_Ty>&&>(_Arg);
    }

    template <class _Ty>
    [[nodiscard]] constexpr conditional_t<!is_nothrow_move_constructible_v<_Ty> && is_copy_constructible_v<_Ty>, const _Ty&, _Ty&&>
    move_if_noexcept(_Ty& _Arg) noexcept
    {
        return ::std::move(_Arg);
    }

    template <class _Ty> class reference_wrapper;

    struct _Invoker_pmf_object
    {
        template <class _Decayed, class _Ty1, class... _Types2>
        static inline auto
        _Call(_Decayed _Pmf,
              _Ty1&& _Arg1,
              _Types2&&... _Args2) noexcept(noexcept((::std::forward<_Ty1>(_Arg1).*_Pmf)(::std::forward<_Types2>(_Args2)...)))
        -> decltype((::std::forward<_Ty1>(_Arg1).*_Pmf)(::std::forward<_Types2>(_Args2)...))
        {
            return (::std::forward<_Ty1>(_Arg1).*_Pmf)(::std::forward<_Types2>(_Args2)...);
        }
    };
    struct _Invoker_pmf_refwrap
    {
        template <class _Decayed, class _Ty1, class... _Types2>
        static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept((::std::forward<_Ty1>(_Arg1).get().*_Pmf)(::std::forward<_Types2>(_Args2)...)))
        -> decltype((::std::forward<_Ty1>(_Arg1).get().*_Pmf)(::std::forward<_Types2>(_Args2)...))
        {
            return (::std::forward<_Ty1>(_Arg1).get().*_Pmf)(::std::forward<_Types2>(_Args2)...);
        }
    };
    struct _Invoker_pmf_pointer
    {
        template <class _Decayed, class _Ty1, class... _Types2>
        static inline auto _Call(_Decayed _Pmf, _Ty1&& _Arg1, _Types2&&... _Args2) noexcept(
        noexcept(((*::std::forward<_Ty1>(_Arg1)).*_Pmf)(::std::forward<_Types2>(_Args2)...)))
        -> decltype(((*::std::forward<_Ty1>(_Arg1)).*_Pmf)(::std::forward<_Types2>(_Args2)...))
        {
            return ((*::std::forward<_Ty1>(_Arg1)).*_Pmf)(::std::forward<_Types2>(_Args2)...);
        }
    };
    struct _Invoker_pmd_object
    {
        template <class _Decayed, class _Ty1>
        static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1).*_Pmd))
        -> decltype(::std::forward<_Ty1>(_Arg1).*_Pmd)
        {
            return ::std::forward<_Ty1>(_Arg1).*_Pmd;
        }
    };
    struct _Invoker_pmd_refwrap
    {
        template <class _Decayed, class _Ty1>
        static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept(::std::forward<_Ty1>(_Arg1).get().*_Pmd))
        -> decltype(::std::forward<_Ty1>(_Arg1).get().*_Pmd)
        {
            return ::std::forward<_Ty1>(_Arg1).get().*_Pmd;
        }
    };
    struct _Invoker_pmd_pointer
    {
        template <class _Decayed, class _Ty1>
        static inline auto _Call(_Decayed _Pmd, _Ty1&& _Arg1) noexcept(noexcept((*::std::forward<_Ty1>(_Arg1)).*_Pmd))
        -> decltype((*::std::forward<_Ty1>(_Arg1)).*_Pmd)
        {
            return (*::std::forward<_Ty1>(_Arg1)).*_Pmd;
        }
    };
    struct _Invoker_functor
    {
        template <class _Callable, class... _Types>
        static inline auto
        _Call(_Callable&& _Obj,
              _Types&&... _Args) noexcept(noexcept(::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...)))
        -> decltype(::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...))
        {
            return ::std::forward<_Callable>(_Obj)(::std::forward<_Types>(_Args)...);
        }
    };
    template <class _Callable, class _Ty1, class _Removed_cvref = _Remove_cvref_t<_Callable>, bool _Is_pmf = is_member_function_pointer_v<_Removed_cvref>, bool _Is_pmd = is_member_object_pointer_v<_Removed_cvref>>
    struct _Invoker1;
    template <class _Callable, class _Ty1, class _Removed_cvref>
    struct _Invoker1<_Callable, _Ty1, _Removed_cvref, true, false>
    : conditional_t<is_base_of_v<typename _Is_memfunptr<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
                    _Invoker_pmf_object,
                    conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmf_refwrap, _Invoker_pmf_pointer>>
    {
    };
    template <class _Callable, class _Ty1, class _Removed_cvref>
    struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, true>
    : conditional_t<is_base_of_v<typename _Is_member_object_pointer<_Removed_cvref>::_Class_type, remove_reference_t<_Ty1>>,
                    _Invoker_pmd_object,
                    conditional_t<_Is_specialization_v<_Remove_cvref_t<_Ty1>, reference_wrapper>, _Invoker_pmd_refwrap, _Invoker_pmd_pointer>>
    {
    };
    template <class _Callable, class _Ty1, class _Removed_cvref>
    struct _Invoker1<_Callable, _Ty1, _Removed_cvref, false, false> : _Invoker_functor
    {
    };
    template <class _Callable, class... _Types> struct _Invoker;
    template <class _Callable> struct _Invoker<_Callable> : _Invoker_functor
    {
    };
    template <class _Callable, class _Ty1, class... _Types2>
    struct _Invoker<_Callable, _Ty1, _Types2...> : _Invoker1<_Callable, _Ty1>
    {
    };
    template <class _Callable, class... _Types>
    inline auto invoke(_Callable&& _Obj, _Types&&... _Args) noexcept(
    noexcept(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...)))
    -> decltype(_Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...))
    {
        return _Invoker<_Callable, _Types...>::_Call(::std::forward<_Callable>(_Obj), ::std::forward<_Types>(_Args)...);
    }

    template <class _Rx, bool = is_void_v<_Rx>> struct _Invoker_ret
    {
    };

    struct _Unforced
    {
    };

    template <class _Cv_void> struct _Invoker_ret<_Cv_void, true>
    {
        template <class... _Valtys> static void _Call(_Valtys&&... _Vals)
        {
            ::std::invoke(::std::forward<_Valtys>(_Vals)...);
        }
    };

    template <class _Rx> struct _Invoker_ret<_Rx, false>
    {
        template <class... _Valtys> static _Rx _Call(_Valtys&&... _Vals)
        {
            return ::std::invoke(::std::forward<_Valtys>(_Vals)...);
        }
    };

    template <> struct _Invoker_ret<_Unforced, false>
    {
        template <class... _Valtys>
        static auto _Call(_Valtys&&... _Vals) -> decltype(::std::invoke(::std::forward<_Valtys>(_Vals)...))
        {
            return ::std::invoke(::std::forward<_Valtys>(_Vals)...);
        }
    };

    template <class _To> void _Implicitly_convert_to(_To) noexcept;

#pragma warning(push)
#pragma warning(disable : 4242)
#pragma warning(disable : 4244)
#pragma warning(disable : 4365)
    template <class _From, class _To, bool = is_convertible_v<_From, _To>, bool = is_void_v<_To>>
    constexpr bool _Is_nothrow_convertible_v = noexcept(_Implicitly_convert_to<_To>(::std::declval<_From>()));
#pragma warning(pop)
    template <class _From, class _To, bool _IsVoid>
    constexpr bool _Is_nothrow_convertible_v<_From, _To, false, _IsVoid> = false;

    template <class _From, class _To> constexpr bool _Is_nothrow_convertible_v<_From, _To, true, true> = true;

    template <class _From, class _To>
    struct _Is_nothrow_convertible : bool_constant<_Is_nothrow_convertible_v<_From, _To>>
    {
    };

    template <class _Void, class... _Types> struct _Invoke_traits
    {
        using _Is_invocable = false_type;
        using _Is_nothrow_invocable = false_type;
        template <class _Rx> using _Is_invocable_r = false_type;
        template <class _Rx> using _Is_nothrow_invocable_r = false_type;
    };

    template <class... _Types>
    struct _Invoke_traits<void_t<decltype(::std::invoke(::std::declval<_Types>()...))>, _Types...>
    {
        using type = decltype(::std::invoke(::std::declval<_Types>()...));
        using _Is_invocable = true_type;
        using _Is_nothrow_invocable = bool_constant<noexcept(::std::invoke(::std::declval<_Types>()...))>;
        template <class _Rx>
        using _Is_invocable_r = bool_constant<disjunction_v<is_void<_Rx>, is_convertible<type, _Rx>>>;
        template <class _Rx>
        using _Is_nothrow_invocable_r
        = bool_constant<conjunction_v<_Is_nothrow_invocable, disjunction<is_void<_Rx>, _Is_nothrow_convertible<type, _Rx>>>>;
    };

    template <class _Fty> struct result_of
    {
        static_assert(_Always_false<_Fty>,
                      "result_of<CallableType> is invalid; use "
                      "result_of<CallableType(zero or more argument types)> instead.");
    };

    template <class _Callable, class... _Args>
    struct result_of<_Callable __cdecl(_Args...)> : _Invoke_traits<void, _Callable, _Args...>
    {
    };
    template <class _Callable, class... _Args>
    struct result_of<_Callable __clrcall(_Args...)> : _Invoke_traits<void, _Callable, _Args...>
    {
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
    using result_of_t = typename result_of<_Ty>::type;
    __pragma(warning(pop))

    template <class _Callable, class... _Args>
    using _Invoke_result_t = typename _Invoke_traits<void, _Callable, _Args...>::type;

    template <class _Rx, class _Callable, class... _Args>
    using _Is_invocable_r_ = typename _Invoke_traits<void, _Callable, _Args...>::template _Is_invocable_r<_Rx>;

    template <class _Rx, class _Callable, class... _Args>
    struct _Is_invocable_r : _Is_invocable_r_<_Rx, _Callable, _Args...>
    {
    };

    template <class _Ty, class = void> struct _Weak_result_type
    {
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
    struct _Weak_result_type<_Ty, void_t<typename _Ty::result_type>>
    {
        typedef typename _Ty::result_type result_type;
    };
    __pragma(warning(pop))

    template <class _Ty, class = void>
    struct _Weak_argument_type : _Weak_result_type<_Ty>
    {
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
    struct _Weak_argument_type<_Ty, void_t<typename _Ty::argument_type>> : _Weak_result_type<_Ty>
    {
        typedef typename _Ty::argument_type argument_type;
    };
    __pragma(warning(pop))

    template <class _Ty, class = void>
    struct _Weak_binary_args : _Weak_argument_type<_Ty>
    {
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
    struct _Weak_binary_args<_Ty, void_t<typename _Ty::first_argument_type, typename _Ty::second_argument_type>>
    : _Weak_argument_type<_Ty>
    {
        typedef typename _Ty::first_argument_type first_argument_type;
        typedef typename _Ty::second_argument_type second_argument_type;
    };
    __pragma(warning(pop))

    template <class _Ty>
    struct _Weak_types
    {
        using _Is_f_or_pf = _Is_function<remove_pointer_t<_Ty>>;
        using _Is_pmf = _Is_memfunptr<remove_cv_t<_Ty>>;
        using type
        = conditional_t<is_function_v<remove_pointer_t<_Ty>>, _Is_f_or_pf, conditional_t<is_member_function_pointer_v<_Ty>, _Is_pmf, _Weak_binary_args<_Ty>>>;
    };

    template <class _Ty> void _Refwrap_ctor_fun(_Identity_t<_Ty&>) noexcept;
    template <class _Ty> void _Refwrap_ctor_fun(_Identity_t<_Ty&&>) = delete;

    template <class _Ty, class _Uty, class = void> struct _Refwrap_has_ctor_from : false_type
    {
    };

    template <class _Ty, class _Uty>
    struct _Refwrap_has_ctor_from<_Ty, _Uty, void_t<decltype(_Refwrap_ctor_fun<_Ty>(::std::declval<_Uty>()))>> : true_type
    {
    };

    template <class _Ty> class reference_wrapper : public _Weak_types<_Ty>::type
    {
    public:
        static_assert(is_object_v<_Ty> || is_function_v<_Ty>, "reference_wrapper<T> requires T to be an object type or a function type.");

        using type = _Ty;

        template <class _Uty, enable_if_t<conjunction_v<negation<is_same<_Remove_cvref_t<_Uty>, reference_wrapper>>, _Refwrap_has_ctor_from<_Ty, _Uty>>, int> = 0>
        reference_wrapper(_Uty&& _Val) noexcept(noexcept(_Refwrap_ctor_fun<_Ty>(::std::declval<_Uty>())))
        {
            _Ty& _Ref = ::std::forward<_Uty>(_Val);
            _Ptr = ::std::addressof(_Ref);
        }

        operator _Ty&() const noexcept
        {
            return *_Ptr;
        }

        [[nodiscard]] _Ty& get() const noexcept
        {
            return *_Ptr;
        }

        template <class... _Types>
        auto operator()(_Types&&... _Args) const -> decltype(::std::invoke(get(), ::std::forward<_Types>(_Args)...))
        {
            return ::std::invoke(get(), ::std::forward<_Types>(_Args)...);
        }

    private:
        _Ty* _Ptr;
    };

    template <class _Ty>[[nodiscard]] reference_wrapper<_Ty> ref(_Ty& _Val) noexcept
    {
        return reference_wrapper<_Ty>(_Val);
    }

    template <class _Ty> void ref(const _Ty&&) = delete;

    template <class _Ty>[[nodiscard]] reference_wrapper<_Ty> ref(reference_wrapper<_Ty> _Val) noexcept
    {
        return ::std::ref(_Val.get());
    }

    template <class _Ty>[[nodiscard]] reference_wrapper<const _Ty> cref(const _Ty& _Val) noexcept
    {
        return reference_wrapper<const _Ty>(_Val);
    }

    template <class _Ty> void cref(const _Ty&&) = delete;

    template <class _Ty>[[nodiscard]] reference_wrapper<const _Ty> cref(reference_wrapper<_Ty> _Val) noexcept
    {
        return ::std::cref(_Val.get());
    }

    template <class _Ty> struct _Is_swappable;

    template <class _Ty> struct _Is_nothrow_swappable;

    template <class _Ty, int _Enabled = 0>
    void swap(_Ty&, _Ty&) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>);

    template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> = 0>
    void swap(_Ty (&)[_Size], _Ty (&)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value);

    template <class _Ty1, class _Ty2, class = void> struct _Swappable_with_helper : false_type
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Swappable_with_helper<_Ty1, _Ty2, void_t<decltype(swap(::std::declval<_Ty1>(), ::std::declval<_Ty2>()))>> : true_type
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Is_swappable_with
    : bool_constant<conjunction_v<_Swappable_with_helper<_Ty1, _Ty2>, _Swappable_with_helper<_Ty2, _Ty1>>>
    {
    };

    template <class _Ty>
    struct _Is_swappable : _Is_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Swap_cannot_throw
    : bool_constant<noexcept(swap(::std::declval<_Ty1>(), ::std::declval<_Ty2>()))&& noexcept(swap(::std::declval<_Ty2>(), ::std::declval<_Ty1>()))>
    {
    };

    template <class _Ty1, class _Ty2>
    struct _Is_nothrow_swappable_with
    : bool_constant<conjunction_v<_Is_swappable_with<_Ty1, _Ty2>, _Swap_cannot_throw<_Ty1, _Ty2>>>
    {
    };

    template <class _Ty>
    struct _Is_nothrow_swappable : _Is_nothrow_swappable_with<add_lvalue_reference_t<_Ty>, add_lvalue_reference_t<_Ty>>::type
    {
    };

    namespace _Has_ADL_swap_detail
    {
        void swap();

        template <class, class = void> struct _Has_ADL_swap : false_type
        {
        };
        template <class _Ty>
        struct _Has_ADL_swap<_Ty, void_t<decltype(swap(::std::declval<_Ty&>(), ::std::declval<_Ty&>()))>> : true_type
        {
        };
    }// namespace _Has_ADL_swap_detail
    using _Has_ADL_swap_detail::_Has_ADL_swap;

    template <class _Ty>
    constexpr bool _Is_trivially_swappable_v
    = conjunction_v<is_trivially_destructible<_Ty>, is_trivially_move_constructible<_Ty>, is_trivially_move_assignable<_Ty>, negation<_Has_ADL_swap<_Ty>>>;

    template <class _Ty> struct _Is_trivially_swappable : bool_constant<_Is_trivially_swappable_v<_Ty>>
    {
    };

    constexpr size_t _FNV_offset_basis = 14695981039346656037ULL;
    constexpr size_t _FNV_prime = 1099511628211ULL;

    [[nodiscard]] inline size_t _Fnv1a_append_bytes(size_t _Val, const unsigned char* const _First, const size_t _Count) noexcept
    {
        for(size_t _Idx = 0; _Idx < _Count; ++_Idx)
        {
            _Val ^= static_cast<size_t>(_First[_Idx]);
            _Val *= _FNV_prime;
        }

        return _Val;
    }

    template <class _Ty>
    [[nodiscard]] size_t _Fnv1a_append_range(const size_t _Val, const _Ty* const _First, const _Ty* const _Last) noexcept
    {
        static_assert(is_trivial_v<_Ty>, "Only trivial types can be directly hashed.");
        const auto _Firstb = reinterpret_cast<const unsigned char*>(_First);
        const auto _Lastb = reinterpret_cast<const unsigned char*>(_Last);
        return _Fnv1a_append_bytes(_Val, _Firstb, static_cast<size_t>(_Lastb - _Firstb));
    }

    template <class _Kty>[[nodiscard]] size_t _Fnv1a_append_value(const size_t _Val, const _Kty& _Keyval) noexcept
    {
        static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
        return _Fnv1a_append_bytes(_Val, &reinterpret_cast<const unsigned char&>(_Keyval), sizeof(_Kty));
    }

    template <class _Kty>[[nodiscard]] size_t _Hash_representation(const _Kty& _Keyval) noexcept
    {
        return _Fnv1a_append_value(_FNV_offset_basis, _Keyval);
    }

    template <class _Kty>
    [[nodiscard]] size_t _Hash_array_representation(const _Kty* const _First, const size_t _Count) noexcept
    {
        static_assert(is_trivial_v<_Kty>, "Only trivial types can be directly hashed.");
        return _Fnv1a_append_bytes(_FNV_offset_basis, reinterpret_cast<const unsigned char*>(_First), _Count * sizeof(_Kty));
    }

    template <class _Kty> struct hash;

    template <class _Kty, bool _Enabled> struct _Conditionally_enabled_hash
    {
        typedef _Kty argument_type;
        typedef size_t result_type;

        [[nodiscard]] size_t operator()(const _Kty& _Keyval) const noexcept(noexcept(hash<_Kty>::_Do_hash(_Keyval)))
        {
            return hash<_Kty>::_Do_hash(_Keyval);
        }
    };

    template <class _Kty> struct _Conditionally_enabled_hash<_Kty, false>
    {
        _Conditionally_enabled_hash() = delete;
        _Conditionally_enabled_hash(const _Conditionally_enabled_hash&) = delete;
        _Conditionally_enabled_hash(_Conditionally_enabled_hash&&) = delete;
        _Conditionally_enabled_hash& operator=(const _Conditionally_enabled_hash&) = delete;
        _Conditionally_enabled_hash& operator=(_Conditionally_enabled_hash&&) = delete;
    };

    template <class _Kty>
    struct hash
    : _Conditionally_enabled_hash<_Kty, !is_const_v<_Kty> && !is_volatile_v<_Kty> && (is_enum_v<_Kty> || is_integral_v<_Kty> || is_pointer_v<_Kty>)>
    {
        static size_t _Do_hash(const _Kty& _Keyval) noexcept
        {
            return _Hash_representation(_Keyval);
        }
    };

    template <> struct hash<float>
    {
        typedef float argument_type;
        typedef size_t result_type;
        [[nodiscard]] size_t operator()(const float _Keyval) const noexcept
        {
            return _Hash_representation(_Keyval == 0.0F ? 0.0F : _Keyval);
        }
    };

    template <> struct hash<double>
    {
        typedef double argument_type;
        typedef size_t result_type;
        [[nodiscard]] size_t operator()(const double _Keyval) const noexcept
        {
            return _Hash_representation(_Keyval == 0.0 ? 0.0 : _Keyval);
        }
    };

    template <> struct hash<long double>
    {
        typedef long double argument_type;
        typedef size_t result_type;
        [[nodiscard]] size_t operator()(const long double _Keyval) const noexcept
        {
            return _Hash_representation(_Keyval == 0.0L ? 0.0L : _Keyval);
        }
    };

    template <> struct hash<nullptr_t>
    {
        typedef nullptr_t argument_type;
        typedef size_t result_type;
        [[nodiscard]] size_t operator()(nullptr_t) const noexcept
        {
            void* _Null{};
            return _Hash_representation(_Null);
        }
    };

    template <class _Kty, class = void> struct _Is_nothrow_hashable : false_type
    {
    };

    template <class _Kty>
    struct _Is_nothrow_hashable<_Kty, void_t<decltype(hash<_Kty>{}(::std::declval<const _Kty&>()))>>
    : bool_constant<noexcept(hash<_Kty>{}(::std::declval<const _Kty&>()))>
    {
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) namespace [[deprecated(
    "warning STL4002: "
    "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
    "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1
    {
        using ::std::add_const;
        using ::std::add_cv;
        using ::std::add_pointer;
        using ::std::add_volatile;
        using ::std::aligned_storage;
        using ::std::alignment_of;
        using ::std::conditional;
        using ::std::cref;
        using ::std::decay;
        using ::std::enable_if;
        using ::std::extent;
        using ::std::false_type;
        using ::std::has_virtual_destructor;
        using ::std::hash;
        using ::std::integral_constant;
        using ::std::is_abstract;
        using ::std::is_arithmetic;
        using ::std::is_array;
        using ::std::is_base_of;
        using ::std::is_class;
        using ::std::is_compound;
        using ::std::is_const;
        using ::std::is_convertible;
        using ::std::is_empty;
        using ::std::is_enum;
        using ::std::is_floating_point;
        using ::std::is_function;
        using ::std::is_fundamental;
        using ::std::is_integral;
        using ::std::is_member_function_pointer;
        using ::std::is_member_object_pointer;
        using ::std::is_member_pointer;
        using ::std::is_object;
        using ::std::is_pod;
        using ::std::is_pointer;
        using ::std::is_polymorphic;
        using ::std::is_reference;
        using ::std::is_same;
        using ::std::is_scalar;
        using ::std::is_signed;
        using ::std::is_union;
        using ::std::is_unsigned;
        using ::std::is_void;
        using ::std::is_volatile;
        using ::std::make_signed;
        using ::std::make_unsigned;
        using ::std::rank;
        using ::std::ref;
        using ::std::reference_wrapper;
        using ::std::remove_all_extents;
        using ::std::remove_const;
        using ::std::remove_cv;
        using ::std::remove_extent;
        using ::std::remove_pointer;
        using ::std::remove_reference;
        using ::std::remove_volatile;
        using ::std::result_of;
        using ::std::true_type;
    }
    __pragma(warning(pop))

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    bool __cdecl uncaught_exception() noexcept;
    int __cdecl uncaught_exceptions() noexcept;

}// namespace std

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    typedef struct _heapinfo
    {
        int* _pentry;
        size_t _size;
        int _useflag;
    } _HEAPINFO;

    void* __cdecl _alloca(size_t _Size);

    __declspec(dllimport) intptr_t __cdecl _get_heap_handle(void);

    __declspec(dllimport) int __cdecl _heapmin(void);

    __declspec(dllimport) int __cdecl _heapwalk(_HEAPINFO * _EntryInfo);

    __declspec(dllimport) int __cdecl _heapchk(void);

    __declspec(dllimport) int __cdecl _resetstkoflw(void);

    typedef char __static_assert_t[(sizeof(unsigned int) <= 16) != 0];

#pragma warning(push)
#pragma warning(disable : 6540)

    __inline void* _MarkAllocaS(void* _Ptr, unsigned int _Marker)
    {
        if(_Ptr)
        {
            *((unsigned int*)_Ptr) = _Marker;
            _Ptr = (char*)_Ptr + 16;
        }
        return _Ptr;
    }

    __inline size_t _MallocaComputeSize(size_t _Size)
    {
        size_t _MarkedSize = _Size + 16;
        return _MarkedSize > _Size ? _MarkedSize : 0;
    }

#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 6014)
    __inline void __cdecl _freea(void* _Memory)
    {
        unsigned int _Marker;
        if(_Memory)
        {
            _Memory = (char*)_Memory - 16;
            _Marker = *(unsigned int*)_Memory;
            if(_Marker == 0xDDDD)
            {
                free(_Memory);
            }

            else if(_Marker != 0xCCCC)
            {
                ((void)0);
            }
        }
    }
#pragma warning(pop)
}
__pragma(pack(pop))

#pragma once

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    typedef void(__cdecl * terminate_handler)();
    typedef void(__cdecl * terminate_function)();

    typedef void(__clrcall * __terminate_function_m)();
    typedef void(__clrcall * __terminate_handler_m)();

    __declspec(dllimport) __declspec(noreturn) void __cdecl abort();
    __declspec(dllimport) __declspec(noreturn) void __cdecl terminate() throw();

    __declspec(dllimport) terminate_handler __cdecl set_terminate(terminate_handler _NewTerminateHandler) throw();

    __declspec(dllimport) terminate_handler __cdecl _get_terminate();
}
__pragma(pack(pop))

#pragma warning(push)
#pragma warning(disable : 4514 4820)

__pragma(pack(push, 8)) extern "C"
{
    typedef void(__cdecl * unexpected_handler)(void);
    typedef void(__cdecl * unexpected_function)(void);

    typedef void(__clrcall * __unexpected_function_m)();
    typedef void(__clrcall * __unexpected_handler_m)();

    struct _EXCEPTION_POINTERS;

    __declspec(noreturn) void __cdecl unexpected() noexcept(false);

    unexpected_handler __cdecl set_unexpected(unexpected_handler _NewUnexpectedHandler) noexcept;

    unexpected_handler __cdecl _get_unexpected() noexcept;

    typedef void(__cdecl * _se_translator_function)(unsigned int, struct _EXCEPTION_POINTERS*);

    _se_translator_function __cdecl _set_se_translator(_se_translator_function _NewSETranslator);

    class type_info;

    int __cdecl _is_exception_typeof(type_info const& _Type, _EXCEPTION_POINTERS* _ExceptionPtr);

    bool __cdecl __uncaught_exception();
    int __cdecl __uncaught_exceptions();
}
__pragma(pack(pop))

#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4514 4820)

#pragma pack(push, 8)

__pragma(pack(push, 8)) extern "C"
{
    struct __std_exception_data
    {
        char const* _What;
        bool _DoFree;
    };

    void __cdecl __std_exception_copy(__std_exception_data const* _From, __std_exception_data* _To);

    void __cdecl __std_exception_destroy(__std_exception_data * _Data);
}
__pragma(pack(pop))

namespace std
{
#pragma warning(push)
#pragma warning(disable : 4577)
    class exception
    {
    public:
        exception() noexcept : _Data()
        {
        }

        explicit exception(char const* const _Message) noexcept : _Data()
        {
            __std_exception_data _InitData = { _Message, true };
            __std_exception_copy(&_InitData, &_Data);
        }

        exception(char const* const _Message, int) noexcept : _Data()
        {
            _Data._What = _Message;
        }

        exception(exception const& _Other) noexcept : _Data()
        {
            __std_exception_copy(&_Other._Data, &_Data);
        }

        exception& operator=(exception const& _Other) noexcept
        {
            if(this == &_Other)
            {
                return *this;
            }

            __std_exception_destroy(&_Data);
            __std_exception_copy(&_Other._Data, &_Data);
            return *this;
        }

        virtual ~exception() noexcept
        {
            __std_exception_destroy(&_Data);
        }

        [[nodiscard]] virtual char const* what() const
        {
            return _Data._What ? _Data._What : "Unknown exception";
        }

    private:
        __std_exception_data _Data;
    };

    class bad_exception : public exception
    {
    public:
        bad_exception() noexcept : exception("bad exception", 1)
        {
        }
    };

    class bad_alloc : public exception
    {
    public:
        bad_alloc() noexcept : exception("bad allocation", 1)
        {
        }

    private:
        friend class bad_array_new_length;

        bad_alloc(char const* const _Message) noexcept : exception(_Message, 1)
        {
        }
    };

    class bad_array_new_length : public bad_alloc
    {
    public:
        bad_array_new_length() noexcept : bad_alloc("bad array new length")
        {
        }
    };

#pragma warning(pop)
}

#pragma pack(pop)

#pragma warning(pop)

namespace std
{
    using ::terminate;

    using ::set_terminate;
    using ::terminate_handler;

    [[nodiscard]] inline terminate_handler __cdecl get_terminate() noexcept
    {
        return _get_terminate();
    }

    using ::unexpected;

    using ::set_unexpected;
    using ::unexpected_handler;

    [[nodiscard]] inline unexpected_handler __cdecl get_unexpected() noexcept
    {
        return _get_unexpected();
    }

}// namespace std

void __cdecl __ExceptionPtrCreate(void*) noexcept;
void __cdecl __ExceptionPtrDestroy(void*) noexcept;
void __cdecl __ExceptionPtrCopy(void*, const void*) noexcept;
void __cdecl __ExceptionPtrAssign(void*, const void*) noexcept;
bool __cdecl __ExceptionPtrCompare(const void*, const void*) noexcept;
bool __cdecl __ExceptionPtrToBool(const void*) noexcept;
void __cdecl __ExceptionPtrSwap(void*, void*) noexcept;
void __cdecl __ExceptionPtrCurrentException(void*) noexcept;
[[noreturn]] void __cdecl __ExceptionPtrRethrow(const void*);
void __cdecl __ExceptionPtrCopyException(void*, const void*, const void*) noexcept;

namespace std
{
    class exception_ptr
    {
    public:
        exception_ptr() noexcept
        {
            __ExceptionPtrCreate(this);
        }

        exception_ptr(nullptr_t) noexcept
        {
            __ExceptionPtrCreate(this);
        }

        ~exception_ptr() noexcept
        {
            __ExceptionPtrDestroy(this);
        }

        exception_ptr(const exception_ptr& _Rhs) noexcept
        {
            __ExceptionPtrCopy(this, &_Rhs);
        }

        exception_ptr& operator=(const exception_ptr& _Rhs) noexcept
        {
            __ExceptionPtrAssign(this, &_Rhs);
            return *this;
        }

        exception_ptr& operator=(nullptr_t) noexcept
        {
            exception_ptr _Ptr;
            __ExceptionPtrAssign(this, &_Ptr);
            return *this;
        }

        explicit operator bool() const noexcept
        {
            return __ExceptionPtrToBool(this);
        }

        static exception_ptr _Current_exception() noexcept
        {
            exception_ptr _Retval;
            __ExceptionPtrCurrentException(&_Retval);
            return _Retval;
        }

        static exception_ptr _Copy_exception(void* _Except, const void* _Ptr)
        {
            exception_ptr _Retval;
            if(!_Ptr)
            {
                return _Retval;
            }
            __ExceptionPtrCopyException(&_Retval, _Except, _Ptr);
            return _Retval;
        }

        friend void swap(exception_ptr& _Lhs, exception_ptr& _Rhs) noexcept
        {
            __ExceptionPtrSwap(&_Lhs, &_Rhs);
        }

        [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept
        {
            return __ExceptionPtrCompare(&_Lhs, &_Rhs);
        }

        [[nodiscard]] friend bool operator==(nullptr_t, const exception_ptr& _Rhs) noexcept
        {
            return !_Rhs;
        }

        [[nodiscard]] friend bool operator==(const exception_ptr& _Lhs, nullptr_t) noexcept
        {
            return !_Lhs;
        }

        [[nodiscard]] friend bool operator!=(const exception_ptr& _Lhs, const exception_ptr& _Rhs) noexcept
        {
            return !(_Lhs == _Rhs);
        }

        [[nodiscard]] friend bool operator!=(nullptr_t _Lhs, const exception_ptr& _Rhs) noexcept
        {
            return !(_Lhs == _Rhs);
        }

        [[nodiscard]] friend bool operator!=(const exception_ptr& _Lhs, nullptr_t _Rhs) noexcept
        {
            return !(_Lhs == _Rhs);
        }

    private:
        void* _Data1;
        void* _Data2;
    };

    [[nodiscard]] inline exception_ptr current_exception() noexcept
    {
        return exception_ptr::_Current_exception();
    }

    [[noreturn]] inline void rethrow_exception(exception_ptr _Ptr)
    {
        __ExceptionPtrRethrow(&_Ptr);
    }

    template <class _Ex> void* __GetExceptionInfo(_Ex);

    template <class _Ex>[[nodiscard]] exception_ptr make_exception_ptr(_Ex _Except) noexcept
    {
        return exception_ptr::_Copy_exception(::std::addressof(_Except), __GetExceptionInfo(_Except));
    }

    [[noreturn]] inline void _Throw_bad_array_new_length()
    {
        throw bad_array_new_length{};
    }

    class nested_exception
    {
    public:
        nested_exception() noexcept : _Exc(::std::current_exception())
        {
        }

        nested_exception(const nested_exception&) noexcept = default;
        nested_exception& operator=(const nested_exception&) noexcept = default;
        virtual ~nested_exception() noexcept
        {
        }

        [[noreturn]] void rethrow_nested() const
        {
            if(_Exc)
            {
                ::std::rethrow_exception(_Exc);
            }
            else
            {
                ::std::terminate();
            }
        }

        [[nodiscard]] exception_ptr nested_ptr() const noexcept
        {
            return _Exc;
        }

    private:
        exception_ptr _Exc;
    };

    template <class _Ty, class _Uty> struct _With_nested : _Uty, nested_exception
    {
        explicit _With_nested(_Ty&& _Arg) : _Uty(::std::forward<_Ty>(_Arg)), nested_exception()
        {
        }
    };

    template <class _Ty>[[noreturn]] void throw_with_nested(_Ty&& _Arg)
    {
        using _Uty = decay_t<_Ty>;

        if constexpr(is_class_v<_Uty> && !is_base_of_v<nested_exception, _Uty> && !is_final_v<_Uty>)
        {
            using _Glued = _With_nested<_Ty, _Uty>;
            throw _Glued(::std::forward<_Ty>(_Arg));
        }
        else
        {
            throw ::std::forward<_Ty>(_Arg);
        }
    }

    template <class _Ty> void _Rethrow_if_nested(const _Ty* _Ptr, true_type)
    {
        const auto _Nested = dynamic_cast<const nested_exception*>(_Ptr);

        if(_Nested)
        {
            _Nested->rethrow_nested();
        }
    }

    template <class _Ty> void _Rethrow_if_nested(const _Ty*, false_type)
    {
    }

    template <class _Ty> void rethrow_if_nested(const _Ty& _Arg)
    {
        bool_constant<is_polymorphic_v<_Ty> && (!is_base_of_v<nested_exception, _Ty> || is_convertible_v<_Ty*, nested_exception*>)> _Tag;

        _Rethrow_if_nested(::std::addressof(_Arg), _Tag);
    }

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma once

#pragma warning(push)
#pragma warning(disable : 4514 4820)

__pragma(pack(push, 8)) extern "C"
{
    [[nodiscard]] void const* __cdecl memchr(void const* _Buf, int _Val, size_t _MaxCount);

    [[nodiscard]] int __cdecl memcmp(void const* _Buf1, void const* _Buf2, size_t _Size);

    void* __cdecl memcpy(void* _Dst, void const* _Src, size_t _Size);

    void* __cdecl memmove(void* _Dst, void const* _Src, size_t _Size);

    void* __cdecl memset(void* _Dst, int _Val, size_t _Size);

    [[nodiscard]] char const* __cdecl strchr(char const* _Str, int _Val);

    [[nodiscard]] char const* __cdecl strrchr(char const* _Str, int _Ch);

    [[nodiscard]] char const* __cdecl strstr(char const* _Str, char const* _SubStr);

    [[nodiscard]]

    wchar_t const* __cdecl wcschr(wchar_t const* _Str, wchar_t _Ch);

    [[nodiscard]] wchar_t const* __cdecl wcsrchr(wchar_t const* _Str, wchar_t _Ch);

    [[nodiscard]]

    wchar_t const* __cdecl wcsstr(wchar_t const* _Str, wchar_t const* _SubStr);
}
__pragma(pack(pop))

#pragma warning(pop)

__pragma(pack(push, 8)) extern "C"
{
    static __inline errno_t __cdecl memcpy_s(void* const _Destination, rsize_t const _DestinationSize,
                                             void const* const _Source, rsize_t const _SourceSize)
    {
        if(_SourceSize == 0)
        {
            return 0;
        }

        {
            int _Expr_val = !!(_Destination != 0);
            if(!(_Expr_val))
            {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        };
        if(_Source == 0 || _DestinationSize < _SourceSize)
        {
            memset(_Destination, 0, _DestinationSize);

            {
                int _Expr_val = !!(_Source != 0);
                if(!(_Expr_val))
                {
                    (*_errno()) = 22;
                    _invalid_parameter_noinfo();
                    return 22;
                }
            };
            {
                int _Expr_val = !!(_DestinationSize >= _SourceSize);
                if(!(_Expr_val))
                {
                    (*_errno()) = 34;
                    _invalid_parameter_noinfo();
                    return 34;
                }
            };

            return 22;
        }
#pragma warning(suppress : 4996)
        memcpy(_Destination, _Source, _SourceSize);
        return 0;
    }

    static __inline errno_t __cdecl memmove_s(void* const _Destination, rsize_t const _DestinationSize,
                                              void const* const _Source, rsize_t const _SourceSize)
    {
        if(_SourceSize == 0)
        {
            return 0;
        }

        {
            int _Expr_val = !!(_Destination != 0);
            if(!(_Expr_val))
            {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        };
        {
            int _Expr_val = !!(_Source != 0);
            if(!(_Expr_val))
            {
                (*_errno()) = 22;
                _invalid_parameter_noinfo();
                return 22;
            }
        };
        {
            int _Expr_val = !!(_DestinationSize >= _SourceSize);
            if(!(_Expr_val))
            {
                (*_errno()) = 34;
                _invalid_parameter_noinfo();
                return 34;
            }
        };

#pragma warning(suppress : 4996)
        memmove(_Destination, _Source, _SourceSize);
        return 0;
    }
}
__pragma(pack(pop))

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) int __cdecl _memicmp(void const* _Buf1, void const* _Buf2, size_t _Size);

    __declspec(dllimport) int __cdecl _memicmp_l(void const* _Buf1, void const* _Buf2, size_t _Size, _locale_t _Locale);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_memccpy"
                          ". See online help for details.")) __declspec(dllimport) void* __cdecl memccpy(void* _Dst, void const* _Src,
                                                                                                         int _Val, size_t _Size);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_memicmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl memicmp(void const* _Buf1,
                                                                                                       void const* _Buf2,
                                                                                                       size_t _Size);

    extern "C++" inline void* __cdecl memchr(void* _Pv, int _C, size_t _N)
    {
        void const* const _Pvc = _Pv;
        return const_cast<void*>(memchr(_Pvc, _C, _N));
    }
}
__pragma(pack(pop))

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) errno_t __cdecl wcscat_s(wchar_t * _Destination, rsize_t _SizeInWords, wchar_t const* _Source);

    __declspec(dllimport) errno_t __cdecl wcscpy_s(wchar_t * _Destination, rsize_t _SizeInWords, wchar_t const* _Source);

    __declspec(dllimport)
    errno_t __cdecl wcsncat_s(wchar_t * _Destination, rsize_t _SizeInWords, wchar_t const* _Source, rsize_t _MaxCount);

    __declspec(dllimport)
    errno_t __cdecl wcsncpy_s(wchar_t * _Destination, rsize_t _SizeInWords, wchar_t const* _Source, rsize_t _MaxCount);

    __declspec(dllimport) wchar_t* __cdecl wcstok_s(wchar_t * _String, wchar_t const* _Delimiter, wchar_t** _Context);

    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wcsdup(wchar_t const* _String);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl wcscat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw()
        {
            return wcscat_s(_Destination, _Size, _Source);
        }
    }

#pragma warning(push)
#pragma warning(disable : 28719)
#pragma warning(disable : 28726)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcscat_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl wcscat(wchar_t * _Destination, wchar_t const* _Source);
#pragma warning(pop)

    __declspec(dllimport) int __cdecl wcscmp(wchar_t const* _String1, wchar_t const* _String2);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl wcscpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source) throw()
        {
            return wcscpy_s(_Destination, _Size, _Source);
        }
    }

#pragma warning(push)
#pragma warning(disable : 28719)
#pragma warning(disable : 28726)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcscpy_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl wcscpy(wchar_t * _Destination, wchar_t const* _Source);
#pragma warning(pop)

    __declspec(dllimport) size_t __cdecl wcscspn(wchar_t const* _String, wchar_t const* _Control);

    __declspec(dllimport) size_t __cdecl wcslen(wchar_t const* _String);

    __declspec(dllimport) size_t __cdecl wcsnlen(wchar_t const* _Source, size_t _MaxCount);

    static __inline size_t __cdecl wcsnlen_s(wchar_t const* _Source, size_t _MaxCount)
    {
        return (_Source == 0) ? 0 : wcsnlen(_Source, _MaxCount);
    }

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl wcsncat_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw()
        {
            return wcsncat_s(_Destination, _Size, _Source, _Count);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcsncat_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl wcsncat(wchar_t * _Destination, wchar_t const* _Source, size_t _Count);

    __declspec(dllimport) int __cdecl wcsncmp(wchar_t const* _String1, wchar_t const* _String2, size_t _MaxCount);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl wcsncpy_s(wchar_t (&_Destination)[_Size], wchar_t const* _Source, size_t _Count) throw()
        {
            return wcsncpy_s(_Destination, _Size, _Source, _Count);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcsncpy_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl wcsncpy(wchar_t * _Destination, wchar_t const* _Source, size_t _Count);

    __declspec(dllimport) wchar_t const* __cdecl wcspbrk(wchar_t const* _String, wchar_t const* _Control);

    __declspec(dllimport) size_t __cdecl wcsspn(wchar_t const* _String, wchar_t const* _Control);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcstok_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl wcstok(wchar_t * _String, wchar_t const* _Delimiter, wchar_t** _Context);

#pragma warning(push)
#pragma warning(disable : 4141 4996)
#pragma warning(disable : 28719 28726 28727)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcstok_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) static __inline wchar_t* __cdecl _wcstok(wchar_t* const _String,
                                                                                                    wchar_t const* const _Delimiter)
    {
        return wcstok(_String, _Delimiter, 0);
    }

    extern "C++" __declspec(deprecated(
    "wcstok has been changed to conform with the ISO C standard, "
    "adding an extra context parameter. To use the legacy Microsoft "
    "wcstok, define _CRT_NON_CONFORMING_WCSTOK.")) inline wchar_t* __cdecl wcstok(wchar_t * _String, wchar_t const* _Delimiter) throw()
    {
        return wcstok(_String, _Delimiter, 0);
    }

#pragma warning(pop)

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcserror_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcserror(int _ErrorNumber);

    __declspec(dllimport) errno_t __cdecl _wcserror_s(wchar_t * _Buffer, size_t _SizeInWords, int _ErrorNumber);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wcserror_s(wchar_t (&_Buffer)[_Size], int _Error) throw()
        {
            return _wcserror_s(_Buffer, _Size, _Error);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "__wcserror_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl __wcserror(wchar_t const* _String);

    __declspec(dllimport) errno_t __cdecl __wcserror_s(wchar_t * _Buffer, size_t _SizeInWords, wchar_t const* _ErrorMessage);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl __wcserror_s(wchar_t (&_Buffer)[_Size], wchar_t const* _ErrorMessage) throw()
        {
            return __wcserror_s(_Buffer, _Size, _ErrorMessage);
        }
    }

    __declspec(dllimport) int __cdecl _wcsicmp(wchar_t const* _String1, wchar_t const* _String2);

    __declspec(dllimport) int __cdecl _wcsicmp_l(wchar_t const* _String1, wchar_t const* _String2, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _wcsnicmp(wchar_t const* _String1, wchar_t const* _String2, size_t _MaxCount);

    __declspec(dllimport) int __cdecl _wcsnicmp_l(wchar_t const* _String1, wchar_t const* _String2, size_t _MaxCount, _locale_t _Locale);

    __declspec(dllimport) errno_t __cdecl _wcsnset_s(wchar_t * _Destination, size_t _SizeInWords, wchar_t _Value, size_t _MaxCount);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _wcsnset_s(wchar_t (&_Destination)[_Size], wchar_t _Value, size_t _MaxCount) throw()
        {
            return _wcsnset_s(_Destination, _Size, _Value, _MaxCount);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcsnset_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _wcsnset(wchar_t * _String, wchar_t _Value, size_t _MaxCount);

    __declspec(dllimport) wchar_t* __cdecl _wcsrev(wchar_t * _String);

    __declspec(dllimport) errno_t __cdecl _wcsset_s(wchar_t * _Destination, size_t _SizeInWords, wchar_t _Value);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wcsset_s(wchar_t (&_String)[_Size], wchar_t _Value) throw()
        {
            return _wcsset_s(_String, _Size, _Value);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcsset_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _wcsset(wchar_t * _String, wchar_t _Value);

    __declspec(dllimport) errno_t __cdecl _wcslwr_s(wchar_t * _String, size_t _SizeInWords);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wcslwr_s(wchar_t (&_String)[_Size]) throw()
        {
            return _wcslwr_s(_String, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcslwr_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcslwr(wchar_t * _String);

    __declspec(dllimport) errno_t __cdecl _wcslwr_s_l(wchar_t * _String, size_t _SizeInWords, _locale_t _Locale);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wcslwr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw()
        {
            return _wcslwr_s_l(_String, _Size, _Locale);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcslwr_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _wcslwr_l(wchar_t * _String, _locale_t _Locale);

    __declspec(dllimport) errno_t __cdecl _wcsupr_s(wchar_t * _String, size_t _Size);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wcsupr_s(wchar_t (&_String)[_Size]) throw()
        {
            return _wcsupr_s(_String, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcsupr_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wcsupr(wchar_t * _String);

    __declspec(dllimport) errno_t __cdecl _wcsupr_s_l(wchar_t * _String, size_t _Size, _locale_t _Locale);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wcsupr_s_l(wchar_t (&_String)[_Size], _locale_t _Locale) throw()
        {
            return _wcsupr_s_l(_String, _Size, _Locale);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wcsupr_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _wcsupr_l(wchar_t * _String, _locale_t _Locale);

    __declspec(dllimport) size_t __cdecl wcsxfrm(wchar_t * _Destination, wchar_t const* _Source, size_t _MaxCount);

    __declspec(dllimport)
    size_t __cdecl _wcsxfrm_l(wchar_t * _Destination, wchar_t const* _Source, size_t _MaxCount, _locale_t _Locale);

    __declspec(dllimport) int __cdecl wcscoll(wchar_t const* _String1, wchar_t const* _String2);

    __declspec(dllimport) int __cdecl _wcscoll_l(wchar_t const* _String1, wchar_t const* _String2, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _wcsicoll(wchar_t const* _String1, wchar_t const* _String2);

    __declspec(dllimport) int __cdecl _wcsicoll_l(wchar_t const* _String1, wchar_t const* _String2, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _wcsncoll(wchar_t const* _String1, wchar_t const* _String2, size_t _MaxCount);

    __declspec(dllimport) int __cdecl _wcsncoll_l(wchar_t const* _String1, wchar_t const* _String2, size_t _MaxCount, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _wcsnicoll(wchar_t const* _String1, wchar_t const* _String2, size_t _MaxCount);

    __declspec(dllimport) int __cdecl _wcsnicoll_l(wchar_t const* _String1, wchar_t const* _String2, size_t _MaxCount,
                                                   _locale_t _Locale);

    extern "C++"
    {
        inline wchar_t* __cdecl wcschr(wchar_t* _String, wchar_t _C)
        {
            return const_cast<wchar_t*>(wcschr(static_cast<wchar_t const*>(_String), _C));
        }

        inline wchar_t* __cdecl wcspbrk(wchar_t* _String, wchar_t const* _Control)
        {
            return const_cast<wchar_t*>(wcspbrk(static_cast<wchar_t const*>(_String), _Control));
        }

        inline wchar_t* __cdecl wcsrchr(wchar_t* _String, wchar_t _C)
        {
            return const_cast<wchar_t*>(wcsrchr(static_cast<wchar_t const*>(_String), _C));
        }

        inline wchar_t* __cdecl wcsstr(wchar_t* _String, wchar_t const* _SubStr)
        {
            return const_cast<wchar_t*>(wcsstr(static_cast<wchar_t const*>(_String), _SubStr));
        }
    }

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsdup"
                          ". See online help for details.")) __declspec(dllimport) wchar_t* __cdecl wcsdup(wchar_t const* _String);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsicmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicmp(wchar_t const* _String1,
                                                                                                       wchar_t const* _String2);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsnicmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl wcsnicmp(wchar_t const* _String1,
                                                                                                        wchar_t const* _String2,
                                                                                                        size_t _MaxCount);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsnset"
                          ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsnset(wchar_t * _String, wchar_t _Value, size_t _MaxCount);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsrev"
                          ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsrev(wchar_t * _String);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsset"
                          ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsset(wchar_t * _String, wchar_t _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcslwr"
                          ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcslwr(wchar_t * _String);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsupr"
                          ". See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl wcsupr(wchar_t * _String);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_wcsicoll"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl wcsicoll(wchar_t const* _String1,
                                                                                                        wchar_t const* _String2);
}
__pragma(pack(pop))

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) errno_t __cdecl strcpy_s(char* _Destination, rsize_t _SizeInBytes, char const* _Source);

    __declspec(dllimport) errno_t __cdecl strcat_s(char* _Destination, rsize_t _SizeInBytes, char const* _Source);

    __declspec(dllimport) errno_t __cdecl strerror_s(char* _Buffer, size_t _SizeInBytes, int _ErrorNumber);

    __declspec(dllimport)
    errno_t __cdecl strncat_s(char* _Destination, rsize_t _SizeInBytes, char const* _Source, rsize_t _MaxCount);

    __declspec(dllimport)
    errno_t __cdecl strncpy_s(char* _Destination, rsize_t _SizeInBytes, char const* _Source, rsize_t _MaxCount);

    __declspec(dllimport) char* __cdecl strtok_s(char* _String, char const* _Delimiter, char** _Context);

    __declspec(dllimport) void* __cdecl _memccpy(void* _Dst, void const* _Src, int _Val, size_t _MaxCount);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl strcat_s(char (&_Destination)[_Size], char const* _Source) throw()
        {
            return strcat_s(_Destination, _Size, _Source);
        }
    }

#pragma warning(push)
#pragma warning(disable : 28719)
#pragma warning(disable : 28726)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strcat_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) char* __cdecl strcat(char* _Destination, char const* _Source);
#pragma warning(pop)

    int __cdecl strcmp(char const* _Str1, char const* _Str2);

    __declspec(dllimport) int __cdecl _strcmpi(char const* _String1, char const* _String2);

    __declspec(dllimport) int __cdecl strcoll(char const* _String1, char const* _String2);

    __declspec(dllimport) int __cdecl _strcoll_l(char const* _String1, char const* _String2, _locale_t _Locale);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl strcpy_s(char (&_Destination)[_Size], char const* _Source) throw()
        {
            return strcpy_s(_Destination, _Size, _Source);
        }
    }

#pragma warning(push)
#pragma warning(disable : 28719)
#pragma warning(disable : 28726)
    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strcpy_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) char* __cdecl strcpy(char* _Destination, char const* _Source);
#pragma warning(pop)

    __declspec(dllimport) size_t __cdecl strcspn(char const* _Str, char const* _Control);

    __declspec(dllimport) __declspec(allocator) char* __cdecl _strdup(char const* _Source);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strerror_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strerror(char const* _ErrorMessage);

    __declspec(dllimport) errno_t __cdecl _strerror_s(char* _Buffer, size_t _SizeInBytes, char const* _ErrorMessage);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _strerror_s(char (&_Buffer)[_Size], char const* _ErrorMessage) throw()
        {
            return _strerror_s(_Buffer, _Size, _ErrorMessage);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strerror_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl strerror(int _ErrorMessage);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl strerror_s(char (&_Buffer)[_Size], int _ErrorMessage) throw()
        {
            return strerror_s(_Buffer, _Size, _ErrorMessage);
        }
    }

    __declspec(dllimport) int __cdecl _stricmp(char const* _String1, char const* _String2);

    __declspec(dllimport) int __cdecl _stricoll(char const* _String1, char const* _String2);

    __declspec(dllimport) int __cdecl _stricoll_l(char const* _String1, char const* _String2, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _stricmp_l(char const* _String1, char const* _String2, _locale_t _Locale);

    size_t __cdecl strlen(char const* _Str);

    __declspec(dllimport) errno_t __cdecl _strlwr_s(char* _String, size_t _Size);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _strlwr_s(char (&_String)[_Size]) throw()
        {
            return _strlwr_s(_String, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strlwr_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr(char* _String);

    __declspec(dllimport) errno_t __cdecl _strlwr_s_l(char* _String, size_t _Size, _locale_t _Locale);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _strlwr_s_l(char (&_String)[_Size], _locale_t _Locale) throw()
        {
            return _strlwr_s_l(_String, _Size, _Locale);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strlwr_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strlwr_l(char* _String, _locale_t _Locale);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl strncat_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw()
        {
            return strncat_s(_Destination, _Size, _Source, _Count);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strncat_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl strncat(char* _Destination,
                                                                                                       char const* _Source,
                                                                                                       size_t _Count);

    __declspec(dllimport) int __cdecl strncmp(char const* _Str1, char const* _Str2, size_t _MaxCount);

    __declspec(dllimport) int __cdecl _strnicmp(char const* _String1, char const* _String2, size_t _MaxCount);

    __declspec(dllimport) int __cdecl _strnicmp_l(char const* _String1, char const* _String2, size_t _MaxCount, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _strnicoll(char const* _String1, char const* _String2, size_t _MaxCount);

    __declspec(dllimport) int __cdecl _strnicoll_l(char const* _String1, char const* _String2, size_t _MaxCount, _locale_t _Locale);

    __declspec(dllimport) int __cdecl _strncoll(char const* _String1, char const* _String2, size_t _MaxCount);

    __declspec(dllimport) int __cdecl _strncoll_l(char const* _String1, char const* _String2, size_t _MaxCount, _locale_t _Locale);

    __declspec(dllimport) size_t __cdecl __strncnt(char const* _String, size_t _Count);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl strncpy_s(char (&_Destination)[_Size], char const* _Source, size_t _Count) throw()
        {
            return strncpy_s(_Destination, _Size, _Source, _Count);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strncpy_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl strncpy(char* _Destination,
                                                                                                       char const* _Source,
                                                                                                       size_t _Count);

    __declspec(dllimport) size_t __cdecl strnlen(char const* _String, size_t _MaxCount);

    static __inline size_t __cdecl strnlen_s(char const* _String, size_t _MaxCount)
    {
        return _String == 0 ? 0 : strnlen(_String, _MaxCount);
    }

    __declspec(dllimport) errno_t __cdecl _strnset_s(char* _String, size_t _SizeInBytes, int _Value, size_t _MaxCount);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _strnset_s(char (&_Destination)[_Size], int _Value, size_t _Count) throw()
        {
            return _strnset_s(_Destination, _Size, _Value, _Count);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strnset_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strnset(char* _Destination,
                                                                                                        int _Value, size_t _Count);

    __declspec(dllimport) char const* __cdecl strpbrk(char const* _Str, char const* _Control);

    __declspec(dllimport) char* __cdecl _strrev(char* _Str);

    __declspec(dllimport) errno_t __cdecl _strset_s(char* _Destination, size_t _DestinationSize, int _Value);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _strset_s(char (&_Destination)[_Size], int _Value) throw()
        {
            return _strset_s(_Destination, _Size, _Value);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strset_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) char* __cdecl _strset(char* _Destination, int _Value);

    __declspec(dllimport) size_t __cdecl strspn(char const* _Str, char const* _Control);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "strtok_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl strtok(char* _String,
                                                                                                      char const* _Delimiter);

    __declspec(dllimport) errno_t __cdecl _strupr_s(char* _String, size_t _Size);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _strupr_s(char (&_String)[_Size]) throw()
        {
            return _strupr_s(_String, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strupr_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr(char* _String);

    __declspec(dllimport) errno_t __cdecl _strupr_s_l(char* _String, size_t _Size, _locale_t _Locale);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _strupr_s_l(char (&_String)[_Size], _locale_t _Locale) throw()
        {
            return _strupr_s_l(_String, _Size, _Locale);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strupr_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strupr_l(char* _String, _locale_t _Locale);

    __declspec(dllimport) size_t __cdecl strxfrm(char* _Destination, char const* _Source, size_t _MaxCount);

    __declspec(dllimport) size_t __cdecl _strxfrm_l(char* _Destination, char const* _Source, size_t _MaxCount, _locale_t _Locale);

    extern "C++"
    {
        inline char* __cdecl strchr(char* const _String, int const _Ch)
        {
            return const_cast<char*>(strchr(static_cast<char const*>(_String), _Ch));
        }

        inline char* __cdecl strpbrk(char* const _String, char const* const _Control)
        {
            return const_cast<char*>(strpbrk(static_cast<char const*>(_String), _Control));
        }

        inline char* __cdecl strrchr(char* const _String, int const _Ch)
        {
            return const_cast<char*>(strrchr(static_cast<char const*>(_String), _Ch));
        }

        inline char* __cdecl strstr(char* const _String, char const* const _SubString)
        {
            return const_cast<char*>(strstr(static_cast<char const*>(_String), _SubString));
        }
    }

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strdup"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strdup(char const* _String);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strcmpi"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl strcmpi(char const* _String1,
                                                                                                       char const* _String2);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_stricmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl stricmp(char const* _String1,
                                                                                                       char const* _String2);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strlwr"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strlwr(char* _String);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strnicmp"
                          ". See online help for details.")) __declspec(dllimport) int __cdecl strnicmp(char const* _String1,
                                                                                                        char const* _String2,
                                                                                                        size_t _MaxCount);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strnset"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strnset(char* _String, int _Value,
                                                                                                         size_t _MaxCount);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strrev"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strrev(char* _String);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strset"
                          ". See online help for details.")) char* __cdecl strset(char* _String, int _Value);

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_strupr"
                          ". See online help for details.")) __declspec(dllimport) char* __cdecl strupr(char* _String);
}
__pragma(pack(pop))

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
#pragma warning(push)
#pragma warning(disable : 4995)

    using ::memchr;
    using ::memcmp;
    using ::memcpy;
    using ::memmove;
    using ::memset;
    using ::size_t;
    using ::strcat;
    using ::strchr;
    using ::strcmp;
    using ::strcoll;
    using ::strcpy;
    using ::strcspn;
    using ::strerror;
    using ::strlen;
    using ::strncat;
    using ::strncmp;
    using ::strncpy;
    using ::strpbrk;
    using ::strrchr;
    using ::strspn;
    using ::strstr;
    using ::strtok;
    using ::strxfrm;

#pragma warning(pop)
}

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) errno_t __cdecl _cgetws_s(wchar_t * _Buffer, size_t _BufferCount, size_t * _SizeRead);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _cgetws_s(wchar_t (&_Buffer)[_Size], size_t* _SizeRead) throw()
        {
            return _cgetws_s(_Buffer, _Size, _SizeRead);
        }
    }

    __declspec(dllimport) int __cdecl _cputws(wchar_t const* _Buffer);

    __declspec(dllimport) wint_t __cdecl _getwch(void);
    __declspec(dllimport) wint_t __cdecl _getwche(void);
    __declspec(dllimport) wint_t __cdecl _putwch(wchar_t _Character);
    __declspec(dllimport) wint_t __cdecl _ungetwch(wint_t _Character);

    __declspec(dllimport) wint_t __cdecl _getwch_nolock(void);
    __declspec(dllimport) wint_t __cdecl _getwche_nolock(void);
    __declspec(dllimport) wint_t __cdecl _putwch_nolock(wchar_t _Character);
    __declspec(dllimport) wint_t __cdecl _ungetwch_nolock(wint_t _Character);

    __declspec(dllimport) int __cdecl __conio_common_vcwprintf(unsigned __int64 _Options, wchar_t const* _Format,
                                                               _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_s(unsigned __int64 _Options, wchar_t const* _Format,
                                                                 _locale_t _Locale, va_list _ArgList);

    __declspec(dllimport) int __cdecl __conio_common_vcwprintf_p(unsigned __int64 _Options, wchar_t const* _Format,
                                                                 _locale_t _Locale, va_list _ArgList);

    __inline int __cdecl _vcwprintf_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __conio_common_vcwprintf((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vcwprintf(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vcwprintf_l(_Format, 0, _ArgList);
    }

    __inline int __cdecl _vcwprintf_s_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __conio_common_vcwprintf_s((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vcwprintf_s(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vcwprintf_s_l(_Format, 0, _ArgList);
    }

    __inline int __cdecl _vcwprintf_p_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __conio_common_vcwprintf_p((*__local_stdio_printf_options()), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vcwprintf_p(const wchar_t* const _Format, va_list _ArgList)

    {
        return _vcwprintf_p_l(_Format, 0, _ArgList);
    }

    __inline int __cdecl _cwprintf_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vcwprintf_l(_Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _cwprintf(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vcwprintf_l(_Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _cwprintf_s_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vcwprintf_s_l(_Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _cwprintf_s(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vcwprintf_s_l(_Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _cwprintf_p_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vcwprintf_p_l(_Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _cwprintf_p(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vcwprintf_p_l(_Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(dllimport) int __cdecl __conio_common_vcwscanf(unsigned __int64 _Options, wchar_t const* _Format,
                                                              _locale_t _Locale, va_list _ArgList);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vcwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vcwscanf_l(wchar_t const* const _Format,
                                                                                            _locale_t const _Locale, va_list _ArgList)

    {
        return __conio_common_vcwscanf((*__local_stdio_scanf_options()), _Format, _Locale, _ArgList);
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_vcwscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _vcwscanf(wchar_t const* const _Format, va_list _ArgList)

    {
#pragma warning(push)
#pragma warning(disable : 4996)
        return _vcwscanf_l(_Format, 0, _ArgList);
#pragma warning(pop)
    }

    __inline int __cdecl _vcwscanf_s_l(wchar_t const* const _Format, _locale_t const _Locale, va_list _ArgList)

    {
        return __conio_common_vcwscanf((*__local_stdio_scanf_options()) | (1ULL << 0), _Format, _Locale, _ArgList);
    }

    __inline int __cdecl _vcwscanf_s(wchar_t const* const _Format, va_list _ArgList)

    {
        return _vcwscanf_s_l(_Format, 0, _ArgList);
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_cwscanf_s_l"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _cwscanf_l(wchar_t const* const _Format,
                                                                                           _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = _vcwscanf_l(_Format, _Locale, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_cwscanf_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __inline int __cdecl _cwscanf(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));

#pragma warning(push)
#pragma warning(disable : 4996)
        _Result = _vcwscanf_l(_Format, 0, _ArgList);
#pragma warning(pop)

        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _cwscanf_s_l(wchar_t const* const _Format, _locale_t const _Locale, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Locale)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))), (sizeof(_Locale)),
                                   __alignof(_Locale), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Locale))))))));
        _Result = _vcwscanf_s_l(_Format, _Locale, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }

    __inline int __cdecl _cwscanf_s(wchar_t const* const _Format, ...)

    {
        int _Result;
        va_list _ArgList;
        ((void)(__vcrt_assert_va_start_is_not_reference<decltype(_Format)>(),
                ((void)(__va_start(&_ArgList, (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))), (sizeof(_Format)),
                                   __alignof(_Format), (&const_cast<char&>(reinterpret_cast<const volatile char&>(_Format))))))));
        _Result = _vcwscanf_s_l(_Format, 0, _ArgList);
        ((void)(__va_end(&_ArgList)));
        return _Result;
    }
}
__pragma(pack(pop))

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) const unsigned short* __cdecl __pctype_func(void);
    __declspec(dllimport) const wctype_t* __cdecl __pwctype_func(void);

    __declspec(dllimport) int __cdecl iswalnum(wint_t _C);
    __declspec(dllimport) int __cdecl iswalpha(wint_t _C);
    __declspec(dllimport) int __cdecl iswascii(wint_t _C);
    __declspec(dllimport) int __cdecl iswblank(wint_t _C);
    __declspec(dllimport) int __cdecl iswcntrl(wint_t _C);

    __declspec(dllimport) int __cdecl iswdigit(wint_t _C);

    __declspec(dllimport) int __cdecl iswgraph(wint_t _C);
    __declspec(dllimport) int __cdecl iswlower(wint_t _C);
    __declspec(dllimport) int __cdecl iswprint(wint_t _C);
    __declspec(dllimport) int __cdecl iswpunct(wint_t _C);
    __declspec(dllimport) int __cdecl iswspace(wint_t _C);
    __declspec(dllimport) int __cdecl iswupper(wint_t _C);
    __declspec(dllimport) int __cdecl iswxdigit(wint_t _C);
    __declspec(dllimport) int __cdecl __iswcsymf(wint_t _C);
    __declspec(dllimport) int __cdecl __iswcsym(wint_t _C);

    __declspec(dllimport) int __cdecl _iswalnum_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswalpha_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswblank_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswcntrl_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswdigit_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswgraph_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswlower_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswprint_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswpunct_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswspace_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswupper_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswxdigit_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswcsymf_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswcsym_l(wint_t _C, _locale_t _Locale);

    __declspec(dllimport) wint_t __cdecl towupper(wint_t _C);
    __declspec(dllimport) wint_t __cdecl towlower(wint_t _C);
    __declspec(dllimport) int __cdecl iswctype(wint_t _C, wctype_t _Type);

    __declspec(dllimport) wint_t __cdecl _towupper_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) wint_t __cdecl _towlower_l(wint_t _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl _iswctype_l(wint_t _C, wctype_t _Type, _locale_t _Locale);

    __declspec(dllimport) int __cdecl isleadbyte(int _C);
    __declspec(dllimport) int __cdecl _isleadbyte_l(int _C, _locale_t _Locale);

    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "iswctype"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) int __cdecl is_wctype(wint_t _C, wctype_t _Type);
}
__pragma(pack(pop))

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetcwd(wchar_t * _DstBuf, int _SizeInWords);

    __declspec(dllimport) __declspec(allocator) wchar_t* __cdecl _wgetdcwd(int _Drive, wchar_t* _DstBuf, int _SizeInWords);

    __declspec(dllimport) int __cdecl _wchdir(wchar_t const* _Path);

    __declspec(dllimport) int __cdecl _wmkdir(wchar_t const* _Path);

    __declspec(dllimport) int __cdecl _wrmdir(wchar_t const* _Path);
}
__pragma(pack(pop))

#pragma once

__pragma(pack(push, 8)) extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

    typedef unsigned long _fsize_t;

    struct _wfinddata32_t
    {
        unsigned attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        _fsize_t size;
        wchar_t name[260];
    };

    struct _wfinddata32i64_t
    {
        unsigned attrib;
        __time32_t time_create;
        __time32_t time_access;
        __time32_t time_write;
        __int64 size;
        wchar_t name[260];
    };

    struct _wfinddata64i32_t
    {
        unsigned attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        _fsize_t size;
        wchar_t name[260];
    };

    struct _wfinddata64_t
    {
        unsigned attrib;
        __time64_t time_create;
        __time64_t time_access;
        __time64_t time_write;
        __int64 size;
        wchar_t name[260];
    };

    __declspec(dllimport) int __cdecl _waccess(wchar_t const* _FileName, int _AccessMode);

    __declspec(dllimport) errno_t __cdecl _waccess_s(wchar_t const* _FileName, int _AccessMode);

    __declspec(dllimport) int __cdecl _wchmod(wchar_t const* _FileName, int _Mode);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wsopen_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int __cdecl _wcreat(wchar_t const* _FileName,
                                                                                                     int _PermissionMode);

    __declspec(dllimport) intptr_t __cdecl _wfindfirst32(wchar_t const* _FileName, struct _wfinddata32_t* _FindData);

    __declspec(dllimport) int __cdecl _wfindnext32(intptr_t _FindHandle, struct _wfinddata32_t * _FindData);

    __declspec(dllimport) int __cdecl _wunlink(wchar_t const* _FileName);

    __declspec(dllimport) int __cdecl _wrename(wchar_t const* _OldFileName, wchar_t const* _NewFileName);

    __declspec(dllimport) errno_t __cdecl _wmktemp_s(wchar_t * _TemplateName, size_t _SizeInWords);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wmktemp_s(wchar_t (&_TemplateName)[_Size]) throw()
        {
            return _wmktemp_s(_TemplateName, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wmktemp_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wmktemp(wchar_t * _TemplateName);

    __declspec(dllimport) intptr_t __cdecl _wfindfirst32i64(wchar_t const* _FileName, struct _wfinddata32i64_t* _FindData);

    __declspec(dllimport) intptr_t __cdecl _wfindfirst64i32(wchar_t const* _FileName, struct _wfinddata64i32_t* _FindData);

    __declspec(dllimport) intptr_t __cdecl _wfindfirst64(wchar_t const* _FileName, struct _wfinddata64_t* _FindData);

    __declspec(dllimport) int __cdecl _wfindnext32i64(intptr_t _FindHandle, struct _wfinddata32i64_t * _FindData);

    __declspec(dllimport) int __cdecl _wfindnext64i32(intptr_t _FindHandle, struct _wfinddata64i32_t * _FindData);

    __declspec(dllimport) int __cdecl _wfindnext64(intptr_t _FindHandle, struct _wfinddata64_t * _FindData);

    __declspec(dllimport)
    errno_t __cdecl _wsopen_s(int* _FileHandle, wchar_t const* _FileName, int _OpenFlag, int _ShareFlag, int _PermissionFlag);

    __declspec(dllimport) errno_t __cdecl _wsopen_dispatch(wchar_t const* _FileName, int _OFlag, int _ShFlag,
                                                           int _PMode, int* _PFileHandle, int _BSecure);

    extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                       "_wsopen_s"
                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                       "See online help for details.")) inline int __cdecl _wopen(wchar_t const* _FileName,
                                                                                                  int _OFlag, int _PMode = 0)
    {
        int _FileHandle;

        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, 0x40, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

    extern "C++" __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                       "_wsopen_s"
                                       " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                       "See online help for details.")) inline int __cdecl _wsopen(wchar_t const* _FileName,
                                                                                                   int _OFlag, int _ShFlag,
                                                                                                   int _PMode = 0)
    {
        int _FileHandle;

        errno_t const _Result = _wsopen_dispatch(_FileName, _OFlag, _ShFlag, _PMode, &_FileHandle, 0);
        return _Result ? -1 : _FileHandle;
    }

#pragma warning(pop)
}
__pragma(pack(pop))

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) intptr_t __cdecl _wexecl(wchar_t const* _FileName, wchar_t const* _ArgList, ...);

    __declspec(dllimport) intptr_t __cdecl _wexecle(wchar_t const* _FileName, wchar_t const* _ArgList, ...);

    __declspec(dllimport) intptr_t __cdecl _wexeclp(wchar_t const* _FileName, wchar_t const* _ArgList, ...);

    __declspec(dllimport) intptr_t __cdecl _wexeclpe(wchar_t const* _FileName, wchar_t const* _ArgList, ...);

    __declspec(dllimport) intptr_t __cdecl _wexecv(wchar_t const* _FileName, wchar_t const* const* _ArgList);

    __declspec(dllimport)
    intptr_t __cdecl _wexecve(wchar_t const* _FileName, wchar_t const* const* _ArgList, wchar_t const* const* _Env);

    __declspec(dllimport) intptr_t __cdecl _wexecvp(wchar_t const* _FileName, wchar_t const* const* _ArgList);

    __declspec(dllimport)
    intptr_t __cdecl _wexecvpe(wchar_t const* _FileName, wchar_t const* const* _ArgList, wchar_t const* const* _Env);

    __declspec(dllimport) intptr_t __cdecl _wspawnl(int _Mode, wchar_t const* _FileName, wchar_t const* _ArgList, ...);

    __declspec(dllimport) intptr_t __cdecl _wspawnle(int _Mode, wchar_t const* _FileName, wchar_t const* _ArgList, ...);

    __declspec(dllimport) intptr_t __cdecl _wspawnlp(int _Mode, wchar_t const* _FileName, wchar_t const* _ArgList, ...);

    __declspec(dllimport) intptr_t __cdecl _wspawnlpe(int _Mode, wchar_t const* _FileName, wchar_t const* _ArgList, ...);

    __declspec(dllimport) intptr_t __cdecl _wspawnv(int _Mode, wchar_t const* _FileName, wchar_t const* const* _ArgList);

    __declspec(dllimport) intptr_t __cdecl _wspawnve(int _Mode, wchar_t const* _FileName,
                                                     wchar_t const* const* _ArgList, wchar_t const* const* _Env);

    __declspec(dllimport) intptr_t __cdecl _wspawnvp(int _Mode, wchar_t const* _FileName, wchar_t const* const* _ArgList);

    __declspec(dllimport) intptr_t __cdecl _wspawnvpe(int _Mode, wchar_t const* _FileName,
                                                      wchar_t const* const* _ArgList, wchar_t const* const* _Env);

    __declspec(dllimport) int __cdecl _wsystem(wchar_t const* _Command);
}
__pragma(pack(pop))

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    struct tm
    {
        int tm_sec;
        int tm_min;
        int tm_hour;
        int tm_mday;
        int tm_mon;
        int tm_year;
        int tm_wday;
        int tm_yday;
        int tm_isdst;
    };

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wasctime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details."))

    __declspec(dllimport) wchar_t* __cdecl _wasctime(struct tm const* _Tm);

    __declspec(dllimport) errno_t __cdecl _wasctime_s(wchar_t * _Buffer, size_t _SizeInWords, struct tm const* _Tm);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _wasctime_s(wchar_t (&_Buffer)[_Size], struct tm const* _Time) throw()
        {
            return _wasctime_s(_Buffer, _Size, _Time);
        }
    }

    __declspec(dllimport)
    size_t __cdecl wcsftime(wchar_t * _Buffer, size_t _SizeInWords, wchar_t const* _Format, struct tm const* _Tm);

    __declspec(dllimport) size_t __cdecl _wcsftime_l(wchar_t * _Buffer, size_t _SizeInWords, wchar_t const* _Format,
                                                     struct tm const* _Tm, _locale_t _Locale);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wctime32_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _wctime32(__time32_t const* _Time);

    __declspec(dllimport) errno_t __cdecl _wctime32_s(wchar_t * _Buffer, size_t _SizeInWords, __time32_t const* _Time);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _wctime32_s(wchar_t (&_Buffer)[_Size], __time32_t const* _Time) throw()
        {
            return _wctime32_s(_Buffer, _Size, _Time);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wctime64_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    wchar_t* __cdecl _wctime64(__time64_t const* _Time);

    __declspec(dllimport) errno_t __cdecl _wctime64_s(wchar_t * _Buffer, size_t _SizeInWords, __time64_t const* _Time);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _wctime64_s(wchar_t (&_Buffer)[_Size], __time64_t const* _Time) throw()
        {
            return _wctime64_s(_Buffer, _Size, _Time);
        }
    }

    __declspec(dllimport) errno_t __cdecl _wstrdate_s(wchar_t * _Buffer, size_t _SizeInWords);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wstrdate_s(wchar_t (&_Buffer)[_Size]) throw()
        {
            return _wstrdate_s(_Buffer, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wstrdate_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrdate(wchar_t * _Buffer);

    __declspec(dllimport) errno_t __cdecl _wstrtime_s(wchar_t * _Buffer, size_t _SizeInWords);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _wstrtime_s(wchar_t (&_Buffer)[_Size]) throw()
        {
            return _wstrtime_s(_Buffer, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_wstrtime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) wchar_t* __cdecl _wstrtime(wchar_t * _Buffer);

#pragma warning(push)
#pragma warning(disable : 4996)

    static __inline wchar_t* __cdecl _wctime(time_t const* const _Time)
    {
        return _wctime64(_Time);
    }

    static __inline errno_t __cdecl _wctime_s(wchar_t* const _Buffer, size_t const _SizeInWords, time_t const* const _Time)
    {
        return _wctime64_s(_Buffer, _SizeInWords, _Time);
    }

#pragma warning(pop)
}
__pragma(pack(pop))

#pragma once

#pragma once

typedef unsigned short _ino_t;

typedef _ino_t ino_t;

typedef unsigned int _dev_t;

typedef _dev_t dev_t;

typedef long _off_t;

typedef _off_t off_t;

__pragma(pack(push, 8)) extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

    struct _stat32
    {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
    };

    struct _stat32i64
    {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time32_t st_atime;
        __time32_t st_mtime;
        __time32_t st_ctime;
    };

    struct _stat64i32
    {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
    };

    struct _stat64
    {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        __int64 st_size;
        __time64_t st_atime;
        __time64_t st_mtime;
        __time64_t st_ctime;
    };

    struct stat
    {
        _dev_t st_dev;
        _ino_t st_ino;
        unsigned short st_mode;
        short st_nlink;
        short st_uid;
        short st_gid;
        _dev_t st_rdev;
        _off_t st_size;
        time_t st_atime;
        time_t st_mtime;
        time_t st_ctime;
    };

    __declspec(dllimport) int __cdecl _fstat32(int _FileHandle, struct _stat32* _Stat);

    __declspec(dllimport) int __cdecl _fstat32i64(int _FileHandle, struct _stat32i64* _Stat);

    __declspec(dllimport) int __cdecl _fstat64i32(int _FileHandle, struct _stat64i32* _Stat);

    __declspec(dllimport) int __cdecl _fstat64(int _FileHandle, struct _stat64* _Stat);

    __declspec(dllimport) int __cdecl _stat32(char const* _FileName, struct _stat32* _Stat);

    __declspec(dllimport) int __cdecl _stat32i64(char const* _FileName, struct _stat32i64* _Stat);

    __declspec(dllimport) int __cdecl _stat64i32(char const* _FileName, struct _stat64i32* _Stat);

    __declspec(dllimport) int __cdecl _stat64(char const* _FileName, struct _stat64* _Stat);

    __declspec(dllimport) int __cdecl _wstat32(wchar_t const* _FileName, struct _stat32* _Stat);

    __declspec(dllimport) int __cdecl _wstat32i64(wchar_t const* _FileName, struct _stat32i64* _Stat);

    __declspec(dllimport) int __cdecl _wstat64i32(wchar_t const* _FileName, struct _stat64i32* _Stat);

    __declspec(dllimport) int __cdecl _wstat64(wchar_t const* _FileName, struct _stat64* _Stat);

    static __inline int __cdecl fstat(int const _FileHandle, struct stat* const _Stat)
    {
        typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
        return _fstat64i32(_FileHandle, (struct _stat64i32*)_Stat);
    }
    static __inline int __cdecl stat(char const* const _FileName, struct stat* const _Stat)
    {
        typedef char __static_assert_t[(sizeof(struct stat) == sizeof(struct _stat64i32)) != 0];
        return _stat64i32(_FileName, (struct _stat64i32*)_Stat);
    }

#pragma warning(pop)
}
__pragma(pack(pop))

__pragma(pack(push, 8)) extern "C"
{
    typedef wchar_t _Wint_t;

    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(int _Category, wchar_t const* _Locale);

    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(int _Category, wchar_t const* _Locale);

    __declspec(dllimport) wint_t __cdecl btowc(int _Ch);

    __declspec(dllimport) size_t __cdecl mbrlen(char const* _Ch, size_t _SizeInBytes, mbstate_t* _State);

    __declspec(dllimport) size_t __cdecl mbrtowc(wchar_t * _DstCh, char const* _SrcCh, size_t _SizeInBytes, mbstate_t* _State);

    __declspec(dllimport) errno_t __cdecl mbsrtowcs_s(size_t * _Retval, wchar_t * _Dst, size_t _Size,
                                                      char const** _PSrc, size_t _N, mbstate_t* _State);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl mbsrtowcs_s(size_t* _Retval, wchar_t (&_Dest)[_Size], char const** _PSource, size_t _Count, mbstate_t* _State) throw()
        {
            return mbsrtowcs_s(_Retval, _Dest, _Size, _PSource, _Count, _State);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "mbsrtowcs_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    size_t __cdecl mbsrtowcs(wchar_t * _Dest, char const** _PSrc, size_t _Count, mbstate_t* _State);

    __declspec(dllimport)
    errno_t __cdecl wcrtomb_s(size_t * _Retval, char* _Dst, size_t _SizeInBytes, wchar_t _Ch, mbstate_t* _State);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl wcrtomb_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t _Source, mbstate_t* _State) throw()
        {
            return wcrtomb_s(_Retval, _Dest, _Size, _Source, _State);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcrtomb_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    size_t __cdecl wcrtomb(char* _Dest, wchar_t _Source, mbstate_t* _State);

    __declspec(dllimport) errno_t __cdecl wcsrtombs_s(size_t * _Retval, char* _Dst, size_t _SizeInBytes,
                                                      wchar_t const** _Src, size_t _Size, mbstate_t* _State);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl wcsrtombs_s(size_t* _Retval, char (&_Dest)[_Size], wchar_t const** _PSrc, size_t _Count, mbstate_t* _State) throw()
        {
            return wcsrtombs_s(_Retval, _Dest, _Size, _PSrc, _Count, _State);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "wcsrtombs_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport)
    size_t __cdecl wcsrtombs(char* _Dest, wchar_t const** _PSource, size_t _Count, mbstate_t* _State);

    __declspec(dllimport) int __cdecl wctob(wint_t _WCh);

    errno_t __cdecl wmemcpy_s(wchar_t * _S1, rsize_t _N1, wchar_t const* _S2, rsize_t _N);

    errno_t __cdecl wmemmove_s(wchar_t * _S1, rsize_t _N1, wchar_t const* _S2, rsize_t _N);

    __inline int __cdecl fwide(FILE * _F, int _M)
    {
        (void)_F;
        return (_M);
    }

    __inline int __cdecl mbsinit(mbstate_t const* _P)
    {
        return _P == 0 || _P->_Wchar == 0;
    }

    __inline wchar_t const* __cdecl wmemchr(wchar_t const* _S, wchar_t _C, size_t _N)
    {
        for(; 0 < _N; ++_S, --_N)
            if(*_S == _C)
                return (wchar_t const*)_S;

        return 0;
    }

    __inline int __cdecl wmemcmp(wchar_t const* _S1, wchar_t const* _S2, size_t _N)
    {
        for(; 0 < _N; ++_S1, ++_S2, --_N)
            if(*_S1 != *_S2)
                return *_S1 < *_S2 ? -1 : 1;

        return 0;
    }

    __inline wchar_t* __cdecl wmemcpy(wchar_t * _S1, wchar_t const* _S2, size_t _N)
    {
#pragma warning(push)
#pragma warning(disable : 4995 4996 6386)
        return (wchar_t*)memcpy(_S1, _S2, _N * sizeof(wchar_t));
#pragma warning(pop)
    }

    __inline wchar_t* __cdecl wmemmove(wchar_t * _S1, wchar_t const* _S2, size_t _N)
    {
#pragma warning(push)
#pragma warning(disable : 4996 6386)
        return (wchar_t*)memmove(_S1, _S2, _N * sizeof(wchar_t));
#pragma warning(pop)
    }

    __inline wchar_t* __cdecl wmemset(wchar_t * _S, wchar_t _C, size_t _N)
    {
        wchar_t* _Su = _S;
        for(; 0 < _N; ++_Su, --_N)
        {
            *_Su = _C;
        }
        return _S;
    }

    extern "C++" inline wchar_t* __cdecl wmemchr(wchar_t * _S, wchar_t _C, size_t _N)
    {
        wchar_t const* const _SC = _S;
        return const_cast<wchar_t*>(wmemchr(_SC, _C, _N));
    }
}
__pragma(pack(pop))

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

using _Mbstatet = mbstate_t;

namespace std
{
#pragma warning(push)
#pragma warning(disable : 4995)

    using ::_Mbstatet;

    using ::mbstate_t;
    using ::size_t;
    using ::tm;
    using ::wint_t;

    using ::btowc;
    using ::fgetwc;
    using ::fgetws;
    using ::fputwc;
    using ::fputws;
    using ::fwide;
    using ::fwprintf;
    using ::fwscanf;
    using ::getwc;
    using ::getwchar;
    using ::mbrlen;
    using ::mbrtowc;
    using ::mbsinit;
    using ::mbsrtowcs;
    using ::putwc;
    using ::putwchar;
    using ::swprintf;
    using ::swscanf;
    using ::ungetwc;
    using ::vfwprintf;
    using ::vswprintf;
    using ::vwprintf;
    using ::wcrtomb;
    using ::wcscat;
    using ::wcschr;
    using ::wcscmp;
    using ::wcscoll;
    using ::wcscpy;
    using ::wcscspn;
    using ::wcsftime;
    using ::wcslen;
    using ::wcsncat;
    using ::wcsncmp;
    using ::wcsncpy;
    using ::wcspbrk;
    using ::wcsrchr;
    using ::wcsrtombs;
    using ::wcsspn;
    using ::wcsstr;
    using ::wcstod;
    using ::wcstok;
    using ::wcstol;
    using ::wcstoul;
    using ::wcsxfrm;
    using ::wctob;
    using ::wmemchr;
    using ::wmemcmp;
    using ::wmemcpy;
    using ::wmemmove;
    using ::wmemset;
    using ::wprintf;
    using ::wscanf;

    using ::vfwscanf;
    using ::vswscanf;
    using ::vwscanf;
    using ::wcstof;
    using ::wcstold;
    using ::wcstoll;
    using ::wcstoull;

#pragma warning(pop)
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    using streamoff = long long;
    using streamsize = long long;

    template <class _Statetype> class fpos
    {
    public:
        fpos(streamoff _Off = 0) : _Myoff(_Off), _Fpos(0), _Mystate()
        {
        }

        fpos(_Statetype _State, fpos_t _Fileposition) : _Myoff(_Fileposition), _Fpos(0), _Mystate(_State)
        {
        }

        [[nodiscard]] _Statetype state() const
        {
            return _Mystate;
        }

        void state(_Statetype _State)
        {
            _Mystate = _State;
        }

        operator streamoff() const
        {
            return _Myoff + _Fpos;
        }

        [[deprecated("warning STL4019: "
                     "The member std::fpos::seekpos() is non-Standard, and is preserved only for compatibility with "
                     "workarounds for old versions of Visual C++. It will be removed in a future release, and in this "
                     "release always returns 0. Please use standards-conforming mechanisms to manipulate fpos, such as "
                     "conversions to and from streamoff, or an integral type, instead. If you are receiving this "
                     "message "
                     "while compiling Boost.IOStreams, a fix has been submitted upstream to make Boost use "
                     "standards-conforming mechanisms, as it does for other compilers. You can define "
                     "_SILENCE_FPOS_SEEKPOS_DEPRECATION_WARNING to acknowledge that you have received this warning, "
                     "or define _REMOVE_FPOS_SEEKPOS to remove std::fpos::seekpos entirely.")]] fpos_t
        seekpos() const noexcept
        {
            return {};
        }

        [[nodiscard]] streamoff operator-(const fpos& _Right) const
        {
            return static_cast<streamoff>(*this) - static_cast<streamoff>(_Right);
        }

        fpos& operator+=(streamoff _Off)
        {
            _Myoff += _Off;
            return *this;
        }

        fpos& operator-=(streamoff _Off)
        {
            _Myoff -= _Off;
            return *this;
        }

        [[nodiscard]] fpos operator+(streamoff _Off) const
        {
            fpos _Tmp = *this;
            _Tmp += _Off;
            return _Tmp;
        }

        [[nodiscard]] fpos operator-(streamoff _Off) const
        {
            fpos _Tmp = *this;
            _Tmp -= _Off;
            return _Tmp;
        }

        [[nodiscard]] bool operator==(const fpos& _Right) const
        {
            return static_cast<streamoff>(*this) == static_cast<streamoff>(_Right);
        }

        template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
        [[nodiscard]] friend bool operator==(const fpos& _Left, const _Int _Right)
        {
            return static_cast<streamoff>(_Left) == _Right;
        }

        template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
        [[nodiscard]] friend bool operator==(const _Int _Left, const fpos& _Right)
        {
            return _Left == static_cast<streamoff>(_Right);
        }

        [[nodiscard]] bool operator!=(const fpos& _Right) const
        {
            return static_cast<streamoff>(*this) != static_cast<streamoff>(_Right);
        }

        template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
        [[nodiscard]] friend bool operator!=(const fpos& _Left, const _Int _Right)
        {
            return static_cast<streamoff>(_Left) != _Right;
        }

        template <class _Int, enable_if_t<is_integral_v<_Int>, int> = 0>
        [[nodiscard]] friend bool operator!=(const _Int _Left, const fpos& _Right)
        {
            return _Left != static_cast<streamoff>(_Right);
        }

    private:
        streamoff _Myoff;
        fpos_t _Fpos;
        _Statetype _Mystate;
    };

    using streampos = fpos<_Mbstatet>;
    using wstreampos = streampos;

    class locale;
    template <class _Facet> const _Facet& __cdecl use_facet(const locale&);

    template <class _Elem> struct char_traits;
    template <> struct char_traits<char>;

    template <> struct char_traits<char16_t>;
    template <> struct char_traits<char32_t>;
    template <> struct char_traits<wchar_t>;

    template <> struct char_traits<unsigned short>;

    template <class _Ty> class allocator;
    class ios_base;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ios;
    template <class _Elem, class _Traits = char_traits<_Elem>> class istreambuf_iterator;
    template <class _Elem, class _Traits = char_traits<_Elem>> class ostreambuf_iterator;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_streambuf;

#pragma vtordisp(push, 2)
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_istream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ostream;
#pragma vtordisp(pop)

    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_iostream;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_stringbuf;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
    class basic_istringstream;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
    class basic_ostringstream;
    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>>
    class basic_stringstream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_filebuf;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ifstream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_ofstream;
    template <class _Elem, class _Traits = char_traits<_Elem>> class basic_fstream;

    template <class _Elem, class _InIt> class num_get;
    template <class _Elem, class _OutIt> class num_put;
    template <class _Elem> class collate;

    using ios = basic_ios<char, char_traits<char>>;
    using streambuf = basic_streambuf<char, char_traits<char>>;
    using istream = basic_istream<char, char_traits<char>>;
    using ostream = basic_ostream<char, char_traits<char>>;
    using iostream = basic_iostream<char, char_traits<char>>;
    using stringbuf = basic_stringbuf<char, char_traits<char>, allocator<char>>;
    using istringstream = basic_istringstream<char, char_traits<char>, allocator<char>>;
    using ostringstream = basic_ostringstream<char, char_traits<char>, allocator<char>>;
    using stringstream = basic_stringstream<char, char_traits<char>, allocator<char>>;
    using filebuf = basic_filebuf<char, char_traits<char>>;
    using ifstream = basic_ifstream<char, char_traits<char>>;
    using ofstream = basic_ofstream<char, char_traits<char>>;
    using fstream = basic_fstream<char, char_traits<char>>;

    using wios = basic_ios<wchar_t, char_traits<wchar_t>>;
    using wstreambuf = basic_streambuf<wchar_t, char_traits<wchar_t>>;
    using wistream = basic_istream<wchar_t, char_traits<wchar_t>>;
    using wostream = basic_ostream<wchar_t, char_traits<wchar_t>>;
    using wiostream = basic_iostream<wchar_t, char_traits<wchar_t>>;
    using wstringbuf = basic_stringbuf<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
    using wistringstream = basic_istringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
    using wostringstream = basic_ostringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
    using wstringstream = basic_stringstream<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;
    using wfilebuf = basic_filebuf<wchar_t, char_traits<wchar_t>>;
    using wifstream = basic_ifstream<wchar_t, char_traits<wchar_t>>;
    using wofstream = basic_ofstream<wchar_t, char_traits<wchar_t>>;
    using wfstream = basic_fstream<wchar_t, char_traits<wchar_t>>;

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

#pragma warning(push)
#pragma warning(disable : 4514 4820)

typedef signed char int8_t;
typedef short int16_t;
typedef int int32_t;
typedef long long int64_t;
typedef unsigned char uint8_t;
typedef unsigned short uint16_t;
typedef unsigned int uint32_t;
typedef unsigned long long uint64_t;

typedef signed char int_least8_t;
typedef short int_least16_t;
typedef int int_least32_t;
typedef long long int_least64_t;
typedef unsigned char uint_least8_t;
typedef unsigned short uint_least16_t;
typedef unsigned int uint_least32_t;
typedef unsigned long long uint_least64_t;

typedef signed char int_fast8_t;
typedef int int_fast16_t;
typedef int int_fast32_t;
typedef long long int_fast64_t;
typedef unsigned char uint_fast8_t;
typedef unsigned int uint_fast16_t;
typedef unsigned int uint_fast32_t;
typedef unsigned long long uint_fast64_t;

typedef long long intmax_t;
typedef unsigned long long uintmax_t;

#pragma warning(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    using ::int16_t;
    using ::int32_t;
    using ::int64_t;
    using ::int8_t;
    using ::uint16_t;
    using ::uint32_t;
    using ::uint64_t;
    using ::uint8_t;

    using ::int_least16_t;
    using ::int_least32_t;
    using ::int_least64_t;
    using ::int_least8_t;
    using ::uint_least16_t;
    using ::uint_least32_t;
    using ::uint_least64_t;
    using ::uint_least8_t;

    using ::int_fast16_t;
    using ::int_fast32_t;
    using ::int_fast64_t;
    using ::int_fast8_t;
    using ::uint_fast16_t;
    using ::uint_fast32_t;
    using ::uint_fast64_t;
    using ::uint_fast8_t;

    using ::intmax_t;
    using ::intptr_t;
    using ::uintmax_t;
    using ::uintptr_t;

    namespace [[deprecated(
    "warning STL4002: "
    "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
    "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1
    {
        using ::int16_t;
        using ::int32_t;
        using ::int64_t;
        using ::int8_t;
        using ::uint16_t;
        using ::uint32_t;
        using ::uint64_t;
        using ::uint8_t;

        using ::int_least16_t;
        using ::int_least32_t;
        using ::int_least64_t;
        using ::int_least8_t;
        using ::uint_least16_t;
        using ::uint_least32_t;
        using ::uint_least64_t;
        using ::uint_least8_t;

        using ::int_fast16_t;
        using ::int_fast32_t;
        using ::int_fast64_t;
        using ::int_fast8_t;
        using ::uint_fast16_t;
        using ::uint_fast32_t;
        using ::uint_fast64_t;
        using ::uint_fast8_t;

        using ::intmax_t;
        using ::intptr_t;
        using ::uintmax_t;
        using ::uintptr_t;
    }// namespace tr1
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(deprecated("Direct floating point control is not supported or reliable from within managed "
                          "code. ")) __declspec(dllimport) unsigned int __cdecl _clearfp(void);

#pragma warning(push)
#pragma warning(disable : 4141)

    __declspec(deprecated(
    "Direct floating point control is not supported or reliable from within managed "
    "code. ")) __declspec(deprecated("This function or variable may be unsafe. Consider using "
                                     "_controlfp_s"
                                     " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                                     "See online help for details.")) __declspec(dllimport) unsigned int __cdecl _controlfp(unsigned int _NewValue,
                                                                                                                            unsigned int _Mask);

#pragma warning(pop)

    __declspec(deprecated("Direct floating point control is not supported or reliable from within managed "
                          "code. ")) __declspec(dllimport) void __cdecl _set_controlfp(unsigned int _NewValue, unsigned int _Mask);

    __declspec(
    deprecated("Direct floating point control is not supported or reliable from within managed code. ")) __declspec(dllimport)
    errno_t __cdecl _controlfp_s(unsigned int* _CurrentState, unsigned int _NewValue, unsigned int _Mask);

    __declspec(deprecated("Direct floating point control is not supported or reliable from within managed "
                          "code. ")) __declspec(dllimport) unsigned int __cdecl _statusfp(void);

    __declspec(deprecated("Direct floating point control is not supported or reliable from within managed "
                          "code. ")) __declspec(dllimport) void __cdecl _fpreset(void);

    __declspec(deprecated("Direct floating point control is not supported or reliable from within managed "
                          "code. ")) __declspec(dllimport) unsigned int __cdecl _control87(unsigned int _NewValue, unsigned int _Mask);

    __declspec(dllimport) int* __cdecl __fpecode(void);

    __declspec(dllimport) int __cdecl __fpe_flt_rounds(void);

    __declspec(dllimport) double __cdecl _copysign(double _Number, double _Sign);
    __declspec(dllimport) double __cdecl _chgsign(double _X);
    __declspec(dllimport) double __cdecl _scalb(double _X, long _Y);
    __declspec(dllimport) double __cdecl _logb(double _X);
    __declspec(dllimport) double __cdecl _nextafter(double _X, double _Y);
    __declspec(dllimport) int __cdecl _finite(double _X);
    __declspec(dllimport) int __cdecl _isnan(double _X);
    __declspec(dllimport) int __cdecl _fpclass(double _X);

    __declspec(dllimport) float __cdecl _scalbf(float _X, long _Y);

    __declspec(deprecated("Direct floating point control is not supported or reliable from within managed "
                          "code. ")) __declspec(dllimport) void __cdecl fpreset(void);
}
__pragma(pack(pop))

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    enum float_denorm_style
    {
        denorm_indeterminate = -1,
        denorm_absent = 0,
        denorm_present = 1
    };

    enum float_round_style
    {
        round_indeterminate = -1,
        round_toward_zero = 0,
        round_to_nearest = 1,
        round_toward_infinity = 2,
        round_toward_neg_infinity = 3
    };

    struct _Num_base
    {
        static constexpr float_denorm_style has_denorm = denorm_absent;
        static constexpr bool has_denorm_loss = false;
        static constexpr bool has_infinity = false;
        static constexpr bool has_quiet_NaN = false;
        static constexpr bool has_signaling_NaN = false;
        static constexpr bool is_bounded = false;
        static constexpr bool is_exact = false;
        static constexpr bool is_iec559 = false;
        static constexpr bool is_integer = false;
        static constexpr bool is_modulo = false;
        static constexpr bool is_signed = false;
        static constexpr bool is_specialized = false;
        static constexpr bool tinyness_before = false;
        static constexpr bool traps = false;
        static constexpr float_round_style round_style = round_toward_zero;
        static constexpr int digits = 0;
        static constexpr int digits10 = 0;
        static constexpr int max_digits10 = 0;
        static constexpr int max_exponent = 0;
        static constexpr int max_exponent10 = 0;
        static constexpr int min_exponent = 0;
        static constexpr int min_exponent10 = 0;
        static constexpr int radix = 0;
    };

    template <class _Ty> class numeric_limits : public _Num_base
    {
    public:
        [[nodiscard]] static constexpr _Ty(min)() noexcept
        {
            return _Ty();
        }

        [[nodiscard]] static constexpr _Ty(max)() noexcept
        {
            return _Ty();
        }

        [[nodiscard]] static constexpr _Ty lowest() noexcept
        {
            return _Ty();
        }

        [[nodiscard]] static constexpr _Ty epsilon() noexcept
        {
            return _Ty();
        }

        [[nodiscard]] static constexpr _Ty round_error() noexcept
        {
            return _Ty();
        }

        [[nodiscard]] static constexpr _Ty denorm_min() noexcept
        {
            return _Ty();
        }

        [[nodiscard]] static constexpr _Ty infinity() noexcept
        {
            return _Ty();
        }

        [[nodiscard]] static constexpr _Ty quiet_NaN() noexcept
        {
            return _Ty();
        }

        [[nodiscard]] static constexpr _Ty signaling_NaN() noexcept
        {
            return _Ty();
        }
    };

    template <class _Ty> class numeric_limits<const _Ty> : public numeric_limits<_Ty>
    {
    };

    template <class _Ty> class numeric_limits<volatile _Ty> : public numeric_limits<_Ty>
    {
    };

    template <class _Ty> class numeric_limits<const volatile _Ty> : public numeric_limits<_Ty>
    {
    };

    struct _Num_int_base : _Num_base
    {
        static constexpr bool is_bounded = true;
        static constexpr bool is_exact = true;
        static constexpr bool is_integer = true;
        static constexpr bool is_specialized = true;
        static constexpr int radix = 2;
    };

    struct _Num_float_base : _Num_base
    {
        static constexpr float_denorm_style has_denorm = denorm_present;
        static constexpr bool has_infinity = true;
        static constexpr bool has_quiet_NaN = true;
        static constexpr bool has_signaling_NaN = true;
        static constexpr bool is_bounded = true;
        static constexpr bool is_iec559 = true;
        static constexpr bool is_signed = true;
        static constexpr bool is_specialized = true;
        static constexpr float_round_style round_style = round_to_nearest;
        static constexpr int radix = 2;
    };

    template <> class numeric_limits<bool> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr bool(min)() noexcept
        {
            return false;
        }

        [[nodiscard]] static constexpr bool(max)() noexcept
        {
            return true;
        }

        [[nodiscard]] static constexpr bool lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr bool epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr bool round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr bool denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr bool infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr bool quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr bool signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr int digits = 1;
    };

    template <> class numeric_limits<char> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr char(min)() noexcept
        {
            return (-128);
        }

        [[nodiscard]] static constexpr char(max)() noexcept
        {
            return 127;
        }

        [[nodiscard]] static constexpr char lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr char epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_signed = (-128) != 0;
        static constexpr bool is_modulo = (-128) == 0;
        static constexpr int digits = 8 - ((-128) != 0);
        static constexpr int digits10 = 2;
    };

    template <> class numeric_limits<signed char> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr signed char(min)() noexcept
        {
            return (-128);
        }

        [[nodiscard]] static constexpr signed char(max)() noexcept
        {
            return 127;
        }

        [[nodiscard]] static constexpr signed char lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr signed char epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr signed char round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr signed char denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr signed char infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr signed char quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr signed char signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_signed = true;
        static constexpr int digits = 7;
        static constexpr int digits10 = 2;
    };

    template <> class numeric_limits<unsigned char> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr unsigned char(min)() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned char(max)() noexcept
        {
            return 0xff;
        }

        [[nodiscard]] static constexpr unsigned char lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr unsigned char epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned char round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned char denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned char infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned char quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned char signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_modulo = true;
        static constexpr int digits = 8;
        static constexpr int digits10 = 2;
    };

    template <> class numeric_limits<char16_t> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr char16_t(min)() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char16_t(max)() noexcept
        {
            return 0xffff;
        }

        [[nodiscard]] static constexpr char16_t lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr char16_t epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char16_t round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char16_t denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char16_t infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char16_t quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char16_t signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_modulo = true;
        static constexpr int digits = 16;
        static constexpr int digits10 = 4;
    };

    template <> class numeric_limits<char32_t> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr char32_t(min)() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char32_t(max)() noexcept
        {
            return 0xffffffff;
        }

        [[nodiscard]] static constexpr char32_t lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr char32_t epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char32_t round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char32_t denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char32_t infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char32_t quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr char32_t signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_modulo = true;
        static constexpr int digits = 32;
        static constexpr int digits10 = 9;
    };

    template <> class numeric_limits<wchar_t> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr wchar_t(min)() noexcept
        {
            return 0x0000;
        }

        [[nodiscard]] static constexpr wchar_t(max)() noexcept
        {
            return 0xffff;
        }

        [[nodiscard]] static constexpr wchar_t lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr wchar_t epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr wchar_t round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr wchar_t denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr wchar_t infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr wchar_t quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr wchar_t signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_modulo = true;
        static constexpr int digits = 16;
        static constexpr int digits10 = 4;
    };

    template <> class numeric_limits<short> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr short(min)() noexcept
        {
            return (-32768);
        }

        [[nodiscard]] static constexpr short(max)() noexcept
        {
            return 32767;
        }

        [[nodiscard]] static constexpr short lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr short epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr short round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr short denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr short infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr short quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr short signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_signed = true;
        static constexpr int digits = 15;
        static constexpr int digits10 = 4;
    };

    template <> class numeric_limits<int> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr int(min)() noexcept
        {
            return (-2147483647 - 1);
        }

        [[nodiscard]] static constexpr int(max)() noexcept
        {
            return 2147483647;
        }

        [[nodiscard]] static constexpr int lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr int epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr int round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr int denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr int infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr int quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr int signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_signed = true;
        static constexpr int digits = 31;
        static constexpr int digits10 = 9;
    };

    template <> class numeric_limits<long> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr long(min)() noexcept
        {
            return (-2147483647L - 1);
        }

        [[nodiscard]] static constexpr long(max)() noexcept
        {
            return 2147483647L;
        }

        [[nodiscard]] static constexpr long lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr long epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long signaling_NaN() noexcept
        {
            return 0;
        }

        static_assert(sizeof(int) == sizeof(long), "LLP64 assumption");
        static constexpr bool is_signed = true;
        static constexpr int digits = 31;
        static constexpr int digits10 = 9;
    };

    template <> class numeric_limits<long long> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr long long(min)() noexcept
        {
            return (-9223372036854775807i64 - 1);
        }

        [[nodiscard]] static constexpr long long(max)() noexcept
        {
            return 9223372036854775807i64;
        }

        [[nodiscard]] static constexpr long long lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr long long epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long long round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long long denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long long infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long long quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr long long signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_signed = true;
        static constexpr int digits = 63;
        static constexpr int digits10 = 18;
    };

    template <> class numeric_limits<unsigned short> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr unsigned short(min)() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned short(max)() noexcept
        {
            return 0xffff;
        }

        [[nodiscard]] static constexpr unsigned short lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr unsigned short epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned short round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned short denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned short infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned short quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned short signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_modulo = true;
        static constexpr int digits = 16;
        static constexpr int digits10 = 4;
    };

    template <> class numeric_limits<unsigned int> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr unsigned int(min)() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned int(max)() noexcept
        {
            return 0xffffffff;
        }

        [[nodiscard]] static constexpr unsigned int lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr unsigned int epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned int round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned int denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned int infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned int quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned int signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_modulo = true;
        static constexpr int digits = 32;
        static constexpr int digits10 = 9;
    };

    template <> class numeric_limits<unsigned long> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr unsigned long(min)() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long(max)() noexcept
        {
            return 0xffffffffUL;
        }

        [[nodiscard]] static constexpr unsigned long lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr unsigned long epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long signaling_NaN() noexcept
        {
            return 0;
        }

        static_assert(sizeof(unsigned int) == sizeof(unsigned long), "LLP64 assumption");
        static constexpr bool is_modulo = true;
        static constexpr int digits = 32;
        static constexpr int digits10 = 9;
    };

    template <> class numeric_limits<unsigned long long> : public _Num_int_base
    {
    public:
        [[nodiscard]] static constexpr unsigned long long(min)() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long long(max)() noexcept
        {
            return 0xffffffffffffffffui64;
        }

        [[nodiscard]] static constexpr unsigned long long lowest() noexcept
        {
            return (min)();
        }

        [[nodiscard]] static constexpr unsigned long long epsilon() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long long round_error() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long long denorm_min() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long long infinity() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long long quiet_NaN() noexcept
        {
            return 0;
        }

        [[nodiscard]] static constexpr unsigned long long signaling_NaN() noexcept
        {
            return 0;
        }

        static constexpr bool is_modulo = true;
        static constexpr int digits = 64;
        static constexpr int digits10 = 19;
    };

    template <> class numeric_limits<float> : public _Num_float_base
    {
    public:
        [[nodiscard]] static constexpr float(min)() noexcept
        {
            return 1.175494351e-38F;
        }

        [[nodiscard]] static constexpr float(max)() noexcept
        {
            return 3.402823466e+38F;
        }

        [[nodiscard]] static constexpr float lowest() noexcept
        {
            return -(max)();
        }

        [[nodiscard]] static constexpr float epsilon() noexcept
        {
            return 1.192092896e-07F;
        }

        [[nodiscard]] static constexpr float round_error() noexcept
        {
            return 0.5F;
        }

        [[nodiscard]] static constexpr float denorm_min() noexcept
        {
            return 1.401298464e-45F;
        }

        [[nodiscard]] static constexpr float infinity() noexcept
        {
            return __builtin_huge_valf();
        }

        [[nodiscard]] static constexpr float quiet_NaN() noexcept
        {
            return __builtin_nanf("0");
        }

        [[nodiscard]] static constexpr float signaling_NaN() noexcept
        {
            return __builtin_nansf("1");
        }

        static constexpr int digits = 24;
        static constexpr int digits10 = 6;
        static constexpr int max_digits10 = 9;
        static constexpr int max_exponent = 128;
        static constexpr int max_exponent10 = 38;
        static constexpr int min_exponent = (-125);
        static constexpr int min_exponent10 = (-37);
    };

    template <> class numeric_limits<double> : public _Num_float_base
    {
    public:
        [[nodiscard]] static constexpr double(min)() noexcept
        {
            return 2.2250738585072014e-308;
        }

        [[nodiscard]] static constexpr double(max)() noexcept
        {
            return 1.7976931348623158e+308;
        }

        [[nodiscard]] static constexpr double lowest() noexcept
        {
            return -(max)();
        }

        [[nodiscard]] static constexpr double epsilon() noexcept
        {
            return 2.2204460492503131e-016;
        }

        [[nodiscard]] static constexpr double round_error() noexcept
        {
            return 0.5;
        }

        [[nodiscard]] static constexpr double denorm_min() noexcept
        {
            return 4.9406564584124654e-324;
        }

        [[nodiscard]] static constexpr double infinity() noexcept
        {
            return __builtin_huge_val();
        }

        [[nodiscard]] static constexpr double quiet_NaN() noexcept
        {
            return __builtin_nan("0");
        }

        [[nodiscard]] static constexpr double signaling_NaN() noexcept
        {
            return __builtin_nans("1");
        }

        static constexpr int digits = 53;
        static constexpr int digits10 = 15;
        static constexpr int max_digits10 = 17;
        static constexpr int max_exponent = 1024;
        static constexpr int max_exponent10 = 308;
        static constexpr int min_exponent = (-1021);
        static constexpr int min_exponent10 = (-307);
    };

    template <> class numeric_limits<long double> : public _Num_float_base
    {
    public:
        [[nodiscard]] static constexpr long double(min)() noexcept
        {
            return 2.2250738585072014e-308;
        }

        [[nodiscard]] static constexpr long double(max)() noexcept
        {
            return 1.7976931348623158e+308;
        }

        [[nodiscard]] static constexpr long double lowest() noexcept
        {
            return -(max)();
        }

        [[nodiscard]] static constexpr long double epsilon() noexcept
        {
            return 2.2204460492503131e-016;
        }

        [[nodiscard]] static constexpr long double round_error() noexcept
        {
            return 0.5L;
        }

        [[nodiscard]] static constexpr long double denorm_min() noexcept
        {
            return 4.9406564584124654e-324;
        }

        [[nodiscard]] static constexpr long double infinity() noexcept
        {
            return __builtin_huge_val();
        }

        [[nodiscard]] static constexpr long double quiet_NaN() noexcept
        {
            return __builtin_nan("0");
        }

        [[nodiscard]] static constexpr long double signaling_NaN() noexcept
        {
            return __builtin_nans("1");
        }

        static constexpr int digits = 53;
        static constexpr int digits10 = 15;
        static constexpr int max_digits10 = 17;
        static constexpr int max_exponent = 1024;
        static constexpr int max_exponent10 = 308;
        static constexpr int min_exponent = (-1021);
        static constexpr int min_exponent10 = (-307);
    };
}

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    using new_handler = void(__cdecl*)();

    new_handler __cdecl set_new_handler(new_handler) noexcept;
    [[nodiscard]] new_handler __cdecl get_new_handler() noexcept;
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma warning(push)
#pragma warning(disable : 4514 4820)

extern "C"
{
    unsigned char _BitScanForward(unsigned long* _Index, unsigned long _Mask);
    unsigned char _BitScanForward64(unsigned long* _Index, unsigned __int64 _Mask);

    unsigned char _BitScanReverse(unsigned long* _Index, unsigned long _Mask);
    unsigned char _BitScanReverse64(unsigned long* _Index, unsigned __int64 _Mask);

    unsigned char _bittest(long const*, long);
    long _InterlockedAnd(long volatile* _Value, long _Mask);
    short _InterlockedAnd16(short volatile* _Value, short _Mask);

    __int64 _InterlockedAnd64(__int64 volatile* _Value, __int64 _Mask);

    char _InterlockedAnd8(char volatile* _Value, char _Mask);

    long _InterlockedCompareExchange(long volatile* _Destination, long _Exchange, long _Comparand);

    short _InterlockedCompareExchange16(short volatile* _Destination, short _Exchange, short _Comparand);

    __int64 _InterlockedCompareExchange64(__int64 volatile* _Destination, __int64 _Exchange, __int64 _Comparand);

    char _InterlockedCompareExchange8(char volatile* _Destination, char _Exchange, char _Comparand);

    long _InterlockedDecrement(long volatile* _Addend);

    short _InterlockedDecrement16(short volatile* _Addend);
    __int64 _InterlockedDecrement64(__int64 volatile* _Addend);
    long _InterlockedExchange(long volatile* _Target, long _Value);

    short _InterlockedExchange16(short volatile* _Target, short _Value);

    __int64 _InterlockedExchange64(__int64 volatile* _Target, __int64 _Value);

    char _InterlockedExchange8(char volatile* _Target, char _Value);

    long _InterlockedExchangeAdd(long volatile* _Addend, long _Value);
    short _InterlockedExchangeAdd16(short volatile* _Addend, short _Value);

    __int64 _InterlockedExchangeAdd64(__int64 volatile* _Addend, __int64 _Value);

    char _InterlockedExchangeAdd8(char volatile* _Addend, char _Value);

    long _InterlockedIncrement(long volatile* _Addend);

    short _InterlockedIncrement16(short volatile* _Addend);
    __int64 _InterlockedIncrement64(__int64 volatile* _Addend);

    long _InterlockedOr(long volatile* _Value, long _Mask);
    short _InterlockedOr16(short volatile* _Value, short _Mask);

    __int64 _InterlockedOr64(__int64 volatile* _Value, __int64 _Mask);

    char _InterlockedOr8(char volatile* _Value, char _Mask);

    long _InterlockedXor(long volatile* _Value, long _Mask);
    short _InterlockedXor16(short volatile* _Value, short _Mask);

    __int64 _InterlockedXor64(__int64 volatile* _Value, __int64 _Mask);

    char _InterlockedXor8(char volatile* _Value, char _Mask);

    void _ReadWriteBarrier(void);
    __int16 __iso_volatile_load16(const volatile __int16*);
    __int32 __iso_volatile_load32(const volatile __int32*);
    __int64 __iso_volatile_load64(const volatile __int64*);
    __int8 __iso_volatile_load8(const volatile __int8*);
    void __iso_volatile_store16(volatile __int16*, __int16);
    void __iso_volatile_store32(volatile __int32*, __int32);
    void __iso_volatile_store64(volatile __int64*, __int64);
    void __iso_volatile_store8(volatile __int8*, __int8);

    unsigned char _interlockedbittestandset(long volatile*, long);

    unsigned __int64 __shiftright128(unsigned __int64 _LowPart, unsigned __int64 _HighPart, unsigned char _Shift);
    unsigned __int64 _umul128(unsigned __int64 _Multiplier, unsigned __int64 _Multiplicand, unsigned __int64* _HighProduct);

    constexpr void* __cdecl __builtin_assume_aligned(const void*, size_t, ...) noexcept;
}
#pragma warning(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    enum memory_order
    {
        memory_order_relaxed,
        memory_order_consume,
        memory_order_acquire,
        memory_order_release,
        memory_order_acq_rel,
        memory_order_seq_cst
    };

    using _Atomic_counter_t = unsigned long;

    template <class _Integral, class _Ty>[[nodiscard]] volatile _Integral* _Atomic_address_as(_Ty& _Source) noexcept
    {
        static_assert(is_integral_v<_Integral>, "Tried to reinterpret memory as non-integral");
        return &reinterpret_cast<volatile _Integral&>(_Source);
    }

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Ty>
    constexpr const _Ty& _Min_value(const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Right < _Left))
    {
        return _Right < _Left ? _Right : _Left;
    }

    template <class _Ty>
    constexpr const _Ty& _Max_value(const _Ty& _Left, const _Ty& _Right) noexcept(noexcept(_Left < _Right))
    {
        return _Left < _Right ? _Right : _Left;
    }

    template <class _FwdIt1, class _FwdIt2> void iter_swap(_FwdIt1 _Left, _FwdIt2 _Right)
    {
        swap(*_Left, *_Right);
    }

    template <class _Ty, size_t _Size, enable_if_t<_Is_swappable<_Ty>::value, int> _Enabled>
    void swap(_Ty (&_Left)[_Size], _Ty (&_Right)[_Size]) noexcept(_Is_nothrow_swappable<_Ty>::value)
    {
        if(&_Left != &_Right)
        {
            _Ty* _First1 = _Left;
            _Ty* _Last1 = _First1 + _Size;
            _Ty* _First2 = _Right;
            for(; _First1 != _Last1; ++_First1, ++_First2)
            {
                ::std::iter_swap(_First1, _First2);
            }
        }
    }

    template <class _Ty, int _Enabled>
    void swap(_Ty& _Left, _Ty& _Right) noexcept(is_nothrow_move_constructible_v<_Ty>&& is_nothrow_move_assignable_v<_Ty>)
    {
        _Ty _Tmp = ::std::move(_Left);
        _Left = ::std::move(_Right);
        _Right = ::std::move(_Tmp);
    }

    template <class _Ty> void _Swap_adl(_Ty& _Left, _Ty& _Right) noexcept(_Is_nothrow_swappable<_Ty>::value)
    {
        swap(_Left, _Right);
    }

    struct piecewise_construct_t
    {
        explicit piecewise_construct_t() = default;
    };

    constexpr piecewise_construct_t piecewise_construct{};

    template <class...> class tuple;

    template <class _Ty1, class _Ty2> struct pair
    {
        using first_type = _Ty1;
        using second_type = _Ty2;

        template <class _Uty1 = _Ty1, class _Uty2 = _Ty2, enable_if_t<conjunction_v<is_default_constructible<_Uty1>, is_default_constructible<_Uty2>>, int> = 0>
        constexpr explicit(!_Is_implicitly_default_constructible<_Uty1>::value || !_Is_implicitly_default_constructible<_Uty2>::value)
        pair() noexcept(is_nothrow_default_constructible_v<_Uty1>&& is_nothrow_default_constructible_v<_Uty2>)
        : first(), second()
        {
        }

        template <class _Uty1 = _Ty1, class _Uty2 = _Ty2, enable_if_t<conjunction_v<is_copy_constructible<_Uty1>, is_copy_constructible<_Uty2>>, int> = 0>
        constexpr explicit(!is_convertible_v<const _Uty1&, _Uty1> || !is_convertible_v<const _Uty2&, _Uty2>)
        pair(const _Ty1& _Val1,
             const _Ty2& _Val2) noexcept(is_nothrow_copy_constructible_v<_Uty1>&& is_nothrow_copy_constructible_v<_Uty2>)
        : first(_Val1), second(_Val2)
        {
        }

        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
        constexpr explicit(!is_convertible_v<_Other1, _Ty1> || !is_convertible_v<_Other2, _Ty2>)
        pair(_Other1&& _Val1,
             _Other2&& _Val2) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>)
        : first(::std::forward<_Other1>(_Val1)), second(::std::forward<_Other2>(_Val2))
        {
        }

        pair(const pair&) = default;
        pair(pair&&) = default;

        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, const _Other1&>, is_constructible<_Ty2, const _Other2&>>, int> = 0>
        constexpr explicit(!is_convertible_v<const _Other1&, _Ty1> || !is_convertible_v<const _Other2&, _Ty2>)
        pair(const pair<_Other1, _Other2>& _Right) noexcept(
        is_nothrow_constructible_v<_Ty1, const _Other1&>&& is_nothrow_constructible_v<_Ty2, const _Other2&>)
        : first(_Right.first), second(_Right.second)
        {
        }

        template <class _Other1, class _Other2, enable_if_t<conjunction_v<is_constructible<_Ty1, _Other1>, is_constructible<_Ty2, _Other2>>, int> = 0>
        constexpr explicit(!is_convertible_v<_Other1, _Ty1> || !is_convertible_v<_Other2, _Ty2>)
        pair(pair<_Other1, _Other2>&& _Right) noexcept(is_nothrow_constructible_v<_Ty1, _Other1>&& is_nothrow_constructible_v<_Ty2, _Other2>)
        : first(::std::forward<_Other1>(_Right.first)), second(::std::forward<_Other2>(_Right.second))
        {
        }

        template <class _Tuple1, class _Tuple2, size_t... _Indexes1, size_t... _Indexes2>
        pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>);

        template <class... _Types1, class... _Types2>
        pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2);

        pair& operator=(const volatile pair&) = delete;

        template <class _Myself = pair,
                  enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<typename _Myself::first_type>, _Is_copy_assignable_no_precondition_check<typename _Myself::second_type>>, int> = 0>
        pair& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_Ty1>, is_nothrow_copy_assignable<_Ty2>>)
        {
            first = _Right.first;
            second = _Right.second;
            return *this;
        }

        template <class _Myself = pair,
                  enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<typename _Myself::first_type>, _Is_move_assignable_no_precondition_check<typename _Myself::second_type>>, int> = 0>
        pair& operator=(_Identity_t<_Myself&&> _Right) noexcept(conjunction_v<is_nothrow_move_assignable<_Ty1>, is_nothrow_move_assignable<_Ty2>>)
        {
            first = ::std::forward<_Ty1>(_Right.first);
            second = ::std::forward<_Ty2>(_Right.second);
            return *this;
        }

        template <class _Other1,
                  class _Other2,
                  enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, const _Other1&>, is_assignable<_Ty2&, const _Other2&>>, int> = 0>
        pair& operator=(const pair<_Other1, _Other2>& _Right) noexcept(
        is_nothrow_assignable_v<_Ty1&, const _Other1&>&& is_nothrow_assignable_v<_Ty2&, const _Other2&>)
        {
            first = _Right.first;
            second = _Right.second;
            return *this;
        }

        template <class _Other1,
                  class _Other2,
                  enable_if_t<conjunction_v<negation<is_same<pair, pair<_Other1, _Other2>>>, is_assignable<_Ty1&, _Other1>, is_assignable<_Ty2&, _Other2>>, int> = 0>
        pair&
        operator=(pair<_Other1, _Other2>&& _Right) noexcept(is_nothrow_assignable_v<_Ty1&, _Other1>&& is_nothrow_assignable_v<_Ty2&, _Other2>)
        {
            first = ::std::forward<_Other1>(_Right.first);
            second = ::std::forward<_Other2>(_Right.second);
            return *this;
        }

        void swap(pair& _Right) noexcept(_Is_nothrow_swappable<_Ty1>::value&& _Is_nothrow_swappable<_Ty2>::value)
        {
            if(this != ::std::addressof(_Right))
            {
                _Swap_adl(first, _Right.first);
                _Swap_adl(second, _Right.second);
            }
        }

        _Ty1 first;
        _Ty2 second;
    };

    template <class _Ty1, class _Ty2, enable_if_t<_Is_swappable<_Ty1>::value && _Is_swappable<_Ty2>::value, int> = 0>
    void swap(pair<_Ty1, _Ty2>& _Left, pair<_Ty1, _Ty2>& _Right) noexcept(noexcept(_Left.swap(_Right)))
    {
        _Left.swap(_Right);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr bool operator==(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
    {
        return _Left.first == _Right.first && _Left.second == _Right.second;
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr bool operator!=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
    {
        return !(_Left == _Right);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr bool operator<(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
    {
        return _Left.first < _Right.first || (!(_Right.first < _Left.first) && _Left.second < _Right.second);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr bool operator>(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
    {
        return _Right < _Left;
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr bool operator<=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
    {
        return !(_Right < _Left);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr bool operator>=(const pair<_Ty1, _Ty2>& _Left, const pair<_Ty1, _Ty2>& _Right)
    {
        return !(_Left < _Right);
    }

    template <class _Ty> struct _Unrefwrap_helper
    {
        using type = _Ty;
    };

    template <class _Ty> struct _Unrefwrap_helper<reference_wrapper<_Ty>>
    {
        using type = _Ty&;
    };

    template <class _Ty> using _Unrefwrap_t = typename _Unrefwrap_helper<decay_t<_Ty>>::type;

    template <class _Ty1, class _Ty2>
    [[nodiscard]] constexpr pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>> make_pair(_Ty1&& _Val1, _Ty2&& _Val2) noexcept(
    is_nothrow_constructible_v<_Unrefwrap_t<_Ty1>, _Ty1>&& is_nothrow_constructible_v<_Unrefwrap_t<_Ty2>, _Ty2>)
    {
        using _Mypair = pair<_Unrefwrap_t<_Ty1>, _Unrefwrap_t<_Ty2>>;
        return _Mypair(::std::forward<_Ty1>(_Val1), ::std::forward<_Ty2>(_Val2));
    }

    namespace rel_ops
    {
        template <class _Ty>[[nodiscard]] bool operator!=(const _Ty& _Left, const _Ty& _Right)
        {
            return !(_Left == _Right);
        }

        template <class _Ty>[[nodiscard]] bool operator>(const _Ty& _Left, const _Ty& _Right)
        {
            return _Right < _Left;
        }

        template <class _Ty>[[nodiscard]] bool operator<=(const _Ty& _Left, const _Ty& _Right)
        {
            return !(_Right < _Left);
        }

        template <class _Ty>[[nodiscard]] bool operator>=(const _Ty& _Left, const _Ty& _Right)
        {
            return !(_Left < _Right);
        }
    }// namespace rel_ops
}// namespace std

namespace std
{
    template <class _Tuple> struct tuple_size;

    template <class _Tuple, class = void> struct _Tuple_size_sfinae
    {
    };

    template <class _Tuple>
    struct _Tuple_size_sfinae<_Tuple, void_t<decltype(tuple_size<_Tuple>::value)>>
    : integral_constant<size_t, tuple_size<_Tuple>::value>
    {
    };

    template <class _Tuple> struct tuple_size<const _Tuple> : _Tuple_size_sfinae<_Tuple>
    {
    };

    template <class _Tuple> struct tuple_size<volatile _Tuple> : _Tuple_size_sfinae<_Tuple>
    {
    };

    template <class _Tuple> struct tuple_size<const volatile _Tuple> : _Tuple_size_sfinae<_Tuple>
    {
    };

    template <class _Ty> constexpr size_t tuple_size_v = tuple_size<_Ty>::value;

    template <size_t _Index, class _Tuple> struct tuple_element;

    template <size_t _Index, class _Tuple> struct tuple_element<_Index, const _Tuple> : tuple_element<_Index, _Tuple>
    {
        using _Mybase = tuple_element<_Index, _Tuple>;
        using type = add_const_t<typename _Mybase::type>;
    };

    template <size_t _Index, class _Tuple> struct tuple_element<_Index, volatile _Tuple> : tuple_element<_Index, _Tuple>
    {
        using _Mybase = tuple_element<_Index, _Tuple>;
        using type = add_volatile_t<typename _Mybase::type>;
    };

    template <size_t _Index, class _Tuple>
    struct tuple_element<_Index, const volatile _Tuple> : tuple_element<_Index, _Tuple>
    {
        using _Mybase = tuple_element<_Index, _Tuple>;
        using type = add_cv_t<typename _Mybase::type>;
    };

    template <size_t _Index, class _Tuple> using tuple_element_t = typename tuple_element<_Index, _Tuple>::type;

    template <class _Ty, size_t _Size> class array;

    template <class _Ty, size_t _Size> struct tuple_size<array<_Ty, _Size>> : integral_constant<size_t, _Size>
    {
    };

    template <size_t _Idx, class _Ty, size_t _Size> struct tuple_element<_Idx, array<_Ty, _Size>>
    {
        static_assert(_Idx < _Size, "array index out of bounds");

        using type = _Ty;
    };

    template <class... _Types> struct tuple_size<tuple<_Types...>> : integral_constant<size_t, sizeof...(_Types)>
    {
    };

    template <size_t _Index> struct tuple_element<_Index, tuple<>>
    {
        static_assert(_Always_false<integral_constant<size_t, _Index>>, "tuple index out of bounds");
    };

    template <class _This, class... _Rest> struct tuple_element<0, tuple<_This, _Rest...>>
    {
        using type = _This;
        using _Ttype = tuple<_This, _Rest...>;
    };

    template <size_t _Index, class _This, class... _Rest>
    struct tuple_element<_Index, tuple<_This, _Rest...>> : tuple_element<_Index - 1, tuple<_Rest...>>
    {
    };

    template <class _Ty1, class _Ty2> struct tuple_size<pair<_Ty1, _Ty2>> : integral_constant<size_t, 2>
    {
    };

    template <size_t _Idx, class _Ty1, class _Ty2> struct tuple_element<_Idx, pair<_Ty1, _Ty2>>
    {
        static_assert(_Idx < 2, "pair index out of bounds");

        using type = conditional_t<_Idx == 0, _Ty1, _Ty2>;
    };

    template <class _Ret, class _Pair> constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 0>) noexcept
    {
        return _Pr.first;
    }

    template <class _Ret, class _Pair> constexpr _Ret _Pair_get(_Pair& _Pr, integral_constant<size_t, 1>) noexcept
    {
        return _Pr.second;
    }

    template <size_t _Idx, class _Ty1, class _Ty2>
    [[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(pair<_Ty1, _Ty2>& _Pr) noexcept
    {
        using _Rtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
        return _Pair_get<_Rtype>(_Pr, integral_constant<size_t, _Idx>());
    }

    template <class _Ty1, class _Ty2>[[nodiscard]] constexpr _Ty1& get(pair<_Ty1, _Ty2>& _Pr) noexcept
    {
        return ::std::get<0>(_Pr);
    }

    template <class _Ty2, class _Ty1>[[nodiscard]] constexpr _Ty2& get(pair<_Ty1, _Ty2>& _Pr) noexcept
    {
        return ::std::get<1>(_Pr);
    }

    template <size_t _Idx, class _Ty1, class _Ty2>
    [[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
    {
        using _Ctype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&;
        return _Pair_get<_Ctype>(_Pr, integral_constant<size_t, _Idx>());
    }

    template <class _Ty1, class _Ty2>[[nodiscard]] constexpr const _Ty1& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
    {
        return ::std::get<0>(_Pr);
    }

    template <class _Ty2, class _Ty1>[[nodiscard]] constexpr const _Ty2& get(const pair<_Ty1, _Ty2>& _Pr) noexcept
    {
        return ::std::get<1>(_Pr);
    }

    template <size_t _Idx, class _Ty1, class _Ty2>
    [[nodiscard]] constexpr tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
    {
        using _RRtype = tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
        return ::std::forward<_RRtype>(::std::get<_Idx>(_Pr));
    }

    template <class _Ty1, class _Ty2>[[nodiscard]] constexpr _Ty1&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
    {
        return ::std::get<0>(::std::move(_Pr));
    }

    template <class _Ty2, class _Ty1>[[nodiscard]] constexpr _Ty2&& get(pair<_Ty1, _Ty2>&& _Pr) noexcept
    {
        return ::std::get<1>(::std::move(_Pr));
    }

    template <size_t _Idx, class _Ty1, class _Ty2>
    [[nodiscard]] constexpr const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
    {
        using _RRtype = const tuple_element_t<_Idx, pair<_Ty1, _Ty2>>&&;
        return ::std::forward<_RRtype>(::std::get<_Idx>(_Pr));
    }

    template <class _Ty1, class _Ty2>[[nodiscard]] constexpr const _Ty1&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
    {
        return ::std::get<0>(::std::move(_Pr));
    }

    template <class _Ty2, class _Ty1>[[nodiscard]] constexpr const _Ty2&& get(const pair<_Ty1, _Ty2>&& _Pr) noexcept
    {
        return ::std::get<1>(::std::move(_Pr));
    }

    template <class _Ty, class _Other = _Ty>
    _Ty exchange(_Ty& _Val,
                 _Other&& _New_val) noexcept(conjunction_v<is_nothrow_move_constructible<_Ty>, is_nothrow_assignable<_Ty&, _Other>>)
    {
        _Ty _Old_val = static_cast<_Ty&&>(_Val);
        _Val = static_cast<_Other&&>(_New_val);
        return _Old_val;
    }

    template <class _Ty>[[nodiscard]] constexpr add_const_t<_Ty>& as_const(_Ty& _Val) noexcept
    {
        return _Val;
    }

    template <class _Ty> void as_const(const _Ty&&) = delete;

    namespace [[deprecated(
    "warning STL4002: "
    "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
    "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1
    {
        using ::std::get;
        using ::std::tuple_element;
        using ::std::tuple_size;
    }// namespace tr1

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

extern "C"
{
    __declspec(noalias) void __cdecl __std_reverse_trivially_swappable_1(void* _First, void* _Last) noexcept;
    __declspec(noalias) void __cdecl __std_reverse_trivially_swappable_2(void* _First, void* _Last) noexcept;
    __declspec(noalias) void __cdecl __std_reverse_trivially_swappable_4(void* _First, void* _Last) noexcept;
    __declspec(noalias) void __cdecl __std_reverse_trivially_swappable_8(void* _First, void* _Last) noexcept;
}

namespace std
{
    template <class _Ty> struct _Get_first_parameter;

    template <template <class, class...> class _Ty, class _First, class... _Rest>
    struct _Get_first_parameter<_Ty<_First, _Rest...>>
    {
        using type = _First;
    };

    template <class _Newfirst, class _Ty> struct _Replace_first_parameter;

    template <class _Newfirst, template <class, class...> class _Ty, class _First, class... _Rest>
    struct _Replace_first_parameter<_Newfirst, _Ty<_First, _Rest...>>
    {
        using type = _Ty<_Newfirst, _Rest...>;
    };

    template <class _Ty, class = void> struct _Get_element_type
    {
        using type = typename _Get_first_parameter<_Ty>::type;
    };

    template <class _Ty> struct _Get_element_type<_Ty, void_t<typename _Ty::element_type>>
    {
        using type = typename _Ty::element_type;
    };

    template <class _Ty, class = void> struct _Get_ptr_difference_type
    {
        using type = ptrdiff_t;
    };

    template <class _Ty> struct _Get_ptr_difference_type<_Ty, void_t<typename _Ty::difference_type>>
    {
        using type = typename _Ty::difference_type;
    };

    template <class _Ty, class _Other, class = void> struct _Get_rebind_alias
    {
        using type = typename _Replace_first_parameter<_Other, _Ty>::type;
    };

    template <class _Ty, class _Other>
    struct _Get_rebind_alias<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>>>
    {
        using type = typename _Ty::template rebind<_Other>;
    };

    template <class _Ty> struct pointer_traits
    {
        using pointer = _Ty;
        using element_type = typename _Get_element_type<_Ty>::type;
        using difference_type = typename _Get_ptr_difference_type<_Ty>::type;

        template <class _Other> using rebind = typename _Get_rebind_alias<_Ty, _Other>::type;

        using _Reftype = conditional_t<is_void_v<element_type>, char, element_type>&;

        [[nodiscard]] static pointer pointer_to(_Reftype _Val) noexcept(noexcept(_Ty::pointer_to(_Val)))
        {
            return _Ty::pointer_to(_Val);
        }
    };

    template <class _Ty> struct pointer_traits<_Ty*>
    {
        using pointer = _Ty*;
        using element_type = _Ty;
        using difference_type = ptrdiff_t;

        template <class _Other> using rebind = _Other*;

        using _Reftype = conditional_t<is_void_v<_Ty>, char, _Ty>&;

        [[nodiscard]] static pointer pointer_to(_Reftype _Val) noexcept
        {
            return ::std::addressof(_Val);
        }
    };

    template <class _Fx> struct _Ref_fn
    {
        template <class... _Args> constexpr decltype(auto) operator()(_Args&&... _Vals)
        {
            return _Fn(::std::forward<_Args>(_Vals)...);
        }

        _Fx& _Fn;
    };

    template <class _Fn>
    constexpr bool _Pass_functor_by_value_v
    = sizeof(_Fn) <= sizeof(void*) && conjunction_v<is_trivially_copy_constructible<_Fn>, is_trivially_destructible<_Fn>>;

    template <class _Fn, enable_if_t<_Pass_functor_by_value_v<_Fn>, int> = 0> constexpr _Fn _Pass_fn(_Fn _Val)
    {
        return _Val;
    }

    template <class _Fn, enable_if_t<!_Pass_functor_by_value_v<_Fn>, int> = 0>
    constexpr _Ref_fn<_Fn> _Pass_fn(_Fn& _Val)
    {
        return { _Val };
    }

    struct _Unused_parameter
    {
        constexpr _Unused_parameter() noexcept = default;
        template <class _Ty> constexpr _Unused_parameter(_Ty&&) noexcept
        {
        }
    };

    using _Any_tag = _Unused_parameter;

    template <class _Ty> using _Algorithm_int_t = conditional_t<is_integral_v<_Ty>, _Ty, ptrdiff_t>;

    struct input_iterator_tag
    {
    };

    struct output_iterator_tag
    {
    };

    struct forward_iterator_tag : input_iterator_tag
    {
    };

    struct bidirectional_iterator_tag : forward_iterator_tag
    {
    };

    struct random_access_iterator_tag : bidirectional_iterator_tag
    {
    };

    template <class, class = void> struct _Iterator_traits_base
    {
    };

    template <class _Iter>
    struct _Iterator_traits_base<_Iter, void_t<typename _Iter::iterator_category, typename _Iter::value_type, typename _Iter::difference_type, typename _Iter::pointer, typename _Iter::reference>>
    {
        using iterator_category = typename _Iter::iterator_category;
        using value_type = typename _Iter::value_type;
        using difference_type = typename _Iter::difference_type;
        using pointer = typename _Iter::pointer;
        using reference = typename _Iter::reference;
    };

    template <class _Ty, bool = is_object_v<_Ty>> struct _Iterator_traits_pointer_base
    {
        using iterator_category = random_access_iterator_tag;
        using value_type = remove_cv_t<_Ty>;
        using difference_type = ptrdiff_t;
        using pointer = _Ty*;
        using reference = _Ty&;
    };

    template <class _Ty> struct _Iterator_traits_pointer_base<_Ty, false>
    {
    };

    template <class _Iter> struct iterator_traits : _Iterator_traits_base<_Iter>
    {
    };

    template <class _Ty> struct iterator_traits<_Ty*> : _Iterator_traits_pointer_base<_Ty>
    {
    };

    template <class _Iter> using _Iter_ref_t = typename iterator_traits<_Iter>::reference;

    template <class _Iter> using _Iter_value_t = typename iterator_traits<_Iter>::value_type;

    template <class _Iter> using _Iter_diff_t = typename iterator_traits<_Iter>::difference_type;

    template <class... _Iters> using _Common_diff_t = common_type_t<_Iter_diff_t<_Iters>...>;

    template <class _Iter> using _Iter_cat_t = typename iterator_traits<_Iter>::iterator_category;

    template <class _Ty, class = void> constexpr bool _Is_iterator_v = false;

    template <class _Ty> constexpr bool _Is_iterator_v<_Ty, void_t<_Iter_cat_t<_Ty>>> = true;

    template <class _Ty> struct _Is_iterator : bool_constant<_Is_iterator_v<_Ty>>
    {
    };

    template <class _Iter> constexpr bool _Is_input_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, input_iterator_tag>;

    template <class _Iter> constexpr bool _Is_fwd_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, forward_iterator_tag>;

    template <class _Iter>
    constexpr bool _Is_bidi_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, bidirectional_iterator_tag>;

    template <class _Iter>
    constexpr bool _Is_random_iter_v = is_convertible_v<_Iter_cat_t<_Iter>, random_access_iterator_tag>;

    template <class, class = void> struct _Is_checked_helper
    {
    };

    template <class _Iter, class = void> constexpr bool _Allow_inheriting_unwrap_v = true;

    template <class _Iter>
    constexpr bool _Allow_inheriting_unwrap_v<_Iter, void_t<typename _Iter::_Prevent_inheriting_unwrap>> = is_same_v<_Iter, typename _Iter::_Prevent_inheriting_unwrap>;

    template <class _Iter, class _Sentinel = _Iter, class = void> constexpr bool _Range_verifiable_v = false;

    template <class _Iter, class _Sentinel>
    constexpr bool
    _Range_verifiable_v<_Iter, _Sentinel, void_t<decltype(_Verify_range(::std::declval<const _Iter&>(), ::std::declval<const _Sentinel&>()))>> = _Allow_inheriting_unwrap_v<_Iter>;

    template <class _Iter, class _Sentinel>
    constexpr void _Adl_verify_range(const _Iter& _First, const _Sentinel& _Last)
    {
        if constexpr(_Range_verifiable_v<_Iter, _Sentinel>)
        {
            _Verify_range(_First, _Last);
        }
        else
        {
            (void)_First;
            (void)_Last;
        }
    }

    template <class _Iter, class = void> constexpr bool _Unwrappable_v = false;

    template <class _Iter>
    constexpr bool
    _Unwrappable_v<_Iter, void_t<decltype(::std::declval<_Remove_cvref_t<_Iter>&>()._Seek_to(::std::declval<_Iter>()._Unwrapped()))>> = _Allow_inheriting_unwrap_v<
    _Remove_cvref_t<_Iter>>;

    template <class _Iter>[[nodiscard]] constexpr decltype(auto) _Get_unwrapped(_Iter&& _It)
    {
        if constexpr(is_pointer_v<decay_t<_Iter>>)
        {
            return _It + 0;
        }
        else if constexpr(_Unwrappable_v<_Iter>)
        {
            return static_cast<_Iter&&>(_It)._Unwrapped();
        }
        else
        {
            return static_cast<_Iter&&>(_It);
        }
    }

    template <class _Iter> using _Unwrapped_t = _Remove_cvref_t<decltype(_Get_unwrapped(::std::declval<_Iter>()))>;

    template <class _Iter, class = bool> constexpr bool _Do_unwrap_when_unverified_v = false;

    template <class _Iter>
    constexpr bool
    _Do_unwrap_when_unverified_v<_Iter, decltype(static_cast<bool>(_Iter::_Unwrap_when_unverified))> = static_cast<bool>(_Iter::_Unwrap_when_unverified);

    template <class _Iter>
    constexpr bool _Unwrappable_for_unverified_v
    = _Unwrappable_v<_Iter>&& _Do_unwrap_when_unverified_v<_Remove_cvref_t<_Iter>>;

    template <class _Iter>[[nodiscard]] constexpr decltype(auto) _Get_unwrapped_unverified(_Iter&& _It)
    {
        if constexpr(is_pointer_v<decay_t<_Iter>>)
        {
            return _It + 0;
        }
        else if constexpr(_Unwrappable_for_unverified_v<_Iter>)
        {
            return static_cast<_Iter&&>(_It)._Unwrapped();
        }
        else
        {
            return static_cast<_Iter&&>(_It);
        }
    }

    template <class _Iter>
    using _Unwrapped_unverified_t = _Remove_cvref_t<decltype(_Get_unwrapped_unverified(::std::declval<_Iter>()))>;

    struct _Distance_unknown
    {
        constexpr _Distance_unknown operator-() const noexcept
        {
            return {};
        }
    };

    template <class _Diff> constexpr auto _Max_possible_v = _Diff{ static_cast<make_unsigned_t<_Diff>>(-1) >> 1 };

    template <class _Diff> constexpr auto _Min_possible_v = _Diff{ -_Max_possible_v<_Diff> - 1 };

    template <class _Iter, class = void> constexpr bool _Offset_verifiable_v = false;

    template <class _Iter>
    constexpr bool _Offset_verifiable_v<_Iter, void_t<decltype(::std::declval<const _Iter&>()._Verify_offset(_Iter_diff_t<_Iter>{}))>> = true;

    template <class _Iter>
    constexpr bool _Unwrappable_for_offset_v = _Unwrappable_v<_Iter>&& _Offset_verifiable_v<_Remove_cvref_t<_Iter>>;

    template <class _Iter, class _Diff>
    [[nodiscard]] constexpr decltype(auto) _Get_unwrapped_n(_Iter&& _It, const _Diff _Off)
    {
        (void)_Off;
        if constexpr(is_pointer_v<decay_t<_Iter>>)
        {
            return _It + 0;
        }
        else if constexpr(_Unwrappable_for_offset_v<_Iter> && is_integral_v<_Diff>)
        {
            using _IDiff = _Iter_diff_t<_Remove_cvref_t<_Iter>>;
            using _CDiff = common_type_t<_Diff, _IDiff>;
            const auto _COff = static_cast<_CDiff>(_Off);

            ;
            (void)_COff;

            _It._Verify_offset(static_cast<_IDiff>(_Off));
            return static_cast<_Iter&&>(_It)._Unwrapped();
        }
        else if constexpr(_Unwrappable_for_unverified_v<_Iter>)
        {
            return static_cast<_Iter&&>(_It)._Unwrapped();
        }
        else
        {
            return static_cast<_Iter&&>(_It);
        }
    }

    template <class _Iter>
    using _Unwrapped_n_t
    = _Remove_cvref_t<decltype(_Get_unwrapped_n(::std::declval<_Iter>(), _Iter_diff_t<_Remove_cvref_t<_Iter>>{}))>;

    template <class _Iter, class _UIter, class = void> constexpr bool _Wrapped_seekable_v = false;

    template <class _Iter, class _UIter>
    constexpr bool _Wrapped_seekable_v<_Iter, _UIter, void_t<decltype(::std::declval<_Iter&>()._Seek_to(::std::declval<_UIter>()))>> = true;

    template <class _Iter, class _UIter> constexpr void _Seek_wrapped(_Iter& _It, _UIter&& _UIt)
    {
        if constexpr(_Wrapped_seekable_v<_Iter, _UIter>)
        {
            _It._Seek_to(static_cast<_UIter&&>(_UIt));
        }
        else
        {
            _It = static_cast<_UIter&&>(_UIt);
        }
    }

    template <class _Checked, class _Iter> auto _Idl_distance(const _Iter& _First, const _Iter& _Last)
    {
        if constexpr(_Is_random_iter_v<_Iter>)
        {
            return static_cast<_Iter_diff_t<_Checked>>(_Last - _First);
        }
        else
        {
            (void)_First;
            (void)_Last;
            return _Distance_unknown{};
        }
    }

    template <class _Elem, bool _Is_enum = is_enum_v<_Elem>> struct _Unwrap_enum
    {
        using type = underlying_type_t<_Elem>;
    };

    template <class _Elem> struct _Unwrap_enum<_Elem, false>
    {
        using type = _Elem;
    };

    template <class _Elem> using _Unwrap_enum_t = typename _Unwrap_enum<_Elem>::type;

    template <class> class move_iterator;

    template <class _Source, class _Dest> struct _Ptr_cat_helper
    {
        using _USource = _Unwrap_enum_t<_Source>;
        using _UDest = _Unwrap_enum_t<_Dest>;
        static constexpr bool _Really_trivial
        = conjunction_v<bool_constant<sizeof(_USource) == sizeof(_UDest) && is_same_v<bool, _USource> == is_same_v<bool, _UDest>>, is_integral<_USource>, is_integral<_UDest>>;
        static constexpr bool _Trivially_copyable = _Really_trivial;
    };

    template <class _Elem> struct _Ptr_cat_helper<_Elem, _Elem>
    {
        static constexpr bool _Really_trivial = is_trivial_v<_Elem>;
        static constexpr bool _Trivially_copyable = is_trivially_copyable_v<_Elem>;
    };

    template <class _Anything> struct _Ptr_cat_helper<_Anything*, const _Anything*>
    {
        static constexpr bool _Really_trivial = true;
        static constexpr bool _Trivially_copyable = true;
    };

    template <class _Anything> struct _Ptr_cat_helper<_Anything*, volatile _Anything*>
    {
        static constexpr bool _Really_trivial = true;
        static constexpr bool _Trivially_copyable = true;
    };

    template <class _Anything> struct _Ptr_cat_helper<_Anything*, const volatile _Anything*>
    {
        static constexpr bool _Really_trivial = true;
        static constexpr bool _Trivially_copyable = true;
    };

    struct _False_copy_cat
    {
        static constexpr bool _Really_trivial = false;
        static constexpr bool _Trivially_copyable = false;
    };

    template <class _Source, class _Dest> struct _Ptr_copy_cat : _False_copy_cat
    {
    };

    template <class _Source, class _Dest>
    struct _Ptr_copy_cat<_Source*, _Dest*>
    : conditional_t<is_trivially_assignable_v<_Dest&, _Source&>, _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>, _False_copy_cat>
    {
    };

    template <class _Source, class _Dest>
    struct _Ptr_copy_cat<move_iterator<_Source*>, _Dest*> : _Ptr_copy_cat<_Source*, _Dest*>
    {
    };

    template <class _Source, class _Dest> struct _Ptr_move_cat : _False_copy_cat
    {
    };

    template <class _Source, class _Dest>
    struct _Ptr_move_cat<_Source*, _Dest*>
    : conditional_t<is_trivially_assignable_v<_Dest&, _Source>, _Ptr_cat_helper<remove_cv_t<_Source>, remove_cv_t<_Dest>>, _False_copy_cat>
    {
    };

    template <class _Source, class _Dest>
    struct _Ptr_move_cat<move_iterator<_Source*>, _Dest*> : _Ptr_move_cat<_Source*, _Dest*>
    {
    };

    template <class _InIt, class _Diff> inline void advance(_InIt& _Where, _Diff _Off)
    {
        if constexpr(_Is_random_iter_v<_InIt>)
        {
            _Where += _Off;
        }
        else
        {
            if constexpr(is_signed_v<_Diff> && !_Is_bidi_iter_v<_InIt>)
            {
                ;
            }

            auto&& _UWhere = _Get_unwrapped_n(::std::move(_Where), _Off);
            constexpr bool _Need_rewrap = !is_reference_v<decltype(_Get_unwrapped_n(::std::move(_Where), _Off))>;

            if constexpr(is_signed_v<_Diff> && _Is_bidi_iter_v<_InIt>)
            {
                for(; _Off < 0; ++_Off)
                {
                    --_UWhere;
                }
            }

            for(; 0 < _Off; --_Off)
            {
                ++_UWhere;
            }

            if constexpr(_Need_rewrap)
            {
                _Seek_wrapped(_Where, ::std::move(_UWhere));
            }
        }
    }

    template <class _InIt>[[nodiscard]] inline _Iter_diff_t<_InIt> distance(_InIt _First, _InIt _Last)
    {
        if constexpr(_Is_random_iter_v<_InIt>)
        {
            return _Last - _First;
        }
        else
        {
            _Adl_verify_range(_First, _Last);
            auto _UFirst = _Get_unwrapped(_First);
            const auto _ULast = _Get_unwrapped(_Last);
            _Iter_diff_t<_InIt> _Off = 0;
            for(; _UFirst != _ULast; ++_UFirst)
            {
                ++_Off;
            }

            return _Off;
        }
    }

    template <class _InIt> constexpr _InIt _Next_iter(_InIt _First)
    {
        return ++_First;
    }

    template <class _InIt>[[nodiscard]] inline _InIt next(_InIt _First, _Iter_diff_t<_InIt> _Off = 1)
    {
        static_assert(_Is_input_iter_v<_InIt>, "next requires input iterator");

        ::std::advance(_First, _Off);
        return _First;
    }

    template <class _BidIt> constexpr _BidIt _Prev_iter(_BidIt _First)
    {
        return --_First;
    }

    template <class _BidIt>[[nodiscard]] inline _BidIt prev(_BidIt _First, _Iter_diff_t<_BidIt> _Off = 1)
    {
        static_assert(_Is_bidi_iter_v<_BidIt>, "prev requires bidirectional iterator");

        ::std::advance(_First, -_Off);
        return _First;
    }

    template <class _Iterator> constexpr _Iterator _Operator_arrow(_Iterator _Target, true_type)
    {
        return _Target;
    }

    template <class _Iterator> constexpr decltype(auto) _Operator_arrow(_Iterator&& _Target, false_type)
    {
        return ::std::forward<_Iterator>(_Target).operator->();
    }

    template <class _BidIt> class reverse_iterator
    {
    public:
        using iterator_type = _BidIt;
        using iterator_category = typename iterator_traits<_BidIt>::iterator_category;
        using value_type = typename iterator_traits<_BidIt>::value_type;
        using difference_type = typename iterator_traits<_BidIt>::difference_type;
        using pointer = typename iterator_traits<_BidIt>::pointer;
        using reference = typename iterator_traits<_BidIt>::reference;

        inline reverse_iterator() = default;

        inline explicit reverse_iterator(_BidIt _Right) noexcept(is_nothrow_move_constructible_v<_BidIt>)
        : current(::std::move(_Right))
        {
        }

        template <class _Other> inline reverse_iterator(const reverse_iterator<_Other>& _Right) : current(_Right.base())
        {
        }

        template <class _Other> inline reverse_iterator& operator=(const reverse_iterator<_Other>& _Right)
        {
            current = _Right.base();
            return *this;
        }

        [[nodiscard]] inline _BidIt base() const
        {
            return current;
        }

        [[nodiscard]] inline reference operator*() const
        {
            _BidIt _Tmp = current;
            return *--_Tmp;
        }

        [[nodiscard]] inline pointer operator->() const
        {
            _BidIt _Tmp = current;
            --_Tmp;
            return _Operator_arrow(_Tmp, is_pointer<_BidIt>());
        }

        inline reverse_iterator& operator++()
        {
            --current;
            return *this;
        }

        inline reverse_iterator operator++(int)
        {
            reverse_iterator _Tmp = *this;
            --current;
            return _Tmp;
        }

        inline reverse_iterator& operator--()
        {
            ++current;
            return *this;
        }

        inline reverse_iterator operator--(int)
        {
            reverse_iterator _Tmp = *this;
            ++current;
            return _Tmp;
        }

        inline reverse_iterator& operator+=(const difference_type _Off)
        {
            current -= _Off;
            return *this;
        }

        [[nodiscard]] inline reverse_iterator operator+(const difference_type _Off) const
        {
            return reverse_iterator(current - _Off);
        }

        inline reverse_iterator& operator-=(const difference_type _Off)
        {
            current += _Off;
            return *this;
        }

        [[nodiscard]] inline reverse_iterator operator-(const difference_type _Off) const
        {
            return reverse_iterator(current + _Off);
        }

        [[nodiscard]] inline reference operator[](const difference_type _Off) const
        {
            return current[static_cast<difference_type>(-_Off - 1)];
        }

        using _Prevent_inheriting_unwrap = reverse_iterator;

        template <class _BidIt2 = _BidIt, enable_if_t<_Offset_verifiable_v<_BidIt2>, int> = 0>
        constexpr void _Verify_offset(const difference_type _Off) const
        {
            do
            {
                if(_Off != _Min_possible_v<difference_type>)
                {
                }
                else
                {
                    do
                    {
                        ;
                        ::_invalid_parameter_noinfo_noreturn();
                    } while(false);
                };
            } while(false);
            current._Verify_offset(-_Off);
        }

        template <class _BidIt2 = _BidIt, enable_if_t<_Unwrappable_v<const _BidIt2&>, int> = 0>
        [[nodiscard]] constexpr reverse_iterator<_Unwrapped_t<const _BidIt2&>> _Unwrapped() const
        {
            return static_cast<reverse_iterator<_Unwrapped_t<const _BidIt2&>>>(current._Unwrapped());
        }

        static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<_BidIt>;

        template <class _Src, enable_if_t<_Wrapped_seekable_v<_BidIt, _Src>, int> = 0>
        constexpr void _Seek_to(const reverse_iterator<_Src>& _It)
        {
            current._Seek_to(_It.base());
        }

    protected:
        _BidIt current{};
    };

    template <class _BidIt, class _BidIt2, enable_if_t<_Range_verifiable_v<_BidIt, _BidIt2>, int> = 0>
    constexpr void _Verify_range(const reverse_iterator<_BidIt>& _First, const reverse_iterator<_BidIt2>& _Last)
    {
        _Verify_range(_Last.base(), _First.base());
    }

    template <class _BidIt>
    [[nodiscard]] inline reverse_iterator<_BidIt>
    operator+(typename reverse_iterator<_BidIt>::difference_type _Off, const reverse_iterator<_BidIt>& _Right)
    {
        return _Right + _Off;
    }

    template <class _BidIt1, class _BidIt2>
    [[nodiscard]] inline auto operator-(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    -> decltype(_Right.base() - _Left.base())
    {
        return _Right.base() - _Left.base();
    }

    template <class _BidIt1, class _BidIt2>
    [[nodiscard]] inline bool operator==(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    {
        return _Left.base() == _Right.base();
    }

    template <class _BidIt1, class _BidIt2>
    [[nodiscard]] inline bool operator!=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    {
        return !(_Left == _Right);
    }

    template <class _BidIt1, class _BidIt2>
    [[nodiscard]] inline bool operator<(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    {
        return _Right.base() < _Left.base();
    }

    template <class _BidIt1, class _BidIt2>
    [[nodiscard]] inline bool operator>(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    {
        return _Right < _Left;
    }

    template <class _BidIt1, class _BidIt2>
    [[nodiscard]] inline bool operator<=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    {
        return !(_Right < _Left);
    }

    template <class _BidIt1, class _BidIt2>
    [[nodiscard]] inline bool operator>=(const reverse_iterator<_BidIt1>& _Left, const reverse_iterator<_BidIt2>& _Right)
    {
        return !(_Left < _Right);
    }

    template <class _BidIt>
    [[nodiscard]] inline reverse_iterator<_BidIt>
    make_reverse_iterator(_BidIt _Iter) noexcept(is_nothrow_move_constructible_v<_BidIt>)
    {
        return reverse_iterator<_BidIt>(::std::move(_Iter));
    }

    template <class _Container>[[nodiscard]] inline auto begin(_Container& _Cont) -> decltype(_Cont.begin())
    {
        return _Cont.begin();
    }

    template <class _Container>[[nodiscard]] inline auto begin(const _Container& _Cont) -> decltype(_Cont.begin())
    {
        return _Cont.begin();
    }

    template <class _Container>[[nodiscard]] inline auto end(_Container& _Cont) -> decltype(_Cont.end())
    {
        return _Cont.end();
    }

    template <class _Container>[[nodiscard]] inline auto end(const _Container& _Cont) -> decltype(_Cont.end())
    {
        return _Cont.end();
    }

    template <class _Ty, size_t _Size>[[nodiscard]] constexpr _Ty* begin(_Ty (&_Array)[_Size]) noexcept
    {
        return _Array;
    }

    template <class _Ty, size_t _Size>[[nodiscard]] constexpr _Ty* end(_Ty (&_Array)[_Size]) noexcept
    {
        return _Array + _Size;
    }

    template <class _Container>
    [[nodiscard]] constexpr auto cbegin(const _Container& _Cont) noexcept(noexcept(::std::begin(_Cont)))
    -> decltype(::std::begin(_Cont))
    {
        return ::std::begin(_Cont);
    }

    template <class _Container>
    [[nodiscard]] constexpr auto cend(const _Container& _Cont) noexcept(noexcept(::std::end(_Cont)))
    -> decltype(::std::end(_Cont))
    {
        return ::std::end(_Cont);
    }

    template <class _Container>[[nodiscard]] inline auto rbegin(_Container& _Cont) -> decltype(_Cont.rbegin())
    {
        return _Cont.rbegin();
    }

    template <class _Container>[[nodiscard]] inline auto rbegin(const _Container& _Cont) -> decltype(_Cont.rbegin())
    {
        return _Cont.rbegin();
    }

    template <class _Container>[[nodiscard]] inline auto rend(_Container& _Cont) -> decltype(_Cont.rend())
    {
        return _Cont.rend();
    }

    template <class _Container>[[nodiscard]] inline auto rend(const _Container& _Cont) -> decltype(_Cont.rend())
    {
        return _Cont.rend();
    }

    template <class _Ty, size_t _Size>[[nodiscard]] inline reverse_iterator<_Ty*> rbegin(_Ty (&_Array)[_Size])
    {
        return reverse_iterator<_Ty*>(_Array + _Size);
    }

    template <class _Ty, size_t _Size>[[nodiscard]] inline reverse_iterator<_Ty*> rend(_Ty (&_Array)[_Size])
    {
        return reverse_iterator<_Ty*>(_Array);
    }

    template <class _Elem>[[nodiscard]] inline reverse_iterator<const _Elem*> rbegin(initializer_list<_Elem> _Ilist)
    {
        return reverse_iterator<const _Elem*>(_Ilist.end());
    }

    template <class _Elem>[[nodiscard]] inline reverse_iterator<const _Elem*> rend(initializer_list<_Elem> _Ilist)
    {
        return reverse_iterator<const _Elem*>(_Ilist.begin());
    }

    template <class _Container>
    [[nodiscard]] inline auto crbegin(const _Container& _Cont) -> decltype(::std::rbegin(_Cont))
    {
        return ::std::rbegin(_Cont);
    }

    template <class _Container>[[nodiscard]] inline auto crend(const _Container& _Cont) -> decltype(::std::rend(_Cont))
    {
        return ::std::rend(_Cont);
    }

    template <class _Container>[[nodiscard]] constexpr auto size(const _Container& _Cont) -> decltype(_Cont.size())
    {
        return _Cont.size();
    }

    template <class _Ty, size_t _Size>[[nodiscard]] constexpr size_t size(const _Ty (&)[_Size]) noexcept
    {
        return _Size;
    }

    template <class _Container>[[nodiscard]] constexpr auto empty(const _Container& _Cont) -> decltype(_Cont.empty())
    {
        return _Cont.empty();
    }

    template <class _Ty, size_t _Size>[[nodiscard]] constexpr bool empty(const _Ty (&)[_Size]) noexcept
    {
        return false;
    }

    template <class _Elem>[[nodiscard]] constexpr bool empty(initializer_list<_Elem> _Ilist) noexcept
    {
        return _Ilist.size() == 0;
    }

    template <class _Container>[[nodiscard]] constexpr auto data(_Container& _Cont) -> decltype(_Cont.data())
    {
        return _Cont.data();
    }

    template <class _Container>[[nodiscard]] constexpr auto data(const _Container& _Cont) -> decltype(_Cont.data())
    {
        return _Cont.data();
    }

    template <class _Ty, size_t _Size>[[nodiscard]] constexpr _Ty* data(_Ty (&_Array)[_Size]) noexcept
    {
        return _Array;
    }

    template <class _Elem>[[nodiscard]] constexpr const _Elem* data(initializer_list<_Elem> _Ilist) noexcept
    {
        return _Ilist.begin();
    }

    struct _Container_proxy;
    struct _Iterator_base12;

    template <class _Ty, size_t _Size> class _Array_const_iterator

    {
    public:
        using iterator_category = random_access_iterator_tag;
        using value_type = _Ty;
        using difference_type = ptrdiff_t;
        using pointer = const _Ty*;
        using reference = const _Ty&;

        enum
        {
            _EEN_SIZE = _Size
        };

        inline _Array_const_iterator() : _Ptr()
        {
        }

        inline explicit _Array_const_iterator(pointer _Parg, size_t _Off = 0) : _Ptr(_Parg + _Off)
        {
        }

        [[nodiscard]] inline reference operator*() const
        {
            return *_Ptr;
        }

        [[nodiscard]] inline pointer operator->() const
        {
            return _Ptr;
        }

        inline _Array_const_iterator& operator++()
        {
            ++_Ptr;
            return *this;
        }

        inline _Array_const_iterator operator++(int)
        {
            _Array_const_iterator _Tmp = *this;
            ++_Ptr;
            return _Tmp;
        }

        inline _Array_const_iterator& operator--()
        {
            --_Ptr;
            return *this;
        }

        inline _Array_const_iterator operator--(int)
        {
            _Array_const_iterator _Tmp = *this;
            --_Ptr;
            return _Tmp;
        }

        inline _Array_const_iterator& operator+=(const ptrdiff_t _Off)
        {
            _Ptr += _Off;
            return *this;
        }

        [[nodiscard]] inline _Array_const_iterator operator+(const ptrdiff_t _Off) const
        {
            _Array_const_iterator _Tmp = *this;
            return _Tmp += _Off;
        }

        inline _Array_const_iterator& operator-=(const ptrdiff_t _Off)
        {
            _Ptr -= _Off;
            return *this;
        }

        [[nodiscard]] inline _Array_const_iterator operator-(const ptrdiff_t _Off) const
        {
            _Array_const_iterator _Tmp = *this;
            return _Tmp -= _Off;
        }

        [[nodiscard]] inline ptrdiff_t operator-(const _Array_const_iterator& _Right) const
        {
            return _Ptr - _Right._Ptr;
        }

        [[nodiscard]] inline reference operator[](const ptrdiff_t _Off) const
        {
            return _Ptr[_Off];
        }

        [[nodiscard]] inline bool operator==(const _Array_const_iterator& _Right) const
        {
            return _Ptr == _Right._Ptr;
        }

        [[nodiscard]] inline bool operator!=(const _Array_const_iterator& _Right) const
        {
            return !(*this == _Right);
        }

        [[nodiscard]] inline bool operator<(const _Array_const_iterator& _Right) const
        {
            return _Ptr < _Right._Ptr;
        }

        [[nodiscard]] inline bool operator>(const _Array_const_iterator& _Right) const
        {
            return _Right < *this;
        }

        [[nodiscard]] inline bool operator<=(const _Array_const_iterator& _Right) const
        {
            return !(_Right < *this);
        }

        [[nodiscard]] inline bool operator>=(const _Array_const_iterator& _Right) const
        {
            return !(*this < _Right);
        }

        using _Prevent_inheriting_unwrap = _Array_const_iterator;

        [[nodiscard]] constexpr pointer _Unwrapped() const
        {
            return _Ptr;
        }

        static constexpr bool _Unwrap_when_unverified = true;

        constexpr void _Seek_to(pointer _It)
        {
            _Ptr = _It;
        }

    private:
        pointer _Ptr;
    };

    template <class _Ty, size_t _Size>
    [[nodiscard]] inline _Array_const_iterator<_Ty, _Size> operator+(ptrdiff_t _Off, _Array_const_iterator<_Ty, _Size> _Next)
    {
        return _Next += _Off;
    }

    template <class _Ty, size_t _Size> class _Array_iterator : public _Array_const_iterator<_Ty, _Size>
    {
    public:
        using _Mybase = _Array_const_iterator<_Ty, _Size>;

        using iterator_category = random_access_iterator_tag;
        using value_type = _Ty;
        using difference_type = ptrdiff_t;
        using pointer = _Ty*;
        using reference = _Ty&;

        enum
        {
            _EEN_SIZE = _Size
        };

        inline _Array_iterator() noexcept
        {
        }

        inline explicit _Array_iterator(pointer _Parg, size_t _Off = 0) : _Mybase(_Parg, _Off)
        {
        }

        [[nodiscard]] inline reference operator*() const
        {
            return const_cast<reference>(_Mybase::operator*());
        }

        [[nodiscard]] inline pointer operator->() const
        {
            return const_cast<pointer>(_Mybase::operator->());
        }

        inline _Array_iterator& operator++()
        {
            _Mybase::operator++();
            return *this;
        }

        inline _Array_iterator operator++(int)
        {
            _Array_iterator _Tmp = *this;
            _Mybase::operator++();
            return _Tmp;
        }

        inline _Array_iterator& operator--()
        {
            _Mybase::operator--();
            return *this;
        }

        inline _Array_iterator operator--(int)
        {
            _Array_iterator _Tmp = *this;
            _Mybase::operator--();
            return _Tmp;
        }

        inline _Array_iterator& operator+=(const ptrdiff_t _Off)
        {
            _Mybase::operator+=(_Off);
            return *this;
        }

        [[nodiscard]] inline _Array_iterator operator+(const ptrdiff_t _Off) const
        {
            _Array_iterator _Tmp = *this;
            return _Tmp += _Off;
        }

        inline _Array_iterator& operator-=(const ptrdiff_t _Off)
        {
            _Mybase::operator-=(_Off);
            return *this;
        }

        using _Mybase::operator-;

        [[nodiscard]] inline _Array_iterator operator-(const ptrdiff_t _Off) const
        {
            _Array_iterator _Tmp = *this;
            return _Tmp -= _Off;
        }

        [[nodiscard]] inline reference operator[](const ptrdiff_t _Off) const
        {
            return const_cast<reference>(_Mybase::operator[](_Off));
        }

        using _Prevent_inheriting_unwrap = _Array_iterator;

        [[nodiscard]] constexpr pointer _Unwrapped() const
        {
            return const_cast<pointer>(_Mybase::_Unwrapped());
        }
    };

    template <class _Ty, size_t _Size>
    [[nodiscard]] inline _Array_iterator<_Ty, _Size> operator+(ptrdiff_t _Off, _Array_iterator<_Ty, _Size> _Next)
    {
        return _Next += _Off;
    }

    struct _Default_sentinel
    {
    };

    template <class _Iter> class move_iterator
    {
    public:
        using iterator_category = typename iterator_traits<_Iter>::iterator_category;
        using value_type = typename iterator_traits<_Iter>::value_type;
        using difference_type = typename iterator_traits<_Iter>::difference_type;
        using pointer = _Iter;
        using _Ref0 = typename iterator_traits<_Iter>::reference;
        using reference = conditional_t<is_reference_v<_Ref0>, remove_reference_t<_Ref0>&&, _Ref0>;
        using iterator_type = _Iter;

        inline move_iterator() : current()
        {
        }

        inline explicit move_iterator(iterator_type _Right) : current(_Right)
        {
        }

        template <class _Iter2> inline move_iterator(const move_iterator<_Iter2>& _Right) : current(_Right.base())
        {
        }

        template <class _Iter2> inline move_iterator& operator=(const move_iterator<_Iter2>& _Right)
        {
            current = _Right.base();
            return *this;
        }

        [[nodiscard]] inline _Iter base() const
        {
            return current;
        }

        [[nodiscard]] inline reference operator*() const
        {
            return static_cast<reference>(*current);
        }

        [[nodiscard]] inline pointer operator->() const
        {
            return current;
        }

        inline move_iterator& operator++()
        {
            ++current;
            return *this;
        }

        inline move_iterator operator++(int)
        {
            move_iterator _Tmp = *this;
            ++current;
            return _Tmp;
        }

        inline move_iterator& operator--()
        {
            --current;
            return *this;
        }

        inline move_iterator operator--(int)
        {
            move_iterator _Tmp = *this;
            --current;
            return _Tmp;
        }

        template <class _Iter2 = _Iter>
        [[nodiscard]] auto operator==(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std::declval<const _Iter2&>() == _Sentinel)
        {
            return current == _Sentinel;
        }

        template <class _Iter2 = _Iter>
        [[nodiscard]] auto operator!=(_Default_sentinel _Sentinel) const noexcept
        -> decltype(::std::declval<const _Iter2&>() != _Sentinel)
        {
            return current != _Sentinel;
        }

        inline move_iterator& operator+=(const difference_type _Off)
        {
            current += _Off;
            return *this;
        }

        [[nodiscard]] inline move_iterator operator+(const difference_type _Off) const
        {
            return move_iterator(current + _Off);
        }

        inline move_iterator& operator-=(const difference_type _Off)
        {
            current -= _Off;
            return *this;
        }

        [[nodiscard]] inline move_iterator operator-(const difference_type _Off) const
        {
            return move_iterator(current - _Off);
        }

        [[nodiscard]] inline reference operator[](const difference_type _Off) const
        {
            return ::std::move(current[_Off]);
        }

        template <class _Iter2, enable_if_t<_Range_verifiable_v<_Iter, _Iter2>, int> = 0>
        friend constexpr void _Verify_range(const move_iterator& _First, const move_iterator<_Iter2>& _Last)
        {
            _Verify_range(_First.base(), _Last.base());
        }

        using _Prevent_inheriting_unwrap = move_iterator;

        template <class _Iter2 = iterator_type, enable_if_t<_Offset_verifiable_v<_Iter2>, int> = 0>
        constexpr void _Verify_offset(const difference_type _Off) const
        {
            current._Verify_offset(_Off);
        }

        template <class _Iter2 = iterator_type, enable_if_t<_Unwrappable_v<const _Iter2&>, int> = 0>
        [[nodiscard]] constexpr move_iterator<_Unwrapped_t<const _Iter2&>> _Unwrapped() const
        {
            return static_cast<move_iterator<_Unwrapped_t<const _Iter2&>>>(current._Unwrapped());
        }

        static constexpr bool _Unwrap_when_unverified = _Do_unwrap_when_unverified_v<iterator_type>;

        template <class _Src, enable_if_t<_Wrapped_seekable_v<iterator_type, _Src>, int> = 0>
        constexpr void _Seek_to(const move_iterator<_Src>& _It)
        {
            current._Seek_to(_It.base());
        }

    protected:
        iterator_type current;
    };

    template <class _Iter>
    [[nodiscard]] inline move_iterator<_Iter>
    operator+(typename move_iterator<_Iter>::difference_type _Off, const move_iterator<_Iter>& _Right)
    {
        return _Right + _Off;
    }

    template <class _Iter1, class _Iter2>
    [[nodiscard]] inline auto operator-(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    -> decltype(_Left.base() - _Right.base())
    {
        return _Left.base() - _Right.base();
    }

    template <class _Iter1, class _Iter2>
    [[nodiscard]] inline bool operator==(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    {
        return _Left.base() == _Right.base();
    }

    template <class _Iter1, class _Iter2>
    [[nodiscard]] inline bool operator!=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    {
        return !(_Left == _Right);
    }

    template <class _Iter1, class _Iter2>
    [[nodiscard]] inline bool operator<(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    {
        return _Left.base() < _Right.base();
    }

    template <class _Iter1, class _Iter2>
    [[nodiscard]] inline bool operator>(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    {
        return _Right < _Left;
    }

    template <class _Iter1, class _Iter2>
    [[nodiscard]] inline bool operator<=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    {
        return !(_Right < _Left);
    }

    template <class _Iter1, class _Iter2>
    [[nodiscard]] inline bool operator>=(const move_iterator<_Iter1>& _Left, const move_iterator<_Iter2>& _Right)
    {
        return !(_Left < _Right);
    }

    template <class _Iter>[[nodiscard]] inline move_iterator<_Iter> make_move_iterator(_Iter _It)
    {
        return move_iterator<_Iter>(_It);
    }

    template <class _InIt, class _OutIt> _OutIt _Copy_memmove(_InIt _First, _InIt _Last, _OutIt _Dest)
    {
        const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
        const char* const _Last_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
        char* const _Dest_ch = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
        const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
        ::memmove(_Dest_ch, _First_ch, _Count);
        return reinterpret_cast<_OutIt>(_Dest_ch + _Count);
    }

    template <class _InIt, class _OutIt>
    _OutIt _Copy_memmove(move_iterator<_InIt> _First, move_iterator<_InIt> _Last, _OutIt _Dest)
    {
        return _Copy_memmove(_First.base(), _Last.base(), _Dest);
    }

    template <class _InIt, class _OutIt> _OutIt _Copy_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest)
    {
        if constexpr(_Ptr_copy_cat<_InIt, _OutIt>::_Trivially_copyable)
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
        else
        {
            for(; _First != _Last; ++_Dest, (void)++_First)
            {
                *_Dest = *_First;
            }

            return _Dest;
        }
    }

    template <class _InIt, class _OutIt> _OutIt copy(_InIt _First, _InIt _Last, _OutIt _Dest)
    {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Copy_unchecked(_UFirst, _ULast, _UDest));
        return _Dest;
    }

    template <class _InIt, class _Diff, class _OutIt> _OutIt copy_n(_InIt _First, _Diff _Count_raw, _OutIt _Dest)
    {
        _Algorithm_int_t<_Diff> _Count = _Count_raw;
        if(0 < _Count)
        {
            auto _UFirst = _Get_unwrapped_n(_First, _Count);
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);
            if constexpr(_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Trivially_copyable)
            {
                _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
            }
            else
            {
                for(;;)
                {
                    *_UDest = *_UFirst;
                    ++_UDest;
                    --_Count;
                    if(_Count == 0)
                    {
                        break;
                    }

                    ++_UFirst;
                }
            }

            _Seek_wrapped(_Dest, _UDest);
        }

        return _Dest;
    }

    template <class _BidIt1, class _BidIt2> _BidIt2 _Copy_backward_memmove(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
    {
        const char* const _First_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_First));
        const char* const _Last_ch = const_cast<const char*>(reinterpret_cast<const volatile char*>(_Last));
        char* const _Dest_ch = const_cast<char*>(reinterpret_cast<volatile char*>(_Dest));
        const auto _Count = static_cast<size_t>(_Last_ch - _First_ch);
        return static_cast<_BidIt2>(::memmove(_Dest_ch - _Count, _First_ch, _Count));
    }

    template <class _BidIt1, class _BidIt2>
    _BidIt2 _Copy_backward_memmove(move_iterator<_BidIt1> _First, move_iterator<_BidIt1> _Last, _BidIt2 _Dest)
    {
        return _Copy_backward_memmove(_First.base(), _Last.base(), _Dest);
    }

    template <class _BidIt1, class _BidIt2> _BidIt2 copy_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
    {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        auto _ULast = _Get_unwrapped(_Last);
        auto _UDest = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
        if constexpr(_Ptr_copy_cat<decltype(_ULast), decltype(_UDest)>::_Trivially_copyable)
        {
            _UDest = _Copy_backward_memmove(_UFirst, _ULast, _UDest);
        }
        else
        {
            while(_UFirst != _ULast)
            {
                *--_UDest = *--_ULast;
            }
        }

        _Seek_wrapped(_Dest, _UDest);
        return _Dest;
    }

    template <class _InIt, class _OutIt> _OutIt _Move_unchecked(_InIt _First, _InIt _Last, _OutIt _Dest)
    {
        if constexpr(_Ptr_move_cat<_InIt, _OutIt>::_Trivially_copyable)
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
        else
        {
            for(; _First != _Last; ++_Dest, (void)++_First)
            {
                *_Dest = ::std::move(*_First);
            }

            return _Dest;
        }
    }

    template <class _InIt, class _OutIt> _OutIt move(_InIt _First, _InIt _Last, _OutIt _Dest)
    {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Move_unchecked(_UFirst, _ULast, _UDest));
        return _Dest;
    }

    template <class _BidIt1, class _BidIt2>
    _BidIt2 _Move_backward_unchecked(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
    {
        if constexpr(_Ptr_move_cat<_BidIt1, _BidIt2>::_Trivially_copyable)
        {
            return _Copy_backward_memmove(_First, _Last, _Dest);
        }
        else
        {
            while(_First != _Last)
            {
                *--_Dest = ::std::move(*--_Last);
            }

            return _Dest;
        }
    }

    template <class _BidIt1, class _BidIt2> _BidIt2 move_backward(_BidIt1 _First, _BidIt1 _Last, _BidIt2 _Dest)
    {
        _Adl_verify_range(_First, _Last);
        const auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        const auto _UDest = _Get_unwrapped_n(_Dest, -_Idl_distance<_BidIt1>(_UFirst, _ULast));
        _Seek_wrapped(_Dest, _Move_backward_unchecked(_UFirst, _ULast, _UDest));
        return _Dest;
    }

    template <class _Ty> struct _Is_character : false_type
    {
    };

    template <> struct _Is_character<char> : true_type
    {
    };

    template <> struct _Is_character<signed char> : true_type
    {
    };

    template <> struct _Is_character<unsigned char> : true_type
    {
    };

    template <class _Ty> struct _Is_character_or_byte : _Is_character<_Ty>::type
    {
    };

    template <class _FwdIt, class _Ty, bool = is_pointer_v<_FwdIt>>
    constexpr bool _Fill_memset_is_safe
    = conjunction_v<disjunction<conjunction<_Is_character_or_byte<_Unwrap_enum_t<_Ty>>, _Is_character_or_byte<_Unwrap_enum_t<_Iter_value_t<_FwdIt>>>>,
                                conjunction<is_same<bool, _Unwrap_enum_t<_Ty>>, is_same<bool, _Unwrap_enum_t<_Iter_value_t<_FwdIt>>>>>,
                    is_assignable<_Iter_ref_t<_FwdIt>, const _Ty&>>;

    template <class _FwdIt, class _Ty> constexpr bool _Fill_memset_is_safe<_FwdIt, _Ty, false> = false;

    template <class _FwdIt, class _Ty> void fill(const _FwdIt _First, const _FwdIt _Last, const _Ty& _Val)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        if constexpr(_Fill_memset_is_safe<decltype(_UFirst), _Ty>)
        {
            ::memset(_UFirst, static_cast<unsigned char>(_Val), static_cast<size_t>(_ULast - _UFirst));
        }
        else
        {
            for(; _UFirst != _ULast; ++_UFirst)
            {
                *_UFirst = _Val;
            }
        }
    }

    template <class _OutIt, class _Diff, class _Ty> _OutIt fill_n(_OutIt _Dest, const _Diff _Count_raw, const _Ty& _Val)
    {
        _Algorithm_int_t<_Diff> _Count = _Count_raw;
        if(0 < _Count)
        {
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);
            if constexpr(_Fill_memset_is_safe<decltype(_UDest), _Ty>)
            {
                ::memset(_UDest, static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
                _UDest += _Count;
            }
            else
            {
                for(; 0 < _Count; --_Count, (void)++_UDest)
                {
                    *_UDest = _Val;
                }
            }

            _Seek_wrapped(_Dest, _UDest);
        }

        return _Dest;
    }

    template <class _Elem1, class _Elem2>
    struct _Value_equality_is_bitwise_equality : bool_constant<static_cast<_Elem1>(-1) == static_cast<_Elem2>(-1)>
    {
    };

    template <class _Elem1, class _Elem2, class _Pr> struct _Equal_memcmp_is_safe_helper : false_type
    {
    };

    template <class _Elem1, class _Elem2>
    struct _Equal_memcmp_is_safe_helper<_Elem1, _Elem2, equal_to<>>
    : bool_constant<conjunction_v<bool_constant<sizeof(_Elem1) == sizeof(_Elem2) && _Is_nonbool_integral<_Elem1> && _Is_nonbool_integral<_Elem2>>,
                                  negation<is_volatile<_Elem1>>,
                                  negation<is_volatile<_Elem2>>,

                                  _Value_equality_is_bitwise_equality<_Elem1, _Elem2>>>
    {
    };

    template <class _Elem1, class _Elem2>
    struct _Equal_memcmp_is_safe_helper<_Elem1*, _Elem2*, equal_to<>> : is_same<remove_cv_t<_Elem1>, remove_cv_t<_Elem2>>::type
    {
    };

    template <class _Elem>
    struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<_Elem>>
    : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
    {
    };

    template <class _Iter1, class _Iter2, class _Pr>
    false_type _Equal_memcmp_is_safe(const _Iter1&, const _Iter2&, const _Pr&)
    {
        return {};
    }

    template <class _Obj1, class _Obj2, class _Pr>
    typename _Equal_memcmp_is_safe_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _Pr>::type
    _Equal_memcmp_is_safe(_Obj1* const&, _Obj2* const&, const _Pr&)
    {
        return {};
    }

    template <class _InIt1, class _InIt2, class _Pr>
    [[nodiscard]] bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, _Pr _Pred)
    {
        _Adl_verify_range(_First1, _Last1);
        auto _UFirst1 = _Get_unwrapped(_First1);
        const auto _ULast1 = _Get_unwrapped(_Last1);
        auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_InIt1>(_UFirst1, _ULast1));
        if constexpr(decltype(_Equal_memcmp_is_safe(_UFirst1, _UFirst2, _Pred))::value)
        {
            const auto _First1_ch = reinterpret_cast<const char*>(_UFirst1);
            const auto _First2_ch = reinterpret_cast<const char*>(_UFirst2);
            const auto _Count = static_cast<size_t>(reinterpret_cast<const char*>(_ULast1) - _First1_ch);
            return ::memcmp(_First1_ch, _First2_ch, _Count) == 0;
        }
        else
        {
            for(; _UFirst1 != _ULast1; ++_UFirst1, (void)++_UFirst2)
            {
                if(!_Pred(*_UFirst1, *_UFirst2))
                {
                    return false;
                }
            }

            return true;
        }
    }

    template <class _InIt1, class _InIt2>
    [[nodiscard]] bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2)
    {
        return ::std::equal(_First1, _Last1, _First2, equal_to<>());
    }

    template <class _InIt1, class _InIt2, class _Pr>
    [[nodiscard]] bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2, _Pr _Pred)
    {
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        auto _UFirst1 = _Get_unwrapped(_First1);
        const auto _ULast1 = _Get_unwrapped(_Last1);
        auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2 = _Get_unwrapped(_Last2);
        if constexpr(_Is_random_iter_v<_InIt1> && _Is_random_iter_v<_InIt2>)
        {
            if(_ULast1 - _UFirst1 != _ULast2 - _UFirst2)
            {
                return false;
            }

            return ::std::equal(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
        }
        else
        {
            for(;;)
            {
                if(_UFirst1 == _ULast1)
                {
                    return _UFirst2 == _ULast2;
                }

                if(_UFirst2 == _ULast2)
                {
                    return false;
                }

                if(!_Pred(*_UFirst1, *_UFirst2))
                {
                    return false;
                }

                ++_UFirst1;
                ++_UFirst2;
            }
        }
    }

    template <class _InIt1, class _InIt2>
    [[nodiscard]] bool equal(const _InIt1 _First1, const _InIt1 _Last1, const _InIt2 _First2, const _InIt2 _Last2)
    {
        return ::std::equal(_First1, _Last1, _First2, _Last2, equal_to<>());
    }

    template <class _Elem1, class _Elem2, class _FTy>
    struct _Lex_compare_check_element_types_helper
    : bool_constant<conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, _Is_character<_FTy>, is_unsigned<_FTy>>>
    {
    };

    template <class _Elem1, class _Elem2>
    struct _Lex_compare_check_element_types_helper<_Elem1, _Elem2, void>
    : bool_constant<conjunction_v<_Is_character<_Elem1>, _Is_character<_Elem2>, is_unsigned<_Elem1>, is_unsigned<_Elem2>>>
    {
    };

    template <class _Memcmp_pr> struct _Lex_compare_optimize
    {
    };

    template <class _Memcmp_pr, class _Obj1, class _Obj2, class _FTy>
    using _Lex_compare_check_element_types
    = _Lex_compare_optimize<conditional_t<_Lex_compare_check_element_types_helper<remove_const_t<_Obj1>, remove_const_t<_Obj2>, _FTy>::value, _Memcmp_pr, void>>;

    template <class _InIt1, class _InIt2, class _Pr>
    _Lex_compare_optimize<void> _Lex_compare_memcmp_classify(const _InIt1&, const _InIt2&, const _Pr&)
    {
        return {};
    }

    template <class _Obj1, class _Obj2, class _FTy>
    _Lex_compare_check_element_types<less<int>, _Obj1, _Obj2, _FTy>
    _Lex_compare_memcmp_classify(_Obj1* const&, _Obj2* const&, const less<_FTy>&)
    {
        return {};
    }

    template <class _Obj1, class _Obj2, class _FTy>
    _Lex_compare_check_element_types<greater<int>, _Obj1, _Obj2, _FTy>
    _Lex_compare_memcmp_classify(_Obj1* const&, _Obj2* const&, const greater<_FTy>&)
    {
        return {};
    }

    template <class _InIt1, class _InIt2, class _Pr>
    bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred, _Lex_compare_optimize<void>)
    {
        for(; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
        {
            if(static_cast<bool>(_Pred(*_First1, *_First2)))
            {
                return true;
            }
            else if(_Pred(*_First2, *_First1))
            {
                return false;
            }
        }

        return _First1 == _Last1 && _First2 != _Last2;
    }

    template <class _InIt1, class _InIt2, class _Pr, class _Memcmp_pr>
    bool _Lex_compare_unchecked(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr, _Lex_compare_optimize<_Memcmp_pr>)
    {
        const auto _Num1 = static_cast<size_t>(_Last1 - _First1);
        const auto _Num2 = static_cast<size_t>(_Last2 - _First2);
        const int _Ans = ::memcmp(_First1, _First2, _Num1 < _Num2 ? _Num1 : _Num2);
        return _Memcmp_pr{}(_Ans, 0) || (_Ans == 0 && _Num1 < _Num2);
    }

    template <class _InIt1, class _InIt2, class _Pr>
    [[nodiscard]] bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2, _Pr _Pred)
    {
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        const auto _UFirst1 = _Get_unwrapped(_First1);
        const auto _ULast1 = _Get_unwrapped(_Last1);
        const auto _UFirst2 = _Get_unwrapped(_First2);
        const auto _ULast2 = _Get_unwrapped(_Last2);
        return _Lex_compare_unchecked(_UFirst1, _ULast1, _UFirst2, _ULast2, _Pass_fn(_Pred),
                                      _Lex_compare_memcmp_classify(_UFirst1, _UFirst2, _Pred));
    }

    template <class _InIt1, class _InIt2>
    [[nodiscard]] bool lexicographical_compare(_InIt1 _First1, _InIt1 _Last1, _InIt2 _First2, _InIt2 _Last2)
    {
        return ::std::lexicographical_compare(_First1, _Last1, _First2, _Last2, less<>());
    }

    template <class _Ty> bool _Within_limits(const _Ty& _Val, true_type, true_type, _Any_tag)
    {
        return (-128) <= _Val && _Val <= 127;
    }

    template <class _Ty> bool _Within_limits(const _Ty& _Val, true_type, false_type, true_type)
    {
        return _Val <= 127 || static_cast<_Ty>((-128)) <= _Val;
    }

    template <class _Ty> bool _Within_limits(const _Ty& _Val, true_type, false_type, false_type)
    {
        return _Val <= 127;
    }

    template <class _Ty> bool _Within_limits(const _Ty& _Val, false_type, true_type, _Any_tag)
    {
        return 0 <= _Val && _Val <= 0xff;
    }

    template <class _Ty> bool _Within_limits(const _Ty& _Val, false_type, false_type, _Any_tag)
    {
        return _Val <= 0xff;
    }

    template <class _InIt, class _Ty> bool _Within_limits(_InIt, const _Ty& _Val)
    {
        using _Elem = remove_pointer_t<_InIt>;
        return _Within_limits(_Val, is_signed<_Elem>{}, is_signed<_Ty>{}, bool_constant<-1 == static_cast<_Ty>(-1)>{});
    }

    template <class _InIt> bool _Within_limits(_InIt, const bool&)
    {
        return true;
    }

    template <class _InIt, class _Ty>
    _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, true_type)
    {
        if(!_Within_limits(_First, _Val))
        {
            return _Last;
        }

        _First = static_cast<_InIt>(::memchr(_First, static_cast<unsigned char>(_Val), static_cast<size_t>(_Last - _First)));
        return _First ? _First : _Last;
    }

    template <class _InIt, class _Ty>
    _InIt _Find_unchecked1(_InIt _First, const _InIt _Last, const _Ty& _Val, false_type)
    {
        for(; _First != _Last; ++_First)
        {
            if(*_First == _Val)
            {
                break;
            }
        }

        return _First;
    }

    template <class _InIt, class _Ty> _InIt _Find_unchecked(const _InIt _First, const _InIt _Last, const _Ty& _Val)
    {
        using _Memchr_opt
        = bool_constant<is_integral_v<_Ty> && _Is_any_of_v<_InIt, char*, signed char*, unsigned char*, const char*, const signed char*, const unsigned char*>>;

        return _Find_unchecked1(_First, _Last, _Val, _Memchr_opt{});
    }

    template <class _InIt, class _Ty>[[nodiscard]] _InIt find(_InIt _First, const _InIt _Last, const _Ty& _Val)
    {
        _Adl_verify_range(_First, _Last);
        _Seek_wrapped(_First, _Find_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
        return _First;
    }

    template <class _InIt, class _Ty, class _Pr> _InIt _Find_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
    {
        for(; _First != _Last; ++_First)
        {
            if(_Pred(*_First, _Val))
            {
                break;
            }
        }

        return _First;
    }

    template <class _InIt, class _Ty>
    [[nodiscard]] _Iter_diff_t<_InIt> count(const _InIt _First, const _InIt _Last, const _Ty& _Val)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        _Iter_diff_t<_InIt> _Count = 0;

        for(; _UFirst != _ULast; ++_UFirst)
        {
            if(*_UFirst == _Val)
            {
                ++_Count;
            }
        }

        return _Count;
    }

    template <class _InIt, class _Ty, class _Pr>
    _Iter_diff_t<_InIt> _Count_pr(_InIt _First, _InIt _Last, const _Ty& _Val, _Pr _Pred)
    {
        _Iter_diff_t<_InIt> _Count = 0;

        for(; _First != _Last; ++_First)
        {
            if(_Pred(*_First, _Val))
            {
                ++_Count;
            }
        }

        return _Count;
    }

    template <class _FwdIt1, class _FwdIt2, class _Pr>
    void _Trim_matching_suffixes(_FwdIt1&, _FwdIt2&, _Pr, forward_iterator_tag, forward_iterator_tag)
    {
    }

    template <class _FwdIt1, class _FwdIt2, class _Pr>
    void _Trim_matching_suffixes(_FwdIt1& _Last1, _FwdIt2& _Last2, _Pr _Pred, bidirectional_iterator_tag, bidirectional_iterator_tag)
    {
        do
        {
            --_Last1;
            --_Last2;
        } while(_Pred(*_Last1, *_Last2));
        ++_Last1;
        ++_Last2;
    }

    template <class _FwdIt1, class _FwdIt2, class _Pr>
    bool _Check_match_counts(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
    {
        _Trim_matching_suffixes(_Last1, _Last2, _Pred, _Iter_cat_t<_FwdIt1>(), _Iter_cat_t<_FwdIt2>());
        for(_FwdIt1 _Next1 = _First1; _Next1 != _Last1; ++_Next1)
        {
            if(_Next1 == _Find_pr(_First1, _Next1, *_Next1, _Pred))
            {
                _Iter_diff_t<_FwdIt2> _Count2 = _Count_pr(_First2, _Last2, *_Next1, _Pred);
                if(_Count2 == 0)
                {
                    return false;
                }

                _FwdIt1 _Skip1 = _Next_iter(_Next1);
                _Iter_diff_t<_FwdIt1> _Count1 = _Count_pr(_Skip1, _Last1, *_Next1, _Pred) + 1;
                if(_Count2 != _Count1)
                {
                    return false;
                }
            }
        }

        return true;
    }

    template <class _FwdIt1, class _FwdIt2, class _Pr>
    bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred)
    {
        for(; _First1 != _Last1; ++_First1, (void)++_First2)
        {
            if(!_Pred(*_First1, *_First2))
            {
                auto _Last2 = ::std::next(_First2, static_cast<_Iter_diff_t<_FwdIt2>>(::std::distance(_First1, _Last1)));
                return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
            }
        }

        return true;
    }

    template <class _FwdIt1, class _FwdIt2, class _Pr>
    [[nodiscard]] bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _Pr _Pred)
    {
        _Adl_verify_range(_First1, _Last1);
        const auto _UFirst1 = _Get_unwrapped(_First1);
        const auto _ULast1 = _Get_unwrapped(_Last1);
        const auto _UFirst2 = _Get_unwrapped_n(_First2, _Idl_distance<_FwdIt1>(_UFirst1, _ULast1));
        return _Is_permutation_unchecked(_UFirst1, _ULast1, _UFirst2, _Pass_fn(_Pred));
    }

    template <class _FwdIt1, class _FwdIt2> bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2)
    {
        return ::std::is_permutation(_First1, _Last1, _First2, equal_to<>());
    }

    template <class _FwdIt1, class _FwdIt2, class _Pr>
    bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, forward_iterator_tag, forward_iterator_tag)
    {
        for(; _First1 != _Last1 && _First2 != _Last2; ++_First1, (void)++_First2)
        {
            if(!_Pred(*_First1, *_First2))
            {
                if(::std::distance(_First1, _Last1) == ::std::distance(_First2, _Last2))
                {
                    return _Check_match_counts(_First1, _Last1, _First2, _Last2, _Pred);
                }
                else
                {
                    return false;
                }
            }
        }

        return _First1 == _Last1 && _First2 == _Last2;
    }

    template <class _FwdIt1, class _FwdIt2, class _Pr>
    bool _Is_permutation_unchecked(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred, random_access_iterator_tag, random_access_iterator_tag)
    {
        if(_Last1 - _First1 != _Last2 - _First2)
        {
            return false;
        }

        return _Is_permutation_unchecked(_First1, _Last1, _First2, _Pred);
    }

    template <class _FwdIt1, class _FwdIt2, class _Pr>
    [[nodiscard]] bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2, _Pr _Pred)
    {
        _Adl_verify_range(_First1, _Last1);
        _Adl_verify_range(_First2, _Last2);
        return _Is_permutation_unchecked(_Get_unwrapped(_First1), _Get_unwrapped(_Last1), _Get_unwrapped(_First2),
                                         _Get_unwrapped(_Last2), _Pass_fn(_Pred), _Iter_cat_t<_FwdIt1>(),
                                         _Iter_cat_t<_FwdIt2>());
    }

    template <class _FwdIt1, class _FwdIt2>
    [[nodiscard]] bool is_permutation(_FwdIt1 _First1, _FwdIt1 _Last1, _FwdIt2 _First2, _FwdIt2 _Last2)
    {
        return ::std::is_permutation(_First1, _Last1, _First2, _Last2, equal_to<>());
    }

    template <class _BidIt> void reverse(const _BidIt _First, const _BidIt _Last)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        auto _ULast = _Get_unwrapped(_Last);

        using _Elem = remove_pointer_t<decltype(_UFirst)>;
        constexpr bool _Allow_vectorization
        = conjunction_v<is_pointer<decltype(_UFirst)>, _Is_trivially_swappable<_Elem>, negation<is_volatile<_Elem>>>;
        if constexpr(_Allow_vectorization && sizeof(_Elem) == 1)
        {
            __std_reverse_trivially_swappable_1(_UFirst, _ULast);
        }
        else if constexpr(_Allow_vectorization && sizeof(_Elem) == 2)
        {
            __std_reverse_trivially_swappable_2(_UFirst, _ULast);
        }
        else if constexpr(_Allow_vectorization && sizeof(_Elem) == 4)
        {
            __std_reverse_trivially_swappable_4(_UFirst, _ULast);
        }
        else if constexpr(_Allow_vectorization && sizeof(_Elem) == 8)
        {
            __std_reverse_trivially_swappable_8(_UFirst, _ULast);
        }
        else
        {
            for(; _UFirst != _ULast && _UFirst != --_ULast; ++_UFirst)
            {
                ::std::iter_swap(_UFirst, _ULast);
            }
        }
    }

    template <class _BidIt>
    pair<_BidIt, _BidIt> _Reverse_until_sentinel_unchecked(_BidIt _First, _BidIt _Sentinel, _BidIt _Last)
    {
        while(_First != _Sentinel && _Last != _Sentinel)
        {
            ::std::iter_swap(_First, --_Last);
            ++_First;
        }

        return pair<_BidIt, _BidIt>(_First, _Last);
    }

    template <class _FwdIt> _FwdIt rotate(_FwdIt _First, _FwdIt _Mid, _FwdIt _Last)
    {
        _Adl_verify_range(_First, _Mid);
        _Adl_verify_range(_Mid, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        auto _UMid = _Get_unwrapped(_Mid);
        const auto _ULast = _Get_unwrapped(_Last);
        if(_UFirst == _UMid)
        {
            return _Last;
        }

        if(_UMid == _ULast)
        {
            return _First;
        }

        if constexpr(_Is_random_iter_v<_FwdIt>)
        {
            ::std::reverse(_UFirst, _UMid);
            ::std::reverse(_UMid, _ULast);
            ::std::reverse(_UFirst, _ULast);
            _Seek_wrapped(_First, _UFirst + (_ULast - _UMid));
        }
        else if constexpr(_Is_bidi_iter_v<_FwdIt>)
        {
            ::std::reverse(_UFirst, _UMid);
            ::std::reverse(_UMid, _ULast);
            auto _Tmp = _Reverse_until_sentinel_unchecked(_UFirst, _UMid, _ULast);
            ::std::reverse(_Tmp.first, _Tmp.second);
            _Seek_wrapped(_First, _UMid != _Tmp.first ? _Tmp.first : _Tmp.second);
        }
        else
        {
            auto _UNext = _UMid;
            do
            {
                ::std::iter_swap(_UFirst, _UNext);
                ++_UFirst;
                ++_UNext;
                if(_UFirst == _UMid)
                {
                    _UMid = _UNext;
                }
            } while(_UNext != _ULast);
            _Seek_wrapped(_First, _UFirst);
            while(_UMid != _ULast)
            {
                _UNext = _UMid;
                do
                {
                    ::std::iter_swap(_UFirst, _UNext);
                    ++_UFirst;
                    ++_UNext;
                    if(_UFirst == _UMid)
                    {
                        _UMid = _UNext;
                    }
                } while(_UNext != _ULast);
            }
        }

        return _First;
    }

    template <class _InIt, class _Pr>[[nodiscard]] _InIt find_if(_InIt _First, const _InIt _Last, _Pr _Pred)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        for(; _UFirst != _ULast; ++_UFirst)
        {
            if(_Pred(*_UFirst))
            {
                break;
            }
        }

        _Seek_wrapped(_First, _UFirst);
        return _First;
    }

    template <class _FwdIt, class _Ty, class _Pr>
    [[nodiscard]] _FwdIt lower_bound(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val, _Pr _Pred)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        _Iter_diff_t<_FwdIt> _Count = ::std::distance(_UFirst, _Get_unwrapped(_Last));

        while(0 < _Count)
        {
            const _Iter_diff_t<_FwdIt> _Count2 = _Count / 2;
            const auto _UMid = ::std::next(_UFirst, _Count2);
            if(_Pred(*_UMid, _Val))
            {
                _UFirst = _Next_iter(_UMid);
                _Count -= _Count2 + 1;
            }
            else
            {
                _Count = _Count2;
            }
        }

        _Seek_wrapped(_First, _UFirst);
        return _First;
    }

    template <class _Diff, class _Urng> class _Rng_from_urng
    {
    public:
        using _Ty0 = make_unsigned_t<_Diff>;
        using _Ty1 = typename _Urng::result_type;

        using _Udiff = conditional_t<sizeof(_Ty1) < sizeof(_Ty0), _Ty0, _Ty1>;

        explicit _Rng_from_urng(_Urng& _Func) : _Ref(_Func), _Bits(8 * sizeof(_Udiff)), _Bmask(_Udiff(-1))
        {
            for(; (_Urng::max)() - (_Urng::min)() < _Bmask; _Bmask >>= 1)
            {
                --_Bits;
            }
        }

        _Diff operator()(_Diff _Index)
        {
            for(;;)
            {
                _Udiff _Ret = 0;
                _Udiff _Mask = 0;

                while(_Mask < _Udiff(_Index - 1))
                {
                    _Ret <<= _Bits - 1;
                    _Ret <<= 1;
                    _Ret |= _Get_bits();
                    _Mask <<= _Bits - 1;
                    _Mask <<= 1;
                    _Mask |= _Bmask;
                }

                if(_Ret / _Index < _Mask / _Index || _Mask % _Index == _Udiff(_Index - 1))
                {
                    return static_cast<_Diff>(_Ret % _Index);
                }
            }
        }

        _Udiff _Get_all_bits()
        {
            _Udiff _Ret = 0;

            for(size_t _Num = 0; _Num < 8 * sizeof(_Udiff); _Num += _Bits)
            {
                _Ret <<= _Bits - 1;
                _Ret <<= 1;
                _Ret |= _Get_bits();
            }

            return _Ret;
        }

        _Rng_from_urng(const _Rng_from_urng&) = delete;
        _Rng_from_urng& operator=(const _Rng_from_urng&) = delete;

    private:
        _Udiff _Get_bits()
        {
            for(;;)
            {
                _Udiff _Val = _Ref() - (_Urng::min)();

                if(_Val <= _Bmask)
                {
                    return _Val;
                }
            }
        }

        _Urng& _Ref;
        size_t _Bits;
        _Udiff _Bmask;
    };

    template <class _Elem> class __declspec(dllimport) _Yarn
    {
    public:
        _Yarn() noexcept : _Myptr(nullptr), _Nul(0)
        {
        }

        _Yarn(const _Yarn& _Right) noexcept : _Myptr(nullptr), _Nul(0)
        {
            *this = _Right;
        }

        _Yarn(const _Elem* _Right) noexcept : _Myptr(nullptr), _Nul(0)
        {
            *this = _Right;
        }

        _Yarn& operator=(const _Yarn& _Right) noexcept
        {
            return *this = _Right._Myptr;
        }

        _Yarn& operator=(const _Elem* _Right) noexcept
        {
            if(_Myptr != _Right)
            {
                _Tidy();

                if(_Right)
                {
                    const _Elem* _Ptr = _Right;
                    while(*_Ptr != _Elem{})
                    {
                        ++_Ptr;
                    }

                    const auto _Count = (++_Ptr - _Right) * sizeof(_Elem);

                    _Myptr = static_cast<_Elem*>(::malloc(_Count));

                    if(_Myptr)
                    {
                        ::memcpy(_Myptr, _Right, _Count);
                    }
                }
            }

            return *this;
        }

        ~_Yarn() noexcept
        {
            _Tidy();
        }

        [[nodiscard]] bool empty() const noexcept
        {
            return _Myptr == nullptr;
        }

        const _Elem* c_str() const noexcept
        {
            return _Myptr ? _Myptr : &_Nul;
        }

        [[nodiscard]] bool _Empty() const noexcept
        {
            return _Myptr == nullptr;
        }

        const _Elem* _C_str() const noexcept
        {
            return _Myptr ? _Myptr : &_Nul;
        }

    private:
        void _Tidy() noexcept
        {
            if(_Myptr)
            {
                ::free(_Myptr);
            }

            _Myptr = nullptr;
        }

        _Elem* _Myptr;
        _Elem _Nul;
    };

    template <class _Container> class back_insert_iterator
    {
    public:
        using iterator_category = output_iterator_tag;
        using value_type = void;
        using difference_type = void;
        using pointer = void;
        using reference = void;

        using container_type = _Container;

        explicit back_insert_iterator(_Container& _Cont) noexcept : container(::std::addressof(_Cont))
        {
        }

        back_insert_iterator& operator=(const typename _Container::value_type& _Val)
        {
            container->push_back(_Val);
            return *this;
        }

        back_insert_iterator& operator=(typename _Container::value_type&& _Val)
        {
            container->push_back(::std::move(_Val));
            return *this;
        }

        [[nodiscard]] back_insert_iterator& operator*() noexcept
        {
            return *this;
        }

        back_insert_iterator& operator++() noexcept
        {
            return *this;
        }

        back_insert_iterator operator++(int) noexcept
        {
            return *this;
        }

    protected:
        _Container* container;
    };

    template <class _Container>[[nodiscard]] back_insert_iterator<_Container> back_inserter(_Container& _Cont) noexcept
    {
        return back_insert_iterator<_Container>(_Cont);
    }

    template <class _Ty, class _Alloc, class = void> struct _Has_allocator_type : false_type
    {
    };

    template <class _Ty, class _Alloc>
    struct _Has_allocator_type<_Ty, _Alloc, void_t<typename _Ty::allocator_type>>
    : is_convertible<_Alloc, typename _Ty::allocator_type>::type
    {
    };

    struct allocator_arg_t
    {
        explicit allocator_arg_t() = default;
    };

    constexpr allocator_arg_t allocator_arg{};

    [[noreturn]] void __cdecl _Xbad_alloc();
    [[noreturn]] void __cdecl _Xinvalid_argument(const char*);
    [[noreturn]] void __cdecl _Xlength_error(const char*);
    [[noreturn]] void __cdecl _Xout_of_range(const char*);
    [[noreturn]] void __cdecl _Xoverflow_error(const char*);
    [[noreturn]] void __cdecl _Xruntime_error(const char*);

    template <class _Ty, class _Alloc> struct uses_allocator : _Has_allocator_type<_Ty, _Alloc>::type
    {
    };

    template <class _Ty, class _Alloc> constexpr bool uses_allocator_v = uses_allocator<_Ty, _Alloc>::value;

    template <class _Category, class _Ty, class _Diff = ptrdiff_t, class _Pointer = _Ty*, class _Reference = _Ty&>
    struct iterator
    {
        using iterator_category = _Category;
        using value_type = _Ty;
        using difference_type = _Diff;
        using pointer = _Pointer;
        using reference = _Reference;
    };

    template <class _Ty> struct _Tidy_guard
    {
        _Ty* _Target;
        ~_Tidy_guard()
        {
            if(_Target)
            {
                _Target->_Tidy();
            }
        }
    };

    template <class _Ty> struct _Tidy_deallocate_guard
    {
        _Ty* _Target;
        ~_Tidy_deallocate_guard()
        {
            if(_Target)
            {
                _Target->_Tidy_deallocate();
            }
        }
    };

    template <class _Keycmp, class _Lhs, class _Rhs>
    constexpr bool _Nothrow_compare
    = noexcept(static_cast<bool>(::std::declval<const _Keycmp&>()(::std::declval<const _Lhs&>(), ::std::declval<const _Rhs&>())));
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <size_t _Ty_size>[[nodiscard]] constexpr size_t _Get_size_of_n(const size_t _Count)
    {
        constexpr bool _Overflow_is_possible = _Ty_size > 1;

        if constexpr(_Overflow_is_possible)
        {
            constexpr size_t _Max_possible = static_cast<size_t>(-1) / _Ty_size;
            if(_Count > _Max_possible)
            {
                _Throw_bad_array_new_length();
            }
        }

        return _Count * _Ty_size;
    }

    template <class _Ty> constexpr size_t _New_alignof = _Max_value(alignof(_Ty), static_cast<size_t>(16ull));

    struct _Default_allocate_traits
    {
        __declspec(allocator) static void* _Allocate(const size_t _Bytes)
        {
            return ::operator new(_Bytes);
        }
    };

    constexpr bool _Is_pow_2(const size_t _Value) noexcept
    {
        return _Value != 0 && (_Value & (_Value - 1)) == 0;
    }

    constexpr size_t _Big_allocation_threshold = 4096;
    constexpr size_t _Big_allocation_alignment = 32;

    static_assert(2 * sizeof(void*) <= _Big_allocation_alignment,
                  "Big allocation alignment should at least match vector register alignment");
    static_assert(_Is_pow_2(_Big_allocation_alignment), "Big allocation alignment must be a power of two");

    constexpr size_t _Non_user_size = sizeof(void*) + _Big_allocation_alignment - 1;

    constexpr size_t _Big_allocation_sentinel = 0xFAFAFAFAFAFAFAFAULL;

    template <class _Traits> __declspec(allocator) void* _Allocate_manually_vector_aligned(const size_t _Bytes)
    {
        const size_t _Block_size = _Non_user_size + _Bytes;
        if(_Block_size <= _Bytes)
        {
            _Throw_bad_array_new_length();
        }

        const uintptr_t _Ptr_container = reinterpret_cast<uintptr_t>(_Traits::_Allocate(_Block_size));
        do
        {
            if(_Ptr_container != 0)
            {
            }
            else
            {
                do
                {
                    ;
                    ::_invalid_parameter_noinfo_noreturn();
                } while(false);
            };
        } while(false);
        void* const _Ptr = reinterpret_cast<void*>((_Ptr_container + _Non_user_size) & ~(_Big_allocation_alignment - 1));
        static_cast<uintptr_t*>(_Ptr)[-1] = _Ptr_container;

        return _Ptr;
    }

    inline void _Adjust_manually_vector_aligned(void*& _Ptr, size_t& _Bytes)
    {
        _Bytes += _Non_user_size;

        const uintptr_t* const _Ptr_user = reinterpret_cast<uintptr_t*>(_Ptr);
        const uintptr_t _Ptr_container = _Ptr_user[-1];

        ;

        constexpr uintptr_t _Min_back_shift = sizeof(void*);
        const uintptr_t _Back_shift = reinterpret_cast<uintptr_t>(_Ptr) - _Ptr_container;
        do
        {
            if(_Back_shift >= _Min_back_shift && _Back_shift <= _Non_user_size)
            {
            }
            else
            {
                do
                {
                    ;
                    ::_invalid_parameter_noinfo_noreturn();
                } while(false);
            };
        } while(false);
        _Ptr = reinterpret_cast<void*>(_Ptr_container);
    }

    template <size_t _Align, class _Traits = _Default_allocate_traits, enable_if_t<(!0 || _Align <= 16ull), int> = 0>
    __declspec(allocator) void* _Allocate(const size_t _Bytes)
    {
        if(_Bytes >= _Big_allocation_threshold)
        {
            return _Allocate_manually_vector_aligned<_Traits>(_Bytes);
        }

        if(_Bytes != 0)
        {
            return _Traits::_Allocate(_Bytes);
        }

        return nullptr;
    }

    template <size_t _Align, enable_if_t<(!0 || _Align <= 16ull), int> = 0>
    void _Deallocate(void* _Ptr, size_t _Bytes) noexcept
    {
        if(_Bytes >= _Big_allocation_threshold)
        {
            _Adjust_manually_vector_aligned(_Ptr, _Bytes);
        }

        ::operator delete(_Ptr, _Bytes);
    }

    template <class _Ty, class... _Types>
    void _Construct_in_place(_Ty& _Obj, _Types&&... _Args) noexcept(is_nothrow_constructible_v<_Ty, _Types...>)
    {
        ::new(const_cast<void*>(static_cast<const volatile void*>(::std::addressof(_Obj)))) _Ty(::std::forward<_Types>(_Args)...);
    }

    template <class _Ty, class... _Types> _Ty* _Global_new(_Types&&... _Args)
    {
        struct _Guard_type
        {
            void* _Result;
            ~_Guard_type()
            {
                if(_Result)
                {
                    _Deallocate<_New_alignof<_Ty>>(_Result, sizeof(_Ty));
                }
            }
        };

        _Guard_type _Guard{ _Allocate<_New_alignof<_Ty>>(sizeof(_Ty)) };
        ::new(_Guard._Result) _Ty(::std::forward<_Types>(_Args)...);
        return static_cast<_Ty*>(::std::exchange(_Guard._Result, nullptr));
    }

    template <class _Ptr, class _Ty> using _Rebind_pointer_t = typename pointer_traits<_Ptr>::template rebind<_Ty>;

    template <class _Pointer, enable_if_t<!is_pointer_v<_Pointer>, int> = 0>
    _Pointer _Refancy(typename pointer_traits<_Pointer>::element_type* _Ptr) noexcept
    {
        return pointer_traits<_Pointer>::pointer_to(*_Ptr);
    }

    template <class _Pointer, enable_if_t<is_pointer_v<_Pointer>, int> = 0> _Pointer _Refancy(_Pointer _Ptr) noexcept
    {
        return _Ptr;
    }

    template <class _Ty> void _Destroy_in_place(_Ty& _Obj) noexcept
    {
        _Obj.~_Ty();
    }

    template <class _Ptrty> auto _Const_cast(_Ptrty _Ptr) noexcept
    {
        using _Elem = typename pointer_traits<_Ptrty>::element_type;
        using _Modifiable = remove_const_t<_Elem>;
        using _Dest = typename pointer_traits<_Ptrty>::template rebind<_Modifiable>;

        return pointer_traits<_Dest>::pointer_to(const_cast<_Modifiable&>(*_Ptr));
    }

    template <class _Ty> auto _Const_cast(_Ty* _Ptr) noexcept
    {
        return const_cast<remove_const_t<_Ty>*>(_Ptr);
    }

    template <class _Ty, class = void> struct _Get_pointer_type
    {
        using type = typename _Ty::value_type*;
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
    struct _Get_pointer_type<_Ty, void_t<typename _Ty::pointer>>
    {
        using type = typename _Ty::pointer;
    };
    __pragma(warning(pop))

    template <class _Ty, class = void>
    struct _Get_const_pointer_type
    {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using _Valty = typename _Ty::value_type;
        using type = typename pointer_traits<_Ptrty>::template rebind<const _Valty>;
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty>
    struct _Get_const_pointer_type<_Ty, void_t<typename _Ty::const_pointer>>
    {
        using type = typename _Ty::const_pointer;
    };
    __pragma(warning(pop))

    template <class _Ty, class = void>
    struct _Get_void_pointer_type
    {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using type = typename pointer_traits<_Ptrty>::template rebind<void>;
    };

    template <class _Ty> struct _Get_void_pointer_type<_Ty, void_t<typename _Ty::void_pointer>>
    {
        using type = typename _Ty::void_pointer;
    };

    template <class _Ty, class = void> struct _Get_const_void_pointer_type
    {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using type = typename pointer_traits<_Ptrty>::template rebind<const void>;
    };

    template <class _Ty> struct _Get_const_void_pointer_type<_Ty, void_t<typename _Ty::const_void_pointer>>
    {
        using type = typename _Ty::const_void_pointer;
    };

    template <class _Ty, class = void> struct _Get_difference_type
    {
        using _Ptrty = typename _Get_pointer_type<_Ty>::type;
        using type = typename pointer_traits<_Ptrty>::difference_type;
    };

    template <class _Ty> struct _Get_difference_type<_Ty, void_t<typename _Ty::difference_type>>
    {
        using type = typename _Ty::difference_type;
    };

    template <class _Ty, class = void> struct _Get_size_type
    {
        using type = make_unsigned_t<typename _Get_difference_type<_Ty>::type>;
    };

    template <class _Ty> struct _Get_size_type<_Ty, void_t<typename _Ty::size_type>>
    {
        using type = typename _Ty::size_type;
    };

    template <class _Ty, class = void> struct _Get_propagate_on_container_copy
    {
        using type = false_type;
    };

    template <class _Ty>
    struct _Get_propagate_on_container_copy<_Ty, void_t<typename _Ty::propagate_on_container_copy_assignment>>
    {
        using type = typename _Ty::propagate_on_container_copy_assignment;
    };

    template <class _Ty, class = void> struct _Get_propagate_on_container_move
    {
        using type = false_type;
    };

    template <class _Ty>
    struct _Get_propagate_on_container_move<_Ty, void_t<typename _Ty::propagate_on_container_move_assignment>>
    {
        using type = typename _Ty::propagate_on_container_move_assignment;
    };

    template <class _Ty, class = void> struct _Get_propagate_on_container_swap
    {
        using type = false_type;
    };

    template <class _Ty> struct _Get_propagate_on_container_swap<_Ty, void_t<typename _Ty::propagate_on_container_swap>>
    {
        using type = typename _Ty::propagate_on_container_swap;
    };

    template <class _Ty, class = void> struct _Get_is_always_equal
    {
        using type = typename is_empty<_Ty>::type;
    };

    template <class _Ty> struct _Get_is_always_equal<_Ty, void_t<typename _Ty::is_always_equal>>
    {
        using type = typename _Ty::is_always_equal;
    };

    template <class _Ty, class _Other, class = void> struct _Get_rebind_type
    {
        using type = typename _Replace_first_parameter<_Other, _Ty>::type;
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Ty, class _Other>
    struct _Get_rebind_type<_Ty, _Other, void_t<typename _Ty::template rebind<_Other>::other>>
    {
        using type = typename _Ty::template rebind<_Other>::other;
    };
    __pragma(warning(pop))

    template <class _Ty>
    class allocator;

    template <class _Alloc, class = void> struct _Is_default_allocator : false_type
    {
    };

    template <class _Ty>
    struct _Is_default_allocator<allocator<_Ty>, void_t<typename allocator<_Ty>::_From_primary>>
    : is_same<typename allocator<_Ty>::_From_primary, allocator<_Ty>>::type
    {
    };

    template <class _Void, class... _Types> struct _Has_no_allocator_construct : true_type
    {
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc, class _Ptr, class... _Args>
    struct _Has_no_allocator_construct<void_t<decltype(::std::declval<_Alloc&>().construct(::std::declval<_Ptr>(), ::std::declval<_Args>()...))>, _Alloc, _Ptr, _Args...>
    : false_type
    {
    };
    __pragma(warning(pop))

    template <class _Alloc, class _Ptr, class... _Args>
    using _Uses_default_construct = disjunction<_Is_default_allocator<_Alloc>, _Has_no_allocator_construct<void, _Alloc, _Ptr, _Args...>>;

    template <class _Alloc, class _Ptr, class = void> struct _Has_no_alloc_destroy : true_type
    {
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc, class _Ptr>
    struct _Has_no_alloc_destroy<_Alloc, _Ptr, void_t<decltype(::std::declval<_Alloc&>().destroy(::std::declval<_Ptr>()))>> : false_type
    {
    };
    __pragma(warning(pop))

    template <class _Alloc, class _Ptr>
    using _Uses_default_destroy = disjunction<_Is_default_allocator<_Alloc>, _Has_no_alloc_destroy<_Alloc, _Ptr>>;

    template <class _Alloc, class _Ptr>
    using _Uses_default_destroy_t = typename _Uses_default_destroy<_Alloc, _Ptr>::type;

    template <class _Alloc, class _Size_type, class _Const_void_pointer, class = void>
    struct _Has_allocate_hint : false_type
    {
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc, class _Size_type, class _Const_void_pointer>
    struct _Has_allocate_hint<_Alloc,
                              _Size_type,
                              _Const_void_pointer,
                              void_t<decltype(::std::declval<_Alloc&>().allocate(::std::declval<const _Size_type&>(), ::std::declval<const _Const_void_pointer&>()))>>
    : true_type
    {
    };
    __pragma(warning(pop))

    template <class _Alloc, class = void>
    struct _Has_max_size : false_type
    {
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc>
    struct _Has_max_size<_Alloc, void_t<decltype(::std::declval<const _Alloc&>().max_size())>> : true_type
    {
    };
    __pragma(warning(pop))

    template <class _Alloc, class = void>
    struct _Has_select_on_container_copy_construction : false_type
    {
    };

    template <class _Alloc>
    struct _Has_select_on_container_copy_construction<_Alloc, void_t<decltype(::std::declval<const _Alloc&>().select_on_container_copy_construction())>>
    : true_type
    {
    };

    template <class _Alloc> struct allocator_traits;

    __pragma(warning(push)) __pragma(warning(disable : 4996)) template <class _Alloc> struct _Normal_allocator_traits
    {
        using allocator_type = _Alloc;
        using value_type = typename _Alloc::value_type;

        using pointer = typename _Get_pointer_type<_Alloc>::type;
        using const_pointer = typename _Get_const_pointer_type<_Alloc>::type;
        using void_pointer = typename _Get_void_pointer_type<_Alloc>::type;
        using const_void_pointer = typename _Get_const_void_pointer_type<_Alloc>::type;

        using size_type = typename _Get_size_type<_Alloc>::type;
        using difference_type = typename _Get_difference_type<_Alloc>::type;

        using propagate_on_container_copy_assignment = typename _Get_propagate_on_container_copy<_Alloc>::type;
        using propagate_on_container_move_assignment = typename _Get_propagate_on_container_move<_Alloc>::type;
        using propagate_on_container_swap = typename _Get_propagate_on_container_swap<_Alloc>::type;
        using is_always_equal = typename _Get_is_always_equal<_Alloc>::type;

        template <class _Other> using rebind_alloc = typename _Get_rebind_type<_Alloc, _Other>::type;

        template <class _Other> using rebind_traits = allocator_traits<rebind_alloc<_Other>>;

        [[nodiscard]] static __declspec(allocator) pointer allocate(_Alloc& _Al, const size_type _Count)
        {
            return _Al.allocate(_Count);
        }

        [[nodiscard]] static __declspec(allocator) pointer
        allocate(_Alloc& _Al, const size_type _Count, const const_void_pointer _Hint)
        {
            if constexpr(_Has_allocate_hint<_Alloc, size_type, const_void_pointer>::value)
            {
                return _Al.allocate(_Count, _Hint);
            }
            else
            {
                (void)_Hint;
                return _Al.allocate(_Count);
            }
        }

        static void deallocate(_Alloc& _Al, pointer _Ptr, size_type _Count)
        {
            _Al.deallocate(_Ptr, _Count);
        }

        template <class _Ty, class... _Types> static void construct(_Alloc& _Al, _Ty* _Ptr, _Types&&... _Args)
        {
            if constexpr(_Uses_default_construct<_Alloc, _Ty*, _Types...>::value)
            {
                (void)_Al;
                ::new(static_cast<void*>(_Ptr)) _Ty(::std::forward<_Types>(_Args)...);
            }
            else
            {
                _Al.construct(_Ptr, ::std::forward<_Types>(_Args)...);
            }
        }

        template <class _Ty> static void destroy(_Alloc& _Al, _Ty* _Ptr)
        {
            if constexpr(_Uses_default_destroy<_Alloc, _Ty*>::value)
            {
                (void)_Al;
                _Ptr->~_Ty();
            }
            else
            {
                _Al.destroy(_Ptr);
            }
        }

        [[nodiscard]] static size_type max_size(const _Alloc& _Al) noexcept
        {
            if constexpr(_Has_max_size<_Alloc>::value)
            {
                return _Al.max_size();
            }
            else
            {
                (void)_Al;
                return (numeric_limits<size_type>::max)() / sizeof(value_type);
            }
        }

        [[nodiscard]] static _Alloc select_on_container_copy_construction(const _Alloc& _Al)
        {
            if constexpr(_Has_select_on_container_copy_construction<_Alloc>::value)
            {
                return _Al.select_on_container_copy_construction();
            }
            else
            {
                return _Al;
            }
        }
    };
    __pragma(warning(pop))

    template <class _Alloc>
    struct _Default_allocator_traits
    {
        using allocator_type = _Alloc;
        using value_type = typename _Alloc::value_type;

        using pointer = value_type*;
        using const_pointer = const value_type*;
        using void_pointer = void*;
        using const_void_pointer = const void*;

        using size_type = size_t;
        using difference_type = ptrdiff_t;

        using propagate_on_container_copy_assignment = false_type;
        using propagate_on_container_move_assignment = true_type;
        using propagate_on_container_swap = false_type;
        using is_always_equal = true_type;

        template <class _Other> using rebind_alloc = allocator<_Other>;

        template <class _Other> using rebind_traits = allocator_traits<allocator<_Other>>;

        [[nodiscard]] static __declspec(allocator) pointer allocate(_Alloc&, const size_type _Count)
        {
            return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }

        [[nodiscard]] static __declspec(allocator) pointer allocate(_Alloc&, const size_type _Count, const_void_pointer)
        {
            return static_cast<pointer>(_Allocate<_New_alignof<value_type>>(_Get_size_of_n<sizeof(value_type)>(_Count)));
        }

        static void deallocate(_Alloc&, const pointer _Ptr, const size_type _Count)
        {
            _Deallocate<_New_alignof<value_type>>(_Ptr, sizeof(value_type) * _Count);
        }

        template <class _Objty, class... _Types> static void construct(_Alloc&, _Objty* const _Ptr, _Types&&... _Args)
        {
            ::new(const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(::std::forward<_Types>(_Args)...);
        }

        template <class _Uty> static void destroy(_Alloc&, _Uty* const _Ptr)
        {
            _Ptr->~_Uty();
        }

        [[nodiscard]] static size_type max_size(const _Alloc&) noexcept
        {
            return static_cast<size_t>(-1) / sizeof(value_type);
        }

        [[nodiscard]] static _Alloc select_on_container_copy_construction(const _Alloc& _Al)
        {
            return _Al;
        }
    };

    template <class _Alloc>
    struct allocator_traits
    : conditional_t<_Is_default_allocator<_Alloc>::value, _Default_allocator_traits<_Alloc>, _Normal_allocator_traits<_Alloc>>
    {
    };

    template <class _Alloc>
    using _Choose_pocca
    = bool_constant<allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value && !allocator_traits<_Alloc>::is_always_equal::value>;

    struct _Equal_allocators
    {
    };
    using _Propagate_allocators = true_type;
    using _No_propagate_allocators = false_type;

    template <class _Alloc>
    using _Choose_pocma
    = conditional_t<allocator_traits<_Alloc>::is_always_equal::value, _Equal_allocators, typename allocator_traits<_Alloc>::propagate_on_container_move_assignment::type>;

    template <class _Alloc, class _Value_type>
    using _Rebind_alloc_t = typename allocator_traits<_Alloc>::template rebind_alloc<_Value_type>;

    template <class _Alloc, class _Value_type>
    using _Maybe_rebind_alloc_t =
    typename _Select<is_same_v<typename _Alloc::value_type, _Value_type>>::template _Apply<_Alloc&, _Rebind_alloc_t<_Alloc, _Value_type>>;

    template <class _Alloc>
    constexpr bool _Is_simple_alloc_v
    = is_same_v<typename allocator_traits<_Alloc>::size_type, size_t>&& is_same_v<typename allocator_traits<_Alloc>::difference_type, ptrdiff_t>&&
    is_same_v<typename allocator_traits<_Alloc>::pointer, typename _Alloc::value_type*>&&
    is_same_v<typename allocator_traits<_Alloc>::const_pointer, const typename _Alloc::value_type*>;

    template <class _Value_type> struct _Simple_types
    {
        using value_type = _Value_type;
        using size_type = size_t;
        using difference_type = ptrdiff_t;
        using pointer = value_type*;
        using const_pointer = const value_type*;
    };

    template <class _Ty> class allocator
    {
    public:
        static_assert(!is_const_v<_Ty>,
                      "The C++ Standard forbids containers of const elements "
                      "because allocator<const T> is ill-formed.");

        using _From_primary = allocator;

        using value_type = _Ty;

        typedef _Ty* pointer;
        typedef const _Ty* const_pointer;

        typedef _Ty& reference;
        typedef const _Ty& const_reference;

        using size_type = size_t;
        using difference_type = ptrdiff_t;

        using propagate_on_container_move_assignment = true_type;
        using is_always_equal = true_type;

        template <class _Other> struct rebind
        {
            using other = allocator<_Other>;
        };

        [[nodiscard]] _Ty* address(_Ty& _Val) const noexcept
        {
            return ::std::addressof(_Val);
        }

        [[nodiscard]] const _Ty* address(const _Ty& _Val) const noexcept
        {
            return ::std::addressof(_Val);
        }

        constexpr allocator() noexcept
        {
        }

        constexpr allocator(const allocator&) noexcept = default;
        template <class _Other> constexpr allocator(const allocator<_Other>&) noexcept
        {
        }

        void deallocate(_Ty* const _Ptr, const size_t _Count)
        {
            _Deallocate<_New_alignof<_Ty>>(_Ptr, sizeof(_Ty) * _Count);
        }

        [[nodiscard]] __declspec(allocator) _Ty* allocate(const size_t _Count)
        {
            return static_cast<_Ty*>(_Allocate<_New_alignof<_Ty>>(_Get_size_of_n<sizeof(_Ty)>(_Count)));
        }

        [[nodiscard]] __declspec(allocator) _Ty* allocate(const size_t _Count, const void*)
        {
            return allocate(_Count);
        }

        template <class _Objty, class... _Types> void construct(_Objty* const _Ptr, _Types&&... _Args)
        {
            ::new(const_cast<void*>(static_cast<const volatile void*>(_Ptr))) _Objty(::std::forward<_Types>(_Args)...);
        }

        template <class _Uty> void destroy(_Uty* const _Ptr)
        {
            _Ptr->~_Uty();
        }

        [[nodiscard]] size_t max_size() const noexcept
        {
            return static_cast<size_t>(-1) / sizeof(_Ty);
        }
    };

    template <> class allocator<void>
    {
    public:
        using value_type = void;
        typedef void* pointer;
        typedef const void* const_pointer;

        using size_type = size_t;
        using difference_type = ptrdiff_t;

        using propagate_on_container_move_assignment = true_type;
        using is_always_equal = true_type;

        template <class _Other> struct rebind
        {
            using other = allocator<_Other>;
        };
    };

    template <class _Ty, class _Other>
    [[nodiscard]] bool operator==(const allocator<_Ty>&, const allocator<_Other>&) noexcept
    {
        return true;
    }

    template <class _Ty, class _Other>
    [[nodiscard]] bool operator!=(const allocator<_Ty>&, const allocator<_Other>&) noexcept
    {
        return false;
    }

    template <class _Alloc> using _Alloc_ptr_t = typename allocator_traits<_Alloc>::pointer;

    template <class _Alloc> using _Alloc_size_t = typename allocator_traits<_Alloc>::size_type;

    template <class _Alloc> void _Pocca(_Alloc& _Left, const _Alloc& _Right) noexcept
    {
        if constexpr(allocator_traits<_Alloc>::propagate_on_container_copy_assignment::value)
        {
            _Left = _Right;
        }
        else
        {
            (void)_Left;
            (void)_Right;
        }
    }

    template <class _Alloc> void _Pocma(_Alloc& _Left, _Alloc& _Right) noexcept
    {
        if constexpr(allocator_traits<_Alloc>::propagate_on_container_move_assignment::value)
        {
            _Left = ::std::move(_Right);
        }
        else
        {
            (void)_Left;
            (void)_Right;
        }
    }

    template <class _Alloc> void _Pocs(_Alloc& _Left, _Alloc& _Right) noexcept
    {
        if constexpr(allocator_traits<_Alloc>::propagate_on_container_swap::value)
        {
            _Swap_adl(_Left, _Right);
        }
        else
        {
            ;
            (void)_Left;
            (void)_Right;
        }
    }

    template <class _Alloc>
    void _Destroy_range(_Alloc_ptr_t<_Alloc> _First, const _Alloc_ptr_t<_Alloc> _Last, _Alloc& _Al) noexcept
    {
        using _Ty = typename _Alloc::value_type;
        if constexpr(conjunction_v<is_trivially_destructible<_Ty>, _Uses_default_destroy<_Alloc, _Ty*>>)
        {
            (void)_First;
            (void)_Last;
            (void)_Al;
        }
        else
        {
            for(; _First != _Last; ++_First)
            {
                allocator_traits<_Alloc>::destroy(_Al, _Unfancy(_First));
            }
        }
    }

    template <class _NoThrowFwdIt> void _Destroy_range(_NoThrowFwdIt _First, const _NoThrowFwdIt _Last) noexcept
    {
        if constexpr(is_trivially_destructible_v<_Iter_value_t<_NoThrowFwdIt>>)
        {
            (void)_First;
            (void)_Last;
        }
        else
        {
            for(; _First != _Last; ++_First)
            {
                _Destroy_in_place(*_First);
            }
        }
    }

    template <class _Size_type>[[nodiscard]] constexpr _Size_type _Convert_size(const size_t _Len) noexcept
    {
        if(_Len > (numeric_limits<_Size_type>::max)())
        {
            _Xlength_error("size_t too long for _Size_type");
        }

        return static_cast<_Size_type>(_Len);
    }

    template <>[[nodiscard]] constexpr size_t _Convert_size<size_t>(const size_t _Len) noexcept
    {
        return _Len;
    }

    template <class _Alloc> void _Deallocate_plain(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept
    {
        using _Alloc_traits = allocator_traits<_Alloc>;
        if constexpr(is_same_v<_Alloc_ptr_t<_Alloc>, typename _Alloc::value_type*>)
        {
            _Alloc_traits::deallocate(_Al, _Ptr, 1);
        }
        else
        {
            using _Ptr_traits = pointer_traits<_Alloc_ptr_t<_Alloc>>;
            _Alloc_traits::deallocate(_Al, _Ptr_traits::pointer_to(*_Ptr), 1);
        }
    }

    template <class _Alloc> void _Delete_plain_internal(_Alloc& _Al, typename _Alloc::value_type* const _Ptr) noexcept
    {
        using _Ty = typename _Alloc::value_type;
        _Ptr->~_Ty();
        _Deallocate_plain(_Al, _Ptr);
    }

    template <class _Alloc> struct _Alloc_construct_ptr
    {
        using pointer = _Alloc_ptr_t<_Alloc>;
        _Alloc& _Al;
        pointer _Ptr;

        explicit _Alloc_construct_ptr(_Alloc& _Al_) : _Al(_Al_), _Ptr(nullptr)
        {
        }

        [[nodiscard]] pointer _Release() noexcept
        {
            return ::std::exchange(_Ptr, nullptr);
        }

        void _Allocate()
        {
            _Ptr = nullptr;
            _Ptr = _Al.allocate(1);
        }

        ~_Alloc_construct_ptr()
        {
            if(_Ptr)
            {
                _Al.deallocate(_Ptr, 1);
            }
        }

        _Alloc_construct_ptr(const _Alloc_construct_ptr&) = delete;
        _Alloc_construct_ptr& operator=(const _Alloc_construct_ptr&) = delete;
    };

    struct _Fake_allocator
    {
    };

    struct _Container_base0
    {
        void _Orphan_all() noexcept
        {
        }
        void _Swap_proxy_and_iterators(_Container_base0&) noexcept
        {
        }
        void _Alloc_proxy(const _Fake_allocator&) noexcept
        {
        }
        void _Reload_proxy(const _Fake_allocator&, const _Fake_allocator&) noexcept
        {
        }
    };

    struct _Iterator_base0
    {
        void _Adopt(const void*) noexcept
        {
        }
        const _Container_base0* _Getcont() const noexcept
        {
            return nullptr;
        }

        static constexpr bool _Unwrap_when_unverified = true;
    };

    struct _Container_base12;
    struct _Container_proxy
    {
        _Container_proxy() noexcept : _Mycont(nullptr), _Myfirstiter(nullptr)
        {
        }
        _Container_proxy(_Container_base12* _Mycont_) noexcept : _Mycont(_Mycont_), _Myfirstiter(nullptr)
        {
        }

        const _Container_base12* _Mycont;
        _Iterator_base12* _Myfirstiter;
    };

    struct _Container_base12
    {
    public:
        _Container_base12() noexcept : _Myproxy(nullptr)
        {
        }

        _Container_base12(const _Container_base12&) = delete;
        _Container_base12& operator=(const _Container_base12&) = delete;

        void _Orphan_all() noexcept;
        void _Swap_proxy_and_iterators(_Container_base12&) noexcept;

        template <class _Alloc> void _Alloc_proxy(_Alloc&& _Al)
        {
            _Container_proxy* const _New_proxy = _Unfancy(_Al.allocate(1));
            _Construct_in_place(*_New_proxy, this);
            _Myproxy = _New_proxy;
            _New_proxy->_Mycont = this;
        }

        template <class _Alloc> void _Reload_proxy(_Alloc&& _Old_alloc, _Alloc&& _New_alloc)
        {
            _Container_proxy* const _New_proxy = _Unfancy(_New_alloc.allocate(1));
            _Construct_in_place(*_New_proxy, this);
            _New_proxy->_Mycont = this;
            _Delete_plain_internal(_Old_alloc, ::std::exchange(_Myproxy, _New_proxy));
        }

        _Container_proxy* _Myproxy;
    };

    struct _Iterator_base12
    {
        _Iterator_base12() noexcept : _Myproxy(nullptr), _Mynextiter(nullptr)
        {
        }

        _Iterator_base12(const _Iterator_base12& _Right) noexcept : _Myproxy(nullptr), _Mynextiter(nullptr)
        {
            *this = _Right;
        }

        _Iterator_base12& operator=(const _Iterator_base12& _Right) noexcept
        {
            if(_Myproxy != _Right._Myproxy)
            {
                if(_Right._Myproxy)
                {
                    _Adopt(_Right._Myproxy->_Mycont);
                }
                else
                {
                    _Myproxy = nullptr;
                }
            }

            return *this;
        }

        ~_Iterator_base12() noexcept
        {
        }

        void _Adopt(const _Container_base12* _Parent) noexcept
        {
            if(_Parent)
            {
                _Container_proxy* _Parent_proxy = _Parent->_Myproxy;

                _Myproxy = _Parent_proxy;
            }
            else
            {
                _Myproxy = nullptr;
            }
        }

        const _Container_base12* _Getcont() const noexcept
        {
            return _Myproxy ? _Myproxy->_Mycont : nullptr;
        }

        static constexpr bool _Unwrap_when_unverified = 0 == 0;

        _Container_proxy* _Myproxy;
        _Iterator_base12* _Mynextiter;
    };

    inline void _Container_base12::_Orphan_all() noexcept
    {
    }

    inline void _Container_base12::_Swap_proxy_and_iterators(_Container_base12& _Right) noexcept
    {
        _Container_proxy* _Temp = _Myproxy;
        _Myproxy = _Right._Myproxy;
        _Right._Myproxy = _Temp;

        if(_Myproxy)
        {
            _Myproxy->_Mycont = this;
        }

        if(_Right._Myproxy)
        {
            _Right._Myproxy->_Mycont = &_Right;
        }
    }

    using _Container_base = _Container_base0;
    using _Iterator_base = _Iterator_base0;

    struct _Leave_proxy_unbound
    {
    };

    struct _Fake_proxy_ptr_impl
    {
        _Fake_proxy_ptr_impl(const _Fake_proxy_ptr_impl&) = delete;
        _Fake_proxy_ptr_impl& operator=(const _Fake_proxy_ptr_impl&) = delete;
        _Fake_proxy_ptr_impl(const _Fake_allocator&, _Leave_proxy_unbound) noexcept
        {
        }
        _Fake_proxy_ptr_impl(const _Fake_allocator&, const _Container_base0&) noexcept
        {
        }

        void _Bind(const _Fake_allocator&, _Container_base0*) noexcept
        {
        }
        void _Release() noexcept
        {
        }
    };

    struct _Basic_container_proxy_ptr12
    {
        _Container_proxy* _Ptr;

        void _Release() noexcept
        {
            _Ptr = nullptr;
        }

    protected:
        _Basic_container_proxy_ptr12() = default;
        _Basic_container_proxy_ptr12(const _Basic_container_proxy_ptr12&) = delete;
        _Basic_container_proxy_ptr12(_Basic_container_proxy_ptr12&&) = delete;
    };

    template <class _Alloc> struct _Container_proxy_ptr12 : _Basic_container_proxy_ptr12
    {
        _Alloc& _Al;

        _Container_proxy_ptr12(_Alloc& _Al_, _Leave_proxy_unbound) : _Al(_Al_)
        {
            _Ptr = _Unfancy(_Al_.allocate(1));
            _Construct_in_place(*_Ptr);
        }

        _Container_proxy_ptr12(_Alloc& _Al_, _Container_base12& _Mycont) : _Al(_Al_)
        {
            _Ptr = _Unfancy(_Al_.allocate(1));
            _Construct_in_place(*_Ptr, ::std::addressof(_Mycont));
            _Mycont._Myproxy = _Ptr;
        }

        void _Bind(_Alloc& _Old_alloc, _Container_base12* _Mycont) noexcept
        {
            _Ptr->_Mycont = _Mycont;
            _Delete_plain_internal(_Old_alloc, ::std::exchange(_Mycont->_Myproxy, ::std::exchange(_Ptr, nullptr)));
        }

        ~_Container_proxy_ptr12()
        {
            if(_Ptr)
            {
                _Delete_plain_internal(_Al, _Ptr);
            }
        }
    };

    template <class _Alloc> using _Container_proxy_ptr = _Fake_proxy_ptr_impl;

    struct _Zero_then_variadic_args_t
    {
    };

    struct _One_then_variadic_args_t
    {
    };

    template <class _Ty1, class _Ty2, bool = is_empty_v<_Ty1> && !is_final_v<_Ty1>>
    class _Compressed_pair final : private _Ty1
    {
    public:
        _Ty2 _Myval2;

        using _Mybase = _Ty1;

        template <class... _Other2>
        constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(), _Myval2(::std::forward<_Other2>(_Val2)...)
        {
        }

        template <class _Other1, class... _Other2>
        constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Ty1(::std::forward<_Other1>(_Val1)), _Myval2(::std::forward<_Other2>(_Val2)...)
        {
        }

        constexpr _Ty1& _Get_first() noexcept
        {
            return *this;
        }

        constexpr const _Ty1& _Get_first() const noexcept
        {
            return *this;
        }
    };

    template <class _Ty1, class _Ty2> class _Compressed_pair<_Ty1, _Ty2, false> final
    {
    public:
        _Ty1 _Myval1;
        _Ty2 _Myval2;

        template <class... _Other2>
        constexpr explicit _Compressed_pair(_Zero_then_variadic_args_t, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_default_constructible<_Ty1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(), _Myval2(::std::forward<_Other2>(_Val2)...)
        {
        }

        template <class _Other1, class... _Other2>
        constexpr _Compressed_pair(_One_then_variadic_args_t, _Other1&& _Val1, _Other2&&... _Val2) noexcept(
        conjunction_v<is_nothrow_constructible<_Ty1, _Other1>, is_nothrow_constructible<_Ty2, _Other2...>>)
        : _Myval1(::std::forward<_Other1>(_Val1)), _Myval2(::std::forward<_Other2>(_Val2)...)
        {
        }

        constexpr _Ty1& _Get_first() noexcept
        {
            return _Myval1;
        }

        constexpr const _Ty1& _Get_first() const noexcept
        {
            return _Myval1;
        }
    };

    struct _Move_allocator_tag
    {
    };

    template <class _Ty> pair<_Ty*, ptrdiff_t> _Get_temporary_buffer(ptrdiff_t _Count) noexcept
    {
        if(static_cast<size_t>(_Count) <= static_cast<size_t>(-1) / sizeof(_Ty))
        {
            for(; 0 < _Count; _Count /= 2)
            {
                const auto _Size = static_cast<size_t>(_Count) * sizeof(_Ty);
                void* _Pbuf;

                {
                    _Pbuf = ::operator new(_Size, nothrow);
                }

                if(_Pbuf)
                {
                    return { static_cast<_Ty*>(_Pbuf), _Count };
                }
            }
        }

        return { nullptr, 0 };
    }

    template <class _Ty> void _Return_temporary_buffer(_Ty* const _Pbuf) noexcept
    {
        {
            ::operator delete(_Pbuf);
        }
    }

    template <class _NoThrowFwdIt> struct _Uninitialized_backout
    {
        _NoThrowFwdIt _First;
        _NoThrowFwdIt _Last;

        explicit _Uninitialized_backout(_NoThrowFwdIt _Dest) : _First(_Dest), _Last(_Dest)
        {
        }

        _Uninitialized_backout(_NoThrowFwdIt _First_, _NoThrowFwdIt _Last_) : _First(_First_), _Last(_Last_)
        {
        }

        _Uninitialized_backout(const _Uninitialized_backout&) = delete;
        _Uninitialized_backout& operator=(const _Uninitialized_backout&) = delete;

        ~_Uninitialized_backout()
        {
            _Destroy_range(_First, _Last);
        }

        template <class... _Types> void _Emplace_back(_Types&&... _Vals)
        {
            _Construct_in_place(*_Last, ::std::forward<_Types>(_Vals)...);
            ++_Last;
        }

        _NoThrowFwdIt _Release()
        {
            _First = _Last;
            return _Last;
        }
    };

    template <class _InIt, class _NoThrowFwdIt>
    _NoThrowFwdIt _Uninitialized_move_unchecked(_InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest)
    {
        if constexpr(_Ptr_move_cat<_InIt, _NoThrowFwdIt>::_Really_trivial)
        {
            return _Copy_memmove(_First, _Last, _Dest);
        }
        else
        {
            _Uninitialized_backout<_NoThrowFwdIt> _Backout{ _Dest };
            for(; _First != _Last; ++_First)
            {
                _Backout._Emplace_back(::std::move(*_First));
            }

            return _Backout._Release();
        }
    }

    template <class _Alloc> class _Uninitialized_backout_al
    {
        using pointer = _Alloc_ptr_t<_Alloc>;

    public:
        _Uninitialized_backout_al(pointer _Dest, _Alloc& _Al_) : _First(_Dest), _Last(_Dest), _Al(_Al_)
        {
        }

        _Uninitialized_backout_al(const _Uninitialized_backout_al&) = delete;
        _Uninitialized_backout_al& operator=(const _Uninitialized_backout_al&) = delete;

        ~_Uninitialized_backout_al()
        {
            _Destroy_range(_First, _Last, _Al);
        }

        template <class... _Types> void _Emplace_back(_Types&&... _Vals)
        {
            allocator_traits<_Alloc>::construct(_Al, _Unfancy(_Last), ::std::forward<_Types>(_Vals)...);
            ++_Last;
        }

        pointer _Release()
        {
            _First = _Last;
            return _Last;
        }

    private:
        pointer _First;
        pointer _Last;
        _Alloc& _Al;
    };

    template <class _InIt, class _Alloc>
    _Alloc_ptr_t<_Alloc> _Uninitialized_copy(const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al)
    {
        using _Ptrval = typename _Alloc::value_type*;

        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);

        if constexpr(conjunction_v<bool_constant<_Ptr_copy_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
                                   _Uses_default_construct<_Alloc, _Ptrval, decltype(*_UFirst)>>)
        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            _Dest += _ULast - _UFirst;
            (void)_Al;
        }
        else
        {
            _Uninitialized_backout_al<_Alloc> _Backout{ _Dest, _Al };
            for(; _UFirst != _ULast; ++_UFirst)
            {
                _Backout._Emplace_back(*_UFirst);
            }

            _Dest = _Backout._Release();
        }

        return _Dest;
    }

    template <class _InIt, class _NoThrowFwdIt>
    _NoThrowFwdIt uninitialized_copy(const _InIt _First, const _InIt _Last, _NoThrowFwdIt _Dest)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        auto _UDest = _Get_unwrapped_n(_Dest, _Idl_distance<_InIt>(_UFirst, _ULast));
        if constexpr(_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial)
        {
            _UDest = _Copy_memmove(_UFirst, _ULast, _UDest);
        }
        else
        {
            _Uninitialized_backout<decltype(_UDest)> _Backout{ _UDest };
            for(; _UFirst != _ULast; ++_UFirst)
            {
                _Backout._Emplace_back(*_UFirst);
            }

            _UDest = _Backout._Release();
        }

        _Seek_wrapped(_Dest, _UDest);
        return _Dest;
    }

    template <class _InIt, class _Alloc>
    _Alloc_ptr_t<_Alloc> _Uninitialized_move(const _InIt _First, const _InIt _Last, _Alloc_ptr_t<_Alloc> _Dest, _Alloc& _Al)
    {
        using _Ptrval = typename _Alloc::value_type*;
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        if constexpr(conjunction_v<bool_constant<_Ptr_move_cat<decltype(_UFirst), _Ptrval>::_Really_trivial>,
                                   _Uses_default_construct<_Alloc, _Ptrval, decltype(::std::move(*_UFirst))>>)
        {
            _Copy_memmove(_UFirst, _ULast, _Unfancy(_Dest));
            return _Dest + (_ULast - _UFirst);
            (void)_Al;
        }
        else
        {
            _Uninitialized_backout_al<_Alloc> _Backout{ _Dest, _Al };
            for(; _UFirst != _ULast; ++_UFirst)
            {
                _Backout._Emplace_back(::std::move(*_UFirst));
            }

            return _Backout._Release();
        }
    }

    template <class _Alloc>
    _Alloc_ptr_t<_Alloc>
    _Uninitialized_fill_n(_Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, const typename _Alloc::value_type& _Val, _Alloc& _Al)
    {
        using _Ty = typename _Alloc::value_type;
        if constexpr(_Fill_memset_is_safe<_Ty*, _Ty> && _Uses_default_construct<_Alloc, _Ty*, _Ty>::value)
        {
            (void)_Al;
            ::memset(_Unfancy(_First), static_cast<unsigned char>(_Val), static_cast<size_t>(_Count));
            return _First + _Count;
        }
        else
        {
            _Uninitialized_backout_al<_Alloc> _Backout{ _First, _Al };
            for(; 0 < _Count; --_Count)
            {
                _Backout._Emplace_back(_Val);
            }

            return _Backout._Release();
        }
    }

    template <class _NoThrowFwdIt, class _Tval>
    void uninitialized_fill(const _NoThrowFwdIt _First, const _NoThrowFwdIt _Last, const _Tval& _Val)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        if constexpr(_Fill_memset_is_safe<_Unwrapped_t<const _NoThrowFwdIt&>, _Tval>)
        {
            ::memset(_UFirst, static_cast<unsigned char>(_Val), static_cast<size_t>(_ULast - _UFirst));
        }
        else
        {
            _Uninitialized_backout<_Unwrapped_t<const _NoThrowFwdIt&>> _Backout{ _UFirst };
            while(_Backout._Last != _ULast)
            {
                _Backout._Emplace_back(_Val);
            }

            _Backout._Release();
        }
    }

    template <class _NoThrowFwdIt>
    constexpr bool _Use_memset_value_construct_v
    = conjunction_v<is_pointer<_NoThrowFwdIt>,
                    is_scalar<_Iter_value_t<_NoThrowFwdIt>>,
                    negation<is_volatile<remove_reference_t<_Iter_ref_t<_NoThrowFwdIt>>>>,
                    negation<is_member_pointer<_Iter_value_t<_NoThrowFwdIt>>>>;

    template <class _Ptr> _Ptr _Zero_range(const _Ptr _First, const _Ptr _Last)
    {
        char* const _First_ch = reinterpret_cast<char*>(_First);
        char* const _Last_ch = reinterpret_cast<char*>(_Last);
        ::memset(_First_ch, 0, static_cast<size_t>(_Last_ch - _First_ch));
        return _Last;
    }

    template <class _Alloc>
    _Alloc_ptr_t<_Alloc> _Uninitialized_value_construct_n(_Alloc_ptr_t<_Alloc> _First, _Alloc_size_t<_Alloc> _Count, _Alloc& _Al)
    {
        using _Ptrty = typename _Alloc::value_type*;
        if constexpr(_Use_memset_value_construct_v<_Ptrty> && _Uses_default_construct<_Alloc, _Ptrty>::value)
        {
            (void)_Al;
            auto _PFirst = _Unfancy(_First);
            _Zero_range(_PFirst, _PFirst + _Count);
            return _First + _Count;
        }
        else
        {
            _Uninitialized_backout_al<_Alloc> _Backout{ _First, _Al };
            for(; 0 < _Count; --_Count)
            {
                _Backout._Emplace_back();
            }

            return _Backout._Release();
        }
    }

    template <class _NoThrowFwdIt, class _Diff>
    _NoThrowFwdIt _Uninitialized_value_construct_n_unchecked1(_NoThrowFwdIt _UFirst, _Diff _Count)
    {
        ;
        if constexpr(_Use_memset_value_construct_v<_NoThrowFwdIt>)
        {
            return _Zero_range(_UFirst, _UFirst + _Count);
        }
        else
        {
            _Uninitialized_backout<_NoThrowFwdIt> _Backout{ _UFirst };
            for(; 0 < _Count; --_Count)
            {
                _Backout._Emplace_back();
            }

            return _Backout._Release();
        }
    }

    template <class _Ty>[[nodiscard]] pair<_Ty*, ptrdiff_t> get_temporary_buffer(ptrdiff_t _Count) noexcept
    {
        return _Get_temporary_buffer<_Ty>(_Count);
    }

    template <class _Ty> void return_temporary_buffer(_Ty* _Pbuf)
    {
        _Return_temporary_buffer(_Pbuf);
    }

    template <class _Key, class... _Args> struct _In_place_key_extract_set
    {
        static constexpr bool _Extractable = false;
    };

    template <class _Key> struct _In_place_key_extract_set<_Key, _Key>
    {
        static constexpr bool _Extractable = true;
        static const _Key& _Extract(const _Key& _Val) noexcept
        {
            return _Val;
        }
    };

    template <class _Key, class... Args> struct _In_place_key_extract_map
    {
        static constexpr bool _Extractable = false;
    };

    template <class _Key, class _Second> struct _In_place_key_extract_map<_Key, _Key, _Second>
    {
        static constexpr bool _Extractable = true;
        static const _Key& _Extract(const _Key& _Val, const _Second&) noexcept
        {
            return _Val;
        }
    };

    template <class _Key, class _First, class _Second> struct _In_place_key_extract_map<_Key, pair<_First, _Second>>
    {
        static constexpr bool _Extractable = is_same_v<_Key, _Remove_cvref_t<_First>>;
        static const _Key& _Extract(const pair<_First, _Second>& _Val)
        {
            return _Val.first;
        }
    };

    template <class _Ty> struct _Wrap
    {
        _Ty _Value;
    };

    template <class _Alloc> struct _Alloc_temporary
    {
        using value_type = typename _Alloc::value_type;
        using _Traits = allocator_traits<_Alloc>;

        _Alloc& _Al;
        union
        {
            _Wrap<value_type> _Storage;
        };

        template <class... _Args>
        explicit _Alloc_temporary(_Alloc& _Al_, _Args&&... _Vals) noexcept(
        noexcept(_Traits::construct(_Al_, ::std::addressof(_Storage._Value), ::std::forward<_Args>(_Vals)...)))
        : _Al(_Al_)
        {
            _Traits::construct(_Al, ::std::addressof(_Storage._Value), ::std::forward<_Args>(_Vals)...);
        }

        _Alloc_temporary(const _Alloc_temporary&) = delete;
        _Alloc_temporary& operator=(const _Alloc_temporary&) = delete;

        ~_Alloc_temporary()
        {
            _Traits::destroy(_Al, ::std::addressof(_Storage._Value));
        }
    };

    template <class _FwdIt, class _Ty>[[nodiscard]] _FwdIt remove(_FwdIt _First, const _FwdIt _Last, const _Ty& _Val)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        _UFirst = _Find_unchecked(_UFirst, _ULast, _Val);
        auto _UNext = _UFirst;
        if(_UFirst != _ULast)
        {
            while(++_UFirst != _ULast)
            {
                if(!(*_UFirst == _Val))
                {
                    *_UNext = ::std::move(*_UFirst);
                    ++_UNext;
                }
            }
        }

        _Seek_wrapped(_First, _UNext);
        return _First;
    }

    template <class _FwdIt, class _Pr>[[nodiscard]] _FwdIt remove_if(_FwdIt _First, const _FwdIt _Last, _Pr _Pred)
    {
        _Adl_verify_range(_First, _Last);
        auto _UFirst = _Get_unwrapped(_First);
        const auto _ULast = _Get_unwrapped(_Last);
        _UFirst = ::std::find_if(_UFirst, _ULast, _Pass_fn(_Pred));
        auto _UNext = _UFirst;
        if(_UFirst != _ULast)
        {
            while(++_UFirst != _ULast)
            {
                if(!_Pred(*_UFirst))
                {
                    *_UNext = ::std::move(*_UFirst);
                    ++_UNext;
                }
            }
        }

        _Seek_wrapped(_First, _UNext);
        return _First;
    }

    template <class _Container, class _Uty> void _Erase_remove(_Container& _Cont, const _Uty& _Val)
    {
        auto _First = _Cont.begin();
        const auto _Last = _Cont.end();
        _Seek_wrapped(_First, ::std::remove(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Val));
        _Cont.erase(_First, _Last);
    }

    template <class _Container, class _Pr> void _Erase_remove_if(_Container& _Cont, _Pr _Pred)
    {
        auto _First = _Cont.begin();
        const auto _Last = _Cont.end();
        _Seek_wrapped(_First, ::std::remove_if(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Pred));
        _Cont.erase(_First, _Last);
    }

    template <class _Container, class _Pr> void _Erase_nodes_if(_Container& _Cont, _Pr _Pred)
    {
        auto _First = _Cont.begin();
        const auto _Last = _Cont.end();
        while(_First != _Last)
        {
            if(_Pred(*_First))
            {
                _First = _Cont.erase(_First);
            }
            else
            {
                ++_First;
            }
        }
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Elem, class _Int_type> struct _Char_traits
    {
        using char_type = _Elem;
        using int_type = _Int_type;
        using pos_type = streampos;
        using off_type = streamoff;
        using state_type = _Mbstatet;

        [[nodiscard]] static inline int compare(const _Elem* _First1, const _Elem* _First2, size_t _Count) noexcept
        {
            for(; 0 < _Count; --_Count, ++_First1, ++_First2)
            {
                if(*_First1 != *_First2)
                {
                    return *_First1 < *_First2 ? -1 : +1;
                }
            }

            return 0;
        }

        [[nodiscard]] static inline size_t length(const _Elem* _First) noexcept
        {
            size_t _Count = 0;
            while(*_First != _Elem())
            {
                ++_Count;
                ++_First;
            }

            return _Count;
        }

        static _Elem* copy(_Elem* const _First1, const _Elem* _First2, size_t _Count) noexcept
        {
            return static_cast<_Elem*>(::memcpy(_First1, _First2, _Count * sizeof(_Elem)));
        }

        static _Elem* _Copy_s(_Elem* const _First1, const size_t _Dest_size, const _Elem* const _First2, const size_t _Count) noexcept
        {
            do
            {
                if(_Count <= _Dest_size)
                {
                }
                else
                {
                    do
                    {
                        ;
                        ::_invalid_parameter_noinfo_noreturn();
                    } while(false);
                };
            } while(false);
            return copy(_First1, _First2, _Count);
        }

        [[nodiscard]] static inline const _Elem* find(const _Elem* _First, size_t _Count, const _Elem& _Ch) noexcept
        {
            for(; 0 < _Count; --_Count, ++_First)
            {
                if(*_First == _Ch)
                {
                    return _First;
                }
            }

            return nullptr;
        }

        static _Elem* move(_Elem* const _First1, const _Elem* _First2, size_t _Count) noexcept
        {
            return static_cast<_Elem*>(::memmove(_First1, _First2, _Count * sizeof(_Elem)));
        }

        static _Elem* assign(_Elem* const _First, size_t _Count, const _Elem _Ch) noexcept
        {
            _Elem* _Next = _First;
            for(; 0 < _Count; --_Count, ++_Next)
            {
                *_Next = _Ch;
            }

            return _First;
        }

        static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept
        {
            _Left = _Right;
        }

        [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept
        {
            return _Left == _Right;
        }

        [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept
        {
            return _Left < _Right;
        }

        [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept
        {
            return static_cast<_Elem>(_Meta);
        }

        [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept
        {
            return static_cast<int_type>(_Ch);
        }

        [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
        {
            return _Left == _Right;
        }

        [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept
        {
            return _Meta != eof() ? _Meta : !eof();
        }

        [[nodiscard]] static constexpr int_type eof() noexcept
        {
            return static_cast<int_type>((-1));
        }
    };

    template <class _Elem> struct _WChar_traits
    {
        using char_type = _Elem;
        using int_type = unsigned short;
        using pos_type = streampos;
        using off_type = streamoff;
        using state_type = mbstate_t;

        [[nodiscard]] static inline int compare(const _Elem* const _First1, const _Elem* const _First2, const size_t _Count) noexcept
        {
            return ::wmemcmp(reinterpret_cast<const wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count);
        }

        [[nodiscard]] static inline size_t length(const _Elem* _First) noexcept
        {
            return ::wcslen(reinterpret_cast<const wchar_t*>(_First));
        }

        static _Elem* copy(_Elem* const _First1, const _Elem* const _First2, const size_t _Count) noexcept
        {
            return reinterpret_cast<_Elem*>(
            ::wmemcpy(reinterpret_cast<wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count));
        }

        static _Elem* _Copy_s(_Elem* const _First1, const size_t _Size_in_words, const _Elem* const _First2, const size_t _Count) noexcept
        {
            do
            {
                if(_Count <= _Size_in_words)
                {
                }
                else
                {
                    do
                    {
                        ;
                        ::_invalid_parameter_noinfo_noreturn();
                    } while(false);
                };
            } while(false);
            return copy(_First1, _First2, _Count);
        }

        [[nodiscard]] static inline const _Elem* find(const _Elem* _First, const size_t _Count, const _Elem& _Ch) noexcept
        {
            return reinterpret_cast<const _Elem*>(::wmemchr(reinterpret_cast<const wchar_t*>(_First), _Ch, _Count));
        }

        static _Elem* move(_Elem* const _First1, const _Elem* const _First2, const size_t _Count) noexcept
        {
            return reinterpret_cast<_Elem*>(
            ::wmemmove(reinterpret_cast<wchar_t*>(_First1), reinterpret_cast<const wchar_t*>(_First2), _Count));
        }

        static _Elem* assign(_Elem* const _First, size_t _Count, _Elem _Ch) noexcept
        {
            return reinterpret_cast<_Elem*>(::wmemset(reinterpret_cast<wchar_t*>(_First), _Ch, _Count));
        }

        static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept
        {
            _Left = _Right;
        }

        [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept
        {
            return _Left == _Right;
        }

        [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept
        {
            return _Left < _Right;
        }

        [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept
        {
            return _Meta;
        }

        [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept
        {
            return _Ch;
        }

        [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
        {
            return _Left == _Right;
        }

        [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept
        {
            return _Meta != eof() ? _Meta : static_cast<int_type>(!eof());
        }

        [[nodiscard]] static constexpr int_type eof() noexcept
        {
            return ((wint_t)(0xFFFF));
        }
    };

    template <class _Elem> struct char_traits : _Char_traits<_Elem, long>
    {
    };

    template <> struct char_traits<char16_t> : _WChar_traits<char16_t>
    {
    };

    using u16streampos = streampos;

    template <> struct char_traits<char32_t> : _Char_traits<char32_t, unsigned int>
    {
    };

    using u32streampos = streampos;

    template <> struct char_traits<wchar_t> : _WChar_traits<wchar_t>
    {
    };

    template <> struct char_traits<unsigned short> : _WChar_traits<unsigned short>
    {
    };

    template <class _Elem, class _Int_type> struct _Narrow_char_traits
    {
        using char_type = _Elem;
        using int_type = _Int_type;
        using pos_type = streampos;
        using off_type = streamoff;
        using state_type = mbstate_t;

        [[nodiscard]] static inline int compare(const _Elem* const _First1, const _Elem* const _First2, const size_t _Count) noexcept
        {
            return ::memcmp(_First1, _First2, _Count);
        }

        [[nodiscard]] static inline size_t length(const _Elem* const _First) noexcept
        {
            return ::strlen(reinterpret_cast<const char*>(_First));
        }

        static _Elem* copy(_Elem* const _First1, const _Elem* const _First2, const size_t _Count) noexcept
        {
            return static_cast<_Elem*>(::memcpy(_First1, _First2, _Count));
        }

        static _Elem* _Copy_s(_Elem* const _First1, const size_t _Size_in_bytes, const _Elem* const _First2, const size_t _Count) noexcept
        {
            do
            {
                if(_Count <= _Size_in_bytes)
                {
                }
                else
                {
                    do
                    {
                        ;
                        ::_invalid_parameter_noinfo_noreturn();
                    } while(false);
                };
            } while(false);
            return copy(_First1, _First2, _Count);
        }

        [[nodiscard]] static inline const _Elem* find(const _Elem* const _First, const size_t _Count, const _Elem& _Ch) noexcept
        {
            return static_cast<const _Elem*>(::memchr(_First, _Ch, _Count));
        }

        static _Elem* move(_Elem* const _First1, const _Elem* const _First2, const size_t _Count) noexcept
        {
            return static_cast<_Elem*>(::memmove(_First1, _First2, _Count));
        }

        static _Elem* assign(_Elem* const _First, const size_t _Count, const _Elem _Ch) noexcept
        {
            return static_cast<_Elem*>(::memset(_First, _Ch, _Count));
        }

        static inline void assign(_Elem& _Left, const _Elem& _Right) noexcept
        {
            _Left = _Right;
        }

        [[nodiscard]] static constexpr bool eq(const _Elem& _Left, const _Elem& _Right) noexcept
        {
            return _Left == _Right;
        }

        [[nodiscard]] static constexpr bool lt(const _Elem& _Left, const _Elem& _Right) noexcept
        {
            return static_cast<unsigned char>(_Left) < static_cast<unsigned char>(_Right);
        }

        [[nodiscard]] static constexpr _Elem to_char_type(const int_type& _Meta) noexcept
        {
            return static_cast<_Elem>(_Meta);
        }

        [[nodiscard]] static constexpr int_type to_int_type(const _Elem& _Ch) noexcept
        {
            return static_cast<unsigned char>(_Ch);
        }

        [[nodiscard]] static constexpr bool eq_int_type(const int_type& _Left, const int_type& _Right) noexcept
        {
            return _Left == _Right;
        }

        [[nodiscard]] static constexpr int_type not_eof(const int_type& _Meta) noexcept
        {
            return _Meta != eof() ? _Meta : !eof();
        }

        [[nodiscard]] static constexpr int_type eof() noexcept
        {
            return static_cast<int_type>((-1));
        }
    };

    template <> struct char_traits<char> : _Narrow_char_traits<char, int>
    {
    };

    template <class _Elem, class _Traits, class _SizeT>
    basic_ostream<_Elem, _Traits>& _Insert_string(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* const _Data, const _SizeT _Size)
    {
        using _Ostr_t = basic_ostream<_Elem, _Traits>;
        typename _Ostr_t::iostate _State = _Ostr_t::goodbit;

        _SizeT _Pad;
        if(_Ostr.width() <= 0 || static_cast<_SizeT>(_Ostr.width()) <= _Size)
        {
            _Pad = 0;
        }
        else
        {
            _Pad = static_cast<_SizeT>(_Ostr.width()) - _Size;
        }

        const typename _Ostr_t::sentry _Ok(_Ostr);

        if(!_Ok)
        {
            _State |= _Ostr_t::badbit;
        }
        else
        {
            try
            {
                if((_Ostr.flags() & _Ostr_t::adjustfield) != _Ostr_t::left)
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= _Ostr_t::badbit;
                            break;
                        }
                    }
                }

                if(_State == _Ostr_t::goodbit
                   && _Ostr.rdbuf()->sputn(_Data, static_cast<streamsize>(_Size)) != static_cast<streamsize>(_Size))
                {
                    _State |= _Ostr_t::badbit;
                }
                else
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= _Ostr_t::badbit;
                            break;
                        }
                    }
                }

                _Ostr.width(0);
            }
            catch(...)
            {
                (_Ostr).setstate(_Ostr_t::badbit, true);
            }
        }

        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Traits> struct _Char_traits_eq
    {
        using _Elem = typename _Traits::char_type;

        bool operator()(_Elem _Left, _Elem _Right) const
        {
            return _Traits::eq(_Left, _Right);
        }
    };

    template <class _Traits> struct _Char_traits_lt
    {
        using _Elem = typename _Traits::char_type;

        bool operator()(_Elem _Left, _Elem _Right) const
        {
            return _Traits::lt(_Left, _Right);
        }
    };

    template <class _Elem>
    struct _Equal_memcmp_is_safe_helper<_Elem, _Elem, _Char_traits_eq<char_traits<_Elem>>>
    : _Equal_memcmp_is_safe_helper<_Elem, _Elem, equal_to<>>::type
    {
    };

    template <class _Traits> using _Traits_ch_t = typename _Traits::char_type;

    template <class _Traits> using _Traits_ptr_t = const typename _Traits::char_type*;

    template <class _Traits>
    constexpr bool
    _Traits_equal(const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size, const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept
    {
        return _Left_size == _Right_size && _Traits::compare(_Left, _Right, _Left_size) == 0;
    }

    template <class _Traits>
    constexpr int
    _Traits_compare(const _Traits_ptr_t<_Traits> _Left, const size_t _Left_size, const _Traits_ptr_t<_Traits> _Right, const size_t _Right_size) noexcept
    {
        const int _Ans = _Traits::compare(_Left, _Right, _Min_value(_Left_size, _Right_size));

        if(_Ans != 0)
        {
            return _Ans;
        }

        if(_Left_size < _Right_size)
        {
            return -1;
        }

        if(_Left_size > _Right_size)
        {
            return 1;
        }

        return 0;
    }

    template <class _Traits>
    constexpr size_t _Traits_find(const _Traits_ptr_t<_Traits> _Haystack,
                                  const size_t _Hay_size,
                                  const size_t _Start_at,
                                  const _Traits_ptr_t<_Traits> _Needle,
                                  const size_t _Needle_size) noexcept
    {
        if(_Needle_size > _Hay_size || _Start_at > _Hay_size - _Needle_size)
        {
            return static_cast<size_t>(-1);
        }

        if(_Needle_size == 0)
        {
            return _Start_at;
        }

        const auto _Possible_matches_end = _Haystack + (_Hay_size - _Needle_size) + 1;
        for(auto _Match_try = _Haystack + _Start_at;; ++_Match_try)
        {
            _Match_try = _Traits::find(_Match_try, static_cast<size_t>(_Possible_matches_end - _Match_try), *_Needle);
            if(!_Match_try)
            {
                return static_cast<size_t>(-1);
            }

            if(_Traits::compare(_Match_try, _Needle, _Needle_size) == 0)
            {
                return static_cast<size_t>(_Match_try - _Haystack);
            }
        }
    }

    template <class _Traits>
    constexpr size_t _Traits_find_ch(const _Traits_ptr_t<_Traits> _Haystack,
                                     const size_t _Hay_size,
                                     const size_t _Start_at,
                                     const _Traits_ch_t<_Traits> _Ch) noexcept
    {
        if(_Start_at < _Hay_size)
        {
            const auto _Found_at = _Traits::find(_Haystack + _Start_at, _Hay_size - _Start_at, _Ch);
            if(_Found_at)
            {
                return static_cast<size_t>(_Found_at - _Haystack);
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_rfind(const _Traits_ptr_t<_Traits> _Haystack,
                                   const size_t _Hay_size,
                                   const size_t _Start_at,
                                   const _Traits_ptr_t<_Traits> _Needle,
                                   const size_t _Needle_size) noexcept
    {
        if(_Needle_size == 0)
        {
            return _Min_value(_Start_at, _Hay_size);
        }

        if(_Needle_size <= _Hay_size)
        {
            for(auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - _Needle_size);; --_Match_try)
            {
                if(_Traits::eq(*_Match_try, *_Needle) && _Traits::compare(_Match_try, _Needle, _Needle_size) == 0)
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }

                if(_Match_try == _Haystack)
                {
                    break;
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_rfind_ch(const _Traits_ptr_t<_Traits> _Haystack,
                                      const size_t _Hay_size,
                                      const size_t _Start_at,
                                      const _Traits_ch_t<_Traits> _Ch) noexcept
    {
        if(_Hay_size != 0)
        {
            for(auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try)
            {
                if(_Traits::eq(*_Match_try, _Ch))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }

                if(_Match_try == _Haystack)
                {
                    break;
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Elem, bool = _Is_character<_Elem>::value> class _String_bitmap
    {
    public:
        constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last)
        {
            for(; _First != _Last; ++_First)
            {
                _Matches[static_cast<unsigned char>(*_First)] = true;
            }

            return true;
        }

        constexpr bool _Match(const _Elem _Ch) const
        {
            return _Matches[static_cast<unsigned char>(_Ch)];
        }

    private:
        bool _Matches[256] = {};
    };

    template <class _Elem> class _String_bitmap<_Elem, false>
    {
    public:
        static_assert(is_unsigned_v<_Elem>,
                      "Standard char_traits is only provided for char, wchar_t, char16_t, and char32_t. See N5687 "
                      "[char.traits]. "
                      "Visual C++ accepts other unsigned integral types as an extension.");

        constexpr bool _Mark(const _Elem* _First, const _Elem* const _Last)
        {
            for(; _First != _Last; ++_First)
            {
                const auto _Ch = *_First;
                if(_Ch >= 256U)
                {
                    return false;
                }

                _Matches[static_cast<unsigned char>(_Ch)] = true;
            }

            return true;
        }

        constexpr bool _Match(const _Elem _Ch) const
        {
            return _Ch < 256U && _Matches[_Ch];
        }

    private:
        bool _Matches[256] = {};
    };

    template <class _Traits>
    constexpr size_t _Traits_find_first_of(const _Traits_ptr_t<_Traits> _Haystack,
                                           const size_t _Hay_size,
                                           const size_t _Start_at,
                                           const _Traits_ptr_t<_Traits> _Needle,
                                           const size_t _Needle_size,
                                           false_type) noexcept
    {
        if(_Needle_size != 0 && _Start_at < _Hay_size)
        {
            const auto _End = _Haystack + _Hay_size;
            for(auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
            {
                if(_Traits::find(_Needle, _Needle_size, *_Match_try))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_find_first_of(const _Traits_ptr_t<_Traits> _Haystack,
                                           const size_t _Hay_size,
                                           const size_t _Start_at,
                                           const _Traits_ptr_t<_Traits> _Needle,
                                           const size_t _Needle_size,
                                           true_type) noexcept
    {
        if(_Needle_size != 0 && _Start_at < _Hay_size)
        {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if(!_Matches._Mark(_Needle, _Needle + _Needle_size))
            {
                return _Traits_find_first_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
            }

            const auto _End = _Haystack + _Hay_size;
            for(auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
            {
                if(_Matches._Match(*_Match_try))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_find_last_of(const _Traits_ptr_t<_Traits> _Haystack,
                                          const size_t _Hay_size,
                                          const size_t _Start_at,
                                          const _Traits_ptr_t<_Traits> _Needle,
                                          const size_t _Needle_size,
                                          false_type) noexcept
    {
        if(_Needle_size != 0 && _Hay_size != 0)
        {
            for(auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try)
            {
                if(_Traits::find(_Needle, _Needle_size, *_Match_try))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }

                if(_Match_try == _Haystack)
                {
                    break;
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_find_last_of(const _Traits_ptr_t<_Traits> _Haystack,
                                          const size_t _Hay_size,
                                          const size_t _Start_at,
                                          const _Traits_ptr_t<_Traits> _Needle,
                                          const size_t _Needle_size,
                                          true_type) noexcept
    {
        if(_Needle_size != 0 && _Hay_size != 0)
        {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if(!_Matches._Mark(_Needle, _Needle + _Needle_size))
            {
                return _Traits_find_last_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
            }

            for(auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try)
            {
                if(_Matches._Match(*_Match_try))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }

                if(_Match_try == _Haystack)
                {
                    break;
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_find_first_not_of(const _Traits_ptr_t<_Traits> _Haystack,
                                               const size_t _Hay_size,
                                               const size_t _Start_at,
                                               const _Traits_ptr_t<_Traits> _Needle,
                                               const size_t _Needle_size,
                                               false_type) noexcept
    {
        if(_Start_at < _Hay_size)
        {
            const auto _End = _Haystack + _Hay_size;
            for(auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
            {
                if(!_Traits::find(_Needle, _Needle_size, *_Match_try))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_find_first_not_of(const _Traits_ptr_t<_Traits> _Haystack,
                                               const size_t _Hay_size,
                                               const size_t _Start_at,
                                               const _Traits_ptr_t<_Traits> _Needle,
                                               const size_t _Needle_size,
                                               true_type) noexcept
    {
        if(_Start_at < _Hay_size)
        {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if(!_Matches._Mark(_Needle, _Needle + _Needle_size))
            {
                return _Traits_find_first_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
            }

            const auto _End = _Haystack + _Hay_size;
            for(auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
            {
                if(!_Matches._Match(*_Match_try))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_find_not_ch(const _Traits_ptr_t<_Traits> _Haystack,
                                         const size_t _Hay_size,
                                         const size_t _Start_at,
                                         const _Traits_ch_t<_Traits> _Ch) noexcept
    {
        if(_Start_at < _Hay_size)
        {
            const auto _End = _Haystack + _Hay_size;
            for(auto _Match_try = _Haystack + _Start_at; _Match_try < _End; ++_Match_try)
            {
                if(!_Traits::eq(*_Match_try, _Ch))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_find_last_not_of(const _Traits_ptr_t<_Traits> _Haystack,
                                              const size_t _Hay_size,
                                              const size_t _Start_at,
                                              const _Traits_ptr_t<_Traits> _Needle,
                                              const size_t _Needle_size,
                                              false_type) noexcept
    {
        if(_Hay_size != 0)
        {
            for(auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try)
            {
                if(!_Traits::find(_Needle, _Needle_size, *_Match_try))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }

                if(_Match_try == _Haystack)
                {
                    break;
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_find_last_not_of(const _Traits_ptr_t<_Traits> _Haystack,
                                              const size_t _Hay_size,
                                              const size_t _Start_at,
                                              const _Traits_ptr_t<_Traits> _Needle,
                                              const size_t _Needle_size,
                                              true_type) noexcept
    {
        if(_Hay_size != 0)
        {
            _String_bitmap<typename _Traits::char_type> _Matches;
            if(!_Matches._Mark(_Needle, _Needle + _Needle_size))
            {
                return _Traits_find_last_not_of<_Traits>(_Haystack, _Hay_size, _Start_at, _Needle, _Needle_size, false_type{});
            }

            for(auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try)
            {
                if(!_Matches._Match(*_Match_try))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }

                if(_Match_try == _Haystack)
                {
                    break;
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Traits>
    constexpr size_t _Traits_rfind_not_ch(const _Traits_ptr_t<_Traits> _Haystack,
                                          const size_t _Hay_size,
                                          const size_t _Start_at,
                                          const _Traits_ch_t<_Traits> _Ch) noexcept
    {
        if(_Hay_size != 0)
        {
            for(auto _Match_try = _Haystack + _Min_value(_Start_at, _Hay_size - 1);; --_Match_try)
            {
                if(!_Traits::eq(*_Match_try, _Ch))
                {
                    return static_cast<size_t>(_Match_try - _Haystack);
                }

                if(_Match_try == _Haystack)
                {
                    break;
                }
            }
        }

        return static_cast<size_t>(-1);
    }

    template <class _Mystr> class _String_const_iterator : public _Iterator_base
    {
    public:
        using iterator_category = random_access_iterator_tag;
        using value_type = typename _Mystr::value_type;
        using difference_type = typename _Mystr::difference_type;
        using pointer = typename _Mystr::const_pointer;
        using reference = const value_type&;

        _String_const_iterator() noexcept : _Ptr()
        {
        }

        _String_const_iterator(pointer _Parg, const _Container_base* _Pstring) noexcept : _Ptr(_Parg)
        {
            this->_Adopt(_Pstring);
        }

        [[nodiscard]] reference operator*() const
        {
            ;
            return *_Ptr;
        }

        [[nodiscard]] pointer operator->() const
        {
            return pointer_traits<pointer>::pointer_to(**this);
        }

        _String_const_iterator& operator++()
        {
            ++_Ptr;
            return *this;
        }

        _String_const_iterator operator++(int)
        {
            _String_const_iterator _Tmp = *this;
            ++*this;
            return _Tmp;
        }

        _String_const_iterator& operator--()
        {
            --_Ptr;
            return *this;
        }

        _String_const_iterator operator--(int)
        {
            _String_const_iterator _Tmp = *this;
            --*this;
            return _Tmp;
        }

        void _Verify_offset(const difference_type _Off) const noexcept
        {
            (void)_Off;
        }

        _String_const_iterator& operator+=(const difference_type _Off)
        {
            _Ptr += _Off;
            return *this;
        }

        [[nodiscard]] _String_const_iterator operator+(const difference_type _Off) const
        {
            _String_const_iterator _Tmp = *this;
            return _Tmp += _Off;
        }

        _String_const_iterator& operator-=(const difference_type _Off)
        {
            return *this += -_Off;
        }

        [[nodiscard]] _String_const_iterator operator-(const difference_type _Off) const
        {
            _String_const_iterator _Tmp = *this;
            return _Tmp -= _Off;
        }

        [[nodiscard]] difference_type operator-(const _String_const_iterator& _Right) const
        {
            _Compat(_Right);
            return _Ptr - _Right._Ptr;
        }

        [[nodiscard]] reference operator[](const difference_type _Off) const
        {
            return *(*this + _Off);
        }

        [[nodiscard]] bool operator==(const _String_const_iterator& _Right) const
        {
            _Compat(_Right);
            return _Ptr == _Right._Ptr;
        }

        [[nodiscard]] bool operator!=(const _String_const_iterator& _Right) const
        {
            return !(*this == _Right);
        }

        [[nodiscard]] bool operator<(const _String_const_iterator& _Right) const
        {
            _Compat(_Right);
            return _Ptr < _Right._Ptr;
        }

        [[nodiscard]] bool operator>(const _String_const_iterator& _Right) const
        {
            return _Right < *this;
        }

        [[nodiscard]] bool operator<=(const _String_const_iterator& _Right) const
        {
            return !(_Right < *this);
        }

        [[nodiscard]] bool operator>=(const _String_const_iterator& _Right) const
        {
            return !(*this < _Right);
        }

        void _Compat(const _String_const_iterator& _Right) const
        {
            (void)_Right;
        }

        using _Prevent_inheriting_unwrap = _String_const_iterator;

        [[nodiscard]] const value_type* _Unwrapped() const
        {
            return _Unfancy(_Ptr);
        }

        void _Seek_to(const value_type* _It)
        {
            _Ptr = _Refancy<pointer>(const_cast<value_type*>(_It));
        }

        pointer _Ptr;
    };

    template <class _Mystr>
    [[nodiscard]] _String_const_iterator<_Mystr>
    operator+(typename _String_const_iterator<_Mystr>::difference_type _Off, _String_const_iterator<_Mystr> _Next)
    {
        return _Next += _Off;
    }

    template <class _Mystr> class _String_iterator : public _String_const_iterator<_Mystr>
    {
    public:
        using _Mybase = _String_const_iterator<_Mystr>;

        using iterator_category = random_access_iterator_tag;
        using value_type = typename _Mystr::value_type;
        using difference_type = typename _Mystr::difference_type;
        using pointer = typename _Mystr::pointer;
        using reference = value_type&;

        using _Mybase::_Mybase;

        [[nodiscard]] reference operator*() const
        {
            return const_cast<reference>(_Mybase::operator*());
        }

        [[nodiscard]] pointer operator->() const
        {
            return pointer_traits<pointer>::pointer_to(**this);
        }

        _String_iterator& operator++()
        {
            _Mybase::operator++();
            return *this;
        }

        _String_iterator operator++(int)
        {
            _String_iterator _Tmp = *this;
            _Mybase::operator++();
            return _Tmp;
        }

        _String_iterator& operator--()
        {
            _Mybase::operator--();
            return *this;
        }

        _String_iterator operator--(int)
        {
            _String_iterator _Tmp = *this;
            _Mybase::operator--();
            return _Tmp;
        }

        _String_iterator& operator+=(const difference_type _Off)
        {
            _Mybase::operator+=(_Off);
            return *this;
        }

        [[nodiscard]] _String_iterator operator+(const difference_type _Off) const
        {
            _String_iterator _Tmp = *this;
            return _Tmp += _Off;
        }

        _String_iterator& operator-=(const difference_type _Off)
        {
            _Mybase::operator-=(_Off);
            return *this;
        }

        using _Mybase::operator-;

        [[nodiscard]] _String_iterator operator-(const difference_type _Off) const
        {
            _String_iterator _Tmp = *this;
            return _Tmp -= _Off;
        }

        [[nodiscard]] reference operator[](const difference_type _Off) const
        {
            return const_cast<reference>(_Mybase::operator[](_Off));
        }

        using _Prevent_inheriting_unwrap = _String_iterator;

        [[nodiscard]] value_type* _Unwrapped() const
        {
            return const_cast<value_type*>(_Unfancy(this->_Ptr));
        }
    };

    template <class _Mystr>
    [[nodiscard]] _String_iterator<_Mystr>
    operator+(typename _String_iterator<_Mystr>::difference_type _Off, _String_iterator<_Mystr> _Next)
    {
        return _Next += _Off;
    }

    template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer, class _Reference, class _Const_reference>
    struct _String_iter_types
    {
        using value_type = _Value_type;
        using size_type = _Size_type;
        using difference_type = _Difference_type;
        using pointer = _Pointer;
        using const_pointer = _Const_pointer;
    };

    template <class _Val_types> class _String_val : public _Container_base
    {
    public:
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = value_type&;
        using const_reference = const value_type&;

        _String_val() : _Bx(), _Mysize(0), _Myres(0)
        {
        }

        static constexpr size_type _BUF_SIZE = 16 / sizeof(value_type) < 1 ? 1 : 16 / sizeof(value_type);

        static constexpr size_type _ALLOC_MASK
        = sizeof(value_type) <= 1 ? 15 : sizeof(value_type) <= 2 ? 7 : sizeof(value_type) <= 4 ? 3 : sizeof(value_type) <= 8 ? 1 : 0;

        value_type* _Myptr()
        {
            value_type* _Result = _Bx._Buf;
            if(_Large_string_engaged())
            {
                _Result = _Unfancy(_Bx._Ptr);
            }

            return _Result;
        }

        const value_type* _Myptr() const
        {
            const value_type* _Result = _Bx._Buf;
            if(_Large_string_engaged())
            {
                _Result = _Unfancy(_Bx._Ptr);
            }

            return _Result;
        }

        bool _Large_string_engaged() const
        {
            return _BUF_SIZE <= _Myres;
        }

        void _Check_offset(const size_type _Off) const
        {
            if(_Mysize < _Off)
            {
                _Xran();
            }
        }

        void _Check_offset_exclusive(const size_type _Off) const
        {
            if(_Mysize <= _Off)
            {
                _Xran();
            }
        }

        [[noreturn]] static void _Xran()
        {
            _Xout_of_range("invalid string position");
        }

        size_type _Clamp_suffix_size(const size_type _Off, const size_type _Size) const noexcept
        {
            return _Min_value(_Size, _Mysize - _Off);
        }

        union _Bxty
        {
            _Bxty()
            {
            }

            ~_Bxty() noexcept
            {
            }

            value_type _Buf[_BUF_SIZE];
            pointer _Ptr;
            char _Alias[_BUF_SIZE];
        } _Bx;

        size_type _Mysize;
        size_type _Myres;
    };

    template <class _Ty> constexpr size_t _Size_after_ebco_v = is_empty_v<_Ty> ? 0 : sizeof(_Ty);

    template <class _Elem, class _Traits = char_traits<_Elem>, class _Alloc = allocator<_Elem>> class basic_string
    {
    private:
        friend _Tidy_deallocate_guard<basic_string>;

        using _Alty = _Rebind_alloc_t<_Alloc, _Elem>;
        using _Alty_traits = allocator_traits<_Alty>;

        using _Scary_val = _String_val<conditional_t<
        _Is_simple_alloc_v<_Alty>,
        _Simple_types<_Elem>,
        _String_iter_types<_Elem, typename _Alty_traits::size_type, typename _Alty_traits::difference_type, typename _Alty_traits::pointer, typename _Alty_traits::const_pointer, _Elem&, const _Elem&>>>;

        static_assert(!0 || is_same_v<_Elem, typename _Alloc::value_type>,
                      "basic_string<T, Traits, Allocator>"
                      " requires that Allocator's value_type match "
                      "T"
                      " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)"
                      " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0"
                      " to suppress this diagnostic.");

        static_assert(is_same_v<_Elem, typename _Traits::char_type>,
                      "N4659 24.3.2.1 [string.require]/3 requires that the supplied "
                      "char_traits character type match the string's character type.");

    public:
        using traits_type = _Traits;
        using allocator_type = _Alloc;

        using value_type = _Elem;
        using size_type = typename _Alty_traits::size_type;
        using difference_type = typename _Alty_traits::difference_type;
        using pointer = typename _Alty_traits::pointer;
        using const_pointer = typename _Alty_traits::const_pointer;
        using reference = value_type&;
        using const_reference = const value_type&;

        using iterator = _String_iterator<_Scary_val>;
        using const_iterator = _String_const_iterator<_Scary_val>;

        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;

    private:
        static constexpr auto _BUF_SIZE = _Scary_val::_BUF_SIZE;
        static constexpr auto _ALLOC_MASK = _Scary_val::_ALLOC_MASK;

        static constexpr bool _Can_memcpy_val = _Is_specialization_v<_Traits, char_traits> && is_trivial_v<pointer>;

        static constexpr size_t _Memcpy_val_offset = _Size_after_ebco_v<_Container_base>;
        static constexpr size_t _Memcpy_val_size = sizeof(_Scary_val) - _Memcpy_val_offset;

        template <class _Iter>
        using _Is_elem_cptr = bool_constant<_Is_any_of_v<_Iter, const _Elem* const, _Elem* const, const _Elem*, _Elem*>>;

    public:
        basic_string(const basic_string& _Right)
        : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal()))
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Construct_lv_contents(_Right);
            _Proxy._Release();
        }

        basic_string(const basic_string& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Construct_lv_contents(_Right);
            _Proxy._Release();
        }

        basic_string() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t())
        {
            _Mypair._Myval2._Alloc_proxy(_Fake_allocator());
            _Tidy_init();
        }

        explicit basic_string(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            _Mypair._Myval2._Alloc_proxy(_Fake_allocator());
            _Tidy_init();
        }

        basic_string(const basic_string& _Right, const size_type _Roff, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            assign(_Right, _Roff, npos);
            _Proxy._Release();
        }

        basic_string(const basic_string& _Right, const size_type _Roff, const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            assign(_Right, _Roff, _Count);
            _Proxy._Release();
        }

        basic_string(const _Elem* const _Ptr, const size_type _Count) : _Mypair(_Zero_then_variadic_args_t())
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            assign(_Ptr, _Count);
            _Proxy._Release();
        }

        basic_string(const _Elem* const _Ptr, const size_type _Count, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            assign(_Ptr, _Count);
            _Proxy._Release();
        }

        basic_string(const _Elem* const _Ptr) : _Mypair(_Zero_then_variadic_args_t())
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            assign(_Ptr);
            _Proxy._Release();
        }

        basic_string(const _Elem* const _Ptr, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            assign(_Ptr);
            _Proxy._Release();
        }

        basic_string(const size_type _Count, const _Elem _Ch) : _Mypair(_Zero_then_variadic_args_t())
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            assign(_Count, _Ch);
            _Proxy._Release();
        }

        basic_string(const size_type _Count, const _Elem _Ch, const _Alloc& _Al)
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            assign(_Count, _Ch);
            _Proxy._Release();
        }

        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
        basic_string(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            _Adl_verify_range(_First, _Last);
            _Construct(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>());
            _Proxy._Release();
        }

        template <class _Iter> void _Construct(_Iter _First, const _Iter _Last, input_iterator_tag)
        {
            _Tidy_deallocate_guard<basic_string> _Guard{ this };
            for(; _First != _Last; ++_First)
            {
                push_back(*_First);
            }

            _Guard._Target = nullptr;
        }

        template <class _Iter> void _Construct(const _Iter _First, const _Iter _Last, forward_iterator_tag)
        {
            const size_type _Count = _Convert_size<size_type>(static_cast<size_t>(::std::distance(_First, _Last)));
            reserve(_Count);
            _Construct(_First, _Last, input_iterator_tag());
        }

        void _Construct(_Elem* const _First, _Elem* const _Last, random_access_iterator_tag)
        {
            if(_First != _Last)
            {
                assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
            }
        }

        void _Construct(const _Elem* const _First, const _Elem* const _Last, random_access_iterator_tag)
        {
            if(_First != _Last)
            {
                assign(_First, _Convert_size<size_type>(static_cast<size_t>(_Last - _First)));
            }
        }

        basic_string(basic_string&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std::move(_Right._Getal()))
        {
            _Mypair._Myval2._Alloc_proxy(_Fake_allocator());
            _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
        }

        basic_string(basic_string&& _Right, const _Alloc& _Al) noexcept(_Alty_traits::is_always_equal::value)
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            if constexpr(!_Alty_traits::is_always_equal::value)
            {
                if(_Getal() != _Right._Getal())
                {
                    _Construct_lv_contents(_Right);
                    _Proxy._Release();
                    return;
                }
            }

            _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
            _Proxy._Release();
        }

    private:
        void _Move_assign(basic_string& _Right, _Equal_allocators) noexcept
        {
            _Tidy_deallocate();
            _Pocma(_Getal(), _Right._Getal());
            _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
        }

        void _Move_assign(basic_string& _Right, _Propagate_allocators) noexcept
        {
            if(_Getal() == _Right._Getal())
            {
                _Move_assign(_Right, _Equal_allocators{});
            }
            else
            {
                _Mypair._Myval2._Orphan_all();
                _Mypair._Myval2._Reload_proxy(_Fake_allocator(), _Fake_allocator());
                _Pocma(_Getal(), _Right._Getal());
                _Take_contents(_Right, bool_constant<_Can_memcpy_val>{});
            }
        }

        void _Move_assign(basic_string& _Right, _No_propagate_allocators)
        {
            if(_Getal() == _Right._Getal())
            {
                _Move_assign(_Right, _Equal_allocators{});
            }
            else
            {
                assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }

    public:
        basic_string& operator=(basic_string&& _Right) noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{})))
        {
            if(this != ::std::addressof(_Right))
            {
                _Move_assign(_Right, _Choose_pocma<_Alty>{});
            }

            return *this;
        }

        basic_string& assign(basic_string&& _Right) noexcept(noexcept(*this = ::std::move(_Right)))
        {
            *this = ::std::move(_Right);
            return *this;
        }

    private:
        void _Memcpy_val_from(const basic_string& _Right) noexcept
        {
            ;
            const auto _My_data_mem = reinterpret_cast<unsigned char*>(::std::addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
            const auto _Right_data_mem
            = reinterpret_cast<const unsigned char*>(::std::addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
            ::memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
        }

        void _Take_contents(basic_string& _Right, true_type) noexcept
        {
            _Memcpy_val_from(_Right);
            _Right._Tidy_init();
        }

        void _Take_contents(basic_string& _Right, false_type) noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            auto& _Right_data = _Right._Mypair._Myval2;
            if(_Right_data._Large_string_engaged())
            {
                _Construct_in_place(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
                _Right_data._Bx._Ptr = pointer();
                _Swap_proxy_and_iterators(_Right);
            }
            else
            {
                _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _Right_data._Mysize + 1);
                _Right_data._Orphan_all();
            }

            _My_data._Mysize = _Right_data._Mysize;
            _My_data._Myres = _Right_data._Myres;
            _Right._Tidy_init();
        }

        void _Construct_lv_contents(const basic_string& _Right)
        {
            auto& _Right_data = _Right._Mypair._Myval2;
            const size_type _Right_size = _Right_data._Mysize;
            const _Elem* const _Right_ptr = _Right_data._Myptr();
            auto& _My_data = _Mypair._Myval2;
            if(_Right_size < _BUF_SIZE)
            {
                _Traits::copy(_My_data._Bx._Buf, _Right_ptr, _BUF_SIZE);
                _My_data._Mysize = _Right_size;
                _My_data._Myres = _BUF_SIZE - 1;
                return;
            }

            auto& _Al = _Getal();
            const size_type _New_capacity = _Min_value(_Right_size | _ALLOC_MASK, max_size());
            const pointer _New_array = _Al.allocate(_New_capacity + 1);
            _Construct_in_place(_My_data._Bx._Ptr, _New_array);
            _Traits::copy(_Unfancy(_New_array), _Right_ptr, _Right_size + 1);
            _My_data._Mysize = _Right_size;
            _My_data._Myres = _New_capacity;
        }

    public:
        basic_string(initializer_list<_Elem> _Ilist, const _Alloc& _Al = allocator_type())
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Tidy_init();
            assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
            _Proxy._Release();
        }

        basic_string& operator=(initializer_list<_Elem> _Ilist)
        {
            return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        }

        basic_string& operator+=(initializer_list<_Elem> _Ilist)
        {
            return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        }

        basic_string& assign(initializer_list<_Elem> _Ilist)
        {
            return assign(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        }

        basic_string& append(initializer_list<_Elem> _Ilist)
        {
            return append(_Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        }

        iterator insert(const const_iterator _Where, const initializer_list<_Elem> _Ilist)
        {
            const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
            insert(_Off, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
            return begin() + static_cast<difference_type>(_Off);
        }

        basic_string& replace(const const_iterator _First, const const_iterator _Last, const initializer_list<_Elem> _Ilist)
        {
            _Adl_verify_range(_First, _Last);

            const auto _Offset = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
            const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
            return replace(_Offset, _Length, _Ilist.begin(), _Convert_size<size_type>(_Ilist.size()));
        }

        ~basic_string() noexcept
        {
            _Tidy_deallocate();
        }

        static constexpr auto npos{ static_cast<size_type>(-1) };

    private:
        void _Copy_assign_val_from_small(const basic_string& _Right)
        {
            _Tidy_deallocate();
            if constexpr(_Can_memcpy_val)
            {
                _Memcpy_val_from(_Right);
            }
            else
            {
                _Traits::copy(_Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Bx._Buf, _Right._Mypair._Myval2._Mysize + 1);
                _Mypair._Myval2._Mysize = _Right._Mypair._Myval2._Mysize;
                _Mypair._Myval2._Myres = _Right._Mypair._Myval2._Myres;
            }
        }

        void _Copy_assign(const basic_string& _Right, false_type)
        {
            _Pocca(_Getal(), _Right._Getal());
            assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        void _Copy_assign(const basic_string& _Right, true_type)
        {
            auto& _Al = _Getal();
            const auto& _Right_al = _Right._Getal();
            if(_Al == _Right_al)
            {
                _Copy_assign(_Right, false_type{});
                return;
            }

            auto&& _Alproxy = _Fake_allocator();
            auto&& _Right_alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _New_proxy(_Right_alproxy, _Leave_proxy_unbound{});

            if(_Right._Mypair._Myval2._Large_string_engaged())
            {
                const auto _New_size = _Right._Mypair._Myval2._Mysize;
                const auto _New_capacity = _Calculate_growth(_New_size, 0, _Right.max_size());
                auto _Right_al_non_const = _Right_al;
                const auto _New_ptr = _Right_al_non_const.allocate(_New_capacity);
                _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_Right._Mypair._Myval2._Bx._Ptr), _New_size + 1);
                _Tidy_deallocate();
                _Mypair._Myval2._Bx._Ptr = _New_ptr;
                _Mypair._Myval2._Mysize = _New_size;
                _Mypair._Myval2._Myres = _New_capacity;
            }
            else
            {
                _Copy_assign_val_from_small(_Right);
            }

            _Pocca(_Al, _Right_al);
            _New_proxy._Bind(_Alproxy, ::std::addressof(_Mypair._Myval2));
        }

    public:
        basic_string& operator=(const basic_string& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Copy_assign(_Right, _Choose_pocca<_Alty>{});
            }

            return *this;
        }

        basic_string& operator=(const _Elem* const _Ptr)
        {
            return assign(_Ptr);
        }

        basic_string& operator=(const _Elem _Ch)
        {
            _Mypair._Myval2._Mysize = 1;
            _Elem* const _Ptr = _Mypair._Myval2._Myptr();
            _Traits::assign(_Ptr[0], _Ch);
            _Traits::assign(_Ptr[1], _Elem());
            return *this;
        }

        basic_string& operator+=(const basic_string& _Right)
        {
            return append(_Right);
        }

        basic_string& operator+=(const _Elem* const _Ptr)
        {
            return append(_Ptr);
        }

        basic_string& operator+=(_Elem _Ch)
        {
            push_back(_Ch);
            return *this;
        }

        basic_string& append(const basic_string& _Right)
        {
            return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        basic_string& append(const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
        {
            _Right._Mypair._Myval2._Check_offset(_Roff);
            _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
            return append(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
        }

        basic_string& append(const _Elem* const _Ptr, const size_type _Count)
        {
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            if(_Count <= _Mypair._Myval2._Myres - _Old_size)
            {
                _Mypair._Myval2._Mysize = _Old_size + _Count;
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Traits::move(_Old_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
                return *this;
            }

            return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem* const _Ptr,
               const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::copy(_New_ptr + _Old_size, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Ptr, _Count);
        }

        basic_string& append(const _Elem* const _Ptr)
        {
            return append(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
        }

        basic_string& append(const size_type _Count, const _Elem _Ch)
        {
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            if(_Count <= _Mypair._Myval2._Myres - _Old_size)
            {
                _Mypair._Myval2._Mysize = _Old_size + _Count;
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Traits::assign(_Old_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_Old_ptr[_Old_size + _Count], _Elem());
                return *this;
            }

            return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr + _Old_size, _Count, _Ch);
                _Traits::assign(_New_ptr[_Old_size + _Count], _Elem());
            },
            _Count, _Ch);
        }

        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
        basic_string& append(const _Iter _First, const _Iter _Last)
        {
            _Adl_verify_range(_First, _Last);
            const auto _UFirst = _Get_unwrapped(_First);
            const auto _ULast = _Get_unwrapped(_Last);
            if constexpr(_Is_elem_cptr<decltype(_UFirst)>::value)
            {
                return append(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
            }
            else
            {
                const basic_string _Right(_UFirst, _ULast, get_allocator());
                return append(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }

        basic_string& assign(const basic_string& _Right)
        {
            *this = _Right;
            return *this;
        }

        basic_string& assign(const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
        {
            _Right._Mypair._Myval2._Check_offset(_Roff);
            _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
            return assign(_Right._Mypair._Myval2._Myptr() + _Roff, _Count);
        }

        basic_string& assign(const _Elem* const _Ptr, const size_type _Count)
        {
            if(_Count <= _Mypair._Myval2._Myres)
            {
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Mypair._Myval2._Mysize = _Count;
                _Traits::move(_Old_ptr, _Ptr, _Count);
                _Traits::assign(_Old_ptr[_Count], _Elem());
                return *this;
            }

            return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem* const _Ptr) {
                _Traits::copy(_New_ptr, _Ptr, _Count);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ptr);
        }

        basic_string& assign(const _Elem* const _Ptr)
        {
            return assign(_Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
        }

        basic_string& assign(const size_type _Count, const _Elem _Ch)
        {
            if(_Count <= _Mypair._Myval2._Myres)
            {
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Mypair._Myval2._Mysize = _Count;
                _Traits::assign(_Old_ptr, _Count, _Ch);
                _Traits::assign(_Old_ptr[_Count], _Elem());
                return *this;
            }

            return _Reallocate_for(
            _Count,
            [](_Elem* const _New_ptr, const size_type _Count, const _Elem _Ch) {
                _Traits::assign(_New_ptr, _Count, _Ch);
                _Traits::assign(_New_ptr[_Count], _Elem());
            },
            _Ch);
        }

        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
        basic_string& assign(const _Iter _First, const _Iter _Last)
        {
            _Adl_verify_range(_First, _Last);
            const auto _UFirst = _Get_unwrapped(_First);
            const auto _ULast = _Get_unwrapped(_Last);
            if constexpr(_Is_elem_cptr<decltype(_UFirst)>::value)
            {
                return assign(_UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
            }
            else
            {
                basic_string _Right(_UFirst, _ULast, get_allocator());
                if(_Mypair._Myval2._Myres < _Right._Mypair._Myval2._Myres)
                {
                    _Mypair._Myval2._Orphan_all();
                    _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
                    return *this;
                }
                else
                {
                    return assign(_Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
                }
            }
        }

        basic_string& insert(const size_type _Off, const basic_string& _Right)
        {
            return insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        basic_string& insert(const size_type _Off, const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
        {
            _Right._Mypair._Myval2._Check_offset(_Roff);
            _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
            return insert(_Off, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
        }

        basic_string& insert(const size_type _Off, const _Elem* const _Ptr, const size_type _Count)
        {
            _Mypair._Myval2._Check_offset(_Off);
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            if(_Count <= _Mypair._Myval2._Myres - _Old_size)
            {
                _Mypair._Myval2._Mysize = _Old_size + _Count;
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;

                size_type _Ptr_shifted_after;
                if(_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)
                {
                    _Ptr_shifted_after = _Count;
                }
                else if(_Insert_at <= _Ptr)
                {
                    _Ptr_shifted_after = 0;
                }
                else
                {
                    _Ptr_shifted_after = static_cast<size_type>(_Insert_at - _Ptr);
                }

                _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1);
                _Traits::copy(_Insert_at, _Ptr, _Ptr_shifted_after);
                _Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Count + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return *this;
            }

            return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
               const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Ptr, _Count);
        }

        basic_string& insert(const size_type _Off, const _Elem* const _Ptr)
        {
            return insert(_Off, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
        }

        basic_string& insert(const size_type _Off, const size_type _Count, const _Elem _Ch)
        {
            _Mypair._Myval2._Check_offset(_Off);
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            if(_Count <= _Mypair._Myval2._Myres - _Old_size)
            {
                _Mypair._Myval2._Mysize = _Old_size + _Count;
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Traits::move(_Insert_at + _Count, _Insert_at, _Old_size - _Off + 1);
                _Traits::assign(_Insert_at, _Count, _Ch);
                return *this;
            }

            return _Reallocate_grow_by(
            _Count,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
               const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off, _Old_size - _Off + 1);
            },
            _Off, _Count, _Ch);
        }

        iterator insert(const const_iterator _Where, const _Elem _Ch)
        {
            const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
            insert(_Off, 1, _Ch);
            return begin() + static_cast<difference_type>(_Off);
        }

        iterator insert(const const_iterator _Where, const size_type _Count, const _Elem _Ch)
        {
            const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
            insert(_Off, _Count, _Ch);
            return begin() + static_cast<difference_type>(_Off);
        }

        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
        iterator insert(const const_iterator _Where, const _Iter _First, const _Iter _Last)
        {
            const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
            _Adl_verify_range(_First, _Last);
            const auto _UFirst = _Get_unwrapped(_First);
            const auto _ULast = _Get_unwrapped(_Last);
            if constexpr(_Is_elem_cptr<decltype(_UFirst)>::value)
            {
                insert(_Off, _UFirst, _Convert_size<size_type>(static_cast<size_t>(_ULast - _UFirst)));
            }
            else
            {
                const basic_string _Right(_UFirst, _ULast, get_allocator());
                insert(_Off, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }

            return begin() + static_cast<difference_type>(_Off);
        }

        basic_string& erase(const size_type _Off = 0)
        {
            _Mypair._Myval2._Check_offset(_Off);
            _Eos(_Off);
            return *this;
        }

        basic_string& erase(const size_type _Off, size_type _Count)
        {
            _Mypair._Myval2._Check_offset(_Off);
            _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            _Elem* const _My_ptr = _Mypair._Myval2._Myptr();
            _Elem* const _Erase_at = _My_ptr + _Off;
            const size_type _New_size = _Old_size - _Count;
            _Mypair._Myval2._Mysize = _New_size;
            _Traits::move(_Erase_at, _Erase_at + _Count, _New_size - _Off + 1);
            return *this;
        }

        iterator erase(const const_iterator _Where) noexcept
        {
            const auto _Off = static_cast<size_type>(_Unfancy(_Where._Ptr) - _Mypair._Myval2._Myptr());
            erase(_Off, 1);
            return begin() + static_cast<difference_type>(_Off);
        }

        iterator erase(const const_iterator _First, const const_iterator _Last) noexcept
        {
            _Adl_verify_range(_First, _Last);

            const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
            erase(_Off, static_cast<size_type>(_Last._Ptr - _First._Ptr));
            return begin() + static_cast<difference_type>(_Off);
        }

        void clear() noexcept
        {
            _Eos(0);
        }

        basic_string& replace(const size_type _Off, const size_type _N0, const basic_string& _Right)
        {
            return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        basic_string&
        replace(const size_type _Off, size_type _N0, const basic_string& _Right, const size_type _Roff, size_type _Count = npos)
        {
            _Right._Mypair._Myval2._Check_offset(_Roff);
            _Count = _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count);
            return replace(_Off, _N0, _Right._Mypair._Myval2._Myptr() + _Roff, _Count);
        }

        basic_string& replace(const size_type _Off, size_type _N0, const _Elem* const _Ptr, const size_type _Count)
        {
            _Mypair._Myval2._Check_offset(_Off);
            _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
            if(_N0 == _Count)
            {
                _Traits::move(_Mypair._Myval2._Myptr() + _Off, _Ptr, _Count);
                return *this;
            }

            const size_type _Old_size = _Mypair._Myval2._Mysize;
            const size_type _Suffix_size = _Old_size - _N0 - _Off + 1;
            if(_Count < _N0)
            {
                _Mypair._Myval2._Mysize = _Old_size - (_N0 - _Count);
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Traits::move(_Insert_at, _Ptr, _Count);
                _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Suffix_size);
                return *this;
            }

            const size_type _Growth = static_cast<size_type>(_Count - _N0);
            if(_Growth <= _Mypair._Myval2._Myres - _Old_size)
            {
                _Mypair._Myval2._Mysize = _Old_size + _Growth;
                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Elem* const _Suffix_at = _Insert_at + _N0;

                size_type _Ptr_shifted_after;
                if(_Ptr + _Count <= _Insert_at || _Ptr > _Old_ptr + _Old_size)
                {
                    _Ptr_shifted_after = _Count;
                }
                else if(_Suffix_at <= _Ptr)
                {
                    _Ptr_shifted_after = 0;
                }
                else
                {
                    _Ptr_shifted_after = static_cast<size_type>(_Suffix_at - _Ptr);
                }

                _Traits::move(_Suffix_at + _Growth, _Suffix_at, _Suffix_size);

                _Traits::move(_Insert_at, _Ptr, _Ptr_shifted_after);

                _Traits::copy(_Insert_at + _Ptr_shifted_after, _Ptr + _Growth + _Ptr_shifted_after, _Count - _Ptr_shifted_after);
                return *this;
            }

            return _Reallocate_grow_by(
            _Growth,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
               const size_type _N0, const _Elem* const _Ptr, const size_type _Count) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::copy(_New_ptr + _Off, _Ptr, _Count);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
            },
            _Off, _N0, _Ptr, _Count);
        }

        basic_string& replace(const size_type _Off, const size_type _N0, const _Elem* const _Ptr)
        {
            return replace(_Off, _N0, _Ptr, _Convert_size<size_type>(_Traits::length(_Ptr)));
        }

        basic_string& replace(const size_type _Off, size_type _N0, const size_type _Count, const _Elem _Ch)
        {
            _Mypair._Myval2._Check_offset(_Off);
            _N0 = _Mypair._Myval2._Clamp_suffix_size(_Off, _N0);
            if(_Count == _N0)
            {
                _Traits::assign(_Mypair._Myval2._Myptr() + _Off, _Count, _Ch);
                return *this;
            }

            const size_type _Old_size = _Mypair._Myval2._Mysize;
            if(_Count < _N0 || _Count - _N0 <= _Mypair._Myval2._Myres - _Old_size)
            {
                _Mypair._Myval2._Mysize = _Old_size + _Count - _N0;

                _Elem* const _Old_ptr = _Mypair._Myval2._Myptr();
                _Elem* const _Insert_at = _Old_ptr + _Off;
                _Traits::move(_Insert_at + _Count, _Insert_at + _N0, _Old_size - _N0 - _Off + 1);
                _Traits::assign(_Insert_at, _Count, _Ch);
                return *this;
            }

            return _Reallocate_grow_by(
            _Count - _N0,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const size_type _Off,
               const size_type _N0, const size_type _Count, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Off);
                _Traits::assign(_New_ptr + _Off, _Count, _Ch);
                _Traits::copy(_New_ptr + _Off + _Count, _Old_ptr + _Off + _N0, _Old_size - _N0 - _Off + 1);
            },
            _Off, _N0, _Count, _Ch);
        }

        basic_string& replace(const const_iterator _First, const const_iterator _Last, const basic_string& _Right)
        {
            _Adl_verify_range(_First, _Last);

            return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
                           static_cast<size_type>(_Last._Ptr - _First._Ptr), _Right);
        }

        basic_string& replace(const const_iterator _First, const const_iterator _Last, const _Elem* const _Ptr, const size_type _Count)
        {
            _Adl_verify_range(_First, _Last);

            return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
                           static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr, _Count);
        }

        basic_string& replace(const const_iterator _First, const const_iterator _Last, const _Elem* const _Ptr)
        {
            _Adl_verify_range(_First, _Last);

            return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
                           static_cast<size_type>(_Last._Ptr - _First._Ptr), _Ptr);
        }

        basic_string& replace(const const_iterator _First, const const_iterator _Last, const size_type _Count, const _Elem _Ch)
        {
            _Adl_verify_range(_First, _Last);

            return replace(static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr()),
                           static_cast<size_type>(_Last._Ptr - _First._Ptr), _Count, _Ch);
        }

        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
        basic_string& replace(const const_iterator _First, const const_iterator _Last, const _Iter _First2, const _Iter _Last2)
        {
            _Adl_verify_range(_First, _Last);

            const auto _Off = static_cast<size_type>(_Unfancy(_First._Ptr) - _Mypair._Myval2._Myptr());
            const auto _Length = static_cast<size_type>(_Last._Ptr - _First._Ptr);
            _Adl_verify_range(_First2, _Last2);
            const auto _UFirst2 = _Get_unwrapped(_First2);
            const auto _ULast2 = _Get_unwrapped(_Last2);
            if constexpr(_Is_elem_cptr<decltype(_UFirst2)>::value)
            {
                return replace(_Off, _Length, _UFirst2, _Convert_size<size_type>(static_cast<size_t>(_ULast2 - _UFirst2)));
            }
            else
            {
                const basic_string _Right(_UFirst2, _ULast2, get_allocator());
                return replace(_Off, _Length, _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
            }
        }

        [[nodiscard]] iterator begin() noexcept
        {
            return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()), ::std::addressof(_Mypair._Myval2));
        }

        [[nodiscard]] const_iterator begin() const noexcept
        {
            return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr()), ::std::addressof(_Mypair._Myval2));
        }

        [[nodiscard]] iterator end() noexcept
        {
            return iterator(_Refancy<pointer>(_Mypair._Myval2._Myptr()) + static_cast<difference_type>(_Mypair._Myval2._Mysize),
                            ::std::addressof(_Mypair._Myval2));
        }

        [[nodiscard]] const_iterator end() const noexcept
        {
            return const_iterator(_Refancy<const_pointer>(_Mypair._Myval2._Myptr())
                                  + static_cast<difference_type>(_Mypair._Myval2._Mysize),
                                  ::std::addressof(_Mypair._Myval2));
        }

        _Elem* _Unchecked_begin() noexcept
        {
            return _Mypair._Myval2._Myptr();
        }

        const _Elem* _Unchecked_begin() const noexcept
        {
            return _Mypair._Myval2._Myptr();
        }

        _Elem* _Unchecked_end() noexcept
        {
            return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
        }

        const _Elem* _Unchecked_end() const noexcept
        {
            return _Mypair._Myval2._Myptr() + _Mypair._Myval2._Mysize;
        }

        [[nodiscard]] reverse_iterator rbegin() noexcept
        {
            return reverse_iterator(end());
        }

        [[nodiscard]] const_reverse_iterator rbegin() const noexcept
        {
            return const_reverse_iterator(end());
        }

        [[nodiscard]] reverse_iterator rend() noexcept
        {
            return reverse_iterator(begin());
        }

        [[nodiscard]] const_reverse_iterator rend() const noexcept
        {
            return const_reverse_iterator(begin());
        }

        [[nodiscard]] const_iterator cbegin() const noexcept
        {
            return begin();
        }

        [[nodiscard]] const_iterator cend() const noexcept
        {
            return end();
        }

        [[nodiscard]] const_reverse_iterator crbegin() const noexcept
        {
            return rbegin();
        }

        [[nodiscard]] const_reverse_iterator crend() const noexcept
        {
            return rend();
        }

        void shrink_to_fit()
        {
            auto& _My_data = _Mypair._Myval2;
            if(!_My_data._Large_string_engaged())
            {
                return;
            }

            if(_My_data._Mysize < _BUF_SIZE)
            {
                _Become_small();
                return;
            }

            const size_type _Target_capacity = _Min_value(_My_data._Mysize | _ALLOC_MASK, max_size());
            if(_Target_capacity < _My_data._Myres)
            {
                auto& _Al = _Getal();
                const pointer _New_ptr = _Al.allocate(_Target_capacity + 1);
                _My_data._Orphan_all();
                _Traits::copy(_Unfancy(_New_ptr), _Unfancy(_My_data._Bx._Ptr), _My_data._Mysize + 1);
                _Al.deallocate(_My_data._Bx._Ptr, _My_data._Myres + 1);
                _My_data._Bx._Ptr = _New_ptr;
                _My_data._Myres = _Target_capacity;
            }
        }

        [[nodiscard]] reference at(const size_type _Off)
        {
            _Mypair._Myval2._Check_offset_exclusive(_Off);
            return _Mypair._Myval2._Myptr()[_Off];
        }

        [[nodiscard]] const_reference at(const size_type _Off) const
        {
            _Mypair._Myval2._Check_offset_exclusive(_Off);
            return _Mypair._Myval2._Myptr()[_Off];
        }

        [[nodiscard]] reference operator[](const size_type _Off) noexcept
        {
            return _Mypair._Myval2._Myptr()[_Off];
        }

        [[nodiscard]] const_reference operator[](const size_type _Off) const noexcept
        {
            return _Mypair._Myval2._Myptr()[_Off];
        }

        void push_back(const _Elem _Ch)
        {
            const size_type _Old_size = _Mypair._Myval2._Mysize;
            if(_Old_size < _Mypair._Myval2._Myres)
            {
                _Mypair._Myval2._Mysize = _Old_size + 1;
                _Elem* const _Ptr = _Mypair._Myval2._Myptr();
                _Traits::assign(_Ptr[_Old_size], _Ch);
                _Traits::assign(_Ptr[_Old_size + 1], _Elem());
                return;
            }

            _Reallocate_grow_by(
            1,
            [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size, const _Elem _Ch) {
                _Traits::copy(_New_ptr, _Old_ptr, _Old_size);
                _Traits::assign(_New_ptr[_Old_size], _Ch);
                _Traits::assign(_New_ptr[_Old_size + 1], _Elem());
            },
            _Ch);
        }

        void pop_back() noexcept
        {
            const size_type _Old_size = _Mypair._Myval2._Mysize;

            _Eos(_Old_size - 1);
        }

        [[nodiscard]] reference front() noexcept
        {
            return _Mypair._Myval2._Myptr()[0];
        }

        [[nodiscard]] const_reference front() const noexcept
        {
            return _Mypair._Myval2._Myptr()[0];
        }

        [[nodiscard]] reference back() noexcept
        {
            return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
        }

        [[nodiscard]] const_reference back() const noexcept
        {
            return _Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize - 1];
        }

        [[nodiscard]] const _Elem* c_str() const noexcept
        {
            return _Mypair._Myval2._Myptr();
        }

        [[nodiscard]] const _Elem* data() const noexcept
        {
            return _Mypair._Myval2._Myptr();
        }

        [[nodiscard]] size_type length() const noexcept
        {
            return _Mypair._Myval2._Mysize;
        }

        [[nodiscard]] size_type size() const noexcept
        {
            return _Mypair._Myval2._Mysize;
        }

        [[nodiscard]] size_type max_size() const noexcept
        {
            const size_type _Alloc_max = _Alty_traits::max_size(_Getal());
            const size_type _Storage_max = _Max_value(_Alloc_max, static_cast<size_type>(_BUF_SIZE));
            return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()), _Storage_max - 1);
        }

        void resize(const size_type _Newsize, const _Elem _Ch = _Elem())
        {
            const size_type _Old_size = size();
            if(_Newsize <= _Old_size)
            {
                _Eos(_Newsize);
            }
            else
            {
                append(_Newsize - _Old_size, _Ch);
            }
        }

        [[nodiscard]] size_type capacity() const noexcept
        {
            return _Mypair._Myval2._Myres;
        }

        void reserve(const size_type _Newcap = 0)
        {
            if(_Mypair._Myval2._Mysize > _Newcap)
            {
                return;
            }

            if(_Mypair._Myval2._Myres == _Newcap)
            {
                return;
            }

            if(_Mypair._Myval2._Myres < _Newcap)
            {
                const size_type _Old_size = _Mypair._Myval2._Mysize;
                _Reallocate_grow_by(_Newcap - _Old_size,
                                    [](_Elem* const _New_ptr, const _Elem* const _Old_ptr, const size_type _Old_size) {
                                        _Traits::copy(_New_ptr, _Old_ptr, _Old_size + 1);
                                    });

                _Mypair._Myval2._Mysize = _Old_size;
                return;
            }

            if(_BUF_SIZE > _Newcap && _Mypair._Myval2._Large_string_engaged())
            {
                _Become_small();
                return;
            }
        }

        [[nodiscard]] bool empty() const noexcept
        {
            return size() == 0;
        }

        size_type copy(_Elem* const _Ptr, size_type _Count, const size_type _Off = 0) const
        {
            _Mypair._Myval2._Check_offset(_Off);
            _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
            _Traits::copy(_Ptr, _Mypair._Myval2._Myptr() + _Off, _Count);
            return _Count;
        }

        size_type _Copy_s(_Elem* const _Dest, const size_type _Dest_size, size_type _Count, const size_type _Off = 0) const
        {
            _Mypair._Myval2._Check_offset(_Off);
            _Count = _Mypair._Myval2._Clamp_suffix_size(_Off, _Count);
            _Traits::_Copy_s(_Dest, _Dest_size, _Mypair._Myval2._Myptr() + _Off, _Count);
            return _Count;
        }

        void _Swap_data(basic_string& _Right, true_type)
        {
            const auto _My_data_mem = reinterpret_cast<unsigned char*>(::std::addressof(_Mypair._Myval2)) + _Memcpy_val_offset;
            const auto _Right_data_mem = reinterpret_cast<unsigned char*>(::std::addressof(_Right._Mypair._Myval2)) + _Memcpy_val_offset;
            unsigned char _Temp_mem[_Memcpy_val_size];
            ::memcpy(_Temp_mem, _My_data_mem, _Memcpy_val_size);
            ::memcpy(_My_data_mem, _Right_data_mem, _Memcpy_val_size);
            ::memcpy(_Right_data_mem, _Temp_mem, _Memcpy_val_size);
        }

        void _Swap_bx_large_with_small(_Scary_val& _Starts_large, _Scary_val& _Starts_small)
        {
            const pointer _Ptr = _Starts_large._Bx._Ptr;
            _Destroy_in_place(_Starts_large._Bx._Ptr);
            _Traits::copy(_Starts_large._Bx._Buf, _Starts_small._Bx._Buf, _BUF_SIZE);
            _Construct_in_place(_Starts_small._Bx._Ptr, _Ptr);
        }

        void _Swap_data(basic_string& _Right, false_type)
        {
            auto& _My_data = _Mypair._Myval2;
            auto& _Right_data = _Right._Mypair._Myval2;
            const bool _My_large = _My_data._Large_string_engaged();
            const bool _Right_large = _Right_data._Large_string_engaged();
            if(_My_large)
            {
                if(_Right_large)
                {
                    _Swap_adl(_My_data._Bx._Ptr, _Right_data._Bx._Ptr);
                }
                else
                {
                    _Swap_bx_large_with_small(_My_data, _Right_data);
                }
            }
            else
            {
                if(_Right_large)
                {
                    _Swap_bx_large_with_small(_Right_data, _My_data);
                }
                else
                {
                    _Elem _Temp_buf[_BUF_SIZE];
                    _Traits::copy(_Temp_buf, _My_data._Bx._Buf, _BUF_SIZE);
                    _Traits::copy(_My_data._Bx._Buf, _Right_data._Bx._Buf, _BUF_SIZE);
                    _Traits::copy(_Right_data._Bx._Buf, _Temp_buf, _BUF_SIZE);
                }
            }

            ::std::swap(_My_data._Mysize, _Right_data._Mysize);
            ::std::swap(_My_data._Myres, _Right_data._Myres);
        }

        void swap(basic_string& _Right) noexcept
        {
            if(this != ::std::addressof(_Right))
            {
                _Pocs(_Getal(), _Right._Getal());
            }

            _Swap_data(_Right, bool_constant<_Can_memcpy_val>{});
        }

        [[nodiscard]] size_type find(const basic_string& _Right, const size_type _Off = 0) const noexcept
        {
            return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
                                                                _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
        }

        [[nodiscard]] size_type find(const _Elem* const _Ptr, const size_type _Off, const size_type _Count) const noexcept
        {
            return static_cast<size_type>(_Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
        }

        [[nodiscard]] size_type find(const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
        {
            return static_cast<size_type>(
            _Traits_find<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Traits::length(_Ptr)));
        }

        [[nodiscard]] size_type find(const _Elem _Ch, const size_type _Off = 0) const noexcept
        {
            return static_cast<size_type>(_Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
        }

        [[nodiscard]] size_type rfind(const basic_string& _Right, const size_type _Off = npos) const noexcept
        {
            return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off,
                                                                 _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize));
        }

        [[nodiscard]] size_type rfind(const _Elem* const _Ptr, const size_type _Off, const size_type _Count) const noexcept
        {
            return static_cast<size_type>(
            _Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count));
        }

        [[nodiscard]] size_type rfind(const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
        {
            return static_cast<size_type>(_Traits_rfind<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
                                                                 _Off, _Ptr, _Traits::length(_Ptr)));
        }

        [[nodiscard]] size_type rfind(const _Elem _Ch, const size_type _Off = npos) const noexcept
        {
            return static_cast<size_type>(_Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
        }

        [[nodiscard]] size_type find_first_of(const basic_string& _Right, const size_type _Off = 0) const noexcept
        {
            return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(),
            _Right._Mypair._Myval2._Mysize, _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_first_of(const _Elem* const _Ptr, const size_type _Off, const size_type _Count) const noexcept
        {
            return static_cast<size_type>(_Traits_find_first_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_first_of(const _Elem* const _Ptr, const size_type _Off = 0) const noexcept
        {
            return static_cast<size_type>(_Traits_find_first_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
                                                                         _Off, _Ptr, _Traits::length(_Ptr),
                                                                         _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_first_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
        {
            return static_cast<size_type>(_Traits_find_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
        }

        [[nodiscard]] size_type find_last_of(const basic_string& _Right, size_type _Off = npos) const noexcept
        {
            return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(),
            _Right._Mypair._Myval2._Mysize, _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_last_of(const _Elem* const _Ptr, const size_type _Off, const size_type _Count) const noexcept
        {
            return static_cast<size_type>(_Traits_find_last_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_last_of(const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
        {
            return static_cast<size_type>(_Traits_find_last_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
                                                                        _Off, _Ptr, _Traits::length(_Ptr),
                                                                        _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_last_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
        {
            return static_cast<size_type>(_Traits_rfind_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
        }

        [[nodiscard]] size_type find_first_not_of(const basic_string& _Right, const size_type _Off = 0) const noexcept
        {
            return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(),
            _Right._Mypair._Myval2._Mysize, _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_first_not_of(const _Elem* const _Ptr, const size_type _Off, const size_type _Count) const noexcept
        {
            return static_cast<size_type>(_Traits_find_first_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_first_not_of(const _Elem* const _Ptr, size_type _Off = 0) const noexcept
        {
            return static_cast<size_type>(
            _Traits_find_first_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr,
                                               _Traits::length(_Ptr), _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_first_not_of(const _Elem _Ch, const size_type _Off = 0) const noexcept
        {
            return static_cast<size_type>(_Traits_find_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
        }

        [[nodiscard]] size_type find_last_not_of(const basic_string& _Right, const size_type _Off = npos) const noexcept
        {
            return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Right._Mypair._Myval2._Myptr(),
            _Right._Mypair._Myval2._Mysize, _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_last_not_of(const _Elem* const _Ptr, const size_type _Off, const size_type _Count) const noexcept
        {
            return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(
            _Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ptr, _Count, _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_last_not_of(const _Elem* const _Ptr, const size_type _Off = npos) const noexcept
        {
            return static_cast<size_type>(_Traits_find_last_not_of<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
                                                                            _Off, _Ptr, _Traits::length(_Ptr),
                                                                            _Is_specialization<_Traits, char_traits>{}));
        }

        [[nodiscard]] size_type find_last_not_of(const _Elem _Ch, const size_type _Off = npos) const noexcept
        {
            return static_cast<size_type>(_Traits_rfind_not_ch<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Off, _Ch));
        }

        [[nodiscard]] basic_string substr(const size_type _Off = 0, const size_type _Count = npos) const
        {
            return basic_string(*this, _Off, _Count, get_allocator());
        }

        bool _Equal(const basic_string& _Right) const noexcept
        {
            return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
                                          _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        bool _Equal(const _Elem* const _Ptr) const noexcept
        {
            return _Traits_equal<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
        }

        [[nodiscard]] int compare(const basic_string& _Right) const noexcept
        {
            return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize,
                                            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        [[nodiscard]] int compare(size_type _Off, size_type _N0, const basic_string& _Right) const
        {
            _Mypair._Myval2._Check_offset(_Off);
            return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _N0),
                                            _Right._Mypair._Myval2._Myptr(), _Right._Mypair._Myval2._Mysize);
        }

        [[nodiscard]] int
        compare(const size_type _Off, const size_type _N0, const basic_string& _Right, const size_type _Roff, const size_type _Count = npos) const
        {
            _Mypair._Myval2._Check_offset(_Off);
            _Right._Mypair._Myval2._Check_offset(_Roff);
            return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off, _Mypair._Myval2._Clamp_suffix_size(_Off, _N0),
                                            _Right._Mypair._Myval2._Myptr() + _Roff,
                                            _Right._Mypair._Myval2._Clamp_suffix_size(_Roff, _Count));
        }

        [[nodiscard]] int compare(const _Elem* const _Ptr) const noexcept
        {
            return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr(), _Mypair._Myval2._Mysize, _Ptr, _Traits::length(_Ptr));
        }

        [[nodiscard]] int compare(const size_type _Off, const size_type _N0, const _Elem* const _Ptr) const
        {
            _Mypair._Myval2._Check_offset(_Off);
            return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off,
                                            _Mypair._Myval2._Clamp_suffix_size(_Off, _N0), _Ptr, _Traits::length(_Ptr));
        }

        [[nodiscard]] int compare(const size_type _Off, const size_type _N0, const _Elem* const _Ptr, const size_type _Count) const
        {
            _Mypair._Myval2._Check_offset(_Off);
            return _Traits_compare<_Traits>(_Mypair._Myval2._Myptr() + _Off,
                                            _Mypair._Myval2._Clamp_suffix_size(_Off, _N0), _Ptr, _Count);
        }

        [[nodiscard]] allocator_type get_allocator() const noexcept
        {
            return static_cast<allocator_type>(_Getal());
        }

    private:
        [[nodiscard]] static size_type _Calculate_growth(const size_type _Requested, const size_type _Old, const size_type _Max) noexcept
        {
            const size_type _Masked = _Requested | _ALLOC_MASK;
            if(_Masked > _Max)
            {
                return _Max;
            }

            if(_Old > _Max - _Old / 2)
            {
                return _Max;
            }

            return _Max_value(_Masked, _Old + _Old / 2);
        }

        [[nodiscard]] size_type _Calculate_growth(const size_type _Requested) const noexcept
        {
            return _Calculate_growth(_Requested, _Mypair._Myval2._Myres, max_size());
        }

        template <class _Fty, class... _ArgTys>
        basic_string& _Reallocate_for(const size_type _New_size, _Fty _Fn, _ArgTys... _Args)
        {
            if(_New_size > max_size())
            {
                _Xlen();
            }

            const size_type _Old_capacity = _Mypair._Myval2._Myres;
            const size_type _New_capacity = _Calculate_growth(_New_size);
            auto& _Al = _Getal();
            const pointer _New_ptr = _Al.allocate(_New_capacity + 1);
            _Mypair._Myval2._Orphan_all();
            _Mypair._Myval2._Mysize = _New_size;
            _Mypair._Myval2._Myres = _New_capacity;
            _Fn(_Unfancy(_New_ptr), _New_size, _Args...);
            if(_BUF_SIZE <= _Old_capacity)
            {
                _Al.deallocate(_Mypair._Myval2._Bx._Ptr, _Old_capacity + 1);
                _Mypair._Myval2._Bx._Ptr = _New_ptr;
            }
            else
            {
                _Construct_in_place(_Mypair._Myval2._Bx._Ptr, _New_ptr);
            }

            return *this;
        }

        template <class _Fty, class... _ArgTys>
        basic_string& _Reallocate_grow_by(const size_type _Size_increase, _Fty _Fn, _ArgTys... _Args)
        {
            auto& _My_data = _Mypair._Myval2;
            const size_type _Old_size = _My_data._Mysize;
            if(max_size() - _Old_size < _Size_increase)
            {
                _Xlen();
            }

            const size_type _New_size = _Old_size + _Size_increase;
            const size_type _Old_capacity = _My_data._Myres;
            const size_type _New_capacity = _Calculate_growth(_New_size);
            auto& _Al = _Getal();
            const pointer _New_ptr = _Al.allocate(_New_capacity + 1);
            _My_data._Orphan_all();
            _My_data._Mysize = _New_size;
            _My_data._Myres = _New_capacity;
            _Elem* const _Raw_new = _Unfancy(_New_ptr);
            if(_BUF_SIZE <= _Old_capacity)
            {
                const pointer _Old_ptr = _My_data._Bx._Ptr;
                _Fn(_Raw_new, _Unfancy(_Old_ptr), _Old_size, _Args...);
                _Al.deallocate(_Old_ptr, _Old_capacity + 1);
                _My_data._Bx._Ptr = _New_ptr;
            }
            else
            {
                _Fn(_Raw_new, _My_data._Bx._Buf, _Old_size, _Args...);
                _Construct_in_place(_My_data._Bx._Ptr, _New_ptr);
            }

            return *this;
        }

        void _Become_small()
        {
            _Mypair._Myval2._Orphan_all();
            const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
            auto& _Al = _Getal();
            _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
            _Traits::copy(_Mypair._Myval2._Bx._Buf, _Unfancy(_Ptr), _Mypair._Myval2._Mysize + 1);
            _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);
            _Mypair._Myval2._Myres = _BUF_SIZE - 1;
        }

        void _Eos(const size_type _Newsize)
        {
            _Traits::assign(_Mypair._Myval2._Myptr()[_Mypair._Myval2._Mysize = _Newsize], _Elem());
        }

        void _Tidy_init() noexcept
        {
            _Mypair._Myval2._Mysize = 0;
            _Mypair._Myval2._Myres = _BUF_SIZE - 1;

            _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());
        }

        void _Tidy_deallocate() noexcept
        {
            _Mypair._Myval2._Orphan_all();
            if(_Mypair._Myval2._Large_string_engaged())
            {
                const pointer _Ptr = _Mypair._Myval2._Bx._Ptr;
                auto& _Al = _Getal();
                _Destroy_in_place(_Mypair._Myval2._Bx._Ptr);
                _Al.deallocate(_Ptr, _Mypair._Myval2._Myres + 1);
            }

            _Mypair._Myval2._Mysize = 0;
            _Mypair._Myval2._Myres = _BUF_SIZE - 1;

            _Traits::assign(_Mypair._Myval2._Bx._Buf[0], _Elem());
        }

        [[noreturn]] static void _Xlen()
        {
            _Xlength_error("string too long");
        }

    public:
        void _Orphan_all() noexcept
        {
            _Mypair._Myval2._Orphan_all();
        }

    private:
        void _Swap_proxy_and_iterators(basic_string& _Right)
        {
            _Mypair._Myval2._Swap_proxy_and_iterators(_Right._Mypair._Myval2);
        }

        _Alty& _Getal() noexcept
        {
            return _Mypair._Get_first();
        }

        const _Alty& _Getal() const noexcept
        {
            return _Mypair._Get_first();
        }

        _Compressed_pair<_Alty, _Scary_val> _Mypair;
    };

    template <class _Elem, class _Traits, class _Alloc>
    void swap(basic_string<_Elem, _Traits, _Alloc>& _Left, basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
    {
        _Left.swap(_Right);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc>
    operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        basic_string<_Elem, _Traits, _Alloc> _Ans;
        _Ans.reserve(_Left.size() + _Right.size());
        _Ans += _Left;
        _Ans += _Right;
        return _Ans;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc>
    operator+(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        using _String_type = basic_string<_Elem, _Traits, _Alloc>;
        using _Size_type = typename _String_type::size_type;
        _String_type _Ans;
        _Ans.reserve(_Convert_size<_Size_type>(_Traits::length(_Left) + _Right.size()));
        _Ans += _Left;
        _Ans += _Right;
        return _Ans;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc>
    operator+(const _Elem _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        basic_string<_Elem, _Traits, _Alloc> _Ans;
        _Ans.reserve(1 + _Right.size());
        _Ans += _Left;
        _Ans += _Right;
        return _Ans;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc>
    operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
    {
        using _String_type = basic_string<_Elem, _Traits, _Alloc>;
        using _Size_type = typename _String_type::size_type;
        _String_type _Ans;
        _Ans.reserve(_Convert_size<_Size_type>(_Left.size() + _Traits::length(_Right)));
        _Ans += _Left;
        _Ans += _Right;
        return _Ans;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc> operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem _Right)
    {
        basic_string<_Elem, _Traits, _Alloc> _Ans;
        _Ans.reserve(_Left.size() + 1);
        _Ans += _Left;
        _Ans += _Right;
        return _Ans;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc>
    operator+(const basic_string<_Elem, _Traits, _Alloc>& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right)
    {
        return ::std::move(_Right.insert(0, _Left));
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc>
    operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        return ::std::move(_Left.append(_Right));
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc>
    operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right)
    {
        if(_Right.size() <= _Left.capacity() - _Left.size() || _Right.capacity() - _Right.size() < _Left.size())
        {
            return ::std::move(_Left.append(_Right));
        }
        else
        {
            return ::std::move(_Right.insert(0, _Left));
        }
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc>
    operator+(const _Elem* const _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right)
    {
        return ::std::move(_Right.insert(0, _Left));
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc> operator+(const _Elem _Left, basic_string<_Elem, _Traits, _Alloc>&& _Right)
    {
        return ::std::move(_Right.insert(0, 1, _Left));
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc>
    operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem* const _Right)
    {
        return ::std::move(_Left.append(_Right));
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] basic_string<_Elem, _Traits, _Alloc> operator+(basic_string<_Elem, _Traits, _Alloc>&& _Left, const _Elem _Right)
    {
        _Left.push_back(_Right);
        return ::std::move(_Left);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool
    operator==(const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
    {
        return _Left._Equal(_Right);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator==(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        return _Right._Equal(_Left);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator==(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
    {
        return _Left._Equal(_Right);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool
    operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
    {
        return !(_Left == _Right);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator!=(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        return !(_Left == _Right);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator!=(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
    {
        return !(_Left == _Right);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool
    operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
    {
        return _Left.compare(_Right) < 0;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator<(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        return _Right.compare(_Left) > 0;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator<(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
    {
        return _Left.compare(_Right) < 0;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool
    operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
    {
        return _Right < _Left;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator>(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        return _Right < _Left;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator>(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
    {
        return _Right < _Left;
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool
    operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
    {
        return !(_Right < _Left);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator<=(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        return !(_Right < _Left);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator<=(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
    {
        return !(_Right < _Left);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool
    operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) noexcept
    {
        return !(_Left < _Right);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator>=(const _Elem* const _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right)
    {
        return !(_Left < _Right);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] bool operator>=(const basic_string<_Elem, _Traits, _Alloc>& _Left, const _Elem* const _Right)
    {
        return !(_Left < _Right);
    }

    using string = basic_string<char, char_traits<char>, allocator<char>>;
    using wstring = basic_string<wchar_t, char_traits<wchar_t>, allocator<wchar_t>>;

    using u16string = basic_string<char16_t, char_traits<char16_t>, allocator<char16_t>>;
    using u32string = basic_string<char32_t, char_traits<char32_t>, allocator<char32_t>>;

    template <class _Elem, class _Traits, class _Alloc> struct hash<basic_string<_Elem, _Traits, _Alloc>>
    {
        typedef basic_string<_Elem, _Traits, _Alloc> argument_type;
        typedef size_t result_type;

        [[nodiscard]] size_t operator()(const basic_string<_Elem, _Traits, _Alloc>& _Keyval) const noexcept
        {
            return _Hash_array_representation(_Keyval.c_str(), _Keyval.size());
        }
    };

    template <class _Elem, class _Traits, class _Alloc>
    basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str)
    {
        using _Myis = basic_istream<_Elem, _Traits>;
        using _Ctype = typename _Myis::_Ctype;
        using _Mystr = basic_string<_Elem, _Traits, _Alloc>;
        using _Mysizt = typename _Mystr::size_type;

        typename _Myis::iostate _State = _Myis::goodbit;
        bool _Changed = false;
        const typename _Myis::sentry _Ok(_Istr);

        if(_Ok)
        {
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Istr.getloc());
            _Str.erase();

            try
            {
                _Mysizt _Size;
                if(0 < _Istr.width() && static_cast<_Mysizt>(_Istr.width()) < _Str.max_size())
                {
                    _Size = static_cast<_Mysizt>(_Istr.width());
                }
                else
                {
                    _Size = _Str.max_size();
                }

                typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

                for(; 0 < _Size; --_Size, _Meta = _Istr.rdbuf()->snextc())
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                    {
                        _State |= _Myis::eofbit;
                        break;
                    }
                    else if(_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta)))
                    {
                        break;
                    }
                    else
                    {
                        _Str.push_back(_Traits::to_char_type(_Meta));
                        _Changed = true;
                    }
                }
            }
            catch(...)
            {
                (_Istr).setstate(_Myis::badbit, true);
            }
        }

        _Istr.width(0);
        if(!_Changed)
        {
            _State |= _Myis::failbit;
        }

        _Istr.setstate(_State);
        return _Istr;
    }

    template <class _Elem, class _Traits, class _Alloc>
    basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str)
    {
        return ::std::move(_Istr) >> _Str;
    }

    template <class _Elem, class _Traits, class _Alloc>
    basic_ostream<_Elem, _Traits>&
    operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const basic_string<_Elem, _Traits, _Alloc>& _Str)
    {
        return _Insert_string(_Ostr, _Str.data(), _Str.size());
    }

    inline namespace literals
    {
        inline namespace string_literals
        {
            [[nodiscard]] inline string operator"" s(const char* _Str, size_t _Len)
            {
                return string(_Str, _Len);
            }

            [[nodiscard]] inline wstring operator"" s(const wchar_t* _Str, size_t _Len)
            {
                return wstring(_Str, _Len);
            }

            [[nodiscard]] inline u16string operator"" s(const char16_t* _Str, size_t _Len)
            {
                return u16string(_Str, _Len);
            }

            [[nodiscard]] inline u32string operator"" s(const char32_t* _Str, size_t _Len)
            {
                return u32string(_Str, _Len);
            }
        }// namespace string_literals
    }// namespace literals

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    class logic_error : public exception
    {
    public:
        using _Mybase = exception;

        explicit logic_error(const string& _Message) : _Mybase(_Message.c_str())
        {
        }

        explicit logic_error(const char* _Message) : _Mybase(_Message)
        {
        }
    };

    class domain_error : public logic_error
    {
    public:
        using _Mybase = logic_error;

        explicit domain_error(const string& _Message) : _Mybase(_Message.c_str())
        {
        }

        explicit domain_error(const char* _Message) : _Mybase(_Message)
        {
        }
    };

    class invalid_argument : public logic_error
    {
    public:
        using _Mybase = logic_error;

        explicit invalid_argument(const string& _Message) : _Mybase(_Message.c_str())
        {
        }

        explicit invalid_argument(const char* _Message) : _Mybase(_Message)
        {
        }
    };

    class length_error : public logic_error
    {
    public:
        using _Mybase = logic_error;

        explicit length_error(const string& _Message) : _Mybase(_Message.c_str())
        {
        }

        explicit length_error(const char* _Message) : _Mybase(_Message)
        {
        }
    };

    class out_of_range : public logic_error
    {
    public:
        using _Mybase = logic_error;

        explicit out_of_range(const string& _Message) : _Mybase(_Message.c_str())
        {
        }

        explicit out_of_range(const char* _Message) : _Mybase(_Message)
        {
        }
    };

    class runtime_error : public exception
    {
    public:
        using _Mybase = exception;

        explicit runtime_error(const string& _Message) : _Mybase(_Message.c_str())
        {
        }

        explicit runtime_error(const char* _Message) : _Mybase(_Message)
        {
        }
    };

    class overflow_error : public runtime_error
    {
    public:
        using _Mybase = runtime_error;

        explicit overflow_error(const string& _Message) : _Mybase(_Message.c_str())
        {
        }

        explicit overflow_error(const char* _Message) : _Mybase(_Message)
        {
        }
    };

    class underflow_error : public runtime_error
    {
    public:
        using _Mybase = runtime_error;

        explicit underflow_error(const string& _Message) : _Mybase(_Message.c_str())
        {
        }

        explicit underflow_error(const char* _Message) : _Mybase(_Message)
        {
        }
    };

    class range_error : public runtime_error
    {
    public:
        using _Mybase = runtime_error;

        explicit range_error(const string& _Message) : _Mybase(_Message.c_str())
        {
        }

        explicit range_error(const char* _Message) : _Mybase(_Message)
        {
        }
    };

    [[noreturn]] inline void _Throw_range_error(const char* const _Message)
    {
        throw range_error{ _Message };
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    struct once_flag
    {
        constexpr once_flag() noexcept : _Opaque(nullptr)
        {
        }

        once_flag(const once_flag&) = delete;
        once_flag& operator=(const once_flag&) = delete;

        void* _Opaque;
    };

    using _Execute_once_fp_t = int(__stdcall*)(void*, void*, void**);

    int __cdecl _Execute_once(once_flag& _Flag, _Execute_once_fp_t _Callback, void* _Pv) noexcept;

    template <class _Ty> int __stdcall _Immortalize_impl(void*, void* _Storage_ptr, void**) noexcept
    {
        ::new(_Storage_ptr) _Ty();
        return 1;
    }

    template <class _Ty> _Ty& _Immortalize()
    {
        static_assert(sizeof(void*) == sizeof(once_flag), "TRANSITION, VSO-406237");
        static_assert(alignof(void*) == alignof(once_flag), "TRANSITION, VSO-406237");
        static void* _Flag = nullptr;
        static aligned_union_t<1, _Ty> _Storage;
        if(_Execute_once(reinterpret_cast<once_flag&>(_Flag), _Immortalize_impl<_Ty>, &_Storage) == 0)
        {
            ::std::terminate();
        }

        return reinterpret_cast<_Ty&>(_Storage);
    }

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    enum class errc
    {
        address_family_not_supported = 102,
        address_in_use = 100,
        address_not_available = 101,
        already_connected = 113,
        argument_list_too_long = 7,
        argument_out_of_domain = 33,
        bad_address = 14,
        bad_file_descriptor = 9,
        bad_message = 104,
        broken_pipe = 32,
        connection_aborted = 106,
        connection_already_in_progress = 103,
        connection_refused = 107,
        connection_reset = 108,
        cross_device_link = 18,
        destination_address_required = 109,
        device_or_resource_busy = 16,
        directory_not_empty = 41,
        executable_format_error = 8,
        file_exists = 17,
        file_too_large = 27,
        filename_too_long = 38,
        function_not_supported = 40,
        host_unreachable = 110,
        identifier_removed = 111,
        illegal_byte_sequence = 42,
        inappropriate_io_control_operation = 25,
        interrupted = 4,
        invalid_argument = 22,
        invalid_seek = 29,
        io_error = 5,
        is_a_directory = 21,
        message_size = 115,
        network_down = 116,
        network_reset = 117,
        network_unreachable = 118,
        no_buffer_space = 119,
        no_child_process = 10,
        no_link = 121,
        no_lock_available = 39,
        no_message_available = 120,
        no_message = 122,
        no_protocol_option = 123,
        no_space_on_device = 28,
        no_stream_resources = 124,
        no_such_device_or_address = 6,
        no_such_device = 19,
        no_such_file_or_directory = 2,
        no_such_process = 3,
        not_a_directory = 20,
        not_a_socket = 128,
        not_a_stream = 125,
        not_connected = 126,
        not_enough_memory = 12,
        not_supported = 129,
        operation_canceled = 105,
        operation_in_progress = 112,
        operation_not_permitted = 1,
        operation_not_supported = 130,
        operation_would_block = 140,
        owner_dead = 133,
        permission_denied = 13,
        protocol_error = 134,
        protocol_not_supported = 135,
        read_only_file_system = 30,
        resource_deadlock_would_occur = 36,
        resource_unavailable_try_again = 11,
        result_out_of_range = 34,
        state_not_recoverable = 127,
        stream_timeout = 137,
        text_file_busy = 139,
        timed_out = 138,
        too_many_files_open_in_system = 23,
        too_many_files_open = 24,
        too_many_links = 31,
        too_many_symbolic_link_levels = 114,
        value_too_large = 132,
        wrong_protocol_type = 136
    };

}

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    enum class io_errc
    {
        stream = 1
    };

    template <class _Enum> struct is_error_code_enum : false_type
    {
    };

    template <> struct is_error_code_enum<io_errc> : true_type
    {
    };

    template <class _Ty> constexpr bool is_error_code_enum_v = is_error_code_enum<_Ty>::value;

    template <class _Enum> struct is_error_condition_enum : false_type
    {
    };

    template <> struct is_error_condition_enum<errc> : true_type
    {
    };

    template <class _Ty> constexpr bool is_error_condition_enum_v = is_error_condition_enum<_Ty>::value;

    class error_code;
    class error_condition;
    [[nodiscard]] error_code make_error_code(errc) noexcept;
    [[nodiscard]] error_code make_error_code(io_errc) noexcept;
    [[nodiscard]] error_condition make_error_condition(errc) noexcept;
    [[nodiscard]] error_condition make_error_condition(io_errc) noexcept;

    class error_category;

    [[nodiscard]] const error_category& generic_category() noexcept;
    [[nodiscard]] const error_category& iostream_category() noexcept;
    [[nodiscard]] const error_category& system_category() noexcept;

    class __declspec(novtable) error_category
    {
    public:
        error_category() noexcept
        {
            _Addr = reinterpret_cast<uintptr_t>(this);
        }

        virtual ~error_category() noexcept
        {
        }

        [[nodiscard]] virtual const char* name() const noexcept = 0;

        [[nodiscard]] virtual string message(int _Errval) const = 0;

        [[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept;

        [[nodiscard]] virtual bool equivalent(int _Errval, const error_condition& _Cond) const noexcept;

        [[nodiscard]] virtual bool equivalent(const error_code& _Code, int _Errval) const noexcept;

        [[nodiscard]] bool operator==(const error_category& _Right) const noexcept
        {
            return _Addr == _Right._Addr;
        }

        [[nodiscard]] bool operator!=(const error_category& _Right) const noexcept
        {
            return !(*this == _Right);
        }

        [[nodiscard]] bool operator<(const error_category& _Right) const noexcept
        {
            return _Addr < _Right._Addr;
        }

        error_category(const error_category&) = delete;
        error_category& operator=(const error_category&) = delete;

    protected:
        uintptr_t _Addr;

        enum : uintptr_t
        {
            _Future_addr = 1,
            _Generic_addr = 3,
            _Iostream_addr = 5,
            _System_addr = 7
        };
    };

    [[nodiscard]] inline bool _System_error_equal(const error_code&, const error_condition&) noexcept;

    class error_code
    {
    public:
        error_code() noexcept : _Myval(0), _Mycat(&system_category())
        {
        }

        error_code(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat)
        {
        }

        template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
        error_code(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr)
        {
            *this = make_error_code(_Errcode);
        }

        void assign(int _Val, const error_category& _Cat) noexcept
        {
            _Myval = _Val;
            _Mycat = &_Cat;
        }

        template <class _Enum, enable_if_t<is_error_code_enum_v<_Enum>, int> = 0>
        error_code& operator=(_Enum _Errcode) noexcept
        {
            *this = make_error_code(_Errcode);
            return *this;
        }

        void clear() noexcept
        {
            _Myval = 0;
            _Mycat = &system_category();
        }

        [[nodiscard]] int value() const noexcept
        {
            return _Myval;
        }

        [[nodiscard]] const error_category& category() const noexcept
        {
            return *_Mycat;
        }

        [[nodiscard]] error_condition default_error_condition() const noexcept;

        [[nodiscard]] string message() const
        {
            return category().message(value());
        }

        explicit operator bool() const noexcept
        {
            return value() != 0;
        }

        [[nodiscard]] friend bool operator==(const error_code& _Left, const error_code& _Right) noexcept
        {
            return _Left.category() == _Right.category() && _Left.value() == _Right.value();
        }

        [[nodiscard]] friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept
        {
            return _System_error_equal(_Left, _Right);
        }

        [[nodiscard]] friend bool operator==(const error_condition& _Left, const error_code& _Right) noexcept
        {
            return _System_error_equal(_Right, _Left);
        }

        [[nodiscard]] friend bool operator!=(const error_code& _Left, const error_code& _Right) noexcept
        {
            return !(_Left == _Right);
        }

        [[nodiscard]] friend bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept
        {
            return !_System_error_equal(_Left, _Right);
        }

        [[nodiscard]] friend bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept
        {
            return !_System_error_equal(_Right, _Left);
        }

        [[nodiscard]] friend bool operator<(const error_code& _Left, const error_code& _Right) noexcept
        {
            return _Left.category() < _Right.category()
                   || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
        }

    private:
        int _Myval;
        const error_category* _Mycat;
    };

    class error_condition
    {
    public:
        error_condition() noexcept : _Myval(0), _Mycat(&generic_category())
        {
        }

        error_condition(int _Val, const error_category& _Cat) noexcept : _Myval(_Val), _Mycat(&_Cat)
        {
        }

        template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
        error_condition(_Enum _Errcode) noexcept : _Myval(0), _Mycat(nullptr)
        {
            *this = make_error_condition(_Errcode);
        }

        void assign(int _Val, const error_category& _Cat) noexcept
        {
            _Myval = _Val;
            _Mycat = &_Cat;
        }

        template <class _Enum, enable_if_t<is_error_condition_enum_v<_Enum>, int> = 0>
        error_condition& operator=(_Enum _Errcode) noexcept
        {
            *this = make_error_condition(_Errcode);
            return *this;
        }

        void clear() noexcept
        {
            _Myval = 0;
            _Mycat = &generic_category();
        }

        [[nodiscard]] int value() const noexcept
        {
            return _Myval;
        }

        [[nodiscard]] const error_category& category() const noexcept
        {
            return *_Mycat;
        }

        [[nodiscard]] string message() const
        {
            return category().message(value());
        }

        explicit operator bool() const noexcept
        {
            return value() != 0;
        }

        [[nodiscard]] friend bool operator==(const error_condition& _Left, const error_condition& _Right) noexcept
        {
            return _Left.category() == _Right.category() && _Left.value() == _Right.value();
        }

        [[nodiscard]] friend bool operator!=(const error_condition& _Left, const error_condition& _Right) noexcept
        {
            return !(_Left == _Right);
        }

        [[nodiscard]] friend bool operator<(const error_condition& _Left, const error_condition& _Right) noexcept
        {
            return _Left.category() < _Right.category()
                   || (_Left.category() == _Right.category() && _Left.value() < _Right.value());
        }

        friend bool operator==(const error_code& _Left, const error_condition& _Right) noexcept;
        friend bool operator==(const error_condition& _Left, const error_code& _Right) noexcept;
        friend bool operator!=(const error_code& _Left, const error_condition& _Right) noexcept;
        friend bool operator!=(const error_condition& _Left, const error_code& _Right) noexcept;

    private:
        int _Myval;
        const error_category* _Mycat;
    };

    [[nodiscard]] inline bool _System_error_equal(const error_code& _Left, const error_condition& _Right) noexcept
    {
        return _Left.category().equivalent(_Left.value(), _Right) || _Right.category().equivalent(_Left, _Right.value());
    }

    [[nodiscard]] inline error_condition error_category::default_error_condition(int _Errval) const noexcept
    {
        return error_condition(_Errval, *this);
    }

    [[nodiscard]] inline bool error_category::equivalent(int _Errval, const error_condition& _Cond) const noexcept
    {
        return default_error_condition(_Errval) == _Cond;
    }

    [[nodiscard]] inline bool error_category::equivalent(const error_code& _Code, int _Errval) const noexcept
    {
        return *this == _Code.category() && _Code.value() == _Errval;
    }

    [[nodiscard]] inline error_condition error_code::default_error_condition() const noexcept
    {
        return category().default_error_condition(value());
    }

    [[nodiscard]] inline error_code make_error_code(errc _Errno) noexcept
    {
        return error_code(static_cast<int>(_Errno), generic_category());
    }

    [[nodiscard]] inline error_code make_error_code(io_errc _Errno) noexcept
    {
        return error_code(static_cast<int>(_Errno), iostream_category());
    }

    [[nodiscard]] inline error_condition make_error_condition(errc _Errno) noexcept
    {
        return error_condition(static_cast<int>(_Errno), generic_category());
    }

    [[nodiscard]] inline error_condition make_error_condition(io_errc _Errno) noexcept
    {
        return error_condition(static_cast<int>(_Errno), iostream_category());
    }

    template <> struct hash<error_code>
    {
        typedef error_code argument_type;
        typedef size_t result_type;

        [[nodiscard]] size_t operator()(const error_code& _Keyval) const noexcept
        {
            return hash<int>{}(_Keyval.value());
        }
    };

    template <> struct hash<error_condition>
    {
        typedef error_condition argument_type;
        typedef size_t result_type;

        [[nodiscard]] size_t operator()(const error_condition& _Keyval) const noexcept
        {
            return hash<int>{}(_Keyval.value());
        }
    };

    class _System_error : public runtime_error
    {
    private:
        static string _Makestr(error_code _Errcode, string _Message)
        {
            if(!_Message.empty())
            {
                _Message.append(": ");
            }

            _Message.append(_Errcode.message());
            return _Message;
        }

    protected:
        _System_error(error_code _Errcode, const string& _Message)
        : runtime_error(_Makestr(_Errcode, _Message)), _Mycode(_Errcode)
        {
        }

        error_code _Mycode;
    };

    class system_error : public _System_error
    {
    private:
        using _Mybase = _System_error;

    public:
        system_error(error_code _Errcode) : _Mybase(_Errcode, "")
        {
        }

        system_error(error_code _Errcode, const string& _Message) : _Mybase(_Errcode, _Message)
        {
        }

        system_error(error_code _Errcode, const char* _Message) : _Mybase(_Errcode, _Message)
        {
        }

        system_error(int _Errval, const error_category& _Errcat) : _Mybase(error_code(_Errval, _Errcat), "")
        {
        }

        system_error(int _Errval, const error_category& _Errcat, const string& _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message)
        {
        }

        system_error(int _Errval, const error_category& _Errcat, const char* _Message)
        : _Mybase(error_code(_Errval, _Errcat), _Message)
        {
        }

        [[nodiscard]] const error_code& code() const noexcept
        {
            return _Mycode;
        }
    };

    [[noreturn]] inline void _Throw_system_error(const errc _Errno)
    {
        throw system_error{ ::std::make_error_code(_Errno) };
    }

    const char* __cdecl _Syserror_map(int);
    int __cdecl _Winerror_map(int);
    unsigned long __cdecl _Winerror_message(unsigned long _Message_id, char* _Narrow, unsigned long _Size);

    class _Generic_error_category : public error_category
    {
    public:
        _Generic_error_category() noexcept
        {
            _Addr = _Generic_addr;
        }

        [[nodiscard]] virtual const char* name() const noexcept override
        {
            return "generic";
        }

        [[nodiscard]] virtual string message(int _Errcode) const override
        {
            return _Syserror_map(_Errcode);
        }
    };

    class _Iostream_error_category : public _Generic_error_category
    {
    public:
        _Iostream_error_category() noexcept
        {
            _Addr = _Iostream_addr;
        }

        [[nodiscard]] virtual const char* name() const noexcept override
        {
            return "iostream";
        }

        [[nodiscard]] virtual string message(int _Errcode) const override
        {
            if(_Errcode == static_cast<int>(io_errc::stream))
            {
                return "iostream stream error";
            }
            else
            {
                return _Generic_error_category::message(_Errcode);
            }
        }
    };

    class _System_error_category : public error_category
    {
    public:
        _System_error_category() noexcept
        {
            _Addr = _System_addr;
        }

        [[nodiscard]] virtual const char* name() const noexcept override
        {
            return "system";
        }

        [[nodiscard]] virtual string message(int _Errcode) const override
        {
            const unsigned long _Size = 32767;
            string _Narrow(_Size, '\0');

            const unsigned long _Val = _Winerror_message(static_cast<unsigned long>(_Errcode), &_Narrow[0], _Size);
            if(_Val == 0)
            {
                _Narrow = "unknown error";
            }
            else
            {
                _Narrow.resize(_Val);
            }

            _Narrow.shrink_to_fit();
            return _Narrow;
        }

        [[nodiscard]] virtual error_condition default_error_condition(int _Errval) const noexcept override
        {
            const int _Posv = _Winerror_map(_Errval);
            if(_Posv == 0)
            {
                return error_condition(_Errval, system_category());
            }
            else
            {
                return error_condition(_Posv, generic_category());
            }
        }
    };

    [[nodiscard]] inline const error_category& generic_category() noexcept
    {
        return _Immortalize<_Generic_error_category>();
    }

    [[nodiscard]] inline const error_category& iostream_category() noexcept
    {
        return _Immortalize<_Iostream_error_category>();
    }

    [[nodiscard]] inline const error_category& system_category() noexcept
    {
        return _Immortalize<_System_error_category>();
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

#pragma warning(disable : 4275)

#pragma once

#pragma warning(push)
#pragma warning(disable : 4514 4820)

#pragma pack(push, 8)

struct __type_info_node
{
};

extern __type_info_node __type_info_root_node;

__pragma(pack(push, 8)) extern "C"
{
    struct __std_type_info_data
    {
        const char* _UndecoratedName;
        const char _DecoratedName[1];
        __std_type_info_data() = delete;
        __std_type_info_data(const __std_type_info_data&) = delete;
        __std_type_info_data(__std_type_info_data&&) = delete;

        __std_type_info_data& operator=(const __std_type_info_data&) = delete;
        __std_type_info_data& operator=(__std_type_info_data&&) = delete;
    };

    int __cdecl __std_type_info_compare(const __std_type_info_data* _Lhs, const __std_type_info_data* _Rhs);

    size_t __cdecl __std_type_info_hash(const __std_type_info_data* _Data);

    const char* __cdecl __std_type_info_name(__std_type_info_data * _Data, __type_info_node * _RootNode);
}
__pragma(pack(pop))

#pragma warning(push)
#pragma warning(disable : 4577)
class type_info
{
public:
    type_info(const type_info&) = delete;
    type_info& operator=(const type_info&) = delete;

    size_t hash_code() const noexcept
    {
        return __std_type_info_hash(&_Data);
    }

    bool operator==(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) == 0;
    }

    bool operator!=(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) != 0;
    }

    bool before(const type_info& _Other) const noexcept
    {
        return __std_type_info_compare(&_Data, &_Other._Data) < 0;
    }

    const char* name() const noexcept
    {
        return __std_type_info_name(&_Data, &__type_info_root_node);
    }

    const char* raw_name() const noexcept
    {
        return _Data._DecoratedName;
    }

    virtual ~type_info() noexcept;

private:
    mutable __std_type_info_data _Data;
};
#pragma warning(pop)

namespace std
{
    using ::type_info;
}

namespace std
{
#pragma warning(push)
#pragma warning(disable : 4577)
    class bad_cast : public exception
    {
    public:
        bad_cast() noexcept : exception("bad cast", 1)
        {
        }

        static bad_cast __construct_from_string_literal(const char* const _Message) noexcept
        {
            return bad_cast(_Message, 1);
        }

    private:
        bad_cast(const char* const _Message, int) noexcept : exception(_Message, 1)
        {
        }
    };

    class bad_typeid : public exception
    {
    public:
        bad_typeid() noexcept : exception("bad typeid", 1)
        {
        }

        static bad_typeid __construct_from_string_literal(const char* const _Message) noexcept
        {
            return bad_typeid(_Message, 1);
        }

    private:
        friend class __non_rtti_object;

        bad_typeid(const char* const _Message, int) noexcept : exception(_Message, 1)
        {
        }
    };

    class __non_rtti_object : public bad_typeid
    {
    public:
        static __non_rtti_object __construct_from_string_literal(const char* const _Message) noexcept
        {
            return __non_rtti_object(_Message, 1);
        }

    private:
        __non_rtti_object(const char* const _Message, int) noexcept : bad_typeid(_Message, 1)
        {
        }
    };

#pragma warning(pop)
}// namespace std

#pragma pack(pop)
#pragma warning(pop)

namespace std
{
    constexpr int _Small_object_num_ptrs = 6 + 16 / sizeof(void*);

    [[noreturn]] inline void _Throw_bad_cast()
    {
        throw bad_cast{};
    }

}// namespace std

#pragma pack(pop)
#pragma warning(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _InIt, class _Diff, class _NoThrowFwdIt>
    _NoThrowFwdIt uninitialized_copy_n(const _InIt _First, const _Diff _Count_raw, _NoThrowFwdIt _Dest)
    {
        _Algorithm_int_t<_Diff> _Count = _Count_raw;
        if(0 < _Count)
        {
            auto _UFirst = _Get_unwrapped_n(_First, _Count);
            auto _UDest = _Get_unwrapped_n(_Dest, _Count);
            if constexpr(_Ptr_copy_cat<decltype(_UFirst), decltype(_UDest)>::_Really_trivial)
            {
                _UDest = _Copy_memmove(_UFirst, _UFirst + _Count, _UDest);
            }
            else
            {
                _Uninitialized_backout<decltype(_UDest)> _Backout{ _UDest };
                for(; 0 < _Count; --_Count, (void)++_UFirst)
                {
                    _Backout._Emplace_back(*_UFirst);
                }

                _UDest = _Backout._Release();
            }

            _Seek_wrapped(_Dest, _UDest);
        }

        return _Dest;
    }

    template <class _NoThrowFwdIt, class _Diff, class _Tval>
    _NoThrowFwdIt uninitialized_fill_n(_NoThrowFwdIt _First, const _Diff _Count_raw, const _Tval& _Val)
    {
        _Algorithm_int_t<_Diff> _Count = _Count_raw;
        if(0 < _Count)
        {
            auto _UFirst = _Get_unwrapped_n(_First, _Count);
            if constexpr(_Fill_memset_is_safe<_Unwrapped_n_t<const _NoThrowFwdIt&>, _Tval>)
            {
                ::memset(_UFirst, static_cast<unsigned char>(_Val), _Count);
                _UFirst += _Count;
            }
            else
            {
                _Uninitialized_backout<_Unwrapped_n_t<const _NoThrowFwdIt&>> _Backout{ _UFirst };
                for(; 0 < _Count; --_Count)
                {
                    _Backout._Emplace_back(_Val);
                }

                _UFirst = _Backout._Release();
            }

            _Seek_wrapped(_First, _UFirst);
        }

        return _First;
    }

    template <class _OutIt, class _Ty> class raw_storage_iterator
    {
    public:
        using iterator_category = output_iterator_tag;
        using value_type = void;
        using difference_type = void;
        using pointer = void;
        using reference = void;

        explicit raw_storage_iterator(_OutIt _First) : _Next(_First)
        {
        }

        [[nodiscard]] raw_storage_iterator& operator*()
        {
            return *this;
        }

        raw_storage_iterator& operator=(const _Ty& _Val)
        {
            _Construct_in_place(*_Next, _Val);
            return *this;
        }

        raw_storage_iterator& operator=(_Ty&& _Val)
        {
            _Construct_in_place(*_Next, ::std::move(_Val));
            return *this;
        }

        raw_storage_iterator& operator++()
        {
            ++_Next;
            return *this;
        }

        raw_storage_iterator operator++(int)
        {
            raw_storage_iterator _Ans = *this;
            ++_Next;
            return _Ans;
        }

        [[nodiscard]] _OutIt base() const
        {
            return _Next;
        }

    private:
        _OutIt _Next;
    };

    template <class _Ty> class auto_ptr;

    template <class _Ty> struct auto_ptr_ref
    {
        explicit auto_ptr_ref(_Ty* _Right) : _Ref(_Right)
        {
        }

        _Ty* _Ref;
    };

    template <class _Ty> class auto_ptr
    {
    public:
        using element_type = _Ty;

        explicit auto_ptr(_Ty* _Ptr = nullptr) noexcept : _Myptr(_Ptr)
        {
        }

        auto_ptr(auto_ptr& _Right) noexcept : _Myptr(_Right.release())
        {
        }

        auto_ptr(auto_ptr_ref<_Ty> _Right) noexcept
        {
            _Ty* _Ptr = _Right._Ref;
            _Right._Ref = nullptr;
            _Myptr = _Ptr;
        }

        template <class _Other> operator auto_ptr<_Other>() noexcept
        {
            return auto_ptr<_Other>(*this);
        }

        template <class _Other> operator auto_ptr_ref<_Other>() noexcept
        {
            _Other* _Cvtptr = _Myptr;
            auto_ptr_ref<_Other> _Ans(_Cvtptr);
            _Myptr = nullptr;
            return _Ans;
        }

        template <class _Other> auto_ptr& operator=(auto_ptr<_Other>& _Right) noexcept
        {
            reset(_Right.release());
            return *this;
        }

        template <class _Other> auto_ptr(auto_ptr<_Other>& _Right) noexcept : _Myptr(_Right.release())
        {
        }

        auto_ptr& operator=(auto_ptr& _Right) noexcept
        {
            reset(_Right.release());
            return *this;
        }

        auto_ptr& operator=(auto_ptr_ref<_Ty> _Right) noexcept
        {
            _Ty* _Ptr = _Right._Ref;
            _Right._Ref = 0;
            reset(_Ptr);
            return *this;
        }

        ~auto_ptr() noexcept
        {
            delete _Myptr;
        }

        [[nodiscard]] _Ty& operator*() const noexcept
        {
            return *get();
        }

        [[nodiscard]] _Ty* operator->() const noexcept
        {
            return get();
        }

        [[nodiscard]] _Ty* get() const noexcept
        {
            return _Myptr;
        }

        _Ty* release() noexcept
        {
            _Ty* _Tmp = _Myptr;
            _Myptr = nullptr;
            return _Tmp;
        }

        void reset(_Ty* _Ptr = nullptr) noexcept
        {
            if(_Ptr != _Myptr)
            {
                delete _Myptr;
            }

            _Myptr = _Ptr;
        }

    private:
        _Ty* _Myptr;
    };

    template <> class auto_ptr<void>
    {
    public:
        using element_type = void;
    };

    class bad_weak_ptr : public exception
    {
    public:
        bad_weak_ptr() noexcept
        {
        }

        [[nodiscard]] virtual const char* what() const noexcept override
        {
            return "bad_weak_ptr";
        }
    };

    [[noreturn]] inline void _Throw_bad_weak_ptr()
    {
        throw bad_weak_ptr{};
    }

    class __declspec(novtable) _Ref_count_base
    {
    private:
        virtual void _Destroy() noexcept = 0;
        virtual void _Delete_this() noexcept = 0;

        _Atomic_counter_t _Uses = 1;
        _Atomic_counter_t _Weaks = 1;

    protected:
        constexpr _Ref_count_base() noexcept = default;

    public:
        _Ref_count_base(const _Ref_count_base&) = delete;
        _Ref_count_base& operator=(const _Ref_count_base&) = delete;

        virtual ~_Ref_count_base() noexcept
        {
        }

        bool _Incref_nz() noexcept
        {
            auto& _Volatile_uses = reinterpret_cast<volatile long&>(_Uses);
            long _Count = (*_Atomic_address_as<const long>(_Volatile_uses));

            while(_Count != 0)
            {
                const long _Old_value = _InterlockedCompareExchange(&_Volatile_uses, _Count + 1, _Count);
                if(_Old_value == _Count)
                {
                    return true;
                }

                _Count = _Old_value;
            }

            return false;
        }

        void _Incref() noexcept
        {
            _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Uses));
        }

        void _Incwref() noexcept
        {
            _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Weaks));
        }

        void _Decref() noexcept
        {
            if(_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Uses)) == 0)
            {
                _Destroy();
                _Decwref();
            }
        }

        void _Decwref() noexcept
        {
            if(_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Weaks)) == 0)
            {
                _Delete_this();
            }
        }

        long _Use_count() const noexcept
        {
            return static_cast<long>(_Uses);
        }

        virtual void* _Get_deleter(const type_info&) const noexcept
        {
            return nullptr;
        }
    };

    template <class _Ty> class _Ref_count : public _Ref_count_base
    {
    public:
        explicit _Ref_count(_Ty* _Px) : _Ref_count_base(), _Ptr(_Px)
        {
        }

    private:
        virtual void _Destroy() noexcept override
        {
            delete _Ptr;
        }

        virtual void _Delete_this() noexcept override
        {
            delete this;
        }

        _Ty* _Ptr;
    };

    template <class _Resource, class _Dx> class _Ref_count_resource : public _Ref_count_base
    {
    public:
        _Ref_count_resource(_Resource _Px, _Dx _Dt)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), ::std::move(_Dt), _Px)
        {
        }

        virtual void* _Get_deleter(const type_info& _Typeid) const noexcept override
        {
            if(_Typeid == typeid(_Dx))
            {
                return const_cast<_Dx*>(::std::addressof(_Mypair._Get_first()));
            }

            return nullptr;
        }

    private:
        virtual void _Destroy() noexcept override
        {
            _Mypair._Get_first()(_Mypair._Myval2);
        }

        virtual void _Delete_this() noexcept override
        {
            delete this;
        }

        _Compressed_pair<_Dx, _Resource> _Mypair;
    };

    template <class _Resource, class _Dx, class _Alloc> class _Ref_count_resource_alloc : public _Ref_count_base
    {
    public:
        _Ref_count_resource_alloc(_Resource _Px, _Dx _Dt, const _Alloc& _Ax)
        : _Ref_count_base(), _Mypair(_One_then_variadic_args_t(), ::std::move(_Dt), _One_then_variadic_args_t(), _Ax, _Px)
        {
        }

        virtual void* _Get_deleter(const type_info& _Typeid) const noexcept override
        {
            if(_Typeid == typeid(_Dx))
            {
                return const_cast<_Dx*>(::std::addressof(_Mypair._Get_first()));
            }

            return nullptr;
        }

    private:
        using _Myalty = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc>;

        virtual void _Destroy() noexcept override
        {
            _Mypair._Get_first()(_Mypair._Myval2._Myval2);
        }

        virtual void _Delete_this() noexcept override
        {
            _Myalty _Al = _Mypair._Myval2._Get_first();
            this->~_Ref_count_resource_alloc();
            _Deallocate_plain(_Al, this);
        }

        _Compressed_pair<_Dx, _Compressed_pair<_Myalty, _Resource>> _Mypair;
    };

    template <class _Ty> struct default_delete;

    template <class _Ty, class _Dx = default_delete<_Ty>> class unique_ptr;

    template <class _Ty> class shared_ptr;

    template <class _Ty> class weak_ptr;

    template <class _Yty, class = void> struct _Can_enable_shared : false_type
    {
    };

    template <class _Yty>
    struct _Can_enable_shared<_Yty, void_t<typename _Yty::_Esft_type>>
    : is_convertible<remove_cv_t<_Yty>*, typename _Yty::_Esft_type*>::type
    {
    };

    struct _Exception_ptr_access;

    template <class _Ty> class _Ptr_base
    {
    public:
        using element_type = remove_extent_t<_Ty>;

        [[nodiscard]] long use_count() const noexcept
        {
            return _Rep ? _Rep->_Use_count() : 0;
        }

        template <class _Ty2>[[nodiscard]] bool owner_before(const _Ptr_base<_Ty2>& _Right) const noexcept
        {
            return _Rep < _Right._Rep;
        }

        _Ptr_base(const _Ptr_base&) = delete;
        _Ptr_base& operator=(const _Ptr_base&) = delete;

    protected:
        [[nodiscard]] element_type* get() const noexcept
        {
            return _Ptr;
        }

        constexpr _Ptr_base() noexcept = default;

        ~_Ptr_base() = default;

        template <class _Ty2> void _Move_construct_from(_Ptr_base<_Ty2>&& _Right) noexcept
        {
            _Ptr = _Right._Ptr;
            _Rep = _Right._Rep;

            _Right._Ptr = nullptr;
            _Right._Rep = nullptr;
        }

        template <class _Ty2> void _Copy_construct_from(const shared_ptr<_Ty2>& _Other) noexcept
        {
            if(_Other._Rep)
            {
                _Other._Rep->_Incref();
            }

            _Ptr = _Other._Ptr;
            _Rep = _Other._Rep;
        }

        template <class _Ty2> void _Alias_construct_from(const shared_ptr<_Ty2>& _Other, element_type* _Px) noexcept
        {
            if(_Other._Rep)
            {
                _Other._Rep->_Incref();
            }

            _Ptr = _Px;
            _Rep = _Other._Rep;
        }

        template <class _Ty2> void _Alias_move_construct_from(shared_ptr<_Ty2>&& _Other, element_type* _Px) noexcept
        {
            _Ptr = _Px;
            _Rep = _Other._Rep;

            _Other._Ptr = nullptr;
            _Other._Rep = nullptr;
        }

        template <class _Ty0> friend class weak_ptr;

        template <class _Ty2> bool _Construct_from_weak(const weak_ptr<_Ty2>& _Other) noexcept
        {
            if(_Other._Rep && _Other._Rep->_Incref_nz())
            {
                _Ptr = _Other._Ptr;
                _Rep = _Other._Rep;
                return true;
            }

            return false;
        }

        void _Decref() noexcept
        {
            if(_Rep)
            {
                _Rep->_Decref();
            }
        }

        void _Swap(_Ptr_base& _Right) noexcept
        {
            ::std::swap(_Ptr, _Right._Ptr);
            ::std::swap(_Rep, _Right._Rep);
        }

        template <class _Ty2> void _Weakly_construct_from(const _Ptr_base<_Ty2>& _Other) noexcept
        {
            if(_Other._Rep)
            {
                _Ptr = _Other._Ptr;
                _Rep = _Other._Rep;
                _Rep->_Incwref();
            }
            else
            {
                ;
            }
        }

        void _Decwref() noexcept
        {
            if(_Rep)
            {
                _Rep->_Decwref();
            }
        }

    private:
        element_type* _Ptr{ nullptr };
        _Ref_count_base* _Rep{ nullptr };

        template <class _Ty0> friend class _Ptr_base;

        friend shared_ptr<_Ty>;

        friend _Exception_ptr_access;

        template <class _Dx, class _Ty0> friend _Dx* get_deleter(const shared_ptr<_Ty0>& _Sx) noexcept;
    };

    template <class _Yty, class = void> struct _Can_scalar_delete : false_type
    {
    };
    template <class _Yty> struct _Can_scalar_delete<_Yty, void_t<decltype(delete ::std::declval<_Yty*>())>> : true_type
    {
    };

    template <class _Yty, class = void> struct _Can_array_delete : false_type
    {
    };
    template <class _Yty> struct _Can_array_delete<_Yty, void_t<decltype(delete[] ::std::declval<_Yty*>())>> : true_type
    {
    };

    template <class _Fx, class _Arg, class = void> struct _Can_call_function_object : false_type
    {
    };
    template <class _Fx, class _Arg>
    struct _Can_call_function_object<_Fx, _Arg, void_t<decltype(::std::declval<_Fx>()(::std::declval<_Arg>()))>> : true_type
    {
    };

    template <class _Yty, class _Ty> struct _SP_convertible : is_convertible<_Yty*, _Ty*>::type
    {
    };
    template <class _Yty, class _Uty>
    struct _SP_convertible<_Yty, _Uty[]> : is_convertible<_Yty (*)[], _Uty (*)[]>::type
    {
    };
    template <class _Yty, class _Uty, size_t _Ext>
    struct _SP_convertible<_Yty, _Uty[_Ext]> : is_convertible<_Yty (*)[_Ext], _Uty (*)[_Ext]>::type
    {
    };

    template <class _Yty, class _Ty> struct _SP_pointer_compatible : is_convertible<_Yty*, _Ty*>::type
    {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<_Uty[_Ext], _Uty[]> : true_type
    {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<_Uty[_Ext], const _Uty[]> : true_type
    {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<_Uty[_Ext], volatile _Uty[]> : true_type
    {
    };
    template <class _Uty, size_t _Ext> struct _SP_pointer_compatible<_Uty[_Ext], const volatile _Uty[]> : true_type
    {
    };

    template <class _Ux> struct _Temporary_owner
    {
        _Ux* _Ptr;

        explicit _Temporary_owner(_Ux* const _Ptr_) noexcept : _Ptr(_Ptr_)
        {
        }
        _Temporary_owner(const _Temporary_owner&) = delete;
        _Temporary_owner& operator=(const _Temporary_owner&) = delete;
        ~_Temporary_owner()
        {
            delete _Ptr;
        }
    };

    template <class _UxptrOrNullptr, class _Dx> struct _Temporary_owner_del
    {
        _UxptrOrNullptr _Ptr;
        _Dx& _Dt;
        bool _Call_deleter = true;

        explicit _Temporary_owner_del(const _UxptrOrNullptr _Ptr_, _Dx& _Dt_) noexcept : _Ptr(_Ptr_), _Dt(_Dt_)
        {
        }
        _Temporary_owner_del(const _Temporary_owner_del&) = delete;
        _Temporary_owner_del& operator=(const _Temporary_owner_del&) = delete;
        ~_Temporary_owner_del()
        {
            if(_Call_deleter)
            {
                _Dt(_Ptr);
            }
        }
    };

    template <class _Ty> class shared_ptr : public _Ptr_base<_Ty>
    {
    private:
        using _Mybase = _Ptr_base<_Ty>;

    public:
        using typename _Mybase::element_type;

        constexpr shared_ptr() noexcept
        {
        }

        constexpr shared_ptr(nullptr_t) noexcept
        {
        }

        template <class _Ux, enable_if_t<conjunction_v<conditional_t<is_array_v<_Ty>, _Can_array_delete<_Ux>, _Can_scalar_delete<_Ux>>, _SP_convertible<_Ux, _Ty>>, int> = 0>
        explicit shared_ptr(_Ux* _Px)
        {
            if constexpr(is_array_v<_Ty>)
            {
                _Setpd(_Px, default_delete<_Ux[]>{});
            }
            else
            {
                _Temporary_owner<_Ux> _Owner(_Px);
                _Set_ptr_rep_and_enable_shared(_Owner._Ptr, new _Ref_count<_Ux>(_Owner._Ptr));
                _Owner._Ptr = nullptr;
            }
        }

        template <class _Ux, class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>, _SP_convertible<_Ux, _Ty>>, int> = 0>
        shared_ptr(_Ux* _Px, _Dx _Dt)
        {
            _Setpd(_Px, ::std::move(_Dt));
        }

        template <class _Ux, class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, _Ux*&>, _SP_convertible<_Ux, _Ty>>, int> = 0>
        shared_ptr(_Ux* _Px, _Dx _Dt, _Alloc _Ax)
        {
            _Setpda(_Px, ::std::move(_Dt), _Ax);
        }

        template <class _Dx, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
        shared_ptr(nullptr_t, _Dx _Dt)
        {
            _Setpd(nullptr, ::std::move(_Dt));
        }

        template <class _Dx, class _Alloc, enable_if_t<conjunction_v<is_move_constructible<_Dx>, _Can_call_function_object<_Dx&, nullptr_t&>>, int> = 0>
        shared_ptr(nullptr_t, _Dx _Dt, _Alloc _Ax)
        {
            _Setpda(nullptr, ::std::move(_Dt), _Ax);
        }

        template <class _Ty2> shared_ptr(const shared_ptr<_Ty2>& _Right, element_type* _Px) noexcept
        {
            this->_Alias_construct_from(_Right, _Px);
        }

        template <class _Ty2> shared_ptr(shared_ptr<_Ty2>&& _Right, element_type* _Px) noexcept
        {
            this->_Alias_move_construct_from(::std::move(_Right), _Px);
        }

        shared_ptr(const shared_ptr& _Other) noexcept
        {
            this->_Copy_construct_from(_Other);
        }

        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
        shared_ptr(const shared_ptr<_Ty2>& _Other) noexcept
        {
            this->_Copy_construct_from(_Other);
        }

        shared_ptr(shared_ptr&& _Right) noexcept
        {
            this->_Move_construct_from(::std::move(_Right));
        }

        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
        shared_ptr(shared_ptr<_Ty2>&& _Right) noexcept
        {
            this->_Move_construct_from(::std::move(_Right));
        }

        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
        explicit shared_ptr(const weak_ptr<_Ty2>& _Other)
        {
            if(!this->_Construct_from_weak(_Other))
            {
                _Throw_bad_weak_ptr();
            }
        }

        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0> shared_ptr(auto_ptr<_Ty2>&& _Other)
        {
            _Ty2* _Px = _Other.get();
            _Set_ptr_rep_and_enable_shared(_Px, new _Ref_count<_Ty2>(_Px));
            _Other.release();
        }

        template <class _Ux, class _Dx, enable_if_t<conjunction_v<_SP_pointer_compatible<_Ux, _Ty>, is_convertible<typename unique_ptr<_Ux, _Dx>::pointer, element_type*>>, int> = 0>
        shared_ptr(unique_ptr<_Ux, _Dx>&& _Other)
        {
            using _Fancy_t = typename unique_ptr<_Ux, _Dx>::pointer;
            using _Raw_t = typename unique_ptr<_Ux, _Dx>::element_type*;
            using _Deleter_t = conditional_t<is_reference_v<_Dx>, decltype(::std::ref(_Other.get_deleter())), _Dx>;

            const _Fancy_t _Fancy = _Other.get();

            if(_Fancy)
            {
                const _Raw_t _Raw = _Fancy;
                const auto _Rx = new _Ref_count_resource<_Fancy_t, _Deleter_t>(_Fancy, _Other.get_deleter());
                _Set_ptr_rep_and_enable_shared(_Raw, _Rx);
                _Other.release();
            }
        }

        ~shared_ptr() noexcept
        {
            this->_Decref();
        }

        shared_ptr& operator=(const shared_ptr& _Right) noexcept
        {
            shared_ptr(_Right).swap(*this);
            return *this;
        }

        template <class _Ty2> shared_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept
        {
            shared_ptr(_Right).swap(*this);
            return *this;
        }

        shared_ptr& operator=(shared_ptr&& _Right) noexcept
        {
            shared_ptr(::std::move(_Right)).swap(*this);
            return *this;
        }

        template <class _Ty2> shared_ptr& operator=(shared_ptr<_Ty2>&& _Right) noexcept
        {
            shared_ptr(::std::move(_Right)).swap(*this);
            return *this;
        }

        template <class _Ty2> shared_ptr& operator=(auto_ptr<_Ty2>&& _Right)
        {
            shared_ptr(::std::move(_Right)).swap(*this);
            return *this;
        }

        template <class _Ux, class _Dx> shared_ptr& operator=(unique_ptr<_Ux, _Dx>&& _Right)
        {
            shared_ptr(::std::move(_Right)).swap(*this);
            return *this;
        }

        void swap(shared_ptr& _Other) noexcept
        {
            this->_Swap(_Other);
        }

        void reset() noexcept
        {
            shared_ptr().swap(*this);
        }

        template <class _Ux> void reset(_Ux* _Px)
        {
            shared_ptr(_Px).swap(*this);
        }

        template <class _Ux, class _Dx> void reset(_Ux* _Px, _Dx _Dt)
        {
            shared_ptr(_Px, _Dt).swap(*this);
        }

        template <class _Ux, class _Dx, class _Alloc> void reset(_Ux* _Px, _Dx _Dt, _Alloc _Ax)
        {
            shared_ptr(_Px, _Dt, _Ax).swap(*this);
        }

        using _Mybase::get;

        template <class _Ty2 = _Ty, enable_if_t<!disjunction_v<is_array<_Ty2>, is_void<_Ty2>>, int> = 0>
        [[nodiscard]] _Ty2& operator*() const noexcept
        {
            return *get();
        }

        template <class _Ty2 = _Ty, enable_if_t<!is_array_v<_Ty2>, int> = 0>
        [[nodiscard]] _Ty2* operator->() const noexcept
        {
            return get();
        }

        template <class _Ty2 = _Ty, class _Elem = element_type, enable_if_t<is_array_v<_Ty2>, int> = 0>
        [[nodiscard]] _Elem& operator[](ptrdiff_t _Idx) const noexcept
        {
            return get()[_Idx];
        }

        [[nodiscard]] bool unique() const noexcept
        {
            return this->use_count() == 1;
        }

        explicit operator bool() const noexcept
        {
            return get() != nullptr;
        }

    private:
        template <class _UxptrOrNullptr, class _Dx> void _Setpd(const _UxptrOrNullptr _Px, _Dx _Dt)
        {
            _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
            _Set_ptr_rep_and_enable_shared(_Owner._Ptr,
                                           new _Ref_count_resource<_UxptrOrNullptr, _Dx>(_Owner._Ptr, ::std::move(_Dt)));
            _Owner._Call_deleter = false;
        }

        template <class _UxptrOrNullptr, class _Dx, class _Alloc>
        void _Setpda(const _UxptrOrNullptr _Px, _Dx _Dt, _Alloc _Ax)
        {
            using _Alref_alloc = _Rebind_alloc_t<_Alloc, _Ref_count_resource_alloc<_UxptrOrNullptr, _Dx, _Alloc>>;

            _Temporary_owner_del<_UxptrOrNullptr, _Dx> _Owner(_Px, _Dt);
            _Alref_alloc _Alref(_Ax);
            _Alloc_construct_ptr<_Alref_alloc> _Constructor(_Alref);
            _Constructor._Allocate();
            _Construct_in_place(*_Constructor._Ptr, _Owner._Ptr, ::std::move(_Dt), _Ax);
            _Set_ptr_rep_and_enable_shared(_Owner._Ptr, _Unfancy(_Constructor._Ptr));
            _Constructor._Ptr = nullptr;
            _Owner._Call_deleter = false;
        }

        template <class _Ty0, class... _Types> friend shared_ptr<_Ty0> make_shared(_Types&&... _Args);

        template <class _Ty0, class _Alloc, class... _Types>
        friend shared_ptr<_Ty0> allocate_shared(const _Alloc& _Al_arg, _Types&&... _Args);

        template <class _Ux> void _Set_ptr_rep_and_enable_shared(_Ux* const _Px, _Ref_count_base* const _Rx) noexcept
        {
            this->_Ptr = _Px;
            this->_Rep = _Rx;

            if constexpr(conjunction_v<negation<is_array<_Ty>>, negation<is_volatile<_Ux>>, _Can_enable_shared<_Ux>>)
            {
                if(_Px && _Px->_Wptr.expired())
                {
                    _Px->_Wptr = shared_ptr<remove_cv_t<_Ux>>(*this, const_cast<remove_cv_t<_Ux>*>(_Px));
                }
            }
        }

        void _Set_ptr_rep_and_enable_shared(nullptr_t, _Ref_count_base* const _Rx) noexcept
        {
            this->_Ptr = nullptr;
            this->_Rep = _Rx;
        }
    };

    template <class _Ty1, class _Ty2>
    [[nodiscard]] bool operator==(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
    {
        return _Left.get() == _Right.get();
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] bool operator!=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
    {
        return _Left.get() != _Right.get();
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] bool operator<(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
    {
        return _Left.get() < _Right.get();
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] bool operator>=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
    {
        return _Left.get() >= _Right.get();
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] bool operator>(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
    {
        return _Left.get() > _Right.get();
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] bool operator<=(const shared_ptr<_Ty1>& _Left, const shared_ptr<_Ty2>& _Right) noexcept
    {
        return _Left.get() <= _Right.get();
    }

    template <class _Ty>[[nodiscard]] bool operator==(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
    {
        return _Left.get() == nullptr;
    }

    template <class _Ty>[[nodiscard]] bool operator==(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
    {
        return nullptr == _Right.get();
    }

    template <class _Ty>[[nodiscard]] bool operator!=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
    {
        return _Left.get() != nullptr;
    }

    template <class _Ty>[[nodiscard]] bool operator!=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
    {
        return nullptr != _Right.get();
    }

    template <class _Ty>[[nodiscard]] bool operator<(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
    {
        return _Left.get() < static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
    }

    template <class _Ty>[[nodiscard]] bool operator<(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
    {
        return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) < _Right.get();
    }

    template <class _Ty>[[nodiscard]] bool operator>=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
    {
        return _Left.get() >= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
    }

    template <class _Ty>[[nodiscard]] bool operator>=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
    {
        return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) >= _Right.get();
    }

    template <class _Ty>[[nodiscard]] bool operator>(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
    {
        return _Left.get() > static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
    }

    template <class _Ty>[[nodiscard]] bool operator>(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
    {
        return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) > _Right.get();
    }

    template <class _Ty>[[nodiscard]] bool operator<=(const shared_ptr<_Ty>& _Left, nullptr_t) noexcept
    {
        return _Left.get() <= static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr);
    }

    template <class _Ty>[[nodiscard]] bool operator<=(nullptr_t, const shared_ptr<_Ty>& _Right) noexcept
    {
        return static_cast<typename shared_ptr<_Ty>::element_type*>(nullptr) <= _Right.get();
    }

    template <class _Elem, class _Traits, class _Ty>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const shared_ptr<_Ty>& _Px)
    {
        return _Out << _Px.get();
    }

    template <class _Ty> void swap(shared_ptr<_Ty>& _Left, shared_ptr<_Ty>& _Right) noexcept
    {
        _Left.swap(_Right);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
    {
        const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
        return shared_ptr<_Ty1>(_Other, _Ptr);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] shared_ptr<_Ty1> static_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept
    {
        const auto _Ptr = static_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
        return shared_ptr<_Ty1>(::std::move(_Other), _Ptr);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
    {
        const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
        return shared_ptr<_Ty1>(_Other, _Ptr);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] shared_ptr<_Ty1> const_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept
    {
        const auto _Ptr = const_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
        return shared_ptr<_Ty1>(::std::move(_Other), _Ptr);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
    {
        const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
        return shared_ptr<_Ty1>(_Other, _Ptr);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] shared_ptr<_Ty1> reinterpret_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept
    {
        const auto _Ptr = reinterpret_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());
        return shared_ptr<_Ty1>(::std::move(_Other), _Ptr);
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(const shared_ptr<_Ty2>& _Other) noexcept
    {
        const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

        if(_Ptr)
        {
            return shared_ptr<_Ty1>(_Other, _Ptr);
        }

        return shared_ptr<_Ty1>();
    }

    template <class _Ty1, class _Ty2>
    [[nodiscard]] shared_ptr<_Ty1> dynamic_pointer_cast(shared_ptr<_Ty2>&& _Other) noexcept
    {
        const auto _Ptr = dynamic_cast<typename shared_ptr<_Ty1>::element_type*>(_Other.get());

        if(_Ptr)
        {
            return shared_ptr<_Ty1>(::std::move(_Other), _Ptr);
        }

        return shared_ptr<_Ty1>();
    }

    template <class _Dx, class _Ty>[[nodiscard]] _Dx* get_deleter(const shared_ptr<_Ty>& _Sx) noexcept
    {
        if(_Sx._Rep)
        {
            return static_cast<_Dx*>(_Sx._Rep->_Get_deleter(typeid(_Dx)));
        }

        return nullptr;
    }

    template <class _Ty> class _Ref_count_obj2 : public _Ref_count_base
    {
    public:
        template <class... _Types> explicit _Ref_count_obj2(_Types&&... _Args) : _Ref_count_base()
        {
            _Construct_in_place(_Storage._Value, ::std::forward<_Types>(_Args)...);
        }

        ~_Ref_count_obj2()
        {
        }

        union
        {
            _Wrap<_Ty> _Storage;
        };

    private:
        virtual void _Destroy() noexcept override
        {
            _Destroy_in_place(_Storage._Value);
        }

        virtual void _Delete_this() noexcept override
        {
            delete this;
        }
    };

    template <class _Ty, bool = is_empty_v<_Ty> && !is_final_v<_Ty>> class _Ebco_base : private _Ty
    {
    private:
        using _Mybase = _Ty;

    protected:
        template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
        explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Ty(::std::forward<_Other>(_Val))
        {
        }

        _Ty& _Get_val() noexcept
        {
            return *this;
        }

        const _Ty& _Get_val() const noexcept
        {
            return *this;
        }
    };

    template <class _Ty> class _Ebco_base<_Ty, false>
    {
    private:
        _Ty _Myval;

    protected:
        template <class _Other, enable_if_t<!is_same_v<_Remove_cvref_t<_Other>, _Ebco_base>, int> = 0>
        explicit _Ebco_base(_Other&& _Val) noexcept(is_nothrow_constructible_v<_Ty, _Other>)
        : _Myval(::std::forward<_Other>(_Val))
        {
        }

        _Ty& _Get_val() noexcept
        {
            return _Myval;
        }

        const _Ty& _Get_val() const noexcept
        {
            return _Myval;
        }
    };

    template <class _Ty, class _Alloc>
    class __declspec(empty_bases) _Ref_count_obj_alloc2 : public _Ebco_base<_Alloc>, public _Ref_count_base
    {
    public:
        template <class... _Types>
        explicit _Ref_count_obj_alloc2(const _Alloc& _Al_arg, _Types&&... _Args)
        : _Ebco_base<_Alloc>(_Al_arg), _Ref_count_base()
        {
            _Maybe_rebind_alloc_t<_Alloc, _Ty> _Alty(this->_Get_val());
            allocator_traits<_Rebind_alloc_t<_Alloc, _Ty>>::construct(_Alty, ::std::addressof(_Storage._Value),
                                                                      ::std::forward<_Types>(_Args)...);
        }

        union
        {
            _Wrap<_Ty> _Storage;
        };

    private:
        ~_Ref_count_obj_alloc2()
        {
        }

        virtual void _Destroy() noexcept override
        {
            _Maybe_rebind_alloc_t<_Alloc, _Ty> _Alty(this->_Get_val());
            allocator_traits<_Rebind_alloc_t<_Alloc, _Ty>>::destroy(_Alty, ::std::addressof(_Storage._Value));
        }

        virtual void _Delete_this() noexcept override
        {
            _Rebind_alloc_t<_Alloc, _Ref_count_obj_alloc2> _Al(this->_Get_val());
            this->~_Ref_count_obj_alloc2();
            _Deallocate_plain(_Al, this);
        }
    };

    template <class _Ty, class... _Types>[[nodiscard]] shared_ptr<_Ty> make_shared(_Types&&... _Args)
    {
        const auto _Rx = new _Ref_count_obj2<_Ty>(::std::forward<_Types>(_Args)...);
        shared_ptr<_Ty> _Ret;
        _Ret._Set_ptr_rep_and_enable_shared(::std::addressof(_Rx->_Storage._Value), _Rx);
        return _Ret;
    }

    template <class _Ty, class _Alloc, class... _Types>
    [[nodiscard]] shared_ptr<_Ty> allocate_shared(const _Alloc& _Al, _Types&&... _Args)
    {
        using _Refoa = _Ref_count_obj_alloc2<remove_cv_t<_Ty>, _Alloc>;
        using _Alblock = _Rebind_alloc_t<_Alloc, _Refoa>;
        _Alblock _Rebound(_Al);
        _Alloc_construct_ptr<_Alblock> _Constructor{ _Rebound };
        _Constructor._Allocate();
        _Construct_in_place(*_Constructor._Ptr, _Al, ::std::forward<_Types>(_Args)...);
        shared_ptr<_Ty> _Ret;
        const auto _Ptr = reinterpret_cast<_Ty*>(::std::addressof(_Constructor._Ptr->_Storage._Value));
        _Ret._Set_ptr_rep_and_enable_shared(_Ptr, _Unfancy(_Constructor._Release()));
        return _Ret;
    }

    template <class _Ty> class weak_ptr : public _Ptr_base<_Ty>
    {
    public:
        constexpr weak_ptr() noexcept
        {
        }

        weak_ptr(const weak_ptr& _Other) noexcept
        {
            this->_Weakly_construct_from(_Other);
        }

        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
        weak_ptr(const shared_ptr<_Ty2>& _Other) noexcept
        {
            this->_Weakly_construct_from(_Other);
        }

        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
        weak_ptr(const weak_ptr<_Ty2>& _Other) noexcept
        {
            this->_Weakly_construct_from(_Other.lock());
        }

        weak_ptr(weak_ptr&& _Other) noexcept
        {
            this->_Move_construct_from(::std::move(_Other));
        }

        template <class _Ty2, enable_if_t<_SP_pointer_compatible<_Ty2, _Ty>::value, int> = 0>
        weak_ptr(weak_ptr<_Ty2>&& _Other) noexcept
        {
            this->_Weakly_construct_from(_Other.lock());
            _Other.reset();
        }

        ~weak_ptr() noexcept
        {
            this->_Decwref();
        }

        weak_ptr& operator=(const weak_ptr& _Right) noexcept
        {
            weak_ptr(_Right).swap(*this);
            return *this;
        }

        template <class _Ty2> weak_ptr& operator=(const weak_ptr<_Ty2>& _Right) noexcept
        {
            weak_ptr(_Right).swap(*this);
            return *this;
        }

        weak_ptr& operator=(weak_ptr&& _Right) noexcept
        {
            weak_ptr(::std::move(_Right)).swap(*this);
            return *this;
        }

        template <class _Ty2> weak_ptr& operator=(weak_ptr<_Ty2>&& _Right) noexcept
        {
            weak_ptr(::std::move(_Right)).swap(*this);
            return *this;
        }

        template <class _Ty2> weak_ptr& operator=(const shared_ptr<_Ty2>& _Right) noexcept
        {
            weak_ptr(_Right).swap(*this);
            return *this;
        }

        void reset() noexcept
        {
            weak_ptr().swap(*this);
        }

        void swap(weak_ptr& _Other) noexcept
        {
            this->_Swap(_Other);
        }

        [[nodiscard]] bool expired() const noexcept
        {
            return this->use_count() == 0;
        }

        [[nodiscard]] shared_ptr<_Ty> lock() const noexcept
        {
            shared_ptr<_Ty> _Ret;
            (void)_Ret._Construct_from_weak(*this);
            return _Ret;
        }
    };

    template <class _Ty> void swap(weak_ptr<_Ty>& _Left, weak_ptr<_Ty>& _Right) noexcept
    {
        _Left.swap(_Right);
    }

    template <class _Ty> class enable_shared_from_this
    {
    public:
        using _Esft_type = enable_shared_from_this;

        [[nodiscard]] shared_ptr<_Ty> shared_from_this()
        {
            return shared_ptr<_Ty>(_Wptr);
        }

        [[nodiscard]] shared_ptr<const _Ty> shared_from_this() const
        {
            return shared_ptr<const _Ty>(_Wptr);
        }

        [[nodiscard]] weak_ptr<_Ty> weak_from_this() noexcept
        {
            return _Wptr;
        }

        [[nodiscard]] weak_ptr<const _Ty> weak_from_this() const noexcept
        {
            return _Wptr;
        }

    protected:
        constexpr enable_shared_from_this() noexcept : _Wptr()
        {
        }

        enable_shared_from_this(const enable_shared_from_this&) noexcept : _Wptr()
        {
        }

        enable_shared_from_this& operator=(const enable_shared_from_this&) noexcept
        {
            return *this;
        }

        ~enable_shared_from_this() = default;

    private:
        template <class _Yty> friend class shared_ptr;

        mutable weak_ptr<_Ty> _Wptr;
    };

    template <class _Ty> struct default_delete
    {
        constexpr default_delete() noexcept = default;

        template <class _Ty2, enable_if_t<is_convertible_v<_Ty2*, _Ty*>, int> = 0>
        default_delete(const default_delete<_Ty2>&) noexcept
        {
        }

        void operator()(_Ty* _Ptr) const noexcept
        {
            static_assert(0 < sizeof(_Ty), "can't delete an incomplete type");
            delete _Ptr;
        }
    };

    template <class _Ty> struct default_delete<_Ty[]>
    {
        constexpr default_delete() noexcept = default;

        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
        default_delete(const default_delete<_Uty[]>&) noexcept
        {
        }

        template <class _Uty, enable_if_t<is_convertible_v<_Uty (*)[], _Ty (*)[]>, int> = 0>
        void operator()(_Uty* _Ptr) const noexcept
        {
            static_assert(0 < sizeof(_Uty), "can't delete an incomplete type");
            delete[] _Ptr;
        }
    };

    template <class _Ty, class _Dx_noref, class = void> struct _Get_deleter_pointer_type
    {
        using type = _Ty*;
    };

    template <class _Ty, class _Dx_noref>
    struct _Get_deleter_pointer_type<_Ty, _Dx_noref, void_t<typename _Dx_noref::pointer>>
    {
        using type = typename _Dx_noref::pointer;
    };

    template <class _Dx2>
    using _Unique_ptr_enable_default_t
    = enable_if_t<conjunction_v<negation<is_pointer<_Dx2>>, is_default_constructible<_Dx2>>, int>;

    template <class _Ty, class _Dx> class unique_ptr
    {
    public:
        using pointer = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
        using element_type = _Ty;
        using deleter_type = _Dx;

        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
        constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t())
        {
        }

        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
        constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t())
        {
        }

        unique_ptr& operator=(nullptr_t) noexcept
        {
            reset();
            return *this;
        }

        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
        explicit unique_ptr(pointer _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr)
        {
        }

        template <class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0>
        unique_ptr(pointer _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t(), _Dt, _Ptr)
        {
        }

        template <class _Dx2 = _Dx, enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0>
        unique_ptr(pointer _Ptr, _Dx&& _Dt) noexcept : _Mypair(_One_then_variadic_args_t(), ::std::move(_Dt), _Ptr)
        {
        }

        template <class _Dx2 = _Dx, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
        unique_ptr(pointer, remove_reference_t<_Dx>&&) = delete;

        unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std::forward<_Dx>(_Right.get_deleter()), _Right.release())
        {
        }

        template <class _Ty2,
                  class _Dx2,
                  enable_if_t<conjunction_v<negation<is_array<_Ty2>>,
                                            is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>,
                                            conditional_t<is_reference_v<_Dx>, is_same<_Dx2, _Dx>, is_convertible<_Dx2, _Dx>>>,
                              int> = 0>
        unique_ptr(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std::forward<_Dx2>(_Right.get_deleter()), _Right.release())
        {
        }

        template <class _Ty2, enable_if_t<conjunction_v<is_convertible<_Ty2*, _Ty*>, is_same<_Dx, default_delete<_Ty>>>, int> = 0>
        unique_ptr(auto_ptr<_Ty2>&& _Right) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Right.release())
        {
        }

        template <class _Ty2, class _Dx2, enable_if_t<conjunction_v<negation<is_array<_Ty2>>, is_assignable<_Dx&, _Dx2>, is_convertible<typename unique_ptr<_Ty2, _Dx2>::pointer, pointer>>, int> = 0>
        unique_ptr& operator=(unique_ptr<_Ty2, _Dx2>&& _Right) noexcept
        {
            reset(_Right.release());
            _Mypair._Get_first() = ::std::forward<_Dx2>(_Right._Mypair._Get_first());
            return *this;
        }

        unique_ptr& operator=(unique_ptr&& _Right) noexcept
        {
            if(this != ::std::addressof(_Right))
            {
                reset(_Right.release());
                _Mypair._Get_first() = ::std::forward<_Dx>(_Right._Mypair._Get_first());
            }
            return *this;
        }

        void swap(unique_ptr& _Right) noexcept
        {
            _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
            _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
        }

        ~unique_ptr() noexcept
        {
            if(_Mypair._Myval2)
            {
                _Mypair._Get_first()(_Mypair._Myval2);
            }
        }

        [[nodiscard]] _Dx& get_deleter() noexcept
        {
            return _Mypair._Get_first();
        }

        [[nodiscard]] const _Dx& get_deleter() const noexcept
        {
            return _Mypair._Get_first();
        }

        [[nodiscard]] add_lvalue_reference_t<_Ty> operator*() const noexcept
        {
            return *_Mypair._Myval2;
        }

        [[nodiscard]] pointer operator->() const noexcept
        {
            return _Mypair._Myval2;
        }

        [[nodiscard]] pointer get() const noexcept
        {
            return _Mypair._Myval2;
        }

        explicit operator bool() const noexcept
        {
            return static_cast<bool>(_Mypair._Myval2);
        }

        pointer release() noexcept
        {
            return ::std::exchange(_Mypair._Myval2, pointer());
        }

        void reset(pointer _Ptr = pointer()) noexcept
        {
            pointer _Old = ::std::exchange(_Mypair._Myval2, _Ptr);
            if(_Old)
            {
                _Mypair._Get_first()(_Old);
            }
        }

        unique_ptr(const unique_ptr&) = delete;
        unique_ptr& operator=(const unique_ptr&) = delete;

    private:
        template <class, class> friend class unique_ptr;

        _Compressed_pair<_Dx, pointer> _Mypair;
    };

    template <class _Ty, class _Dx> class unique_ptr<_Ty[], _Dx>
    {
    public:
        using pointer = typename _Get_deleter_pointer_type<_Ty, remove_reference_t<_Dx>>::type;
        using element_type = _Ty;
        using deleter_type = _Dx;

        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
        constexpr unique_ptr() noexcept : _Mypair(_Zero_then_variadic_args_t())
        {
        }

        template <class _Uty, class _Is_nullptr = is_same<_Uty, nullptr_t>>
        using _Enable_ctor_reset
        = enable_if_t<is_same_v<_Uty, pointer> || _Is_nullptr::value
                      || (is_same_v<pointer, element_type*> && is_pointer_v<_Uty> && is_convertible_v<remove_pointer_t<_Uty> (*)[], element_type (*)[]>)>;

        template <class _Uty, class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0, class = _Enable_ctor_reset<_Uty>>
        explicit unique_ptr(_Uty _Ptr) noexcept : _Mypair(_Zero_then_variadic_args_t(), _Ptr)
        {
        }

        template <class _Uty, class _Dx2 = _Dx, enable_if_t<is_constructible_v<_Dx2, const _Dx2&>, int> = 0, class = _Enable_ctor_reset<_Uty>>
        unique_ptr(_Uty _Ptr, const _Dx& _Dt) noexcept : _Mypair(_One_then_variadic_args_t(), _Dt, _Ptr)
        {
        }

        template <class _Uty, class _Dx2 = _Dx, enable_if_t<conjunction_v<negation<is_reference<_Dx2>>, is_constructible<_Dx2, _Dx2>>, int> = 0, class = _Enable_ctor_reset<_Uty>>
        unique_ptr(_Uty _Ptr, _Dx&& _Dt) noexcept : _Mypair(_One_then_variadic_args_t(), ::std::move(_Dt), _Ptr)
        {
        }

        template <class _Uty, class _Dx2 = _Dx, enable_if_t<conjunction_v<is_reference<_Dx2>, is_constructible<_Dx2, remove_reference_t<_Dx2>>>, int> = 0>
        unique_ptr(_Uty, remove_reference_t<_Dx>&&) = delete;

        unique_ptr(unique_ptr&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std::forward<_Dx>(_Right.get_deleter()), _Right.release())
        {
        }

        unique_ptr& operator=(unique_ptr&& _Right) noexcept
        {
            if(this != ::std::addressof(_Right))
            {
                reset(_Right.release());
                _Mypair._Get_first() = ::std::move(_Right._Mypair._Get_first());
            }

            return *this;
        }

        template <class _Uty, class _Ex, class _More, class _UP_pointer = typename unique_ptr<_Uty, _Ex>::pointer, class _UP_element_type = typename unique_ptr<_Uty, _Ex>::element_type>
        using _Enable_conversion
        = enable_if_t<conjunction_v<is_array<_Uty>, is_same<pointer, element_type*>, is_same<_UP_pointer, _UP_element_type*>, is_convertible<_UP_element_type (*)[], element_type (*)[]>, _More>>;

        template <class _Uty, class _Ex, class = _Enable_conversion<_Uty, _Ex, conditional_t<is_reference_v<_Dx>, is_same<_Ex, _Dx>, is_convertible<_Ex, _Dx>>>>
        unique_ptr(unique_ptr<_Uty, _Ex>&& _Right) noexcept
        : _Mypair(_One_then_variadic_args_t(), ::std::forward<_Ex>(_Right.get_deleter()), _Right.release())
        {
        }

        template <class _Uty, class _Ex, class = _Enable_conversion<_Uty, _Ex, is_assignable<_Dx&, _Ex>>>
        unique_ptr& operator=(unique_ptr<_Uty, _Ex>&& _Right) noexcept
        {
            reset(_Right.release());
            _Mypair._Get_first() = ::std::forward<_Ex>(_Right._Mypair._Get_first());
            return *this;
        }

        template <class _Dx2 = _Dx, _Unique_ptr_enable_default_t<_Dx2> = 0>
        constexpr unique_ptr(nullptr_t) noexcept : _Mypair(_Zero_then_variadic_args_t())
        {
        }

        unique_ptr& operator=(nullptr_t) noexcept
        {
            reset();
            return *this;
        }

        void reset(nullptr_t = nullptr) noexcept
        {
            reset(pointer());
        }

        void swap(unique_ptr& _Right) noexcept
        {
            _Swap_adl(_Mypair._Myval2, _Right._Mypair._Myval2);
            _Swap_adl(_Mypair._Get_first(), _Right._Mypair._Get_first());
        }

        ~unique_ptr() noexcept
        {
            if(_Mypair._Myval2)
            {
                _Mypair._Get_first()(_Mypair._Myval2);
            }
        }

        [[nodiscard]] _Dx& get_deleter() noexcept
        {
            return _Mypair._Get_first();
        }

        [[nodiscard]] const _Dx& get_deleter() const noexcept
        {
            return _Mypair._Get_first();
        }

        [[nodiscard]] _Ty& operator[](size_t _Idx) const noexcept
        {
            return _Mypair._Myval2[_Idx];
        }

        [[nodiscard]] pointer get() const noexcept
        {
            return _Mypair._Myval2;
        }

        explicit operator bool() const noexcept
        {
            return static_cast<bool>(_Mypair._Myval2);
        }

        pointer release() noexcept
        {
            return ::std::exchange(_Mypair._Myval2, pointer());
        }

        template <class _Uty, class = _Enable_ctor_reset<_Uty, false_type>> void reset(_Uty _Ptr) noexcept
        {
            pointer _Old = ::std::exchange(_Mypair._Myval2, _Ptr);
            if(_Old)
            {
                _Mypair._Get_first()(_Old);
            }
        }

        unique_ptr(const unique_ptr&) = delete;
        unique_ptr& operator=(const unique_ptr&) = delete;

    private:
        template <class, class> friend class unique_ptr;

        _Compressed_pair<_Dx, pointer> _Mypair;
    };

    template <class _Ty, class... _Types, enable_if_t<!is_array_v<_Ty>, int> = 0>
    [[nodiscard]] unique_ptr<_Ty> make_unique(_Types&&... _Args)
    {
        return unique_ptr<_Ty>(new _Ty(::std::forward<_Types>(_Args)...));
    }

    template <class _Ty, enable_if_t<is_array_v<_Ty> && extent_v<_Ty> == 0, int> = 0>
    [[nodiscard]] unique_ptr<_Ty> make_unique(size_t _Size)
    {
        using _Elem = remove_extent_t<_Ty>;
        return unique_ptr<_Ty>(new _Elem[_Size]());
    }

    template <class _Ty, class... _Types, enable_if_t<extent_v<_Ty> != 0, int> = 0>
    void make_unique(_Types&&...) = delete;

    template <class _Ty, class _Dx, enable_if_t<_Is_swappable<_Dx>::value, int> = 0>
    void swap(unique_ptr<_Ty, _Dx>& _Left, unique_ptr<_Ty, _Dx>& _Right) noexcept
    {
        _Left.swap(_Right);
    }

    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
    [[nodiscard]] bool operator==(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
    {
        return _Left.get() == _Right.get();
    }

    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
    [[nodiscard]] bool operator!=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
    {
        return !(_Left == _Right);
    }

    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
    [[nodiscard]] bool operator<(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
    {
        using _Ptr1 = typename unique_ptr<_Ty1, _Dx1>::pointer;
        using _Ptr2 = typename unique_ptr<_Ty2, _Dx2>::pointer;
        using _Common = common_type_t<_Ptr1, _Ptr2>;
        return less<_Common>()(_Left.get(), _Right.get());
    }

    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
    [[nodiscard]] bool operator>=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
    {
        return !(_Left < _Right);
    }

    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
    [[nodiscard]] bool operator>(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
    {
        return _Right < _Left;
    }

    template <class _Ty1, class _Dx1, class _Ty2, class _Dx2>
    [[nodiscard]] bool operator<=(const unique_ptr<_Ty1, _Dx1>& _Left, const unique_ptr<_Ty2, _Dx2>& _Right)
    {
        return !(_Right < _Left);
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator==(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t) noexcept
    {
        return !_Left;
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator==(nullptr_t, const unique_ptr<_Ty, _Dx>& _Right) noexcept
    {
        return !_Right;
    }

    template <class _Ty, class _Dx>
    [[nodiscard]] bool operator!=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right) noexcept
    {
        return !(_Left == _Right);
    }

    template <class _Ty, class _Dx>
    [[nodiscard]] bool operator!=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right) noexcept
    {
        return !(_Left == _Right);
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator<(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
    {
        using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
        return less<_Ptr>()(_Left.get(), _Right);
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator<(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
    {
        using _Ptr = typename unique_ptr<_Ty, _Dx>::pointer;
        return less<_Ptr>()(_Left, _Right.get());
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator>=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
    {
        return !(_Left < _Right);
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator>=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
    {
        return !(_Left < _Right);
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator>(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
    {
        return _Right < _Left;
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator>(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
    {
        return _Right < _Left;
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator<=(const unique_ptr<_Ty, _Dx>& _Left, nullptr_t _Right)
    {
        return !(_Right < _Left);
    }

    template <class _Ty, class _Dx>[[nodiscard]] bool operator<=(nullptr_t _Left, const unique_ptr<_Ty, _Dx>& _Right)
    {
        return !(_Right < _Left);
    }

    template <class _OutTy, class _PxTy, class = void> struct _Can_stream_unique_ptr : false_type
    {
    };
    template <class _OutTy, class _PxTy>
    struct _Can_stream_unique_ptr<_OutTy, _PxTy, void_t<decltype(::std::declval<_OutTy>() << ::std::declval<_PxTy>().get())>> : true_type
    {
    };

    template <class _Elem, class _Traits, class _Yty, class _Dx, enable_if_t<_Can_stream_unique_ptr<basic_ostream<_Elem, _Traits>&, const unique_ptr<_Yty, _Dx>&>::value, int> = 0>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Out, const unique_ptr<_Yty, _Dx>& _Px)
    {
        _Out << _Px.get();
        return _Out;
    }

    enum class pointer_safety
    {
        relaxed,
        preferred,
        strict
    };

    inline void declare_reachable(void*)
    {
    }

    template <class _Ty> _Ty* undeclare_reachable(_Ty* _Ptr)
    {
        return _Ptr;
    }

    inline void declare_no_pointers(char*, size_t)
    {
    }

    inline void undeclare_no_pointers(char*, size_t)
    {
    }

    inline pointer_safety get_pointer_safety() noexcept
    {
        return pointer_safety::relaxed;
    }

    template <class _Ty = void> struct owner_less;

    template <class _Ty> struct owner_less<shared_ptr<_Ty>>
    {
        typedef shared_ptr<_Ty> first_argument_type;
        typedef shared_ptr<_Ty> second_argument_type;
        typedef bool result_type;

        [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }

        [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }

        [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }
    };

    template <class _Ty> struct owner_less<weak_ptr<_Ty>>
    {
        typedef weak_ptr<_Ty> first_argument_type;
        typedef weak_ptr<_Ty> second_argument_type;
        typedef bool result_type;

        [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }

        [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Ty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }

        [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Ty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }
    };

    template <> struct owner_less<void>
    {
        using is_transparent = int;

        template <class _Ty, class _Uty>
        [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }

        template <class _Ty, class _Uty>
        [[nodiscard]] bool operator()(const shared_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }

        template <class _Ty, class _Uty>
        [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const shared_ptr<_Uty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }

        template <class _Ty, class _Uty>
        [[nodiscard]] bool operator()(const weak_ptr<_Ty>& _Left, const weak_ptr<_Uty>& _Right) const noexcept
        {
            return _Left.owner_before(_Right);
        }
    };

    template <class _Ty, class _Dx>
    struct hash<unique_ptr<_Ty, _Dx>>
    : _Conditionally_enabled_hash<unique_ptr<_Ty, _Dx>, is_default_constructible_v<hash<typename unique_ptr<_Ty, _Dx>::pointer>>>
    {
        static size_t
        _Do_hash(const unique_ptr<_Ty, _Dx>& _Keyval) noexcept(_Is_nothrow_hashable<typename unique_ptr<_Ty, _Dx>::pointer>::value)
        {
            return hash<typename unique_ptr<_Ty, _Dx>::pointer>{}(_Keyval.get());
        }
    };

    template <class _Ty> struct hash<shared_ptr<_Ty>>
    {
        typedef shared_ptr<_Ty> argument_type;
        typedef size_t result_type;

        [[nodiscard]] size_t operator()(const shared_ptr<_Ty>& _Keyval) const noexcept
        {
            return hash<typename shared_ptr<_Ty>::element_type*>()(_Keyval.get());
        }
    };

    inline void* align(size_t _Bound, size_t _Size, void*& _Ptr, size_t& _Space) noexcept
    {
        size_t _Off = static_cast<size_t>(reinterpret_cast<uintptr_t>(_Ptr) & (_Bound - 1));
        if(_Off != 0)
        {
            _Off = _Bound - _Off;
        }

        if(_Space < _Off || _Space - _Off < _Size)
        {
            return nullptr;
        }

        _Ptr = static_cast<char*>(_Ptr) + _Off;
        _Space -= _Off;
        return _Ptr;
    }

    extern "C"
    {
        void __cdecl _Lock_shared_ptr_spin_lock();
        void __cdecl _Unlock_shared_ptr_spin_lock();
    }

    struct _Shared_ptr_spin_lock
    {
        _Shared_ptr_spin_lock()
        {
            _Lock_shared_ptr_spin_lock();
        }

        ~_Shared_ptr_spin_lock() noexcept
        {
            _Unlock_shared_ptr_spin_lock();
        }
    };

    template <class _Ty>[[nodiscard]] bool atomic_is_lock_free(const shared_ptr<_Ty>*)
    {
        return false;
    }

    template <class _Ty>[[nodiscard]] shared_ptr<_Ty> atomic_load_explicit(const shared_ptr<_Ty>* _Ptr, memory_order)
    {
        _Shared_ptr_spin_lock _Lock;
        shared_ptr<_Ty> _Result = *_Ptr;
        return _Result;
    }

    template <class _Ty>[[nodiscard]] shared_ptr<_Ty> atomic_load(const shared_ptr<_Ty>* _Ptr)
    {
        return ::std::atomic_load_explicit(_Ptr, memory_order_seq_cst);
    }

    template <class _Ty> void atomic_store_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order)
    {
        _Shared_ptr_spin_lock _Lock;
        _Ptr->swap(_Other);
    }

    template <class _Ty> void atomic_store(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other)
    {
        ::std::atomic_store_explicit(_Ptr, ::std::move(_Other), memory_order_seq_cst);
    }

    template <class _Ty>
    shared_ptr<_Ty> atomic_exchange_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other, memory_order)
    {
        _Shared_ptr_spin_lock _Lock;
        _Ptr->swap(_Other);
        return _Other;
    }

    template <class _Ty> shared_ptr<_Ty> atomic_exchange(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty> _Other)
    {
        return ::std::atomic_exchange_explicit(_Ptr, ::std::move(_Other), memory_order_seq_cst);
    }

    template <class _Ty>
    bool atomic_compare_exchange_weak_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order)
    {
        shared_ptr<_Ty> _Old_exp;
        _Shared_ptr_spin_lock _Lock;
        bool _Success = _Ptr->get() == _Exp->get() && !_Ptr->owner_before(*_Exp) && !_Exp->owner_before(*_Ptr);
        if(_Success)
        {
            _Ptr->swap(_Value);
        }
        else
        {
            _Exp->swap(_Old_exp);
            *_Exp = *_Ptr;
        }
        return _Success;
    }

    template <class _Ty>
    bool atomic_compare_exchange_weak(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value)
    {
        return ::std::atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std::move(_Value), memory_order_seq_cst, memory_order_seq_cst);
    }

    template <class _Ty>
    bool atomic_compare_exchange_strong_explicit(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value, memory_order, memory_order)
    {
        return ::std::atomic_compare_exchange_weak_explicit(_Ptr, _Exp, ::std::move(_Value), memory_order_seq_cst, memory_order_seq_cst);
    }

    template <class _Ty>
    bool atomic_compare_exchange_strong(shared_ptr<_Ty>* _Ptr, shared_ptr<_Ty>* _Exp, shared_ptr<_Ty> _Value)
    {
        return ::std::atomic_compare_exchange_strong_explicit(_Ptr, _Exp, ::std::move(_Value), memory_order_seq_cst, memory_order_seq_cst);
    }

    namespace [[deprecated(
    "warning STL4002: "
    "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
    "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1
    {
        using ::std::allocate_shared;
        using ::std::bad_weak_ptr;
        using ::std::const_pointer_cast;
        using ::std::dynamic_pointer_cast;
        using ::std::enable_shared_from_this;
        using ::std::get_deleter;
        using ::std::make_shared;
        using ::std::shared_ptr;
        using ::std::static_pointer_cast;
        using ::std::swap;
        using ::std::weak_ptr;
    }// namespace tr1

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    class __declspec(dllimport) _Facet_base
    {
    public:
        virtual ~_Facet_base() noexcept
        {
        }

        virtual void _Incref() noexcept = 0;

        virtual _Facet_base* _Decref() noexcept = 0;
    };

    void __cdecl _Facet_Register_m(_Facet_base*);

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    __declspec(dllimport) int __cdecl _isctype(int _C, int _Type);
    __declspec(dllimport) int __cdecl _isctype_l(int _C, int _Type, _locale_t _Locale);
    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl isalpha(int _C);
    __declspec(dllimport) int __cdecl _isalpha_l(int _C, _locale_t _Locale);
    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl isupper(int _C);
    __declspec(dllimport) int __cdecl _isupper_l(int _C, _locale_t _Locale);
    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl islower(int _C);
    __declspec(dllimport) int __cdecl _islower_l(int _C, _locale_t _Locale);

    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl isdigit(int _C);

    __declspec(dllimport) int __cdecl _isdigit_l(int _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl isxdigit(int _C);
    __declspec(dllimport) int __cdecl _isxdigit_l(int _C, _locale_t _Locale);

    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl isspace(int _C);

    __declspec(dllimport) int __cdecl _isspace_l(int _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl ispunct(int _C);
    __declspec(dllimport) int __cdecl _ispunct_l(int _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl isblank(int _C);
    __declspec(dllimport) int __cdecl _isblank_l(int _C, _locale_t _Locale);
    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl isalnum(int _C);
    __declspec(dllimport) int __cdecl _isalnum_l(int _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl isprint(int _C);
    __declspec(dllimport) int __cdecl _isprint_l(int _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl isgraph(int _C);
    __declspec(dllimport) int __cdecl _isgraph_l(int _C, _locale_t _Locale);
    __declspec(dllimport) int __cdecl iscntrl(int _C);
    __declspec(dllimport) int __cdecl _iscntrl_l(int _C, _locale_t _Locale);

    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl toupper(int _C);

    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl tolower(int _C);

    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl _tolower(int _C);
    __declspec(dllimport) int __cdecl _tolower_l(int _C, _locale_t _Locale);
    __declspec(jitintrinsic) __declspec(dllimport) int __cdecl _toupper(int _C);
    __declspec(dllimport) int __cdecl _toupper_l(int _C, _locale_t _Locale);

    __declspec(dllimport) int __cdecl __isascii(int _C);
    __declspec(dllimport) int __cdecl __toascii(int _C);
    __declspec(dllimport) int __cdecl __iscsymf(int _C);
    __declspec(dllimport) int __cdecl __iscsym(int _C);

    __inline int __cdecl __acrt_locale_get_ctype_array_value(unsigned short const* const _Locale_pctype_array,
                                                             int const _Char_value, int const _Mask)
    {
        if(_Char_value >= -1 && _Char_value <= 255)
        {
            return _Locale_pctype_array[_Char_value] & _Mask;
        }

        return 0;
    }

    __inline __crt_locale_data_public* __cdecl __acrt_get_locale_data_prefix(void const volatile* const _LocalePointers)
    {
        _locale_t const _TypedLocalePointers = (_locale_t)_LocalePointers;
        return (__crt_locale_data_public*)_TypedLocalePointers->locinfo;
    }

    __inline int __cdecl _chvalidchk_l(int const _C, int const _Mask, _locale_t const _Locale)
    {
        if(_Locale)
        {
            return __acrt_locale_get_ctype_array_value(__acrt_get_locale_data_prefix(_Locale)->_locale_pctype, _C, _Mask);
        }

        return (__acrt_locale_get_ctype_array_value(__pctype_func(), (_C), (_Mask)));
    }

    __inline int __cdecl _ischartype_l(int const _C, int const _Mask, _locale_t const _Locale)
    {
        if(_Locale && __acrt_get_locale_data_prefix(_Locale)->_locale_mb_cur_max > 1)
        {
            return _isctype_l(_C, _Mask, _Locale);
        }

        return _chvalidchk_l(_C, _Mask, _Locale);
    }
}
__pragma(pack(pop))

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    struct lconv
    {
        char* decimal_point;
        char* thousands_sep;
        char* grouping;
        char* int_curr_symbol;
        char* currency_symbol;
        char* mon_decimal_point;
        char* mon_thousands_sep;
        char* mon_grouping;
        char* positive_sign;
        char* negative_sign;
        char int_frac_digits;
        char frac_digits;
        char p_cs_precedes;
        char p_sep_by_space;
        char n_cs_precedes;
        char n_sep_by_space;
        char p_sign_posn;
        char n_sign_posn;
        wchar_t* _W_decimal_point;
        wchar_t* _W_thousands_sep;
        wchar_t* _W_int_curr_symbol;
        wchar_t* _W_currency_symbol;
        wchar_t* _W_mon_decimal_point;
        wchar_t* _W_mon_thousands_sep;
        wchar_t* _W_positive_sign;
        wchar_t* _W_negative_sign;
    };

    struct tm;

    __declspec(dllimport) void __cdecl _lock_locales(void);
    __declspec(dllimport) void __cdecl _unlock_locales(void);

    __declspec(dllimport) int __cdecl _configthreadlocale(int _Flag);

    __declspec(dllimport) char* __cdecl setlocale(int _Category, char const* _Locale);

    __declspec(dllimport) struct lconv* __cdecl localeconv(void);

    __declspec(dllimport) _locale_t __cdecl _get_current_locale(void);

    __declspec(dllimport) _locale_t __cdecl _create_locale(int _Category, char const* _Locale);

    __declspec(dllimport) void __cdecl _free_locale(_locale_t _Locale);

    __declspec(dllimport) wchar_t* __cdecl _wsetlocale(int _Category, wchar_t const* _Locale);

    __declspec(dllimport) _locale_t __cdecl _wcreate_locale(int _Category, wchar_t const* _Locale);

    __declspec(dllimport) wchar_t** __cdecl ___lc_locale_name_func(void);
    __declspec(dllimport) unsigned int __cdecl ___lc_codepage_func(void);
    __declspec(dllimport) unsigned int __cdecl ___lc_collate_cp_func(void);

    __declspec(dllimport) char* __cdecl _Getdays(void);

    __declspec(dllimport) char* __cdecl _Getmonths(void);

    __declspec(dllimport) void* __cdecl _Gettnames(void);

    __declspec(dllimport) wchar_t* __cdecl _W_Getdays(void);

    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths(void);

    __declspec(dllimport) void* __cdecl _W_Gettnames(void);

    __declspec(dllimport) size_t __cdecl _Strftime(char* _Buffer, size_t _Max_size, char const* _Format,
                                                   struct tm const* _Timeptr, void* _Lc_time_arg);

    __declspec(dllimport) size_t __cdecl _Wcsftime(wchar_t * _Buffer, size_t _Max_size, wchar_t const* _Format,
                                                   struct tm const* _Timeptr, void* _Lc_time_arg);
}
__pragma(pack(pop))

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

extern "C"
{
    struct _Collvec
    {
        unsigned int _Page;
        wchar_t* _LocaleName;
    };

    struct _Ctypevec
    {
        unsigned int _Page;
        const short* _Table;
        int _Delfl;
        wchar_t* _LocaleName;
    };

    struct _Cvtvec
    {
        unsigned int _Page;
        unsigned int _Mbcurmax;
        int _Isclocale;
        unsigned char _Isleadbyte[32];
    };

    _Collvec __cdecl _Getcoll();
    _Ctypevec __cdecl _Getctype();
    _Cvtvec __cdecl _Getcvt();
    int __cdecl _Getdateorder();

    int __cdecl _Mbrtowc(wchar_t*, const char*, size_t, mbstate_t*, const _Cvtvec*);

    float __cdecl _Stof(const char*, char**, long);
    double __cdecl _Stod(const char*, char**, long);
    long double __cdecl _Stold(const char*, char**, long);

    int __cdecl _Strcoll(const char*, const char*, const char*, const char*, const _Collvec*);
    size_t __cdecl _Strxfrm(char* _String1, char* _End1, const char*, const char*, const _Collvec*);
    int __cdecl _Tolower(int, const _Ctypevec*);
    int __cdecl _Toupper(int, const _Ctypevec*);
    int __cdecl _Wcrtomb(char*, wchar_t, mbstate_t*, const _Cvtvec*);
    int __cdecl _Wcscoll(const wchar_t*, const wchar_t*, const wchar_t*, const wchar_t*, const _Collvec*);
    size_t __cdecl _Wcsxfrm(wchar_t * _String1, wchar_t * _End1, const wchar_t*, const wchar_t*, const _Collvec*);

    short __cdecl _Getwctype(wchar_t, const _Ctypevec*);
    const wchar_t* __cdecl _Getwctypes(const wchar_t*, const wchar_t*, short*, const _Ctypevec*);
    wchar_t __cdecl _Towlower(wchar_t, const _Ctypevec*);
    wchar_t __cdecl _Towupper(wchar_t, const _Ctypevec*);
}

extern "C"
{
    __declspec(dllimport) char* __cdecl _Getdays();

    __declspec(dllimport) char* __cdecl _Getmonths();

    __declspec(dllimport) void* __cdecl _Gettnames();

    __declspec(dllimport) size_t __cdecl _Strftime(char*, size_t _Maxsize, const char*, const tm*, void*);

    __declspec(dllimport) wchar_t* __cdecl _W_Getdays();

    __declspec(dllimport) wchar_t* __cdecl _W_Getmonths();

    __declspec(dllimport) void* __cdecl _W_Gettnames();

    __declspec(dllimport) size_t __cdecl _Wcsftime(wchar_t*, size_t _Maxsize, const wchar_t*, const tm*, void*);
}

_locale_t __cdecl _GetLocaleForCP(unsigned int);

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    class __declspec(dllimport) _Timevec
    {
    public:
        explicit _Timevec(void* _Ptr = nullptr) : _Timeptr(_Ptr)
        {
        }

        _Timevec(const _Timevec& _Right) : _Timeptr(nullptr)
        {
            *this = _Right;
        }

        ~_Timevec() noexcept
        {
            ::free(_Timeptr);
        }

        _Timevec& operator=(const _Timevec& _Right)
        {
            if(this != &_Right)
            {
                ::free(_Timeptr);
                _Timeptr = _Right._Timeptr;
                const_cast<_Timevec&>(_Right)._Timeptr = nullptr;
            }

            return *this;
        }

        void* _Getptr() const
        {
            return _Timeptr;
        }

    private:
        void* _Timeptr;
    };

    class __declspec(dllimport) _Locinfo
    {
    public:
        using _Collvec = ::_Collvec;
        using _Ctypevec = ::_Ctypevec;
        using _Cvtvec = ::_Cvtvec;
        using _Timevec = ::std::_Timevec;

        static void __cdecl _Locinfo_ctor(_Locinfo*, const char*);
        static void __cdecl _Locinfo_ctor(_Locinfo*, int, const char*);
        static void __cdecl _Locinfo_dtor(_Locinfo*);
        static _Locinfo& __cdecl _Locinfo_Addcats(_Locinfo*, int, const char*);

        _Locinfo(const char* _Pch = "C")

        {
            if(_Pch)
            {
                _Locinfo_ctor(this, _Pch);
                return;
            }

            _Xruntime_error("bad locale name");
        }

        _Locinfo(int _Cat, const char* _Pch)

        {
            if(_Pch)
            {
                _Locinfo_ctor(this, _Cat, _Pch);
                return;
            }

            _Xruntime_error("bad locale name");
        }

        ~_Locinfo() noexcept
        {
            _Locinfo_dtor(this);
        }

        _Locinfo& _Addcats(int _Cat, const char* _Pch)
        {
            if(_Pch)
            {
                return _Locinfo_Addcats(this, _Cat, _Pch);
            }

            _Xruntime_error("bad locale name");
        }

        const char* _Getname() const
        {
            return _Newlocname._C_str();
        }

        _Collvec _Getcoll() const
        {
            return ::_Getcoll();
        }

        _Ctypevec _Getctype() const
        {
            return ::_Getctype();
        }

        _Cvtvec _Getcvt() const
        {
            return ::_Getcvt();
        }

        const lconv* _Getlconv() const
        {
            return localeconv();
        }

        _Timevec _Gettnames() const
        {
            return _Timevec(::_Gettnames());
        }

        const char* _Getdays() const
        {
            const char* _Ptr = ::_Getdays();
            if(_Ptr)
            {
                const_cast<_Locinfo*>(this)->_Days = _Ptr;
                ::free(const_cast<char*>(_Ptr));
            }

            return !_Days._Empty() ? _Days._C_str() :
                                     ":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday"
                                     ":Thu:Thursday:Fri:Friday:Sat:Saturday";
        }

        const char* _Getmonths() const
        {
            const char* _Ptr = ::_Getmonths();
            if(_Ptr)
            {
                const_cast<_Locinfo*>(this)->_Months = _Ptr;
                ::free(const_cast<char*>(_Ptr));
            }

            return !_Months._Empty() ? _Months._C_str() :
                                       ":Jan:January:Feb:February:Mar:March"
                                       ":Apr:April:May:May:Jun:June"
                                       ":Jul:July:Aug:August:Sep:September"
                                       ":Oct:October:Nov:November:Dec:December";
        }

        const char* _Getfalse() const
        {
            return "false";
        }

        const char* _Gettrue() const
        {
            return "true";
        }

        int _Getdateorder() const
        {
            return ::_Getdateorder();
        }

        _Timevec _W_Gettnames() const
        {
            return _Timevec(::_W_Gettnames());
        }

        const unsigned short* _W_Getdays() const
        {
            const wchar_t* _Ptr = ::_W_Getdays();
            if(_Ptr)
            {
                const_cast<_Locinfo*>(this)->_W_Days = _Ptr;
                ::free(const_cast<wchar_t*>(_Ptr));
            }

            const wchar_t* _Ret;

            if(_W_Days._Empty())
            {
                _Ret = L":Sun:Sunday:Mon:Monday:Tue:Tuesday:Wed:Wednesday:Thu:Thursday:Fri:Friday:Sat:Saturday";
            }
            else
            {
                _Ret = _W_Days._C_str();
            }

            return reinterpret_cast<const unsigned short*>(_Ret);
        }

        const unsigned short* _W_Getmonths() const
        {
            const wchar_t* _Ptr = ::_W_Getmonths();
            if(_Ptr)
            {
                const_cast<_Locinfo*>(this)->_W_Months = _Ptr;
                ::free(const_cast<wchar_t*>(_Ptr));
            }

            const wchar_t* _Ret;

            if(_W_Months._Empty())
            {
                _Ret = L":Jan:January:Feb:February:Mar:March:Apr:April:May:May:Jun:June"
                       L":Jul:July:Aug:August:Sep:September:Oct:October:Nov:November:Dec:December";
            }
            else
            {
                _Ret = _W_Months._C_str();
            }

            return reinterpret_cast<const unsigned short*>(_Ret);
        }

        _Locinfo(const _Locinfo&) = delete;
        _Locinfo& operator=(const _Locinfo&) = delete;

    private:
        _EmptyLockit _Empty_lock;

        _Yarn<char> _Days;
        _Yarn<char> _Months;
        _Yarn<wchar_t> _W_Days;
        _Yarn<wchar_t> _W_Months;
        _Yarn<char> _Oldlocname;
        _Yarn<char> _Newlocname;
    };

    template <class _Elem>
    int __cdecl _LStrcoll(const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2, const _Locinfo::_Collvec*)
    {
        for(; _First1 != _Last1 && _First2 != _Last2; ++_First1, ++_First2)
        {
            if(*_First1 < *_First2)
            {
                return -1;
            }
            else if(*_First2 < *_First1)
            {
                return +1;
            }
        }

        return _First2 != _Last2 ? -1 : _First1 != _Last1 ? +1 : 0;
    }

    template <>
    inline int __cdecl _LStrcoll(const char* _First1, const char* _Last1, const char* _First2, const char* _Last2, const _Locinfo::_Collvec* _Vector)
    {
        return _Strcoll(_First1, _Last1, _First2, _Last2, _Vector);
    }

    template <>
    inline int __cdecl _LStrcoll(const wchar_t* _First1,
                                 const wchar_t* _Last1,
                                 const wchar_t* _First2,
                                 const wchar_t* _Last2,
                                 const _Locinfo::_Collvec* _Vector)
    {
        return _Wcscoll(_First1, _Last1, _First2, _Last2, _Vector);
    }

    template <class _Elem>
    size_t __cdecl _LStrxfrm(_Elem* _First1, _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2, const _Locinfo::_Collvec*)
    {
        const ptrdiff_t _Count = _Last2 - _First2;
        if(_Count <= _Last1 - _First1)
        {
            ::memcpy(_First1, _First2, _Count * sizeof(_Elem));
        }

        return _Count;
    }

    template <>
    inline size_t __cdecl _LStrxfrm(char* _First1, char* _Last1, const char* _First2, const char* _Last2, const _Locinfo::_Collvec* _Vector)
    {
        return _Strxfrm(_First1, _Last1, _First2, _Last2, _Vector);
    }

    template <>
    inline size_t __cdecl _LStrxfrm(wchar_t* _First1, wchar_t* _Last1, const wchar_t* _First2, const wchar_t* _Last2, const _Locinfo::_Collvec* _Vector)
    {
        return _Wcsxfrm(_First1, _Last1, _First2, _Last2, _Vector);
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Dummy> class _Locbase
    {
    public:
        __declspec(process) static const int collate = ((1 << (1)) >> 1);
        __declspec(process) static const int ctype = ((1 << (2)) >> 1);
        __declspec(process) static const int monetary = ((1 << (3)) >> 1);
        __declspec(process) static const int numeric = ((1 << (4)) >> 1);
        __declspec(process) static const int time = ((1 << (5)) >> 1);
        __declspec(process) static const int messages = ((1 << (6)) >> 1);
        __declspec(process) static const int all = (((1 << ((6 + 1))) >> 1) - 1);
        __declspec(process) static const int none = 0;
    };

    template <class _Dummy> const int _Locbase<_Dummy>::collate;
    template <class _Dummy> const int _Locbase<_Dummy>::ctype;
    template <class _Dummy> const int _Locbase<_Dummy>::monetary;
    template <class _Dummy> const int _Locbase<_Dummy>::numeric;
    template <class _Dummy> const int _Locbase<_Dummy>::time;
    template <class _Dummy> const int _Locbase<_Dummy>::messages;
    template <class _Dummy> const int _Locbase<_Dummy>::all;
    template <class _Dummy> const int _Locbase<_Dummy>::none;

    template <class _Elem> class collate;

    struct __declspec(dllimport) _Crt_new_delete
    {
    };

    class locale : public _Locbase<int>, public _Crt_new_delete
    {
    public:
        using category = int;

        class __declspec(dllimport) id
        {
        public:
            id(size_t _Val = 0) : _Id(_Val)
            {
            }

            id(const id&) = delete;
            id& operator=(const id&) = delete;

            operator size_t()
            {
                if(_Id == 0)
                {
                    {
                        ::std::_Lockit _Lock(0);
                        if(_Id == 0)
                        {
                            _Id = static_cast<size_t>(++_Id_cnt);
                        }
                    }
                }
                return _Id;
            }

        private:
            size_t _Id;

            static int _Id_cnt;
        };

        class _Locimp;

        class __declspec(dllimport) facet : public _Facet_base, public _Crt_new_delete
        {
        private:
            friend struct _Facet_guard;

        public:
            static size_t __cdecl _Getcat(const facet** = nullptr, const locale* = nullptr)
            {
                return static_cast<size_t>(-1);
            }

            virtual void _Incref() noexcept override
            {
                _InterlockedIncrement(reinterpret_cast<volatile long*>(&_Myrefs));
            }

            virtual _Facet_base* _Decref() noexcept override
            {
                if(_InterlockedDecrement(reinterpret_cast<volatile long*>(&_Myrefs)) == 0)
                {
                    return this;
                }

                return nullptr;
            }

        private:
            _Atomic_counter_t _Myrefs;

        protected:
            explicit facet(size_t _Initrefs = 0) : _Myrefs(static_cast<_Atomic_counter_t>(_Initrefs))
            {
            }

            virtual ~facet() noexcept override
            {
            }

        public:
            facet(const facet&) = delete;
            facet& operator=(const facet&) = delete;
        };

        struct _Facet_guard
        {
            facet* _Target;
            ~_Facet_guard()
            {
                if(_Target)
                {
                    delete _Target->_Decref();
                }
            }
        };

        class __declspec(dllimport) _Locimp : public facet
        {
        protected:
            ~_Locimp() noexcept
            {
                _Locimp_dtor(this);
            }

        private:
            static _Locimp* __cdecl _New_Locimp(bool _Transparent = false);
            static _Locimp* __cdecl _New_Locimp(const _Locimp& _Right);

            static void __cdecl _Locimp_dtor(_Locimp*);
            static void __cdecl _Locimp_Addfac(_Locimp*, facet*, size_t);
            static void __cdecl _Locimp_ctor(_Locimp*, const _Locimp&);

            friend locale;

            _Locimp(bool _Transparent)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(0), _Catmask(none), _Xparent(_Transparent), _Name("*")
            {
            }

            _Locimp(const _Locimp& _Right)
            : locale::facet(1), _Facetvec(nullptr), _Facetcount(_Right._Facetcount), _Catmask(_Right._Catmask),
              _Xparent(_Right._Xparent), _Name(_Right._Name.c_str())
            {
                _Locimp_ctor(this, _Right);
            }

            void _Addfac(facet* _Pfacet, size_t _Id)
            {
                _Locimp_Addfac(this, _Pfacet, _Id);
            }

            static _Locimp* __cdecl _Makeloc(const _Locinfo&, category, _Locimp*, const locale*);

            static void __cdecl _Makewloc(const _Locinfo&, category, _Locimp*, const locale*);

            static void __cdecl _Makeushloc(const _Locinfo&, category, _Locimp*, const locale*);

            static void __cdecl _Makexloc(const _Locinfo&, category, _Locimp*, const locale*);

            facet** _Facetvec;
            size_t _Facetcount;
            category _Catmask;
            bool _Xparent;
            _Yarn<char> _Name;

            static _Locimp* _Clocptr;

        public:
            _Locimp& operator=(const _Locimp&) = delete;
        };

        template <class _Elem, class _Traits, class _Alloc>
        bool operator()(const basic_string<_Elem, _Traits, _Alloc>& _Left, const basic_string<_Elem, _Traits, _Alloc>& _Right) const
        {
            const auto& _Coll_fac = ::std::use_facet<::std::collate<_Elem>>(*this);

            const _Elem* const _Left_data = _Left.data();
            const _Elem* const _Right_data = _Right.data();
            return _Coll_fac.compare(_Left_data, _Left_data + _Left.size(), _Right_data, _Right_data + _Right.size()) < 0;
        }

        template <class _Facet> locale combine(const locale& _Loc) const
        {
            _Facet* _Facptr;

            try
            {
                _Facptr = const_cast<_Facet*>(::std::addressof(::std::use_facet<_Facet>(_Loc)));
            }
            catch(...)
            {
                _Xruntime_error("locale::combine facet missing");
            }

            _Locimp* _Newimp = _Locimp::_New_Locimp(*_Ptr);
            _Newimp->_Addfac(_Facptr, _Facet::id);
            _Newimp->_Catmask = none;
            _Newimp->_Name = "*";
            return locale(_Newimp);
        }

        template <class _Facet>
        locale(const locale& _Loc, const _Facet* _Facptr) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
        {
            if(_Facptr)
            {
                _Ptr->_Addfac(const_cast<_Facet*>(_Facptr), _Facet::id);
                _Ptr->_Catmask = none;
                _Ptr->_Name = "*";
            }
        }

        locale(_Uninitialized)
        {
        }

        locale(const locale& _Right) noexcept : _Ptr(_Right._Ptr)
        {
            _Ptr->_Incref();
        }

        locale() noexcept : _Ptr(_Init(true))
        {
        }

        locale(const locale& _Loc, const locale& _Other, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
        {
            if(_Cat != none)
            {
                _Facet_guard _Guard{ _Ptr };
                {
                    ::std::_Lockit _Lock(0);
                    _Locinfo _Lobj;
                    _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, &_Other);
                    _Lobj._Addcats(_Loc._Ptr->_Catmask, _Loc.name().c_str());
                    _Lobj._Addcats(_Other._Ptr->_Catmask, _Other.name().c_str());
                    _Ptr->_Catmask = _Loc._Ptr->_Catmask | _Other._Ptr->_Catmask;
                    _Ptr->_Name = _Lobj._Getname();
                }
                _Guard._Target = nullptr;
            }
        }

    private:
        void _Construct(const string& _Str, category _Cat)
        {
            bool _Bad = false;
            _Init();
            if(_Cat != none)
            {
                _Facet_guard _Guard{ _Ptr };
                {
                    ::std::_Lockit _Lock(0);
                    _Locinfo _Lobj(_Cat, _Str.c_str());
                    if(_Badname(_Lobj))
                    {
                        _Bad = true;
                    }
                    else
                    {
                        _Locimp::_Makeloc(_Lobj, _Cat, _Ptr, nullptr);
                        _Ptr->_Catmask = _Cat;
                        _Ptr->_Name = _Str.c_str();
                    }
                }
                _Guard._Target = nullptr;
            }

            if(_Bad)
            {
                delete _Ptr->_Decref();
                _Xruntime_error("bad locale name");
            }
        }

    public:
        explicit locale(const char* _Locname, category _Cat = all) : _Ptr(_Locimp::_New_Locimp())
        {
            if(_Locname)
            {
                _Construct(_Locname, _Cat);
                return;
            }

            _Xruntime_error("bad locale name");
        }

        locale(const locale& _Loc, const char* _Locname, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
        {
            if(_Locname)
            {
                _Construct(_Locname, _Cat);
                return;
            }

            _Xruntime_error("bad locale name");
        }

        explicit locale(const string& _Str, category _Cat = all) : _Ptr(_Locimp::_New_Locimp())
        {
            _Construct(_Str, _Cat);
        }

        locale(const locale& _Loc, const string& _Str, category _Cat) : _Ptr(_Locimp::_New_Locimp(*_Loc._Ptr))
        {
            _Construct(_Str, _Cat);
        }

        ~locale() noexcept
        {
            if(_Ptr)
            {
                delete _Ptr->_Decref();
            }
        }

        const locale& operator=(const locale& _Right) noexcept
        {
            if(_Ptr != _Right._Ptr)
            {
                delete _Ptr->_Decref();
                _Ptr = _Right._Ptr;
                _Ptr->_Incref();
            }
            return *this;
        }

        string name() const
        {
            return _Ptr ? _Ptr->_Name.c_str() : string();
        }

        const char* c_str() const
        {
            return _Ptr ? _Ptr->_Name.c_str() : "";
        }

        const facet* _Getfacet(size_t _Id) const
        {
            const facet* _Facptr = _Id < _Ptr->_Facetcount ? _Ptr->_Facetvec[_Id] : nullptr;
            if(_Facptr || !_Ptr->_Xparent)
            {
                return _Facptr;
            }

            locale::_Locimp* _Ptr0 = _Getgloballocale();
            if(_Id < _Ptr0->_Facetcount)
            {
                return _Ptr0->_Facetvec[_Id];
            }

            return nullptr;
        }

        [[nodiscard]] bool operator==(const locale& _Loc) const
        {
            return _Ptr == _Loc._Ptr || (name().compare("*") != 0 && name().compare(_Loc.name()) == 0);
        }

        [[nodiscard]] bool operator!=(const locale& _Right) const
        {
            return !(*this == _Right);
        }

        static const locale& __cdecl classic();

        static locale __cdecl global(const locale&);

        static locale __cdecl empty();

    private:
        locale(_Locimp* _Ptrimp) : _Ptr(_Ptrimp)
        {
        }

        static _Locimp* __cdecl _Init(bool _Do_incref = false);
        static _Locimp* __cdecl _Getgloballocale();
        static void __cdecl _Setgloballocale(void*);

        bool _Badname(const _Locinfo& _Lobj)
        {
            return ::strcmp(_Lobj._Getname(), "*") == 0;
        }

        _Locimp* _Ptr;
    };

    template <class _Facet> struct _Facetptr
    {
        static const locale::facet* _Psave;
    };

    template <class _Facet> const locale::facet* _Facetptr<_Facet>::_Psave = nullptr;

    template <class _Facet> const _Facet& __cdecl use_facet(const locale& _Loc)
    {
        {
            ::std::_Lockit _Lock(0);
            const locale::facet* _Psave = _Facetptr<_Facet>::_Psave;

            const size_t _Id = _Facet::id;
            const locale::facet* _Pf = _Loc._Getfacet(_Id);

            if(!_Pf)
            {
                if(_Psave)
                {
                    _Pf = _Psave;
                }
                else if(_Facet::_Getcat(&_Psave, &_Loc) == static_cast<size_t>(-1))
                {
                    _Throw_bad_cast();
                }
                else
                {
                    auto _Pfmod = const_cast<locale::facet*>(_Psave);
                    unique_ptr<_Facet_base> _Psave_guard(static_cast<_Facet_base*>(_Pfmod));

                    _Facet_Register_m(_Pfmod);

                    _Pfmod->_Incref();
                    _Facetptr<_Facet>::_Psave = _Psave;
                    _Pf = _Psave;

                    (void)_Psave_guard.release();
                }
            }

            return static_cast<const _Facet&>(*_Pf);
        }
    }

    template <class _Elem, class _InIt>
    int __cdecl _Getloctxt(_InIt& _First, _InIt& _Last, size_t _Numfields, const _Elem* _Ptr)
    {
        for(size_t _Off = 0; _Ptr[_Off] != _Elem{}; ++_Off)
        {
            if(_Ptr[_Off] == _Ptr[0])
            {
                ++_Numfields;
            }
        }

        string _Str(_Numfields, '\0');

        int _Ans = -2;
        for(size_t _Column = 1;; ++_Column, (void)++_First, _Ans = -1)
        {
            bool _Prefix = false;
            size_t _Off = 0;
            size_t _Field = 0;

            for(; _Field < _Numfields; ++_Field)
            {
                while(_Ptr[_Off] != _Elem{} && _Ptr[_Off] != _Ptr[0])
                {
                    ++_Off;
                }

                if(_Str[_Field] != '\0')
                {
                    _Off += _Str[_Field];
                }
                else if(_Ptr[_Off += _Column] == _Ptr[0] || _Ptr[_Off] == _Elem{})
                {
                    _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127);
                    _Ans = static_cast<int>(_Field);
                }
                else if(_First == _Last || _Ptr[_Off] != *_First)
                {
                    _Str[_Field] = static_cast<char>(_Column < 127 ? _Column : 127);
                }
                else
                {
                    _Prefix = true;
                }
            }

            if(!_Prefix || _First == _Last)
            {
                break;
            }
        }
        return _Ans;
    }

    template <class _Elem> char __cdecl _Maklocbyte(_Elem _Char, const _Locinfo::_Cvtvec&)
    {
        return static_cast<char>(static_cast<unsigned char>(_Char));
    }

    template <> inline char __cdecl _Maklocbyte(wchar_t _Char, const _Locinfo::_Cvtvec& _Cvt)
    {
        char _Byte = '\0';
        mbstate_t _Mbst1 = {};
        _Wcrtomb(&_Byte, _Char, &_Mbst1, &_Cvt);
        return _Byte;
    }

    template <> inline char __cdecl _Maklocbyte(unsigned short _Char, const _Locinfo::_Cvtvec& _Cvt)
    {
        char _Byte = '\0';
        mbstate_t _Mbst1 = {};
        _Wcrtomb(&_Byte, static_cast<wchar_t>(_Char), &_Mbst1, &_Cvt);
        return _Byte;
    }

    template <class _Elem> _Elem __cdecl _Maklocchr(char _Byte, _Elem*, const _Locinfo::_Cvtvec&)
    {
        return static_cast<_Elem>(static_cast<unsigned char>(_Byte));
    }

    template <> inline wchar_t __cdecl _Maklocchr(char _Byte, wchar_t*, const _Locinfo::_Cvtvec& _Cvt)
    {
        wchar_t _Wc = L'\0';
        mbstate_t _Mbst1 = {};
        _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst1, &_Cvt);
        return _Wc;
    }

    template <> inline unsigned short __cdecl _Maklocchr(char _Byte, unsigned short*, const _Locinfo::_Cvtvec& _Cvt)
    {
        unsigned short _Wc = 0;
        mbstate_t _Mbst1 = {};
        _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst1, &_Cvt);
        return _Wc;
    }

    template <class _Elem> _Elem* __cdecl _Maklocstr(const char* _Ptr, _Elem*, const _Locinfo::_Cvtvec&)
    {
        size_t _Count = ::strlen(_Ptr) + 1;

        _Elem* _Ptrdest = static_cast<_Elem*>(calloc(_Count, sizeof(_Elem)));

        if(!_Ptrdest)
        {
            _Xbad_alloc();
        }

        for(_Elem* _Ptrnext = _Ptrdest; 0 < _Count; --_Count, ++_Ptrnext, ++_Ptr)
        {
            *_Ptrnext = static_cast<_Elem>(static_cast<unsigned char>(*_Ptr));
        }

        return _Ptrdest;
    }

    template <> inline wchar_t* __cdecl _Maklocstr(const char* _Ptr, wchar_t*, const _Locinfo::_Cvtvec& _Cvt)
    {
        size_t _Count;
        size_t _Count1;
        size_t _Wchars;
        const char* _Ptr1;
        int _Bytes;
        wchar_t _Wc;
        mbstate_t _Mbst1 = {};

        _Count1 = ::strlen(_Ptr) + 1;
        for(_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
        {
            if((_Bytes = _Mbrtowc(&_Wc, _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
            {
                break;
            }
        }

        ++_Wchars;

        wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Wchars, sizeof(wchar_t)));

        if(!_Ptrdest)
        {
            _Xbad_alloc();
        }

        wchar_t* _Ptrnext = _Ptrdest;
        mbstate_t _Mbst2 = {};

        for(; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
        {
            if((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
            {
                break;
            }
        }

        *_Ptrnext = L'\0';

        return _Ptrdest;
    }

    template <>
    inline unsigned short* __cdecl _Maklocstr(const char* _Ptr, unsigned short*, const _Locinfo::_Cvtvec& _Cvt)
    {
        size_t _Count;
        size_t _Count1;
        size_t _Wchars;
        const char* _Ptr1;
        int _Bytes;
        unsigned short _Wc;
        mbstate_t _Mbst1 = {};

        _Count1 = ::strlen(_Ptr) + 1;
        for(_Count = _Count1, _Wchars = 0, _Ptr1 = _Ptr; 0 < _Count; _Count -= _Bytes, _Ptr1 += _Bytes, ++_Wchars)
        {
            if((_Bytes = _Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), _Ptr1, _Count, &_Mbst1, &_Cvt)) <= 0)
            {
                break;
            }
        }

        ++_Wchars;

        wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Wchars, sizeof(wchar_t)));

        if(!_Ptrdest)
        {
            _Xbad_alloc();
        }

        wchar_t* _Ptrnext = _Ptrdest;
        mbstate_t _Mbst2 = {};
        for(; 0 < _Wchars; _Count -= _Bytes, _Ptr += _Bytes, --_Wchars, ++_Ptrnext)
        {
            if((_Bytes = _Mbrtowc(_Ptrnext, _Ptr, _Count1, &_Mbst2, &_Cvt)) <= 0)
            {
                break;
            }
        }

        *_Ptrnext = L'\0';
        return reinterpret_cast<unsigned short*>(_Ptrdest);
    }

    class __declspec(dllimport) codecvt_base : public locale::facet
    {
    public:
        enum
        {
            ok,
            partial,
            error,
            noconv
        };
        using result = int;

        codecvt_base(size_t _Refs = 0) : locale::facet(_Refs)
        {
        }

        bool always_noconv() const noexcept
        {
            return do_always_noconv();
        }

        int max_length() const noexcept
        {
            return do_max_length();
        }

        int encoding() const noexcept
        {
            return do_encoding();
        }

        ~codecvt_base() noexcept
        {
        }

    protected:
        virtual bool do_always_noconv() const noexcept
        {
            return false;
        }

        virtual int do_max_length() const noexcept
        {
            return 1;
        }

        virtual int do_encoding() const noexcept
        {
            return 1;
        }
    };

    template <class _Elem, class _Byte, class _Statype> class codecvt : public codecvt_base
    {
    public:
        static_assert(!0 || is_same_v<codecvt, codecvt<char, char, mbstate_t>>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        using intern_type = _Elem;
        using extern_type = _Byte;
        using state_type = _Statype;

        result
        in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1, _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const
        {
            return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result
        out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const
        {
            return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result unshift(_Statype& _State, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const
        {
            return do_unshift(_State, _First2, _Last2, _Mid2);
        }

        int length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const
        {
            return do_length(_State, _First1, _Last1, _Count);
        }

        static locale::id id;

        explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs)
        {
            _Init(_Locinfo());
        }

        explicit codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
            }

            return 2;
        }

    protected:
        virtual ~codecvt() noexcept
        {
        }

        void _Init(const _Locinfo&)
        {
        }

        virtual bool do_always_noconv() const noexcept override
        {
            return is_same_v<_Byte, _Elem>;
        }

        virtual result
        do_in(_Statype&, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1, _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const
        {
            _Mid1 = _First1;
            _Mid2 = _First2;
            if constexpr(is_same_v<_Byte, _Elem>)
            {
                (void)_Last1;
                (void)_Last2;
                return noconv;
            }
            else
            {
                for(; _Mid1 != _Last1; ++_Mid1, ++_Mid2)
                {
                    if(_Mid2 == _Last2)
                    {
                        return partial;
                    }
                    *_Mid2 = static_cast<_Elem>(*_Mid1);
                }

                return ok;
            }
        }

        virtual result
        do_out(_Statype&, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const
        {
            _Mid1 = _First1;
            _Mid2 = _First2;
            if constexpr(is_same_v<_Byte, _Elem>)
            {
                (void)_Last1;
                (void)_Last2;
                return noconv;
            }
            else
            {
                for(; _Mid1 != _Last1; ++_Mid1, ++_Mid2)
                {
                    if(_Mid2 == _Last2)
                    {
                        return partial;
                    }
                    *_Mid2 = static_cast<_Byte>(*_Mid1);
                }

                return ok;
            }
        }

        virtual result do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const
        {
            _Mid2 = _First2;
            return noconv;
        }

        virtual int do_length(_Statype&, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const
        {
            const auto _Dist = static_cast<size_t>(_Min_value(_Last1 - _First1, ptrdiff_t{ 2147483647 }));
            return static_cast<int>(_Min_value(_Count, _Dist));
        }
    };

    template <class _Elem, class _Byte, class _Statype> locale::id codecvt<_Elem, _Byte, _Statype>::id;

    template <class _CvtTy, class _Byte, class _Statype>
    [[nodiscard]] int _Codecvt_do_length(const _CvtTy& _Cvt, _Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count)
    {
        __pragma(warning(push)) __pragma(warning(disable : 4996)) using _Elem = typename _CvtTy::intern_type;
        __pragma(warning(pop))

        _Adl_verify_range(_First1, _Last1);
        const auto _Old_first1 = _First1;

        while(_Count > 0 && _First1 != _Last1)
        {
            const _Byte* _Mid1;
            _Elem* _Mid2;
            _Elem _Ch;

            __pragma(warning(push)) __pragma(warning(disable : 4996)) const auto _Result
            = _Cvt._CvtTy::do_in(_State, _First1, _Last1, _Mid1, &_Ch, &_Ch + 1, _Mid2);
            __pragma(warning(pop))

            if(_Result != codecvt_base::ok)
            {
                if(_Result == codecvt_base::noconv)
                {
                    _First1 += _Min_value(static_cast<size_t>(_Last1 - _First1), _Count);
                }

                break;
            }

            if(_Mid2 == &_Ch + 1)
            {
                --_Count;
            }

            _First1 = _Mid1;
        }

        return static_cast<int>(_Min_value(_First1 - _Old_first1, ptrdiff_t{ 2147483647 }));
    }

    enum _Codecvt_mode
    {
        _Consume_header = 4,
        _Generate_header = 2
    };

    template <> class __declspec(dllimport) codecvt<char16_t, char, mbstate_t> : public codecvt_base
    {
    public:
        using intern_type = char16_t;
        using extern_type = char;
        using state_type = mbstate_t;

        result
        in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1, char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const
        {
            return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result
        out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1, const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const
        {
            return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const
        {
            return do_unshift(_State, _First2, _Last2, _Mid2);
        }

        int length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const
        {
            return do_length(_State, _First1, _Last1, _Count);
        }

        static locale::id id;

        explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        explicit codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0x10ffff), _Mode(_Consume_header)
        {
            _Init(_Lobj);
        }

        codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                __pragma(warning(push)) __pragma(warning(disable : 4996))* _Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
                __pragma(warning(pop))
            }

            return 2;
        }

    protected:
        virtual ~codecvt() noexcept
        {
        }

        void _Init(const _Locinfo&)
        {
        }

        virtual result
        do_in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1, char16_t* _First2, char16_t* _Last2, char16_t*& _Mid2) const
        {
            unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                unsigned char _By = static_cast<unsigned char>(*_Mid1);
                unsigned long _Ch;
                int _Nextra;
                int _Nskip;

                if(*_Pstate > 1)
                {
                    if(_By < 0x80 || 0xc0 <= _By)
                    {
                        return codecvt::error;
                    }

                    ++_Mid1;
                    *_Mid2++ = static_cast<char16_t>(*_Pstate | (_By & 0x3f));
                    *_Pstate = 1;
                    continue;
                }

                if(_By < 0x80u)
                {
                    _Ch = _By;
                    _Nextra = 0;
                }
                else if(_By < 0xc0u)
                {
                    ++_Mid1;
                    return codecvt::error;
                }
                else if(_By < 0xe0u)
                {
                    _Ch = static_cast<unsigned long>(_By & 0x1f);
                    _Nextra = 1;
                }
                else if(_By < 0xf0u)
                {
                    _Ch = static_cast<unsigned long>(_By & 0x0f);
                    _Nextra = 2;
                }
                else if(_By < 0xf8u)
                {
                    _Ch = static_cast<unsigned long>(_By & 0x07);
                    _Nextra = 3;
                }
                else
                {
                    _Ch = static_cast<unsigned long>(_By & 0x03);
                    _Nextra = _By < 0xfc ? 4 : 5;
                }

                _Nskip = _Nextra < 3 ? 0 : 1;
                _First1 = _Mid1;

                if(_Nextra == 0)
                {
                    ++_Mid1;
                }
                else if(_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
                {
                    break;
                }
                else
                {
                    for(++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
                    {
                        if((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By)
                        {
                            return codecvt::error;
                        }
                        else
                        {
                            _Ch = _Ch << 6 | (_By & 0x3f);
                        }
                    }
                }

                if(0 < _Nskip)
                {
                    _Ch <<= 6;
                }

                if((_Maxcode < 0x10ffffu ? _Maxcode : 0x10ffffu) < _Ch)
                {
                    return codecvt::error;
                }

                if(0xffffu < _Ch)
                {
                    unsigned short _Ch0 = static_cast<unsigned short>(0xd800 | (_Ch >> 10) - 0x0040);

                    *_Mid2++ = static_cast<char16_t>(_Ch0);
                    *_Pstate = static_cast<unsigned short>(0xdc00 | (_Ch & 0x03ff));
                    continue;
                }

                if(_Nskip != 0)
                {
                    if(_Mid1 == _Last1)
                    {
                        _Mid1 = _First1;
                        break;
                    }

                    if((_By = static_cast<unsigned char>(*_Mid1++)) < 0x80u || 0xc0u <= _By)
                    {
                        return codecvt::error;
                    }

                    _Ch |= _By & 0x3f;
                }

                if(*_Pstate == 0u)
                {
                    *_Pstate = 1;

                    if((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu)
                    {
                        const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                        if(_Ans == codecvt::partial)
                        {
                            *_Pstate = 0;
                            _Mid1 = _First1;
                        }

                        return _Ans;
                    }
                }

                *_Mid2++ = static_cast<char16_t>(_Ch);
            }

            return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
        }

        virtual result
        do_out(mbstate_t& _State, const char16_t* _First1, const char16_t* _Last1, const char16_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const
        {
            unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                unsigned long _Ch;
                const unsigned short _Ch1 = static_cast<unsigned short>(*_Mid1);
                bool _Save = false;

                if(1 < *_Pstate)
                {
                    if(_Ch1 < 0xdc00u || 0xe000u <= _Ch1)
                    {
                        return codecvt::error;
                    }

                    _Ch = static_cast<unsigned long>((*_Pstate << 10) | (_Ch1 - 0xdc00));
                }
                else if(0xd800u <= _Ch1 && _Ch1 < 0xdc00u)
                {
                    _Ch = static_cast<unsigned long>((_Ch1 - 0xd800 + 0x0040) << 10);
                    _Save = true;
                }
                else
                {
                    _Ch = _Ch1;
                }

                char _By;
                int _Nextra;

                if(_Ch < 0x0080u)
                {
                    _By = static_cast<char>(_Ch);
                    _Nextra = 0;
                }
                else if(_Ch < 0x0800u)
                {
                    _By = static_cast<char>(0xc0 | _Ch >> 6);
                    _Nextra = 1;
                }
                else if(_Ch < 0x10000u)
                {
                    _By = static_cast<char>(0xe0 | _Ch >> 12);
                    _Nextra = 2;
                }
                else
                {
                    _By = static_cast<char>(0xf0 | _Ch >> 18);
                    _Nextra = 3;
                }

                int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

                if(_Last2 - _Mid2 < _Nput)
                {
                    break;
                }

                if(*_Pstate == 0u && (_Mode & _Generate_header) != 0)
                {
                    if(_Last2 - _Mid2 < 3 + _Nput)
                    {
                        break;
                    }

                    *_Mid2++ = '\xef';
                    *_Mid2++ = '\xbb';
                    *_Mid2++ = '\xbf';
                }

                ++_Mid1;
                if(_Save || _Nextra < 3)
                {
                    *_Mid2++ = _By;
                    --_Nput;
                }

                for(; 0 < _Nput; --_Nput)
                {
                    *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
                }

                *_Pstate = static_cast<unsigned short>(_Save ? _Ch >> 10 : 1);
            }

            return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
        }

        virtual result do_unshift(mbstate_t& _State, char* _First2, char*, char*& _Mid2) const
        {
            unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
            _Mid2 = _First2;

            return 1u < *_Pstate ? codecvt::error : codecvt::ok;
        }

        friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

        virtual int do_length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const
        {
            return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
        }

        virtual bool do_always_noconv() const noexcept override
        {
            return false;
        }

        virtual int do_max_length() const noexcept override
        {
            if((_Mode & _Consume_header) != 0)
            {
                return 9;
            }

            if((_Mode & _Generate_header) != 0)
            {
                return 7;
            }

            return 6;
        }

        virtual int do_encoding() const noexcept override
        {
            return 0;
        }

    private:
        unsigned long _Maxcode;
        _Codecvt_mode _Mode;
    };

    template <> class __declspec(dllimport) codecvt<char32_t, char, mbstate_t> : public codecvt_base
    {
    public:
        using intern_type = char32_t;
        using extern_type = char;
        using state_type = mbstate_t;

        result
        in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1, char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const
        {
            return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result
        out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1, const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const
        {
            return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const
        {
            return do_unshift(_State, _First2, _Last2, _Mid2);
        }

        int length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const
        {
            return do_length(_State, _First1, _Last1, _Count);
        }

        static locale::id id;

        explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        explicit codecvt(const _Locinfo& _Lobj, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(0xffffffff), _Mode(_Consume_header)
        {
            _Init(_Lobj);
        }

        codecvt(const _Locinfo& _Lobj, unsigned long _Maxcode_arg, _Codecvt_mode _Mode_arg, size_t _Refs = 0)
        : codecvt_base(_Refs), _Maxcode(_Maxcode_arg), _Mode(_Mode_arg)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                __pragma(warning(push)) __pragma(warning(disable : 4996))* _Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
                __pragma(warning(pop))
            }

            return 2;
        }

    protected:
        virtual ~codecvt() noexcept
        {
        }

        void _Init(const _Locinfo&)
        {
        }

        virtual result
        do_in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1, char32_t* _First2, char32_t* _Last2, char32_t*& _Mid2) const
        {
            char* _Pstate = reinterpret_cast<char*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                unsigned char _By = static_cast<unsigned char>(*_Mid1);
                unsigned long _Ch;
                int _Nextra;

                if(_By < 0x80u)
                {
                    _Ch = _By;
                    _Nextra = 0;
                }
                else if(_By < 0xc0u)
                {
                    ++_Mid1;
                    return codecvt::error;
                }
                else if(_By < 0xe0u)
                {
                    _Ch = static_cast<unsigned long>(_By & 0x1f);
                    _Nextra = 1;
                }
                else if(_By < 0xf0u)
                {
                    _Ch = static_cast<unsigned long>(_By & 0x0f);
                    _Nextra = 2;
                }
                else if(_By < 0xf8u)
                {
                    _Ch = static_cast<unsigned long>(_By & 0x07);
                    _Nextra = 3;
                }
                else
                {
                    _Ch = static_cast<unsigned long>(_By & 0x03);
                    _Nextra = _By < 0xfc ? 4 : 5;
                }

                if(_Nextra == 0)
                {
                    ++_Mid1;
                }
                else if(_Last1 - _Mid1 < _Nextra + 1)
                {
                    break;
                }
                else
                {
                    for(++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
                    {
                        if((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By)
                        {
                            return codecvt::error;
                        }
                        else
                        {
                            _Ch = _Ch << 6 | (_By & 0x3f);
                        }
                    }
                }

                if(*_Pstate == 0)
                {
                    *_Pstate = 1;

                    if((_Mode & _Consume_header) != 0 && _Ch == 0xfeffu)
                    {
                        const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                        if(_Ans == codecvt::partial)
                        {
                            *_Pstate = 0;
                            _Mid1 = _First1;
                        }
                        return _Ans;
                    }
                }

                if(_Maxcode < _Ch)
                {
                    return codecvt::error;
                }

                *_Mid2++ = static_cast<char32_t>(_Ch);
            }

            return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
        }

        virtual result
        do_out(mbstate_t& _State, const char32_t* _First1, const char32_t* _Last1, const char32_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const
        {
            char* _Pstate = reinterpret_cast<char*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                char _By;
                int _Nextra;
                unsigned long _Ch = static_cast<unsigned long>(*_Mid1);

                if(_Maxcode < _Ch)
                {
                    return codecvt::error;
                }

                if(_Ch < 0x0080u)
                {
                    _By = static_cast<char>(_Ch);
                    _Nextra = 0;
                }
                else if(_Ch < 0x0800u)
                {
                    _By = static_cast<char>(0xc0 | _Ch >> 6);
                    _Nextra = 1;
                }
                else if(_Ch < 0x00010000u)
                {
                    _By = static_cast<char>(0xe0 | _Ch >> 12);
                    _Nextra = 2;
                }
                else if(_Ch < 0x00200000u)
                {
                    _By = static_cast<char>(0xf0 | _Ch >> 18);
                    _Nextra = 3;
                }
                else if(_Ch < 0x04000000u)
                {
                    _By = static_cast<char>(0xf8 | _Ch >> 24);
                    _Nextra = 4;
                }
                else
                {
                    _By = static_cast<char>(0xfc | (_Ch >> 30 & 0x03));
                    _Nextra = 5;
                }

                if(*_Pstate == 0)
                {
                    *_Pstate = 1;
                    if((_Mode & _Generate_header) != 0)
                    {
                        if(_Last2 - _Mid2 < 3 + 1 + _Nextra)
                        {
                            return codecvt::partial;
                        }

                        *_Mid2++ = '\xef';
                        *_Mid2++ = '\xbb';
                        *_Mid2++ = '\xbf';
                    }
                }

                if(_Last2 - _Mid2 < 1 + _Nextra)
                {
                    break;
                }

                ++_Mid1;
                for(*_Mid2++ = _By; 0 < _Nextra;)
                {
                    *_Mid2++ = static_cast<char>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
                }
            }
            return _First1 == _Mid1 ? codecvt::partial : codecvt::ok;
        }

        virtual result do_unshift(mbstate_t&, char* _First2, char*, char*& _Mid2) const
        {
            _Mid2 = _First2;
            return codecvt::noconv;
        }

        friend int _Codecvt_do_length<>(const codecvt&, mbstate_t&, const char*, const char*, size_t);

        virtual int do_length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const
        {
            return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
        }

        virtual bool do_always_noconv() const noexcept override
        {
            return false;
        }

        virtual int do_max_length() const noexcept override
        {
            return (_Mode & (_Consume_header | _Generate_header)) != 0 ? 9 : 6;
        }

        virtual int do_encoding() const noexcept override
        {
            return (_Mode & (_Consume_header | _Generate_header)) != 0 ? -1 : 0;
        }

    private:
        unsigned long _Maxcode;
        _Codecvt_mode _Mode;
    };

    template <> class __declspec(dllimport) codecvt<wchar_t, char, mbstate_t> : public codecvt_base
    {
    public:
        using intern_type = wchar_t;
        using extern_type = char;
        using state_type = mbstate_t;

        result
        in(mbstate_t& _State, const char* _First1, const char* _Last1, const char*& _Mid1, wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const
        {
            return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result
        out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1, const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const
        {
            return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const
        {
            return do_unshift(_State, _First2, _Last2, _Mid2);
        }

        int length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const
        {
            return do_length(_State, _First1, _Last1, _Count);
        }

        static locale::id id;

        explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        explicit codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
            }

            return 2;
        }

    protected:
        virtual ~codecvt() noexcept
        {
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Cvt = _Lobj._Getcvt();
        }

        virtual result
        do_in(mbstate_t&, const char* _First1, const char* _Last1, const char*& _Mid1, wchar_t* _First2, wchar_t* _Last2, wchar_t*& _Mid2) const
        {
            mbstate_t _Mystate{};
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            _Mid1 = _First1;
            _Mid2 = _First2;
            for(;;)
            {
                if(_Mid1 == _Last1)
                {
                    return ok;
                }

                if(_Mid2 == _Last2)
                {
                    return partial;
                }

                int _Bytes = _Mbrtowc(_Mid2, _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
                switch(_Bytes)
                {
                    case -2:
                        return partial;

                    case -1:
                        return error;

                    case 0:
                        _Bytes = 1;

                    default:
                        _Mid1 += _Bytes;
                        ++_Mid2;
                        break;
                }
            }
        }

        virtual result
        do_out(mbstate_t& _State, const wchar_t* _First1, const wchar_t* _Last1, const wchar_t*& _Mid1, char* _First2, char* _Last2, char*& _Mid2) const
        {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            _Mid1 = _First1;
            _Mid2 = _First2;
            int _Bytes;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                if(5 <= _Last2 - _Mid2)
                {
                    if((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0)
                    {
                        return error;
                    }
                    else
                    {
                        ++_Mid1;
                        _Mid2 += _Bytes;
                    }
                }
                else
                {
                    char _Buf[5];
                    mbstate_t _Stsave = _State;

                    if((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0)
                    {
                        return error;
                    }
                    else if(_Last2 - _Mid2 < _Bytes)
                    {
                        _State = _Stsave;
                        break;
                    }
                    else
                    {
                        ::memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                        ++_Mid1;
                        _Mid2 += _Bytes;
                    }
                }
            }

            return _Mid1 == _Last1 ? ok : partial;
        }

        virtual result do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const
        {
            _Adl_verify_range(_First2, _Last2);
            _Mid2 = _First2;
            result _Ans = ok;
            int _Bytes;
            char _Buf[5];
            mbstate_t _Stsave = _State;

            if((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
            {
                _Ans = error;
            }
            else if(_Last2 - _Mid2 < --_Bytes)
            {
                _State = _Stsave;
                _Ans = partial;
            }
            else if(0 < _Bytes)
            {
                ::memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                _Mid2 += _Bytes;
            }
            return _Ans;
        }

        virtual int do_length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const
        {
            _Adl_verify_range(_First1, _Last1);
            const auto _Old_first1 = _First1;

            for(; _Count > 0u && _First1 != _Last1; --_Count)
            {
                wchar_t _Ch;
                int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
                if(_Bytes < 0)
                {
                    break;
                }

                if(_Bytes == 0)
                {
                    _Bytes = 1;
                }

                _First1 += _Bytes;
            }

            return static_cast<int>(_Min_value(_First1 - _Old_first1, ptrdiff_t{ 2147483647 }));
        }

        virtual bool do_always_noconv() const noexcept override
        {
            return false;
        }

        virtual int do_max_length() const noexcept override
        {
            return static_cast<int>(_Cvt._Mbcurmax);
        }

        virtual int do_encoding() const noexcept override
        {
            return _Cvt._Mbcurmax == 1;
        }

    private:
        _Locinfo::_Cvtvec _Cvt;
    };

    template <> class __declspec(dllimport) codecvt<unsigned short, char, mbstate_t> : public codecvt_base
    {
    public:
        using intern_type = unsigned short;
        using extern_type = char;
        using state_type = mbstate_t;

        result in(mbstate_t& _State,
                  const char* _First1,
                  const char* _Last1,
                  const char*& _Mid1,
                  unsigned short* _First2,
                  unsigned short* _Last2,
                  unsigned short*& _Mid2) const
        {
            return do_in(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result out(mbstate_t& _State,
                   const unsigned short* _First1,
                   const unsigned short* _Last1,
                   const unsigned short*& _Mid1,
                   char* _First2,
                   char* _Last2,
                   char*& _Mid2) const
        {
            return do_out(_State, _First1, _Last1, _Mid1, _First2, _Last2, _Mid2);
        }

        result unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const
        {
            return do_unshift(_State, _First2, _Last2, _Mid2);
        }

        int length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const
        {
            return do_length(_State, _First1, _Last1, _Count);
        }

        static locale::id id;

        explicit codecvt(size_t _Refs = 0) : codecvt_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        explicit codecvt(const _Locinfo& _Lobj, size_t _Refs = 0) : codecvt_base(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new codecvt(_Locinfo(_Ploc->c_str()));
            }

            return 2;
        }

    protected:
        virtual ~codecvt() noexcept
        {
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Cvt = _Lobj._Getcvt();
        }

        virtual result do_in(mbstate_t&,
                             const char* _First1,
                             const char* _Last1,
                             const char*& _Mid1,
                             unsigned short* _First2,
                             unsigned short* _Last2,
                             unsigned short*& _Mid2) const
        {
            mbstate_t _Mystate{};
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            _Mid1 = _First1;
            _Mid2 = _First2;
            for(;;)
            {
                if(_Mid1 == _Last1)
                {
                    return ok;
                }

                if(_Mid2 == _Last2)
                {
                    return partial;
                }

                int _Bytes
                = _Mbrtowc(reinterpret_cast<wchar_t*>(_Mid2), _Mid1, static_cast<size_t>(_Last1 - _Mid1), &_Mystate, &_Cvt);
                switch(_Bytes)
                {
                    case -2:
                        return partial;

                    case -1:
                        return error;

                    case 0:
                        _Bytes = 1;

                    default:
                        _Mid1 += _Bytes;
                        ++_Mid2;
                        break;
                }
            }
        }

        virtual result do_out(mbstate_t& _State,
                              const unsigned short* _First1,
                              const unsigned short* _Last1,
                              const unsigned short*& _Mid1,
                              char* _First2,
                              char* _Last2,
                              char*& _Mid2) const
        {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            _Mid1 = _First1;
            _Mid2 = _First2;
            int _Bytes;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                if(5 <= _Last2 - _Mid2)
                {
                    if((_Bytes = _Wcrtomb(_Mid2, *_Mid1, &_State, &_Cvt)) < 0)
                    {
                        return error;
                    }
                    else
                    {
                        ++_Mid1;
                        _Mid2 += _Bytes;
                    }
                }
                else
                {
                    char _Buf[5];
                    mbstate_t _Stsave = _State;

                    if((_Bytes = _Wcrtomb(_Buf, *_Mid1, &_State, &_Cvt)) < 0)
                    {
                        return error;
                    }
                    else if(_Last2 - _Mid2 < _Bytes)
                    {
                        _State = _Stsave;
                        break;
                    }
                    else
                    {
                        ::memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                        ++_Mid1;
                        _Mid2 += _Bytes;
                    }
                }
            }

            return _Mid1 == _Last1 ? ok : partial;
        }

        virtual result do_unshift(mbstate_t& _State, char* _First2, char* _Last2, char*& _Mid2) const
        {
            _Adl_verify_range(_First2, _Last2);
            _Mid2 = _First2;
            result _Ans = ok;
            int _Bytes;
            char _Buf[5];
            mbstate_t _Stsave = _State;

            if((_Bytes = _Wcrtomb(_Buf, L'\0', &_State, &_Cvt)) <= 0)
            {
                _Ans = error;
            }
            else if(_Last2 - _Mid2 < --_Bytes)
            {
                _State = _Stsave;
                _Ans = partial;
            }
            else if(0 < _Bytes)
            {
                ::memcpy(_Mid2, _Buf, static_cast<size_t>(_Bytes));
                _Mid2 += _Bytes;
            }

            return _Ans;
        }

        virtual int do_length(mbstate_t& _State, const char* _First1, const char* _Last1, size_t _Count) const
        {
            _Adl_verify_range(_First1, _Last1);
            const auto _Old_first1 = _First1;

            for(; _Count > 0u && _First1 != _Last1; --_Count)
            {
                wchar_t _Ch;
                int _Bytes = _Mbrtowc(&_Ch, _First1, static_cast<size_t>(_Last1 - _First1), &_State, &_Cvt);
                if(_Bytes < 0)
                {
                    break;
                }

                if(_Bytes == 0)
                {
                    _Bytes = 1;
                }

                _First1 += _Bytes;
            }

            return static_cast<int>(_Min_value(_First1 - _Old_first1, ptrdiff_t{ 2147483647 }));
        }

        virtual bool do_always_noconv() const noexcept override
        {
            return false;
        }

        virtual int do_max_length() const noexcept override
        {
            return static_cast<int>(_Cvt._Mbcurmax);
        }

        virtual int do_encoding() const noexcept override
        {
            return _Cvt._Mbcurmax == 1u;
        }

    private:
        _Locinfo::_Cvtvec _Cvt;
    };

    template <class _Elem, class _Byte, class _Statype> class codecvt_byname : public codecvt<_Elem, _Byte, _Statype>
    {
    public:
        static_assert(!0
                      || _Is_any_of_v<codecvt_byname,

                                      codecvt_byname<char, char, mbstate_t>,
                                      codecvt_byname<wchar_t, char, mbstate_t>>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        explicit codecvt_byname(const char* _Locname, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Locname), _Refs)
        {
        }

        explicit codecvt_byname(const string& _Str, size_t _Refs = 0)
        : codecvt<_Elem, _Byte, _Statype>(_Locinfo(_Str.c_str()), _Refs)
        {
        }

    protected:
        virtual ~codecvt_byname() noexcept
        {
        }
    };

    struct __declspec(dllimport) ctype_base : locale::facet
    {
        enum
        {
            alnum = 0x04 | 0x02 | 0x01 | 0x100,
            alpha = 0x02 | 0x01 | 0x100,
            cntrl = 0x20,
            digit = 0x04,
            graph = 0x04 | 0x02 | 0x10 | 0x01 | 0x100,
            lower = 0x02,
            print = 0x04 | 0x02 | 0x10 | 0x40 | 0x01 | 0x100 | 0x80,
            punct = 0x10,
            space = 0x08 | 0x40 | 0x000,
            upper = 0x01,
            xdigit = 0x80,
            blank = 0x08 | 0x40 | 0x000 | 0x000
        };
        using mask = short;

        ctype_base(size_t _Refs = 0) : locale::facet(_Refs)
        {
        }

        ~ctype_base() noexcept
        {
        }
    };

    template <class _Elem> class ctype : public ctype_base
    {
    public:
        static_assert(!0 || _Always_false<_Elem>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        using char_type = _Elem;

        bool is(mask _Maskval, _Elem _Ch) const
        {
            return do_is(_Maskval, _Ch);
        }

        const _Elem* is(const _Elem* _First, const _Elem* _Last, mask* _Dest) const
        {
            return do_is(_First, _Last, _Dest);
        }

        const _Elem* scan_is(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            return do_scan_is(_Maskval, _First, _Last);
        }

        const _Elem* scan_not(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            return do_scan_not(_Maskval, _First, _Last);
        }

        _Elem tolower(_Elem _Ch) const
        {
            return do_tolower(_Ch);
        }

        const _Elem* tolower(_Elem* _First, const _Elem* _Last) const
        {
            return do_tolower(_First, _Last);
        }

        _Elem toupper(_Elem _Ch) const
        {
            return do_toupper(_Ch);
        }

        const _Elem* toupper(_Elem* _First, const _Elem* _Last) const
        {
            return do_toupper(_First, _Last);
        }

        _Elem widen(char _Byte) const
        {
            return do_widen(_Byte);
        }

        const char* widen(const char* _First, const char* _Last, _Elem* _Dest) const
        {
            return do_widen(_First, _Last, _Dest);
        }

        char narrow(_Elem _Ch, char _Dflt = '\0') const
        {
            return do_narrow(_Ch, _Dflt);
        }

        const _Elem* narrow(const _Elem* _First, const _Elem* _Last, char _Dflt, char* _Dest) const
        {
            return do_narrow(_First, _Last, _Dflt, _Dest);
        }

        static locale::id id;

        explicit ctype(size_t _Refs = 0) : ctype_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
            }

            return 2;
        }

    protected:
        virtual ~ctype() noexcept
        {
            if(_Ctype._Delfl)
            {
                ::free(const_cast<short*>(_Ctype._Table));
            }

            ::free(_Ctype._LocaleName);
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Ctype = _Lobj._Getctype();
            _Cvt = _Lobj._Getcvt();
        }

        virtual bool do_is(mask _Maskval, _Elem _Ch) const
        {
            return (_Ctype._Table[static_cast<unsigned char>(narrow(_Ch))] & _Maskval) != 0;
        }

        virtual const _Elem* do_is(const _Elem* _First, const _Elem* _Last, mask* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First, ++_Dest)
            {
                *_Dest = _Ctype._Table[static_cast<unsigned char>(narrow(*_First))];
            }

            return _First;
        }

        virtual const _Elem* do_scan_is(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            while(_First != _Last && !is(_Maskval, *_First))
            {
                ++_First;
            }

            return _First;
        }

        virtual const _Elem* do_scan_not(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            while(_First != _Last && is(_Maskval, *_First))
            {
                ++_First;
            }

            return _First;
        }

        virtual _Elem do_tolower(_Elem _Ch) const
        {
            unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
            if(_Byte == '\0')
            {
                return _Ch;
            }

            return widen(static_cast<char>(_Tolower(_Byte, &_Ctype)));
        }

        virtual const _Elem* do_tolower(_Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First)
            {
                unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
                if(_Byte != '\0')
                {
                    *_First = (widen(static_cast<char>(_Tolower(_Byte, &_Ctype))));
                }
            }
            return _First;
        }

        virtual _Elem do_toupper(_Elem _Ch) const
        {
            unsigned char _Byte = static_cast<unsigned char>(narrow(_Ch, '\0'));
            if(_Byte == '\0')
            {
                return _Ch;
            }

            return widen(static_cast<char>(_Toupper(_Byte, &_Ctype)));
        }

        virtual const _Elem* do_toupper(_Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First)
            {
                unsigned char _Byte = static_cast<unsigned char>(narrow(*_First, '\0'));
                if(_Byte != '\0')
                {
                    *_First = (widen(static_cast<char>(_Toupper(_Byte, &_Ctype))));
                }
            }

            return _First;
        }

        virtual _Elem do_widen(char _Byte) const
        {
            return _Maklocchr(_Byte, static_cast<_Elem*>(nullptr), _Cvt);
        }

        virtual const char* do_widen(const char* _First, const char* _Last, _Elem* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First, ++_Dest)
            {
                *_Dest = _Maklocchr(*_First, static_cast<_Elem*>(nullptr), _Cvt);
            }

            return _First;
        }

        char _Donarrow(_Elem _Ch, char _Dflt) const
        {
            char _Byte;
            if(_Ch == _Elem{})
            {
                return '\0';
            }

            if((_Byte = _Maklocbyte(_Ch, _Cvt)) == '\0')
            {
                return _Dflt;
            }

            return _Byte;
        }

        virtual char do_narrow(_Elem _Ch, char _Dflt) const
        {
            return _Donarrow(_Ch, _Dflt);
        }

        virtual const _Elem* do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt, char* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First, ++_Dest)
            {
                *_Dest = _Donarrow(*_First, _Dflt);
            }

            return _First;
        }

    private:
        _Locinfo::_Ctypevec _Ctype;
        _Locinfo::_Cvtvec _Cvt;
    };

    template <class _Elem> locale::id ctype<_Elem>::id;

    template <> class __declspec(dllimport) ctype<char> : public ctype_base
    {
    public:
        using _Elem = char;
        using char_type = _Elem;

        bool is(mask _Maskval, _Elem _Ch) const
        {
            return (_Ctype._Table[static_cast<unsigned char>(_Ch)] & _Maskval) != 0;
        }

        const _Elem* is(const _Elem* _First, const _Elem* _Last, mask* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First, ++_Dest)
            {
                *_Dest = _Ctype._Table[static_cast<unsigned char>(*_First)];
            }

            return _First;
        }

        const _Elem* scan_is(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            while(_First != _Last && !is(_Maskval, *_First))
            {
                ++_First;
            }

            return _First;
        }

        const _Elem* scan_not(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            while(_First != _Last && is(_Maskval, *_First))
            {
                ++_First;
            }

            return _First;
        }

        _Elem tolower(_Elem _Ch) const
        {
            return do_tolower(_Ch);
        }

        const _Elem* tolower(_Elem* _First, const _Elem* _Last) const
        {
            return do_tolower(_First, _Last);
        }

        _Elem toupper(_Elem _Ch) const
        {
            return do_toupper(_Ch);
        }

        const _Elem* toupper(_Elem* _First, const _Elem* _Last) const
        {
            return do_toupper(_First, _Last);
        }

        _Elem widen(char _Byte) const
        {
            return do_widen(_Byte);
        }

        const _Elem* widen(const char* _First, const char* _Last, _Elem* _Dest) const
        {
            return do_widen(_First, _Last, _Dest);
        }

        _Elem narrow(_Elem _Ch, char _Dflt = '\0') const
        {
            return do_narrow(_Ch, _Dflt);
        }

        const _Elem* narrow(const _Elem* _First, const _Elem* _Last, char _Dflt, char* _Dest) const
        {
            return do_narrow(_First, _Last, _Dflt, _Dest);
        }

        static locale::id id;

        explicit ctype(const mask* _Table = nullptr, bool _Deletetable = false, size_t _Refs = 0) : ctype_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }

            _Tidy();
            if(_Table)
            {
                _Ctype._Table = _Table;
                _Ctype._Delfl = _Deletetable ? -1 : 0;
            }
            else
            {
                _Ctype._Table = classic_table();
                _Ctype._Delfl = 0;
            }
        }

        ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
            }

            return 2;
        }

        const mask* table() const noexcept
        {
            return _Ctype._Table;
        }

        static const mask* __cdecl classic_table() noexcept
        {
            return ::std::use_facet<ctype>(locale::classic()).table();
        }

        __declspec(process) static const size_t table_size = 1 << 8;

    protected:
        virtual ~ctype() noexcept
        {
            _Tidy();
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Ctype = _Lobj._Getctype();
        }

        void _Tidy() noexcept
        {
            if(0 < _Ctype._Delfl)
            {
                ::free(const_cast<short*>(_Ctype._Table));
            }
            else if(_Ctype._Delfl < 0)
            {
                delete[] _Ctype._Table;
            }

            ::free(_Ctype._LocaleName);
        }

        virtual _Elem do_tolower(_Elem _Ch) const
        {
            return static_cast<_Elem>(_Tolower(static_cast<unsigned char>(_Ch), &_Ctype));
        }

        virtual const _Elem* do_tolower(_Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First)
            {
                *_First = static_cast<_Elem>(_Tolower(static_cast<unsigned char>(*_First), &_Ctype));
            }

            return _First;
        }

        virtual _Elem do_toupper(_Elem _Ch) const
        {
            return static_cast<_Elem>(_Toupper(static_cast<unsigned char>(_Ch), &_Ctype));
        }

        virtual const _Elem* do_toupper(_Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First)
            {
                *_First = static_cast<_Elem>(_Toupper(static_cast<unsigned char>(*_First), &_Ctype));
            }

            return _First;
        }

        virtual _Elem do_widen(char _Byte) const
        {
            return _Byte;
        }

        virtual const _Elem* do_widen(const char* _First, const char* _Last, _Elem* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            ::memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
            return _Last;
        }

        virtual _Elem do_narrow(_Elem _Ch, char) const
        {
            return _Ch;
        }

        virtual const _Elem* do_narrow(const _Elem* _First, const _Elem* _Last, char, char* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            ::memcpy(_Dest, _First, static_cast<size_t>(_Last - _First));
            return _Last;
        }

    private:
        _Locinfo::_Ctypevec _Ctype;
    };

    template <> class __declspec(dllimport) ctype<wchar_t> : public ctype_base
    {
    public:
        using _Elem = wchar_t;
        using char_type = _Elem;

        bool is(mask _Maskval, _Elem _Ch) const
        {
            return do_is(_Maskval, _Ch);
        }

        const _Elem* is(const _Elem* _First, const _Elem* _Last, mask* _Dest) const
        {
            return do_is(_First, _Last, _Dest);
        }

        const _Elem* scan_is(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            return do_scan_is(_Maskval, _First, _Last);
        }

        const _Elem* scan_not(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            return do_scan_not(_Maskval, _First, _Last);
        }

        _Elem tolower(_Elem _Ch) const
        {
            return do_tolower(_Ch);
        }

        const _Elem* tolower(_Elem* _First, const _Elem* _Last) const
        {
            return do_tolower(_First, _Last);
        }

        _Elem toupper(_Elem _Ch) const
        {
            return do_toupper(_Ch);
        }

        const _Elem* toupper(_Elem* _First, const _Elem* _Last) const
        {
            return do_toupper(_First, _Last);
        }

        _Elem widen(char _Byte) const
        {
            return do_widen(_Byte);
        }

        const char* widen(const char* _First, const char* _Last, _Elem* _Dest) const
        {
            return do_widen(_First, _Last, _Dest);
        }

        char narrow(_Elem _Ch, char _Dflt = '\0') const
        {
            return do_narrow(_Ch, _Dflt);
        }

        const _Elem* narrow(const _Elem* _First, const _Elem* _Last, char _Dflt, char* _Dest) const
        {
            return do_narrow(_First, _Last, _Dflt, _Dest);
        }

        static locale::id id;

        explicit ctype(size_t _Refs = 0) : ctype_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
            }

            return 2;
        }

    protected:
        virtual ~ctype() noexcept
        {
            if(_Ctype._Delfl)
            {
                ::free(const_cast<short*>(_Ctype._Table));
            }

            ::free(_Ctype._LocaleName);
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Ctype = _Lobj._Getctype();
            _Cvt = _Lobj._Getcvt();
        }

        virtual bool do_is(mask _Maskval, _Elem _Ch) const
        {
            return (::_Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
        }

        virtual const _Elem* do_is(const _Elem* _First, const _Elem* _Last, mask* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            return ::_Getwctypes(_First, _Last, _Dest, &_Ctype);
        }

        virtual const _Elem* do_scan_is(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            while(_First != _Last && !is(_Maskval, *_First))
            {
                ++_First;
            }

            return _First;
        }

        virtual const _Elem* do_scan_not(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            while(_First != _Last && is(_Maskval, *_First))
            {
                ++_First;
            }

            return _First;
        }

        virtual _Elem do_tolower(_Elem _Ch) const
        {
            return _Towlower(_Ch, &_Ctype);
        }

        virtual const _Elem* do_tolower(_Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First)
            {
                *_First = _Towlower(*_First, &_Ctype);
            }

            return _First;
        }

        virtual _Elem do_toupper(_Elem _Ch) const
        {
            return _Towupper(_Ch, &_Ctype);
        }

        virtual const _Elem* do_toupper(_Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First)
            {
                *_First = _Towupper(*_First, &_Ctype);
            }

            return _First;
        }

        _Elem _Dowiden(char _Byte) const
        {
            mbstate_t _Mbst = {};
            wchar_t _Wc;
            return _Mbrtowc(&_Wc, &_Byte, 1, &_Mbst, &_Cvt) < 0 ? static_cast<wchar_t>(((wint_t)(0xFFFF))) : _Wc;
        }

        virtual _Elem do_widen(char _Byte) const
        {
            return _Dowiden(_Byte);
        }

        virtual const char* do_widen(const char* _First, const char* _Last, _Elem* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First, ++_Dest)
            {
                *_Dest = _Dowiden(*_First);
            }

            return _First;
        }

        char _Donarrow(_Elem _Ch, char _Dflt) const
        {
            char _Buf[5];
            mbstate_t _Mbst = {};
            return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
        }

        virtual char do_narrow(_Elem _Ch, char _Dflt) const
        {
            return _Donarrow(_Ch, _Dflt);
        }

        virtual const _Elem* do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt, char* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First, ++_Dest)
            {
                *_Dest = _Donarrow(*_First, _Dflt);
            }

            return _First;
        }

    private:
        _Locinfo::_Ctypevec _Ctype;
        _Locinfo::_Cvtvec _Cvt;
    };

    template <> class __declspec(dllimport) ctype<unsigned short> : public ctype_base
    {
    public:
        using _Elem = unsigned short;
        using char_type = _Elem;

        bool is(mask _Maskval, _Elem _Ch) const
        {
            return do_is(_Maskval, _Ch);
        }

        const _Elem* is(const _Elem* _First, const _Elem* _Last, mask* _Dest) const
        {
            return do_is(_First, _Last, _Dest);
        }

        const _Elem* scan_is(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            return do_scan_is(_Maskval, _First, _Last);
        }

        const _Elem* scan_not(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            return do_scan_not(_Maskval, _First, _Last);
        }

        _Elem tolower(_Elem _Ch) const
        {
            return do_tolower(_Ch);
        }

        const _Elem* tolower(_Elem* _First, const _Elem* _Last) const
        {
            return do_tolower(_First, _Last);
        }

        _Elem toupper(_Elem _Ch) const
        {
            return do_toupper(_Ch);
        }

        const _Elem* toupper(_Elem* _First, const _Elem* _Last) const
        {
            return do_toupper(_First, _Last);
        }

        _Elem widen(char _Byte) const
        {
            return do_widen(_Byte);
        }

        const char* widen(const char* _First, const char* _Last, _Elem* _Dest) const
        {
            return do_widen(_First, _Last, _Dest);
        }

        char narrow(_Elem _Ch, char _Dflt = '\0') const
        {
            return do_narrow(_Ch, _Dflt);
        }

        const _Elem* narrow(const _Elem* _First, const _Elem* _Last, char _Dflt, char* _Dest) const
        {
            return do_narrow(_First, _Last, _Dflt, _Dest);
        }

        static locale::id id;

        explicit ctype(size_t _Refs = 0) : ctype_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        ctype(const _Locinfo& _Lobj, size_t _Refs = 0) : ctype_base(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new ctype<_Elem>(_Locinfo(_Ploc->c_str()));
            }

            return 2;
        }

    protected:
        virtual ~ctype() noexcept
        {
            if(_Ctype._Delfl)
            {
                ::free(const_cast<short*>(_Ctype._Table));
            }

            ::free(_Ctype._LocaleName);
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Ctype = _Lobj._Getctype();
            _Cvt = _Lobj._Getcvt();
        }

        virtual bool do_is(mask _Maskval, _Elem _Ch) const
        {
            return (::_Getwctype(_Ch, &_Ctype) & _Maskval) != 0;
        }

        virtual const _Elem* do_is(const _Elem* _First, const _Elem* _Last, mask* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            return reinterpret_cast<const _Elem*>(::_Getwctypes(reinterpret_cast<const wchar_t*>(_First),
                                                                reinterpret_cast<const wchar_t*>(_Last), _Dest, &_Ctype));
        }

        virtual const _Elem* do_scan_is(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            while(_First != _Last && !is(_Maskval, *_First))
            {
                ++_First;
            }

            return _First;
        }

        virtual const _Elem* do_scan_not(mask _Maskval, const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            while(_First != _Last && is(_Maskval, *_First))
            {
                ++_First;
            }

            return _First;
        }

        virtual _Elem do_tolower(_Elem _Ch) const
        {
            return _Towlower(_Ch, &_Ctype);
        }

        virtual const _Elem* do_tolower(_Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First)
            {
                *_First = _Towlower(*_First, &_Ctype);
            }

            return _First;
        }

        virtual _Elem do_toupper(_Elem _Ch) const
        {
            return _Towupper(_Ch, &_Ctype);
        }

        virtual const _Elem* do_toupper(_Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First)
            {
                *_First = _Towupper(*_First, &_Ctype);
            }

            return _First;
        }

        _Elem _Dowiden(char _Byte) const
        {
            mbstate_t _Mbst = {};
            unsigned short _Wc;

            if(_Mbrtowc(reinterpret_cast<wchar_t*>(&_Wc), &_Byte, 1, &_Mbst, &_Cvt) < 0)
            {
                return static_cast<unsigned short>(((wint_t)(0xFFFF)));
            }

            return _Wc;
        }

        virtual _Elem do_widen(char _Byte) const
        {
            return _Dowiden(_Byte);
        }

        virtual const char* do_widen(const char* _First, const char* _Last, _Elem* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First, ++_Dest)
            {
                *_Dest = _Dowiden(*_First);
            }

            return _First;
        }

        char _Donarrow(_Elem _Ch, char _Dflt) const
        {
            char _Buf[5];
            mbstate_t _Mbst = {};
            return _Wcrtomb(_Buf, _Ch, &_Mbst, &_Cvt) != 1 ? _Dflt : _Buf[0];
        }

        virtual char do_narrow(_Elem _Ch, char _Dflt) const
        {
            return _Donarrow(_Ch, _Dflt);
        }

        virtual const _Elem* do_narrow(const _Elem* _First, const _Elem* _Last, char _Dflt, char* _Dest) const
        {
            _Adl_verify_range(_First, _Last);
            for(; _First != _Last; ++_First, ++_Dest)
            {
                *_Dest = _Donarrow(*_First, _Dflt);
            }

            return _First;
        }

    private:
        _Locinfo::_Ctypevec _Ctype;
        _Locinfo::_Cvtvec _Cvt;
    };

    template <class _Elem> class ctype_byname : public ctype<_Elem>
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        explicit ctype_byname(const char* _Locname, size_t _Refs = 0) : ctype<_Elem>(_Locinfo(_Locname), _Refs)
        {
        }

        explicit ctype_byname(const string& _Str, size_t _Refs = 0) : ctype<_Elem>(_Locinfo(_Str.c_str()), _Refs)
        {
        }

    protected:
        virtual ~ctype_byname() noexcept
        {
        }
    };

    template class __declspec(dllimport) codecvt<char, char, mbstate_t>;
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Dummy> class _Iosb
    {
    public:
        enum _Dummy_enum
        {
            _Dummy_enum_val = 1
        };
        enum _Fmtflags
        {
            _Fmtmask = 0xffff,
            _Fmtzero = 0
        };

        static constexpr _Fmtflags skipws = static_cast<_Fmtflags>(0x0001);
        static constexpr _Fmtflags unitbuf = static_cast<_Fmtflags>(0x0002);
        static constexpr _Fmtflags uppercase = static_cast<_Fmtflags>(0x0004);
        static constexpr _Fmtflags showbase = static_cast<_Fmtflags>(0x0008);
        static constexpr _Fmtflags showpoint = static_cast<_Fmtflags>(0x0010);
        static constexpr _Fmtflags showpos = static_cast<_Fmtflags>(0x0020);
        static constexpr _Fmtflags left = static_cast<_Fmtflags>(0x0040);
        static constexpr _Fmtflags right = static_cast<_Fmtflags>(0x0080);
        static constexpr _Fmtflags internal = static_cast<_Fmtflags>(0x0100);
        static constexpr _Fmtflags dec = static_cast<_Fmtflags>(0x0200);
        static constexpr _Fmtflags oct = static_cast<_Fmtflags>(0x0400);
        static constexpr _Fmtflags hex = static_cast<_Fmtflags>(0x0800);
        static constexpr _Fmtflags scientific = static_cast<_Fmtflags>(0x1000);
        static constexpr _Fmtflags fixed = static_cast<_Fmtflags>(0x2000);

        static constexpr _Fmtflags hexfloat = static_cast<_Fmtflags>(0x3000);

        static constexpr _Fmtflags boolalpha = static_cast<_Fmtflags>(0x4000);
        static constexpr _Fmtflags _Stdio = static_cast<_Fmtflags>(0x8000);
        static constexpr _Fmtflags adjustfield = static_cast<_Fmtflags>(0x01C0);
        static constexpr _Fmtflags basefield = static_cast<_Fmtflags>(0x0E00);
        static constexpr _Fmtflags floatfield = static_cast<_Fmtflags>(0x3000);

        enum _Iostate
        {
            _Statmask = 0x17
        };

        static constexpr _Iostate goodbit = static_cast<_Iostate>(0x0);
        static constexpr _Iostate eofbit = static_cast<_Iostate>(0x1);
        static constexpr _Iostate failbit = static_cast<_Iostate>(0x2);
        static constexpr _Iostate badbit = static_cast<_Iostate>(0x4);

        enum _Openmode
        {
            _Openmask = 0xff
        };

        static constexpr _Openmode in = static_cast<_Openmode>(0x01);
        static constexpr _Openmode out = static_cast<_Openmode>(0x02);
        static constexpr _Openmode ate = static_cast<_Openmode>(0x04);
        static constexpr _Openmode app = static_cast<_Openmode>(0x08);
        static constexpr _Openmode trunc = static_cast<_Openmode>(0x10);
        static constexpr _Openmode _Nocreate = static_cast<_Openmode>(0x40);
        static constexpr _Openmode _Noreplace = static_cast<_Openmode>(0x80);
        static constexpr _Openmode binary = static_cast<_Openmode>(0x20);

        enum _Seekdir
        {
            _Seekbeg,
            _Seekcur,
            _Seekend
        };

        static constexpr _Seekdir beg = _Seekbeg;
        static constexpr _Seekdir cur = _Seekcur;
        static constexpr _Seekdir end = _Seekend;

        enum
        {
            _Openprot = 0x40
        };

        static constexpr int _Default_open_prot = 0x40;
    };

    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::skipws;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::unitbuf;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::uppercase;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showbase;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpoint;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::showpos;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::left;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::right;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::internal;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::dec;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::oct;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hex;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::scientific;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::fixed;

    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::hexfloat;

    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::boolalpha;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::_Stdio;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::adjustfield;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::basefield;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Fmtflags _Iosb<_Dummy>::floatfield;

    template <class _Dummy> const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::goodbit;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::eofbit;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::failbit;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Iostate _Iosb<_Dummy>::badbit;

    template <class _Dummy> const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::in;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::out;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::ate;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::app;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::trunc;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Nocreate;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::_Noreplace;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Openmode _Iosb<_Dummy>::binary;

    template <class _Dummy> const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::beg;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::cur;
    template <class _Dummy> const typename _Iosb<_Dummy>::_Seekdir _Iosb<_Dummy>::end;

    class __declspec(dllimport) ios_base : public _Iosb<int>
    {
    public:
        using fmtflags = int;
        using iostate = int;
        using openmode = int;
        using seekdir = int;

        using streamoff = ::std::streamoff;
        using streampos = ::std::streampos;

        enum event
        {
            erase_event,
            imbue_event,
            copyfmt_event
        };

        using event_callback = void(__cdecl*)(event, ios_base&, int);

        using io_state = unsigned int;
        using open_mode = unsigned int;
        using seek_dir = unsigned int;

        class failure : public system_error
        {
        public:
            explicit failure(const string& _Message, const error_code& _Errcode = make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message)
            {
            }

            explicit failure(const char* _Message, const error_code& _Errcode = make_error_code(io_errc::stream))
            : system_error(_Errcode, _Message)
            {
            }
        };

        class __declspec(dllimport) Init
        {
        public:
            Init()
            {
                _Init_ctor(this);
            }

            ~Init() noexcept
            {
                _Init_dtor(this);
            }

        private:
            static void __cdecl _Init_ctor(Init*);
            static void __cdecl _Init_dtor(Init*);

            static int _Init_cnt;

            static int& __cdecl _Init_cnt_func();
        };

        explicit operator bool() const
        {
            return !fail();
        }

        [[nodiscard]] bool operator!() const
        {
            return fail();
        }

        void clear(iostate _State, bool _Reraise)
        {
            _State &= _Statmask;
            _Mystate = _State;
            const auto _Filtered = _State & _Except;
            if(_Filtered)
            {
                if(_Reraise)
                {
                    throw;
                }

                const char* _Msg;
                if(_Filtered & ios_base::badbit)
                {
                    _Msg = "ios_base::badbit set";
                }
                else if(_Filtered & ios_base::failbit)
                {
                    _Msg = "ios_base::failbit set";
                }
                else
                {
                    _Msg = "ios_base::eofbit set";
                }

                throw failure(_Msg);
            }
        }

        void clear(iostate _State = goodbit)
        {
            clear(_State, false);
        }

        void clear(io_state _State)
        {
            clear(static_cast<iostate>(_State));
        }

        [[nodiscard]] iostate rdstate() const
        {
            return _Mystate;
        }

        void setstate(iostate _State, bool _Exreraise)
        {
            clear(rdstate() | _State, _Exreraise);
        }

        void setstate(iostate _State)
        {
            clear(rdstate() | _State, false);
        }

        void setstate(io_state _State)
        {
            setstate(static_cast<iostate>(_State));
        }

        [[nodiscard]] bool good() const
        {
            return rdstate() == ios_base::goodbit;
        }

        [[nodiscard]] bool eof() const
        {
            return rdstate() & ios_base::eofbit;
        }

        [[nodiscard]] bool fail() const
        {
            return rdstate() & (ios_base::badbit | ios_base::failbit);
        }

        [[nodiscard]] bool bad() const
        {
            return rdstate() & ios_base::badbit;
        }

        [[nodiscard]] iostate exceptions() const
        {
            return _Except;
        }

        void exceptions(iostate _Newexcept)
        {
            _Except = _Newexcept & _Statmask;
            clear(rdstate());
        }

        void exceptions(io_state _State)
        {
            exceptions(static_cast<iostate>(_State));
        }

        [[nodiscard]] fmtflags flags() const
        {
            return _Fmtfl;
        }

        fmtflags flags(fmtflags _Newfmtflags)
        {
            const fmtflags _Oldfmtflags = _Fmtfl;
            _Fmtfl = _Newfmtflags & _Fmtmask;
            return _Oldfmtflags;
        }

        fmtflags setf(fmtflags _Newfmtflags)
        {
            const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
            _Fmtfl |= _Newfmtflags & _Fmtmask;
            return _Oldfmtflags;
        }

        fmtflags setf(fmtflags _Newfmtflags, fmtflags _Mask)
        {
            const ios_base::fmtflags _Oldfmtflags = _Fmtfl;
            _Fmtfl = (_Oldfmtflags & ~_Mask) | (_Newfmtflags & _Mask & _Fmtmask);
            return _Oldfmtflags;
        }

        void unsetf(fmtflags _Mask)
        {
            _Fmtfl &= ~_Mask;
        }

        [[nodiscard]] streamsize precision() const
        {
            return _Prec;
        }

        streamsize precision(streamsize _Newprecision)
        {
            const streamsize _Oldprecision = _Prec;
            _Prec = _Newprecision;
            return _Oldprecision;
        }

        [[nodiscard]] streamsize width() const
        {
            return _Wide;
        }

        streamsize width(streamsize _Newwidth)
        {
            const streamsize _Oldwidth = _Wide;
            _Wide = _Newwidth;
            return _Oldwidth;
        }

        [[nodiscard]] locale getloc() const
        {
            return *_Ploc;
        }

        locale imbue(const locale& _Loc)
        {
            locale _Oldlocale = *_Ploc;
            *_Ploc = _Loc;
            _Callfns(imbue_event);
            return _Oldlocale;
        }

        [[nodiscard]] static int __cdecl xalloc()
        {
            {
                ::std::_Lockit _Lock(2);
                return _Index++;
            }
        }

        [[nodiscard]] long& iword(int _Idx)
        {
            return _Findarr(_Idx)._Lo;
        }

        [[nodiscard]] void*& pword(int _Idx)
        {
            return _Findarr(_Idx)._Vp;
        }

        void register_callback(event_callback _Pfn, int _Idx)
        {
            _Calls = new _Fnarray(_Idx, _Pfn, _Calls);
        }

        ios_base& copyfmt(const ios_base& _Other)
        {
            if(this != ::std::addressof(_Other))
            {
                _Tidy();
                *_Ploc = *_Other._Ploc;
                _Fmtfl = _Other._Fmtfl;
                _Prec = _Other._Prec;
                _Wide = _Other._Wide;
                _Iosarray* _Ptr = _Other._Arr;

                for(_Arr = nullptr; _Ptr; _Ptr = _Ptr->_Next)
                {
                    if(_Ptr->_Lo != 0 || _Ptr->_Vp)
                    {
                        iword(_Ptr->_Index) = _Ptr->_Lo;
                        pword(_Ptr->_Index) = _Ptr->_Vp;
                    }
                }

                for(_Fnarray* _Pfa = _Other._Calls; _Pfa; _Pfa = _Pfa->_Next)
                {
                    register_callback(_Pfa->_Pfn, _Pfa->_Index);
                }

                _Callfns(copyfmt_event);
                exceptions(_Other._Except);
            }
            return *this;
        }

        static bool __cdecl sync_with_stdio(bool _Newsync = true)
        {
            {
                ::std::_Lockit _Lock(2);
                const bool _Oldsync = _Sync;
                _Sync = _Newsync;
                return _Oldsync;
            }
        }

        void swap(ios_base& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                ::std::swap(_Mystate, _Right._Mystate);
                ::std::swap(_Except, _Right._Except);
                ::std::swap(_Fmtfl, _Right._Fmtfl);
                ::std::swap(_Prec, _Right._Prec);
                ::std::swap(_Wide, _Right._Wide);

                ::std::swap(_Arr, _Right._Arr);
                ::std::swap(_Calls, _Right._Calls);
                ::std::swap(_Ploc, _Right._Ploc);
            }
        }

        virtual ~ios_base() noexcept
        {
            _Ios_base_dtor(this);
        }

        static void __cdecl _Addstd(ios_base*);

        size_t _Stdstr;

    protected:
        ios_base()
        {
        }

        void _Init()
        {
            _Ploc = nullptr;
            _Stdstr = 0;
            _Except = goodbit;
            _Fmtfl = skipws | dec;
            _Prec = 6;
            _Wide = 0;
            _Arr = nullptr;
            _Calls = nullptr;
            clear(goodbit);
            _Ploc = new locale;
        }

    private:
        struct _Iosarray : _Crt_new_delete
        {
        public:
            _Iosarray(int _Idx, _Iosarray* _Link) : _Next(_Link), _Index(_Idx), _Lo(0), _Vp(nullptr)
            {
            }

            _Iosarray* _Next;
            int _Index;
            long _Lo;
            void* _Vp;
        };

        struct _Fnarray : _Crt_new_delete
        {
            _Fnarray(int _Idx, event_callback _Pnew, _Fnarray* _Link) : _Next(_Link), _Index(_Idx), _Pfn(_Pnew)
            {
            }

            _Fnarray* _Next;
            int _Index;
            event_callback _Pfn;
        };

        void _Callfns(event _Ev)
        {
            for(_Fnarray* _Pfa = _Calls; _Pfa; _Pfa = _Pfa->_Next)
            {
                (*_Pfa->_Pfn)(_Ev, *this, _Pfa->_Index);
            }
        }

        _Iosarray& _Findarr(int _Idx)
        {
            _Iosarray *_Ptr1, *_Ptr2;

            for(_Ptr1 = _Arr, _Ptr2 = nullptr; _Ptr1; _Ptr1 = _Ptr1->_Next)
            {
                if(_Ptr1->_Index == _Idx)
                {
                    return *_Ptr1;
                }
                else if(!_Ptr2 && _Ptr1->_Lo == 0 && !_Ptr1->_Vp)
                {
                    _Ptr2 = _Ptr1;
                }
            }

            if(_Ptr2)
            {
                _Ptr2->_Index = _Idx;
                return *_Ptr2;
            }

            _Arr = new _Iosarray(_Idx, _Arr);
            return *_Arr;
        }

        void _Tidy() noexcept
        {
            _Callfns(erase_event);
            _Iosarray *_Ptr1, *_Ptr2;

            for(_Ptr1 = _Arr; _Ptr1; _Ptr1 = _Ptr2)
            {
                _Ptr2 = _Ptr1->_Next;
                delete _Ptr1;
            }
            _Arr = nullptr;

            _Fnarray *_Pfa1, *_Pfa2;
            for(_Pfa1 = _Calls; _Pfa1; _Pfa1 = _Pfa2)
            {
                _Pfa2 = _Pfa1->_Next;
                delete _Pfa1;
            }
            _Calls = nullptr;
        }

        iostate _Mystate;
        iostate _Except;
        fmtflags _Fmtfl;
        streamsize _Prec;
        streamsize _Wide;
        _Iosarray* _Arr;
        _Fnarray* _Calls;
        locale* _Ploc;

        static int _Index;
        static bool _Sync;

        static void __cdecl _Ios_base_dtor(ios_base*);

    public:
        ios_base(const ios_base&) = delete;
        ios_base& operator=(const ios_base&) = delete;
    };
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Elem, class _Traits> class basic_streambuf
    {
    protected:
        basic_streambuf() : _Plocale(new locale)
        {
            _Init();
        }

        basic_streambuf(_Uninitialized)
        {
        }

        basic_streambuf(const basic_streambuf& _Right) : _Plocale(new locale(_Right.getloc()))
        {
            _Init();
            setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
            setg(_Right.eback(), _Right.gptr(), _Right.egptr());
        }

        basic_streambuf& operator=(const basic_streambuf& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
                setg(_Right.eback(), _Right.gptr(), _Right.egptr());
                pubimbue(_Right.getloc());
            }
            return *this;
        }

        void swap(basic_streambuf& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Elem* _Pfirst0 = pbase();
                _Elem* _Pnext0 = pptr();
                _Elem* _Pend = epptr();
                _Elem* _Gfirst0 = eback();
                _Elem* _Gnext0 = gptr();
                _Elem* _Gend = egptr();

                setp(_Right.pbase(), _Right.pptr(), _Right.epptr());
                _Right.setp(_Pfirst0, _Pnext0, _Pend);

                setg(_Right.eback(), _Right.gptr(), _Right.egptr());
                _Right.setg(_Gfirst0, _Gnext0, _Gend);

                ::std::swap(_Plocale, _Right._Plocale);
            }
        }

    public:
        using char_type = _Elem;
        using traits_type = _Traits;

        virtual ~basic_streambuf() noexcept
        {
            delete _Plocale;
        }

        using int_type = typename _Traits::int_type;
        using pos_type = typename _Traits::pos_type;
        using off_type = typename _Traits::off_type;

        pos_type pubseekoff(off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        {
            return seekoff(_Off, _Way, _Mode);
        }

        pos_type pubseekoff(off_type _Off, ios_base::seek_dir _Way, ios_base::open_mode _Mode)
        {
            return pubseekoff(_Off, static_cast<ios_base::seekdir>(_Way), static_cast<ios_base::openmode>(_Mode));
        }

        pos_type pubseekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        {
            return seekpos(_Pos, _Mode);
        }

        pos_type pubseekpos(pos_type _Pos, ios_base::open_mode _Mode)
        {
            return seekpos(_Pos, static_cast<ios_base::openmode>(_Mode));
        }

        basic_streambuf* pubsetbuf(_Elem* _Buffer, streamsize _Count)
        {
            return setbuf(_Buffer, _Count);
        }

        locale pubimbue(const locale& _Newlocale)
        {
            locale _Oldlocale = *_Plocale;
            imbue(_Newlocale);
            *_Plocale = _Newlocale;
            return _Oldlocale;
        }

        locale getloc() const
        {
            return *_Plocale;
        }

        streamsize in_avail()
        {
            streamsize _Res = _Gnavail();
            return 0 < _Res ? _Res : showmanyc();
        }

        int pubsync()
        {
            return sync();
        }

        int_type sbumpc()
        {
            return 0 < _Gnavail() ? _Traits::to_int_type(*_Gninc()) : uflow();
        }

        int_type sgetc()
        {
            return 0 < _Gnavail() ? _Traits::to_int_type(*gptr()) : underflow();
        }

        streamsize sgetn(_Elem* _Ptr, streamsize _Count)
        {
            return xsgetn(_Ptr, _Count);
        }

        int_type snextc()
        {
            return 1 < _Gnavail() ? _Traits::to_int_type(*_Gnpreinc()) :
                                    _Traits::eq_int_type(_Traits::eof(), sbumpc()) ? _Traits::eof() : sgetc();
        }

        int_type sputbackc(_Elem _Ch)
        {
            if(gptr() && eback() < gptr() && _Traits::eq(_Ch, gptr()[-1]))
            {
                return _Traits::to_int_type(*_Gndec());
            }

            return pbackfail(_Traits::to_int_type(_Ch));
        }

        void stossc()
        {
            if(0 < _Gnavail())
            {
                _Gninc();
            }
            else
            {
                uflow();
            }
        }

        int_type sungetc()
        {
            return gptr() && eback() < gptr() ? _Traits::to_int_type(*_Gndec()) : pbackfail();
        }

        int_type sputc(_Elem _Ch)
        {
            return 0 < _Pnavail() ? _Traits::to_int_type(*_Pninc() = _Ch) : overflow(_Traits::to_int_type(_Ch));
        }

        streamsize sputn(const _Elem* _Ptr, streamsize _Count)
        {
            return xsputn(_Ptr, _Count);
        }

        virtual void _Lock()
        {
        }

        virtual void _Unlock()
        {
        }

    protected:
        _Elem* eback() const
        {
            return *_IGfirst;
        }

        _Elem* gptr() const
        {
            return *_IGnext;
        }

        _Elem* pbase() const
        {
            return *_IPfirst;
        }

        _Elem* pptr() const
        {
            return *_IPnext;
        }

        _Elem* egptr() const
        {
            return *_IGnext + *_IGcount;
        }

        void gbump(int _Off)
        {
            *_IGcount -= _Off;
            *_IGnext += _Off;
        }

        void setg(_Elem* _First, _Elem* _Next, _Elem* _Last)
        {
            *_IGfirst = _First;
            *_IGnext = _Next;
            *_IGcount = static_cast<int>(_Last - _Next);
        }

        _Elem* epptr() const
        {
            return *_IPnext + *_IPcount;
        }

        _Elem* _Gndec()
        {
            ++*_IGcount;
            return --*_IGnext;
        }

        _Elem* _Gninc()
        {
            --*_IGcount;
            return (*_IGnext)++;
        }

        _Elem* _Gnpreinc()
        {
            --*_IGcount;
            return ++(*_IGnext);
        }

        streamsize _Gnavail() const
        {
            return *_IGnext ? *_IGcount : 0;
        }

        void pbump(int _Off)
        {
            *_IPcount -= _Off;
            *_IPnext += _Off;
        }

        void setp(_Elem* _First, _Elem* _Last)
        {
            *_IPfirst = _First;
            *_IPnext = _First;
            *_IPcount = static_cast<int>(_Last - _First);
        }

        void setp(_Elem* _First, _Elem* _Next, _Elem* _Last)
        {
            *_IPfirst = _First;
            *_IPnext = _Next;
            *_IPcount = static_cast<int>(_Last - _Next);
        }

        _Elem* _Pninc()
        {
            --*_IPcount;
            return (*_IPnext)++;
        }

        streamsize _Pnavail() const
        {
            return *_IPnext ? *_IPcount : 0;
        }

        void _Init()
        {
            _IGfirst = &_Gfirst;
            _IPfirst = &_Pfirst;
            _IGnext = &_Gnext;
            _IPnext = &_Pnext;
            _IGcount = &_Gcount;
            _IPcount = &_Pcount;
            setp(nullptr, nullptr);
            setg(nullptr, nullptr, nullptr);
        }

        void _Init(_Elem** _Gf, _Elem** _Gn, int* _Gc, _Elem** _Pf, _Elem** _Pn, int* _Pc)
        {
            _IGfirst = _Gf;
            _IPfirst = _Pf;
            _IGnext = _Gn;
            _IPnext = _Pn;
            _IGcount = _Gc;
            _IPcount = _Pc;
        }

        virtual int_type overflow(int_type = _Traits::eof())
        {
            return _Traits::eof();
        }

        virtual int_type pbackfail(int_type = _Traits::eof())
        {
            return _Traits::eof();
        }

        virtual streamsize showmanyc()
        {
            return 0;
        }

        virtual int_type underflow()
        {
            return _Traits::eof();
        }

        virtual int_type uflow()
        {
            return _Traits::eq_int_type(_Traits::eof(), underflow()) ? _Traits::eof() : _Traits::to_int_type(*_Gninc());
        }

        virtual streamsize xsgetn(_Elem* _Ptr, streamsize _Count)
        {
            const streamsize _Start_count = _Count;

            while(0 < _Count)
            {
                streamsize _Size = _Gnavail();
                if(0 < _Size)
                {
                    if(_Count < _Size)
                    {
                        _Size = _Count;
                    }

                    _Traits::copy(_Ptr, gptr(), static_cast<size_t>(_Size));
                    _Ptr += _Size;
                    _Count -= _Size;
                    gbump(static_cast<int>(_Size));
                }
                else
                {
                    const int_type _Meta = uflow();
                    if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                    {
                        break;
                    }

                    *_Ptr++ = _Traits::to_char_type(_Meta);
                    --_Count;
                }
            }

            return _Start_count - _Count;
        }

        virtual streamsize xsputn(const _Elem* _Ptr, streamsize _Count)
        {
            const streamsize _Start_count = _Count;
            while(0 < _Count)
            {
                streamsize _Size = _Pnavail();
                if(0 < _Size)
                {
                    if(_Count < _Size)
                    {
                        _Size = _Count;
                    }

                    _Traits::copy(pptr(), _Ptr, static_cast<size_t>(_Size));
                    _Ptr += _Size;
                    _Count -= _Size;
                    pbump(static_cast<int>(_Size));
                }
                else if(_Traits::eq_int_type(_Traits::eof(), overflow(_Traits::to_int_type(*_Ptr))))
                {
                    break;
                }
                else
                {
                    ++_Ptr;
                    --_Count;
                }
            }

            return _Start_count - _Count;
        }

        virtual pos_type seekoff(off_type, ios_base::seekdir, ios_base::openmode = ios_base::in | ios_base::out)
        {
            return streampos(-1);
        }

        virtual pos_type seekpos(pos_type, ios_base::openmode = ios_base::in | ios_base::out)
        {
            return streampos(-1);
        }

        virtual basic_streambuf* setbuf(_Elem*, streamsize)
        {
            return this;
        }

        virtual int sync()
        {
            return 0;
        }

        virtual void imbue(const locale&)
        {
        }

    private:
        _Elem* _Gfirst;
        _Elem* _Pfirst;
        _Elem** _IGfirst;
        _Elem** _IPfirst;
        _Elem* _Gnext;
        _Elem* _Pnext;
        _Elem** _IGnext;
        _Elem** _IPnext;

        int _Gcount;
        int _Pcount;
        int* _IGcount;
        int* _IPcount;

    protected:
        locale* _Plocale;
    };

    template class __declspec(dllimport) basic_streambuf<char, char_traits<char>>;
    template class __declspec(dllimport) basic_streambuf<wchar_t, char_traits<wchar_t>>;

    template <class _Elem, class _Traits> class istreambuf_iterator
    {
    public:
        using iterator_category = input_iterator_tag;
        using value_type = _Elem;
        using difference_type = typename _Traits::off_type;
        using pointer = const _Elem*;
        using reference = _Elem;

        using char_type = _Elem;
        using traits_type = _Traits;
        using streambuf_type = basic_streambuf<_Elem, _Traits>;
        using istream_type = basic_istream<_Elem, _Traits>;

        using int_type = typename traits_type::int_type;

        constexpr istreambuf_iterator() noexcept : _Strbuf(nullptr), _Got(true), _Val()
        {
        }

        istreambuf_iterator(streambuf_type* _Sb) noexcept : _Strbuf(_Sb), _Got(!_Sb), _Val()
        {
        }

        istreambuf_iterator(istream_type& _Istr) noexcept : _Strbuf(_Istr.rdbuf()), _Got(!_Strbuf), _Val()
        {
        }

    private:
        class _Istreambuf_proxy
        {
        public:
            [[nodiscard]] _Elem operator*() const
            {
                return _Keep;
            }

        private:
            friend istreambuf_iterator;
            _Istreambuf_proxy(streambuf_type* _Strbuf_, _Elem _Keep_) : _Strbuf(_Strbuf_), _Keep(_Keep_)
            {
            }

            streambuf_type* _Strbuf;
            _Elem _Keep;
        };

    public:
        istreambuf_iterator(const _Istreambuf_proxy& _Px) noexcept : _Strbuf(_Px._Strbuf), _Got(!_Strbuf), _Val()
        {
        }

        [[nodiscard]] _Elem operator*() const
        {
            if(!_Got)
            {
                _Peek();
            }

            return _Val;
        }

        istreambuf_iterator& operator++()
        {
            _Inc();
            return *this;
        }

        _Istreambuf_proxy operator++(int)
        {
            if(!_Got)
            {
                _Peek();
            }

            _Istreambuf_proxy _Tmp{ _Strbuf, _Val };
            ++*this;
            return _Tmp;
        }

        [[nodiscard]] bool equal(const istreambuf_iterator& _Right) const
        {
            if(!_Got)
            {
                _Peek();
            }

            if(!_Right._Got)
            {
                _Right._Peek();
            }

            return (!_Strbuf && !_Right._Strbuf) || (_Strbuf && _Right._Strbuf);
        }

    private:
        void _Inc()
        {
            if(!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Strbuf->sbumpc()))
            {
                _Strbuf = nullptr;
                _Got = true;
            }
            else
            {
                _Got = false;
            }
        }

        _Elem _Peek() const
        {
            int_type _Meta;
            if(!_Strbuf || traits_type::eq_int_type(traits_type::eof(), _Meta = _Strbuf->sgetc()))
            {
                _Strbuf = nullptr;
            }
            else
            {
                _Val = traits_type::to_char_type(_Meta);
            }

            _Got = true;
            return _Val;
        }

        mutable streambuf_type* _Strbuf;
        mutable bool _Got;
        mutable _Elem _Val;
    };

    template <class _Elem, class _Traits>
    [[nodiscard]] bool
    operator==(const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right)
    {
        return _Left.equal(_Right);
    }

    template <class _Elem, class _Traits>
    [[nodiscard]] bool
    operator!=(const istreambuf_iterator<_Elem, _Traits>& _Left, const istreambuf_iterator<_Elem, _Traits>& _Right)
    {
        return !(_Left == _Right);
    }

    template <class _Elem, class _Traits> class ostreambuf_iterator
    {
    public:
        using iterator_category = output_iterator_tag;
        using value_type = void;
        using difference_type = void;
        using pointer = void;
        using reference = void;

        using char_type = _Elem;
        using traits_type = _Traits;
        using streambuf_type = basic_streambuf<_Elem, _Traits>;
        using ostream_type = basic_ostream<_Elem, _Traits>;

        ostreambuf_iterator(streambuf_type* _Sb) noexcept : _Failed(false), _Strbuf(_Sb)
        {
        }

        ostreambuf_iterator(ostream_type& _Ostr) noexcept : _Failed(false), _Strbuf(_Ostr.rdbuf())
        {
        }

        ostreambuf_iterator& operator=(_Elem _Right)
        {
            if(!_Strbuf || traits_type::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Right)))
            {
                _Failed = true;
            }

            return *this;
        }

        [[nodiscard]] ostreambuf_iterator& operator*()
        {
            return *this;
        }

        ostreambuf_iterator& operator++()
        {
            return *this;
        }

        ostreambuf_iterator& operator++(int)
        {
            return *this;
        }

        [[nodiscard]] bool failed() const noexcept
        {
            return _Failed;
        }

    private:
        bool _Failed;
        streambuf_type* _Strbuf;
    };
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

extern "C"
{
    extern float __cdecl _Stofx(const char*, char**, long, int*);
    extern double __cdecl _Stodx(const char*, char**, long, int*);
    extern long double __cdecl _Stoldx(const char*, char**, long, int*);
    extern long __cdecl _Stolx(const char*, char**, int, int*);
    extern unsigned long __cdecl _Stoulx(const char*, char**, int, int*);
    extern long long __cdecl _Stollx(const char*, char**, int, int*);
    extern unsigned long long __cdecl _Stoullx(const char*, char**, int, int*);
}

namespace std
{
    inline double _Stodx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr)
    {
        int& _Errno_ref = (*_errno());
        const int _Orig = _Errno_ref;

        _Errno_ref = 0;
        double _Val = ::strtod(_Str, _Endptr);
        *_Perr = _Errno_ref;
        _Errno_ref = _Orig;

        if(_Pten != 0)
        {
            _Val *= ::pow(10.0, static_cast<double>(_Pten));
        }

        return _Val;
    }

    inline float _Stofx_v2(const char* _Str, char** _Endptr, int _Pten, int* _Perr)
    {
        int& _Errno_ref = (*_errno());
        const int _Orig = _Errno_ref;

        _Errno_ref = 0;
        float _Val = ::strtof(_Str, _Endptr);
        *_Perr = _Errno_ref;
        _Errno_ref = _Orig;

        if(_Pten != 0)
        {
            _Val *= ::powf(10.0f, static_cast<float>(_Pten));
        }

        return _Val;
    }

    template <class _Elem, size_t _Base_size> size_t _Find_elem(const _Elem (&_Base)[_Base_size], const _Elem _Ch)
    {
        return static_cast<size_t>(_Find_unchecked(_Base, _Base + (_Base_size - 1), _Ch) - _Base);
    }

    inline wchar_t* _Maklocwcs(const wchar_t* _Ptr)
    {
        const size_t _Count = ::wcslen(_Ptr) + 1;

        wchar_t* _Ptrdest = static_cast<wchar_t*>(calloc(_Count, sizeof(wchar_t)));

        if(!_Ptrdest)
        {
            _Xbad_alloc();
        }

        ::wmemcpy(_Ptrdest, _Ptr, _Count);
        return _Ptrdest;
    }

    template <class _Elem> class numpunct : public locale::facet
    {
    private:
        friend _Tidy_guard<numpunct>;

    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;
        using char_type = _Elem;

        __declspec(dllimport) static locale::id id;

        _Elem decimal_point() const
        {
            return do_decimal_point();
        }

        _Elem thousands_sep() const
        {
            return do_thousands_sep();
        }

        string grouping() const
        {
            return do_grouping();
        }

        string_type falsename() const
        {
            return do_falsename();
        }

        string_type truename() const
        {
            return do_truename();
        }

        explicit numpunct(size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
                if(_Kseparator == 0)
                {
                    _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Lobj._Getcvt());
                }
            }
        }

        numpunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs)
        {
            _Init(_Lobj, _Isdef);
        }

        static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new numpunct<_Elem>(_Locinfo(_Ploc->c_str()), 0, true);
            }
            return 4;
        }

    protected:
        virtual ~numpunct() noexcept
        {
            _Tidy();
        }

        numpunct(const char* _Locname, size_t _Refs = 0, bool _Isdef = false) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj(_Locname);
                _Init(_Lobj, _Isdef);
            }
        }

        template <class _Elem2> void _Getvals(_Elem2, const lconv* _Ptr, _Locinfo::_Cvtvec _Cvt)
        {
            _Dp = _Maklocchr(_Ptr->decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);
            _Kseparator = _Maklocchr(_Ptr->thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);
        }

        void _Getvals(wchar_t, const lconv* _Ptr, _Locinfo::_Cvtvec)
        {
            _Dp = static_cast<_Elem>(_Ptr->_W_decimal_point[0]);
            _Kseparator = static_cast<_Elem>(_Ptr->_W_thousands_sep[0]);
        }

        void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
        {
            const lconv* _Ptr = _Lobj._Getlconv();
            _Locinfo::_Cvtvec _Cvt = _Lobj._Getcvt();

            _Grouping = nullptr;
            _Falsename = nullptr;
            _Truename = nullptr;

            _Tidy_guard<numpunct> _Guard{ this };
            _Grouping = _Maklocstr(_Isdef ? "" : _Ptr->grouping, static_cast<char*>(nullptr), _Lobj._Getcvt());
            _Falsename = _Maklocstr(_Lobj._Getfalse(), static_cast<_Elem*>(nullptr), _Cvt);
            _Truename = _Maklocstr(_Lobj._Gettrue(), static_cast<_Elem*>(nullptr), _Cvt);
            _Guard._Target = nullptr;

            if(_Isdef)
            {
                _Dp = _Maklocchr('.', static_cast<_Elem*>(nullptr), _Cvt);
                _Kseparator = _Maklocchr(',', static_cast<_Elem*>(nullptr), _Cvt);
            }
            else
            {
                _Getvals(_Elem{}, _Ptr, _Cvt);
            }
        }

        virtual _Elem do_decimal_point() const
        {
            return _Dp;
        }

        virtual _Elem do_thousands_sep() const
        {
            return _Kseparator;
        }

        virtual string do_grouping() const
        {
            return string(_Grouping);
        }

        virtual string_type do_falsename() const
        {
            return string_type(_Falsename);
        }

        virtual string_type do_truename() const
        {
            return string_type(_Truename);
        }

    private:
        void _Tidy() noexcept
        {
            ::free(const_cast<char*>(_Grouping));
            ::free(const_cast<_Elem*>(_Falsename));
            ::free(const_cast<_Elem*>(_Truename));
        }

        const char* _Grouping;
        _Elem _Dp;
        _Elem _Kseparator;
        const _Elem* _Falsename;
        const _Elem* _Truename;
    };

    template <class _Elem> class numpunct_byname : public numpunct<_Elem>
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        explicit numpunct_byname(const char* _Locname, size_t _Refs = 0) : numpunct<_Elem>(_Locname, _Refs)
        {
        }

        explicit numpunct_byname(const string& _Str, size_t _Refs = 0) : numpunct<_Elem>(_Str.c_str(), _Refs)
        {
        }

    protected:
        virtual ~numpunct_byname() noexcept
        {
        }
    };

    template <class _Elem> locale::id numpunct<_Elem>::id;

    template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
    class num_get : public locale::facet
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new num_get<_Elem, _InIt>(_Locinfo(_Ploc->c_str()));
            }

            return 4;
        }

        static locale::id id;

    protected:
        virtual ~num_get() noexcept
        {
        }

        void _Init(const _Locinfo&)
        {
        }

    public:
        explicit num_get(size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        num_get(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs)
        {
            _Init(_Lobj);
        }

        using char_type = _Elem;
        using iter_type = _InIt;

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, bool& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, unsigned short& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, unsigned int& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, long& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, unsigned long& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, long long& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, unsigned long long& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, float& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, double& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, long double& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, void*& _Val) const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Val);
        }

    protected:
        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, bool& _Val) const
        {
            _Adl_verify_range(_First, _Last);
            if(_Iosbase.flags() & ios_base::boolalpha)
            {
                const auto& _Punct_fac = ::std::use_facet<numpunct<_Elem>>(_Iosbase.getloc());
                basic_string<_Elem> _Str(static_cast<size_t>(1), _Elem{});
                _Str += _Punct_fac.falsename();
                _Str.push_back(_Elem{});
                _Str += _Punct_fac.truename();
                switch(_Getloctxt(_First, _Last, 2, _Str.c_str()))
                {
                    case 0:
                        _Val = false;
                        break;
                    case 1:
                        _Val = true;
                        break;
                    default:
                        _Val = false;
                        _State = ios_base::failbit;
                        break;
                }
            }
            else
            {
                char _Ac[32];
                const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
                if(_Ac[0] == '\0')
                {
                    _Val = false;
                    _State = ios_base::failbit;
                }
                else
                {
                    char* _Ep;
                    int _Errno;
                    const long _Ans = ::_Stolx(_Ac, &_Ep, _Base, &_Errno);
                    if(_Ep == _Ac || _Errno != 0)
                    {
                        _Val = true;
                        _State = ios_base::failbit;
                    }
                    else
                    {
                        _Val = _Ans != 0;
                        if(_Ans != 0 && _Ans != 1)
                        {
                            _State = ios_base::failbit;
                        }
                    }
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, unsigned short& _Val) const
        {
            _Adl_verify_range(_First, _Last);
            char _Ac[32];
            const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
            if(_Ac[0] == '\0')
            {
                _State = ios_base::failbit;
                _Val = 0;
            }
            else
            {
                const bool _Minus = _Ac[0] == '-';
                const char* _Digits = _Ac;

                if(_Minus)
                {
                    ++_Digits;
                }

                char* _Ep;
                int _Errno;
                const unsigned long _Tmp = ::_Stoulx(_Digits, &_Ep, _Base, &_Errno);
                _Val = static_cast<unsigned short>(_Tmp);
                if(_Ep == _Digits || _Errno != 0 || _Tmp > 0xffff)
                {
                    _State = ios_base::failbit;
                    _Val = 0xffff;
                }
                else if(_Minus)
                {
                    _Val = static_cast<unsigned short>(0 - _Val);
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, unsigned int& _Val) const
        {
            static_assert(sizeof(unsigned int) == sizeof(unsigned long),
                          "Bad overflow assumptions due to sizeof(unsigned int) != sizeof(unsigned long)");
            unsigned long _Tmp;
            _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Tmp);
            _Val = _Tmp;
            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, long& _Val) const
        {
            _Adl_verify_range(_First, _Last);
            char _Ac[32];
            const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
            if(_Ac[0] == '\0')
            {
                _State = ios_base::failbit;
                _Val = 0;
            }
            else
            {
                char* _Ep;
                int _Errno;
                _Val = ::_Stolx(_Ac, &_Ep, _Base, &_Errno);
                if(_Ep == _Ac || _Errno != 0)
                {
                    _State = ios_base::failbit;
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, unsigned long& _Val) const
        {
            _Adl_verify_range(_First, _Last);
            char _Ac[32];
            const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
            if(_Ac[0] == '\0')
            {
                _State = ios_base::failbit;
                _Val = 0;
            }
            else
            {
                char* _Ep;
                int _Errno;
                _Val = ::_Stoulx(_Ac, &_Ep, _Base, &_Errno);
                if(_Ep == _Ac || _Errno != 0)
                {
                    _State = ios_base::failbit;
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, long long& _Val) const
        {
            _Adl_verify_range(_First, _Last);
            char _Ac[32];
            const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
            if(_Ac[0] == '\0')
            {
                _State = ios_base::failbit;
                _Val = 0;
            }
            else
            {
                char* _Ep;
                int _Errno;
                _Val = ::_Stollx(_Ac, &_Ep, _Base, &_Errno);
                if(_Ep == _Ac || _Errno != 0)
                {
                    _State = ios_base::failbit;
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, unsigned long long& _Val) const
        {
            _Adl_verify_range(_First, _Last);
            char _Ac[32];
            const int _Base = _Getifld(_Ac, _First, _Last, _Iosbase.flags(), _Iosbase.getloc());
            if(_Ac[0] == '\0')
            {
                _State = ios_base::failbit;
                _Val = 0;
            }
            else
            {
                int _Errno;
                char* _Ep;
                _Val = ::_Stoullx(_Ac, &_Ep, _Base, &_Errno);
                if(_Ep == _Ac || _Errno != 0)
                {
                    _State = ios_base::failbit;
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, float& _Val) const
        {
            _Adl_verify_range(_First, _Last);
            char _Ac[(8 + 768 + 16)];
            int _Hexexp = 1000000000;
            const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp);
            if(_Ac[0] == '\0')
            {
                _State = ios_base::failbit;
                _Val = 0.0f;
            }
            else
            {
                int _Errno;
                char* _Ep;
                _Val = _Stofx_v2(_Ac, &_Ep, _Base, &_Errno);
                if(_Ep == _Ac || _Errno != 0)
                {
                    _State = ios_base::failbit;
                    _Val = 0.0f;
                }
                else if(_Hexexp != 1000000000 && _Hexexp != 0)
                {
                    _Val = ::ldexpf(_Val, 4 * _Hexexp);
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, double& _Val) const
        {
            _Adl_verify_range(_First, _Last);
            char _Ac[(8 + 768 + 16)];
            int _Hexexp = 1000000000;
            const int _Base = _Getffld(_Ac, _First, _Last, _Iosbase, &_Hexexp);
            if(_Ac[0] == '\0')
            {
                _State = ios_base::failbit;
                _Val = 0.0;
            }
            else
            {
                int _Errno;
                char* _Ep;
                _Val = _Stodx_v2(_Ac, &_Ep, _Base, &_Errno);
                if(_Ep == _Ac || _Errno != 0)
                {
                    _State = ios_base::failbit;
                    _Val = 0.0;
                }
                else if(_Hexexp != 1000000000 && _Hexexp != 0)
                {
                    _Val = ::ldexp(_Val, 4 * _Hexexp);
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, long double& _Val) const
        {
            static_assert(sizeof(double) == sizeof(long double),
                          "Bad assumption: sizeof(double) == sizeof(long double).");
            double _Result;
            _First = num_get::do_get(_First, _Last, _Iosbase, _State, _Result);
            _Val = _Result;
            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, void*& _Val) const
        {
            _Adl_verify_range(_First, _Last);
            char _Ac[32];
            const int _Base = _Getifld(_Ac, _First, _Last, ios_base::hex, _Iosbase.getloc());
            if(_Ac[0] == '\0')
            {
                _State = ios_base::failbit;
                _Val = nullptr;
            }
            else
            {
                int _Errno;
                char* _Ep;

                _Val = reinterpret_cast<void*>(::_Stoullx(_Ac, &_Ep, _Base, &_Errno));

                if(_Ep == _Ac || _Errno != 0)
                {
                    _State = ios_base::failbit;
                    _Val = nullptr;
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

    private:
        int __cdecl _Getifld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base::fmtflags _Basefield, const locale& _Loc) const
        {
            const auto& _Punct_fac = ::std::use_facet<numpunct<_Elem>>(_Loc);
            const string _Grouping = _Punct_fac.grouping();
            const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Punct_fac.thousands_sep();

            constexpr int _Numget_signoff = 22;
            constexpr int _Numget_xoff = 24;
            static constexpr char _Src[] = "0123456789ABCDEFabcdef-+Xx";
            _Elem _Atoms[sizeof(_Src)];
            const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Loc);
            _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);

            char* _Ptr = _Ac;

            if(_First != _Last)
            {
                if(*_First == _Atoms[_Numget_signoff + 1])
                {
                    *_Ptr++ = '+';
                    ++_First;
                }
                else if(*_First == _Atoms[_Numget_signoff])
                {
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            _Basefield &= ios_base::basefield;

            int _Base;
            if(_Basefield == ios_base::oct)
            {
                _Base = 8;
            }
            else if(_Basefield == ios_base::hex)
            {
                _Base = 16;
            }
            else if(_Basefield == ios_base::_Fmtzero)
            {
                _Base = 0;
            }
            else
            {
                _Base = 10;
            }

            bool _Seendigit = false;
            bool _Nonzero = false;

            if(_First != _Last && *_First == _Atoms[0])
            {
                _Seendigit = true;
                ++_First;
                if(_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff])
                   && (_Base == 0 || _Base == 16))
                {
                    _Base = 16;
                    _Seendigit = false;
                    ++_First;
                }
                else if(_Base == 0)
                {
                    _Base = 8;
                }
            }

            const auto _Dlen = static_cast<size_t>(_Base == 0 || _Base == 10 ? 10 : _Base == 8 ? 8 : 16 + 6);
            string _Groups(1, static_cast<char>(_Seendigit));
            size_t _Group = 0;

            for(char* const _Pe = &_Ac[32 - 1]; _First != _Last; ++_First)
            {
                size_t _Idx = _Find_elem(_Atoms, *_First);
                if(_Idx < _Dlen)
                {
                    *_Ptr = _Src[_Idx];
                    if((_Nonzero || *_Ptr != '0') && _Ptr < _Pe)
                    {
                        ++_Ptr;
                        _Nonzero = true;
                    }

                    _Seendigit = true;
                    if(_Groups[_Group] != 127)
                    {
                        ++_Groups[_Group];
                    }
                }
                else if(_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator)
                {
                    break;
                }
                else
                {
                    _Groups.push_back('\0');
                    ++_Group;
                }
            }

            if(_Group != 0)
            {
                if('\0' < _Groups[_Group])
                {
                    ++_Group;
                }
                else
                {
                    _Seendigit = false;
                }
            }

            for(const char* _Pg = &_Grouping[0]; _Seendigit && 0 < _Group;)
            {
                if(*_Pg == 127)
                {
                    break;
                }
                else if((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group]))
                {
                    _Seendigit = false;
                }
                else if('\0' < _Pg[1])
                {
                    ++_Pg;
                }
            }

            if(_Seendigit && !_Nonzero)
            {
                *_Ptr++ = '0';
            }
            else if(!_Seendigit)
            {
                _Ptr = _Ac;
            }

            *_Ptr = '\0';
            return _Base;
        }

        int __cdecl _Getffld(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase, int* _Phexexp) const
        {
            if((_Iosbase.flags() & ios_base::floatfield) == ios_base::hexfloat)
            {
                return _Getffldx(_Ac, _First, _Last, _Iosbase, _Phexexp);
            }

            const auto& _Punct_fac = ::std::use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            const string _Grouping = _Punct_fac.grouping();
            char* _Ptr = _Ac;
            bool _Bad = false;
            bool _Sticky = false;

            constexpr int _Numget_signoff = 10;
            constexpr int _Numget_eoff = 12;
            static constexpr char _Src[] = "0123456789-+Ee";
            _Elem _Atoms[sizeof(_Src)];
            const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Iosbase.getloc());
            _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);

            if(_First != _Last)
            {
                if(*_First == _Atoms[_Numget_signoff + 1])
                {
                    *_Ptr++ = '+';
                    ++_First;
                }
                else if(*_First == _Atoms[_Numget_signoff])
                {
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            char* _Leading = _Ptr;
            *_Ptr++ = '0';

            bool _Seendigit = false;
            int _Significant = 0;
            int _Pten = 0;
            size_t _Idx;

            const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

            const char* _Pg = &_Grouping[0];
            if(*_Pg == 127 || *_Pg <= '\0')
            {
                for(; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void)++_First)
                {
                    if(_Max_sig_dig <= _Significant)
                    {
                        ++_Pten;
                        if(0 < _Idx)
                        {
                            _Sticky = true;
                        }
                    }
                    else if(_Idx != 0 || _Significant != 0)
                    {
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }
                }
            }
            else
            {
                const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Punct_fac.thousands_sep();
                string _Groups(1, '\0');
                size_t _Group = 0;

                for(; _First != _Last; ++_First)
                {
                    if((_Idx = _Find_elem(_Atoms, *_First)) < 10)
                    {
                        _Seendigit = true;
                        if(_Max_sig_dig <= _Significant)
                        {
                            ++_Pten;
                            if(0 < _Idx)
                            {
                                _Sticky = true;
                            }
                        }
                        else if(_Idx != 0 || _Significant != 0)
                        {
                            *_Ptr++ = _Src[_Idx];
                            ++_Significant;
                        }

                        if(_Groups[_Group] != 127)
                        {
                            ++_Groups[_Group];
                        }
                    }
                    else if(_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator)
                    {
                        break;
                    }
                    else
                    {
                        _Groups.push_back('\0');
                        ++_Group;
                    }
                }

                if(_Group != 0)
                {
                    if('\0' < _Groups[_Group])
                    {
                        ++_Group;
                    }
                    else
                    {
                        _Bad = true;
                    }
                }

                while(!_Bad && 0 < _Group)
                {
                    if(*_Pg == 127)
                    {
                        break;
                    }

                    if((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group]))
                    {
                        _Bad = true;
                    }
                    else if('\0' < _Pg[1])
                    {
                        ++_Pg;
                    }
                }
            }

            if(_First != _Last && *_First == _Punct_fac.decimal_point())
            {
                *_Ptr++ = localeconv()->decimal_point[0];
                ++_First;
            }

            if(*_Phexexp != 1000000000 && _Significant == 0)
            {
                for(; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void)++_First)
                {
                    --_Pten;
                }

                if(_Pten < 0)
                {
                    *_Ptr++ = '0';
                    ++_Pten;
                }
            }

            for(; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void)++_First)
            {
                if(_Significant < _Max_sig_dig)
                {
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
                else if(0 < _Idx)
                {
                    _Sticky = true;
                }
            }

            if(_Sticky)
            {
                char* _Px = _Ptr;
                while(--_Px != _Leading)
                {
                    if(*_Px != localeconv()->decimal_point[0])
                    {
                        if(*_Px != '9')
                        {
                            ++*_Px;
                            break;
                        }

                        *_Px = '0';
                    }
                }

                if(_Px == _Leading)
                {
                    *_Px = '1';
                    ++_Pten;
                }
            }

            if(_Seendigit && _First != _Last && (*_First == _Atoms[_Numget_eoff + 1] || *_First == _Atoms[_Numget_eoff]))
            {
                *_Ptr++ = 'e';
                ++_First;
                _Seendigit = false;
                _Significant = 0;

                if(_First != _Last)
                {
                    if(*_First == _Atoms[_Numget_signoff + 1])
                    {
                        *_Ptr++ = '+';
                        ++_First;
                    }
                    else if(*_First == _Atoms[_Numget_signoff])
                    {
                        *_Ptr++ = '-';
                        ++_First;
                    }
                }

                for(; _First != _Last && *_First == _Atoms[0]; ++_First)
                {
                    _Seendigit = true;
                }

                if(_Seendigit)
                {
                    *_Ptr++ = '0';
                }

                for(; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; _Seendigit = true, (void)++_First)
                {
                    if(_Significant < 8)
                    {
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }
                }
            }

            if(_Bad || !_Seendigit)
            {
                _Ptr = _Ac;
            }

            *_Ptr = '\0';
            return _Pten;
        }

        int __cdecl _Getffldx(char* _Ac, _InIt& _First, _InIt& _Last, ios_base& _Iosbase, int* _Phexexp) const
        {
            const auto& _Punct_fac = ::std::use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            const string _Grouping = _Punct_fac.grouping();

            constexpr int _Numget_signoff = 22;
            constexpr int _Numget_xoff = 24;
            constexpr int _Numget_poff = 26;
            static constexpr char _Src[] = "0123456789ABCDEFabcdef-+XxPp";
            _Elem _Atoms[sizeof(_Src)];
            const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Iosbase.getloc());
            _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);

            char* _Ptr = _Ac;
            bool _Bad = false;
            size_t _Idx;

            if(_First != _Last)
            {
                if(*_First == _Atoms[_Numget_signoff + 1])
                {
                    *_Ptr++ = '+';
                    ++_First;
                }
                else if(*_First == _Atoms[_Numget_signoff])
                {
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            *_Ptr++ = '0';
            *_Ptr++ = 'x';

            bool _Seendigit = false;
            int _Significant = 0;
            int _Phex = 0;

            if(_First != _Last && *_First == _Atoms[0])
            {
                if(++_First != _Last && (*_First == _Atoms[_Numget_xoff + 1] || *_First == _Atoms[_Numget_xoff]))
                {
                    ++_First;
                }
                else
                {
                    _Seendigit = true;
                }
            }

            const int _Max_sig_dig = (*_Phexexp == 1000000000 ? 768 : 36);

            const char* _Pg = &_Grouping[0];
            if(*_Pg == 127 || *_Pg <= '\0')
            {
                for(; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff; _Seendigit = true, (void)++_First)
                {
                    if(_Max_sig_dig <= _Significant)
                    {
                        ++_Phex;
                    }
                    else if(_Idx != 0 || _Significant != 0)
                    {
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }
                }
            }
            else
            {
                const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Punct_fac.thousands_sep();
                string _Groups(1, '\0');
                size_t _Group = 0;

                for(; _First != _Last; ++_First)
                {
                    if((_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff)
                    {
                        _Seendigit = true;
                        if(_Max_sig_dig <= _Significant)
                        {
                            ++_Phex;
                        }
                        else if(_Idx != 0 || _Significant != 0)
                        {
                            *_Ptr++ = _Src[_Idx];
                            ++_Significant;
                        }

                        if(_Groups[_Group] != 127)
                        {
                            ++_Groups[_Group];
                        }
                    }
                    else if(_Groups[_Group] == '\0' || _Kseparator == _Elem{} || *_First != _Kseparator)
                    {
                        break;
                    }
                    else
                    {
                        _Groups.push_back('\0');
                        ++_Group;
                    }
                }

                if(_Group != 0)
                {
                    if('\0' < _Groups[_Group])
                    {
                        ++_Group;
                    }
                    else
                    {
                        _Bad = true;
                    }
                }

                while(!_Bad && 0 < _Group)
                {
                    if(*_Pg == 127)
                    {
                        break;
                    }

                    if((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group]))
                    {
                        _Bad = true;
                    }
                    else if('\0' < _Pg[1])
                    {
                        ++_Pg;
                    }
                }
            }

            if(_Seendigit && _Significant == 0)
            {
                *_Ptr++ = '0';
            }

            if(_First != _Last && *_First == _Punct_fac.decimal_point())
            {
                *_Ptr++ = localeconv()->decimal_point[0];
                ++_First;
            }

            if(_Significant == 0)
            {
                for(; _First != _Last && *_First == _Atoms[0]; _Seendigit = true, (void)++_First)
                {
                    --_Phex;
                }

                if(_Phex < 0)
                {
                    *_Ptr++ = '0';
                    ++_Phex;
                }
            }

            for(; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff; _Seendigit = true, (void)++_First)
            {
                if(_Significant < _Max_sig_dig)
                {
                    *_Ptr++ = _Src[_Idx];
                    ++_Significant;
                }
            }

            if(_Seendigit && _First != _Last && (*_First == _Atoms[_Numget_poff + 1] || *_First == _Atoms[_Numget_poff]))
            {
                *_Ptr++ = 'p';
                ++_First;
                _Seendigit = false;
                _Significant = 0;

                if(_First != _Last)
                {
                    if(*_First == _Atoms[_Numget_signoff + 1])
                    {
                        *_Ptr++ = '+';
                        ++_First;
                    }
                    else if(*_First == _Atoms[_Numget_signoff])
                    {
                        *_Ptr++ = '-';
                        ++_First;
                    }
                }

                for(; _First != _Last && *_First == _Atoms[0]; ++_First)
                {
                    _Seendigit = true;
                }

                if(_Seendigit)
                {
                    *_Ptr++ = '0';
                }

                for(; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < _Numget_signoff; _Seendigit = true, (void)++_First)
                {
                    if(_Significant < 8)
                    {
                        *_Ptr++ = _Src[_Idx];
                        ++_Significant;
                    }
                }
            }

            if(_Bad || !_Seendigit)
            {
                _Ptr = _Ac;
            }

            *_Ptr = '\0';
            *_Phexexp = _Phex;
            return 0;
        }
    };

    template <class _Elem, class _InIt> locale::id num_get<_Elem, _InIt>::id;

    template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
    class num_put : public locale::facet
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new num_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));
            }

            return 4;
        }

        static locale::id id;

    protected:
        virtual ~num_put() noexcept
        {
        }

        void _Init(const _Locinfo&)
        {
        }

    public:
        explicit num_put(size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        num_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs)
        {
            _Init(_Lobj);
        }

        using char_type = _Elem;
        using iter_type = _OutIt;

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Val);
        }

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Val);
        }

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Val);
        }

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Val);
        }

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Val);
        }

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Val);
        }

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Val);
        }

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Val);
        }

    protected:
        virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, bool _Val) const
        {
            if(!(_Iosbase.flags() & ios_base::boolalpha))
            {
                return do_put(_Dest, _Iosbase, _Fill, static_cast<long>(_Val));
            }
            else
            {
                const auto& _Punct_fac = ::std::use_facet<numpunct<_Elem>>(_Iosbase.getloc());
                basic_string<_Elem> _Str;
                if(_Val)
                {
                    _Str.assign(_Punct_fac.truename());
                }
                else
                {
                    _Str.assign(_Punct_fac.falsename());
                }

                size_t _Fillcount;
                if(_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Str.size())
                {
                    _Fillcount = 0;
                }
                else
                {
                    _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Str.size();
                }

                if((_Iosbase.flags() & ios_base::adjustfield) != ios_base::left)
                {
                    _Dest = _Rep(_Dest, _Fill, _Fillcount);
                    _Fillcount = 0;
                }
                _Dest = _Put(_Dest, _Str.c_str(), _Str.size());
                _Iosbase.width(0);
                return _Rep(_Dest, _Fill, _Fillcount);
            }
        }

#pragma warning(push)
#pragma warning(disable : 4774)
        virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long _Val) const
        {
            char _Buf[2 * 32], _Fmt[6];

            return _Iput(_Dest, _Iosbase, _Fill, _Buf,
                         static_cast<size_t>(::sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "ld", _Iosbase.flags()), _Val)));
        }

        virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, unsigned long _Val) const
        {
            char _Buf[2 * 32], _Fmt[6];

            return _Iput(_Dest, _Iosbase, _Fill, _Buf,
                         static_cast<size_t>(::sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "lu", _Iosbase.flags()), _Val)));
        }

        virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long long _Val) const
        {
            char _Buf[2 * 32], _Fmt[8];

            return _Iput(_Dest, _Iosbase, _Fill, _Buf,
                         static_cast<size_t>(::sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Ld", _Iosbase.flags()), _Val)));
        }

        virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, unsigned long long _Val) const
        {
            char _Buf[2 * 32], _Fmt[8];

            return _Iput(_Dest, _Iosbase, _Fill, _Buf,
                         static_cast<size_t>(::sprintf_s(_Buf, sizeof(_Buf), _Ifmt(_Fmt, "Lu", _Iosbase.flags()), _Val)));
        }

        virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, double _Val) const
        {
            string _Buf;
            char _Fmt[8];
            bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;
            streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision();
            size_t _Bufsize = static_cast<size_t>(_Precision);
            if(_Isfixed && 1e10 < ::fabs(_Val))
            {
                int _Ptwo;
                (void)::frexp(_Val, &_Ptwo);
                _Bufsize += ::abs(_Ptwo) * 30103L / 100000L;
            }

            _Buf.resize(_Bufsize + 50);
            const auto _Ngen = static_cast<size_t>(
            ::sprintf_s(&_Buf[0], _Buf.size(), _Ffmt(_Fmt, 0, _Iosbase.flags()), static_cast<int>(_Precision), _Val));

            return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
        }

        virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, long double _Val) const
        {
            string _Buf;
            char _Fmt[8];
            bool _Isfixed = (_Iosbase.flags() & ios_base::floatfield) == ios_base::fixed;
            streamsize _Precision = _Iosbase.precision() <= 0 && !_Isfixed ? 6 : _Iosbase.precision();
            size_t _Bufsize = static_cast<size_t>(_Precision);
            if(_Isfixed && 1e10 < ::fabsl(_Val))
            {
                int _Ptwo;
                (void)::frexpl(_Val, &_Ptwo);
                _Bufsize += ::abs(_Ptwo) * 30103L / 100000L;
            }

            _Buf.resize(_Bufsize + 50);
            const auto _Ngen = static_cast<size_t>(
            ::sprintf_s(&_Buf[0], _Buf.size(), _Ffmt(_Fmt, 'L', _Iosbase.flags()), static_cast<int>(_Precision), _Val));

            return _Fput(_Dest, _Iosbase, _Fill, _Buf.c_str(), _Ngen);
        }
#pragma warning(pop)

        virtual _OutIt do_put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const void* _Val) const
        {
            char _Buf[2 * 32];

            return _Iput(_Dest, _Iosbase, _Fill, _Buf, static_cast<size_t>(::sprintf_s(_Buf, sizeof(_Buf), "%p", _Val)));
        }

    private:
        char* __cdecl _Ffmt(char* _Fmt, char _Spec, ios_base::fmtflags _Flags) const
        {
            char* _Ptr = _Fmt;
            *_Ptr++ = '%';

            if(_Flags & ios_base::showpos)
            {
                *_Ptr++ = '+';
            }

            if(_Flags & ios_base::showpoint)
            {
                *_Ptr++ = '#';
            }

            *_Ptr++ = '.';
            *_Ptr++ = '*';
            if(_Spec != '\0')
            {
                *_Ptr++ = _Spec;
            }

            char _Ch;
            ios_base::fmtflags _Ffl = _Flags & ios_base::floatfield;
            if(_Flags & ios_base::uppercase)
            {
                if(_Ffl == ios_base::fixed)
                {
                    _Ch = 'f';
                }
                else if(_Ffl == ios_base::hexfloat)
                {
                    _Ch = 'A';
                }
                else if(_Ffl == ios_base::scientific)
                {
                    _Ch = 'E';
                }
                else
                {
                    _Ch = 'G';
                }
            }
            else
            {
                if(_Ffl == ios_base::fixed)
                {
                    _Ch = 'f';
                }
                else if(_Ffl == ios_base::hexfloat)
                {
                    _Ch = 'a';
                }
                else if(_Ffl == ios_base::scientific)
                {
                    _Ch = 'e';
                }
                else
                {
                    _Ch = 'g';
                }
            }
            *_Ptr++ = _Ch;

            *_Ptr = '\0';
            return _Fmt;
        }

        _OutIt __cdecl _Fput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const char* _Buf, size_t _Count) const
        {
            auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
            const char* _Exps;
            if((_Iosbase.flags() & ios_base::floatfield) != ios_base::hexfloat)
            {
                _Exps = "eE";
            }
            else
            {
                _Exps = "pP";
                if(_Prefix + 2 <= _Count && _Buf[_Prefix] == '0' && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
                {
                    _Prefix += 2;
                }
            }
            const size_t _Eoff = ::strcspn(&_Buf[0], _Exps);
            char _Dp[2] = { "." };
            _Dp[0] = ::localeconv()->decimal_point[0];
            const size_t _Poff = ::strcspn(&_Buf[0], &_Dp[0]);

            const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Groupstring(_Count, _Elem(0));
            _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

            const auto& _Punct_fac = ::std::use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            const string _Grouping = _Punct_fac.grouping();
            const _Elem _Kseparator = _Punct_fac.thousands_sep();

            if(_Poff != _Count)
            {
                _Groupstring[_Poff] = _Punct_fac.decimal_point();
            }

            size_t _Off = _Poff == _Count ? _Eoff : _Poff;
            const char* _Pg = &_Grouping[0];
            while(*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off - _Prefix)
            {
                _Groupstring.insert(_Off -= *_Pg, 1, _Kseparator);
                if('\0' < _Pg[1])
                {
                    ++_Pg;
                }
            }

            _Count = _Groupstring.size();

            size_t _Fillcount;
            if(_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count)
            {
                _Fillcount = 0;
            }
            else
            {
                _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
            }

            ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
            if(_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal)
            {
                _Dest = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
                _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
            }
            else if(_Adjustfield == ios_base::internal)
            {
                _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
                _Dest = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
            }
            else
            {
                _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
            }

            _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
            _Iosbase.width(0);
            return _Rep(_Dest, _Fill, _Fillcount);
        }

        char* __cdecl _Ifmt(char* _Fmt, const char* _Spec, ios_base::fmtflags _Flags) const
        {
            char* _Ptr = _Fmt;
            *_Ptr++ = '%';

            if(_Flags & ios_base::showpos)
            {
                *_Ptr++ = '+';
            }

            if(_Flags & ios_base::showbase)
            {
                *_Ptr++ = '#';
            }

            if(_Spec[0] != 'L')
            {
                *_Ptr++ = _Spec[0];
            }
            else
            {
                *_Ptr++ = 'I';
                *_Ptr++ = '6';
                *_Ptr++ = '4';
            }

            ios_base::fmtflags _Basefield = _Flags & ios_base::basefield;
            *_Ptr++ = _Basefield == ios_base::oct ?
                      'o' :
                      _Basefield != ios_base::hex ? _Spec[1] : _Flags & ios_base::uppercase ? 'X' : 'x';
            *_Ptr = '\0';
            return _Fmt;
        }

        _OutIt __cdecl _Iput(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, char* _Buf, size_t _Count) const
        {
            auto _Prefix = static_cast<size_t>(0 < _Count && (*_Buf == '+' || *_Buf == '-'));
            if((_Iosbase.flags() & ios_base::basefield) == ios_base::hex && _Prefix + 2 <= _Count
               && _Buf[_Prefix] == '0' && (_Buf[_Prefix + 1] == 'x' || _Buf[_Prefix + 1] == 'X'))
            {
                _Prefix += 2;
            }

            const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Iosbase.getloc());
            basic_string<_Elem> _Groupstring(_Count, _Elem(0));
            _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Groupstring[0]);

            const auto& _Punct_fac = ::std::use_facet<numpunct<_Elem>>(_Iosbase.getloc());
            const string _Grouping = _Punct_fac.grouping();
            const char* _Pg = &_Grouping[0];
            if(*_Pg != 127 && '\0' < *_Pg)
            {
                const _Elem _Kseparator = _Punct_fac.thousands_sep();
                while(*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Count - _Prefix)
                {
                    _Count -= *_Pg;
                    _Groupstring.insert(_Count, 1, _Kseparator);
                    if('\0' < _Pg[1])
                    {
                        ++_Pg;
                    }
                }
            }

            _Count = _Groupstring.size();

            size_t _Fillcount;
            if(_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Count)
            {
                _Fillcount = 0;
            }
            else
            {
                _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Count;
            }

            ios_base::fmtflags _Adjustfield = _Iosbase.flags() & ios_base::adjustfield;
            if(_Adjustfield != ios_base::left && _Adjustfield != ios_base::internal)
            {
                _Dest = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
                _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
            }
            else if(_Adjustfield == ios_base::internal)
            {
                _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
                _Dest = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
            }
            else
            {
                _Dest = _Put(_Dest, &_Groupstring[0], _Prefix);
            }

            _Dest = _Put(_Dest, &_Groupstring[_Prefix], _Count - _Prefix);
            _Iosbase.width(0);
            return _Rep(_Dest, _Fill, _Fillcount);
        }

        _OutIt __cdecl _Put(_OutIt _Dest, const _Elem* _Ptr, size_t _Count) const
        {
            for(; 0 < _Count; --_Count, (void)++_Dest, ++_Ptr)
            {
                *_Dest = *_Ptr;
            }

            return _Dest;
        }

        _OutIt __cdecl _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count) const
        {
            for(; 0 < _Count; --_Count, (void)++_Dest)
            {
                *_Dest = _Ch;
            }

            return _Dest;
        }
    };

    template <class _Elem, class _OutIt> locale::id num_put<_Elem, _OutIt>::id;

    template locale::id numpunct<char>::id;
    template class __declspec(dllimport) num_get<char, istreambuf_iterator<char, char_traits<char>>>;
    template class __declspec(dllimport) num_put<char, ostreambuf_iterator<char, char_traits<char>>>;

    template locale::id numpunct<wchar_t>::id;
    template class __declspec(dllimport) num_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
    template class __declspec(dllimport) num_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>;

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Elem, class _Traits> class basic_ios : public ios_base
    {
    public:
        using _Myos = basic_ostream<_Elem, _Traits>;
        using _Mysb = basic_streambuf<_Elem, _Traits>;
        using _Ctype = ctype<_Elem>;
        using char_type = _Elem;
        using traits_type = _Traits;
        using int_type = typename _Traits::int_type;
        using pos_type = typename _Traits::pos_type;
        using off_type = typename _Traits::off_type;

        explicit basic_ios(_Mysb* _Strbuf)
        {
            init(_Strbuf);
        }

        virtual ~basic_ios() noexcept
        {
        }

        void clear(iostate _State = goodbit, bool _Reraise = false)
        {
            ios_base::clear(_State | (_Mystrbuf ? ios_base::_Iostate{} : ios_base::badbit), _Reraise);
        }

        void clear(io_state _State)
        {
            clear(static_cast<iostate>(_State));
        }

        void setstate(iostate _State, bool _Reraise = false)
        {
            clear(rdstate() | _State, _Reraise);
        }

        void setstate(io_state _State)
        {
            setstate(static_cast<iostate>(_State));
        }

        basic_ios& copyfmt(const basic_ios& _Right)
        {
            _Tiestr = _Right.tie();
            _Fillch = _Right.fill();
            ios_base::copyfmt(_Right);
            return *this;
        }

        _Myos* tie() const
        {
            return _Tiestr;
        }

        _Myos* tie(_Myos* _Newtie)
        {
            _Myos* _Oldtie = _Tiestr;
            _Tiestr = _Newtie;
            return _Oldtie;
        }

        [[nodiscard]] _Mysb* rdbuf() const
        {
            return _Mystrbuf;
        }

        _Mysb* rdbuf(_Mysb* _Strbuf)
        {
            _Mysb* _Oldstrbuf = _Mystrbuf;
            _Mystrbuf = _Strbuf;
            clear();
            return _Oldstrbuf;
        }

        locale imbue(const locale& _Loc)
        {
            locale _Oldlocale = ios_base::imbue(_Loc);
            const auto _Rdbuf = rdbuf();
            if(_Rdbuf)
            {
                _Rdbuf->pubimbue(_Loc);
            }

            return _Oldlocale;
        }

        _Elem fill() const
        {
            return _Fillch;
        }

        _Elem fill(_Elem _Newfill)
        {
            _Elem _Oldfill = _Fillch;
            _Fillch = _Newfill;
            return _Oldfill;
        }

        char narrow(_Elem _Ch, char _Dflt = '\0') const
        {
            return ::std::use_facet<_Ctype>(getloc()).narrow(_Ch, _Dflt);
        }

        _Elem widen(char _Byte) const
        {
            return ::std::use_facet<_Ctype>(getloc()).widen(_Byte);
        }

        void move(basic_ios& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Mystrbuf = nullptr;
                _Tiestr = nullptr;
                this->swap(_Right);
            }
        }

        void move(basic_ios&& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Mystrbuf = nullptr;
                _Tiestr = nullptr;
                this->swap(_Right);
            }
        }

        void swap(basic_ios& _Right) noexcept
        {
            ios_base::swap(_Right);
            ::std::swap(_Fillch, _Right._Fillch);
            ::std::swap(_Tiestr, _Right._Tiestr);
        }

        void set_rdbuf(_Mysb* _Strbuf)
        {
            _Mystrbuf = _Strbuf;
        }

    protected:
        void init(_Mysb* _Strbuf = nullptr, bool _Isstd = false)
        {
            _Init();
            _Mystrbuf = _Strbuf;
            _Tiestr = nullptr;
            _Fillch = widen(' ');

            if(!_Mystrbuf)
            {
                setstate(badbit);
            }

            if(_Isstd)
            {
                _Addstd(this);
            }
        }

        basic_ios()
        {
        }

    private:
        _Mysb* _Mystrbuf;
        _Myos* _Tiestr;
        _Elem _Fillch;

    public:
        basic_ios(const basic_ios&) = delete;
        basic_ios& operator=(const basic_ios&) = delete;
    };

    template class __declspec(dllimport) basic_ios<char, char_traits<char>>;
    template class __declspec(dllimport) basic_ios<wchar_t, char_traits<wchar_t>>;

    inline ios_base& __cdecl boolalpha(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::boolalpha);
        return _Iosbase;
    }

    inline ios_base& __cdecl dec(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::dec, ios_base::basefield);
        return _Iosbase;
    }

    inline ios_base& __cdecl defaultfloat(ios_base& _Iosbase)
    {
        _Iosbase.unsetf(ios_base::floatfield);
        return _Iosbase;
    }

    inline ios_base& __cdecl fixed(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::fixed, ios_base::floatfield);
        return _Iosbase;
    }

    inline ios_base& __cdecl hex(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::hex, ios_base::basefield);
        return _Iosbase;
    }

    inline ios_base& __cdecl hexfloat(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::hexfloat, ios_base::floatfield);
        return _Iosbase;
    }

    inline ios_base& __cdecl internal(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::internal, ios_base::adjustfield);
        return _Iosbase;
    }

    inline ios_base& __cdecl left(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::left, ios_base::adjustfield);
        return _Iosbase;
    }

    inline ios_base& __cdecl noboolalpha(ios_base& _Iosbase)
    {
        _Iosbase.unsetf(ios_base::boolalpha);
        return _Iosbase;
    }

    inline ios_base& __cdecl noshowbase(ios_base& _Iosbase)
    {
        _Iosbase.unsetf(ios_base::showbase);
        return _Iosbase;
    }

    inline ios_base& __cdecl noshowpoint(ios_base& _Iosbase)
    {
        _Iosbase.unsetf(ios_base::showpoint);
        return _Iosbase;
    }

    inline ios_base& __cdecl noshowpos(ios_base& _Iosbase)
    {
        _Iosbase.unsetf(ios_base::showpos);
        return _Iosbase;
    }

    inline ios_base& __cdecl noskipws(ios_base& _Iosbase)
    {
        _Iosbase.unsetf(ios_base::skipws);
        return _Iosbase;
    }

    inline ios_base& __cdecl nounitbuf(ios_base& _Iosbase)
    {
        _Iosbase.unsetf(ios_base::unitbuf);
        return _Iosbase;
    }

    inline ios_base& __cdecl nouppercase(ios_base& _Iosbase)
    {
        _Iosbase.unsetf(ios_base::uppercase);
        return _Iosbase;
    }

    inline ios_base& __cdecl oct(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::oct, ios_base::basefield);
        return _Iosbase;
    }

    inline ios_base& __cdecl right(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::right, ios_base::adjustfield);
        return _Iosbase;
    }

    inline ios_base& __cdecl scientific(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::scientific, ios_base::floatfield);
        return _Iosbase;
    }

    inline ios_base& __cdecl showbase(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::showbase);
        return _Iosbase;
    }

    inline ios_base& __cdecl showpoint(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::showpoint);
        return _Iosbase;
    }

    inline ios_base& __cdecl showpos(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::showpos);
        return _Iosbase;
    }

    inline ios_base& __cdecl skipws(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::skipws);
        return _Iosbase;
    }

    inline ios_base& __cdecl unitbuf(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::unitbuf);
        return _Iosbase;
    }

    inline ios_base& __cdecl uppercase(ios_base& _Iosbase)
    {
        _Iosbase.setf(ios_base::uppercase);
        return _Iosbase;
    }

    namespace [[deprecated(
    "warning STL4002: "
    "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
    "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1
    {
        using ::std::hexfloat;
    }

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
#pragma vtordisp(push, 2)

    template <class _Elem, class _Traits> class basic_ostream : virtual public basic_ios<_Elem, _Traits>
    {
    public:
        using _Myios = basic_ios<_Elem, _Traits>;
        using _Mysb = basic_streambuf<_Elem, _Traits>;
        using _Iter = ostreambuf_iterator<_Elem, _Traits>;
        using _Nput = num_put<_Elem, _Iter>;

        explicit basic_ostream(basic_streambuf<_Elem, _Traits>* _Strbuf, bool _Isstd = false)
        {
            _Myios::init(_Strbuf, _Isstd);
        }

        basic_ostream(_Uninitialized, bool _Addit = true)
        {
            if(_Addit)
            {
                this->_Addstd(this);
            }
        }

    protected:
        basic_ostream(basic_ostream&& _Right)
        {
            _Myios::init();
            _Myios::move(::std::move(_Right));
        }

        basic_ostream& operator=(basic_ostream&& _Right)
        {
            this->swap(_Right);
            return *this;
        }

        void swap(basic_ostream& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Myios::swap(_Right);
            }
        }

    public:
        basic_ostream(const basic_ostream&) = delete;
        basic_ostream& operator=(const basic_ostream&) = delete;

        virtual ~basic_ostream() noexcept
        {
        }

        using int_type = typename _Traits::int_type;
        using pos_type = typename _Traits::pos_type;
        using off_type = typename _Traits::off_type;

        class _Sentry_base
        {
        public:
            _Sentry_base(basic_ostream& _Ostr) : _Myostr(_Ostr)
            {
                const auto _Rdbuf = _Myostr.rdbuf();
                if(_Rdbuf)
                {
                    _Rdbuf->_Lock();
                }
            }

            ~_Sentry_base() noexcept
            {
                const auto _Rdbuf = _Myostr.rdbuf();
                if(_Rdbuf)
                {
                    _Rdbuf->_Unlock();
                }
            }

            basic_ostream& _Myostr;

            _Sentry_base& operator=(const _Sentry_base&) = delete;
        };

        class sentry : public _Sentry_base
        {
        public:
            explicit sentry(basic_ostream& _Ostr) : _Sentry_base(_Ostr)
            {
                if(!_Ostr.good())
                {
                    _Ok = false;
                    return;
                }

                const auto _Tied = _Ostr.tie();
                if(!_Tied || _Tied == &_Ostr)
                {
                    _Ok = true;
                    return;
                }

                _Tied->flush();
                _Ok = _Ostr.good();
            }

            __pragma(warning(push)) __pragma(warning(disable : 4996)) ~sentry() noexcept
            {
                if(!::std::uncaught_exception())
                {
                    this->_Myostr._Osfx();
                }
            }
            __pragma(warning(pop))

            explicit
            operator bool() const
            {
                return _Ok;
            }

            sentry(const sentry&) = delete;
            sentry& operator=(const sentry&) = delete;

        private:
            bool _Ok;
        };

        bool opfx()
        {
            if(!this->good())
            {
                return false;
            }

            const auto _Tied = _Myios::tie();
            if(!_Tied || _Myios::tie() == this)
            {
                return true;
            }

            _Tied->flush();
            return this->good();
        }

        void osfx()
        {
            _Osfx();
        }

        void _Osfx()
        {
            try
            {
                if(this->good() && this->flags() & ios_base::unitbuf)
                {
                    if(_Myios::rdbuf()->pubsync() == -1)
                    {
                        _Myios::setstate(ios_base::badbit);
                    }
                }
            }
            catch(...)
            {
            }
        }

        basic_ostream& operator<<(basic_ostream&(__cdecl* _Pfn)(basic_ostream&))
        {
            return _Pfn(*this);
        }

        basic_ostream& operator<<(_Myios&(__cdecl* _Pfn)(_Myios&))
        {
            _Pfn(*this);
            return *this;
        }

        basic_ostream& operator<<(ios_base&(__cdecl* _Pfn)(ios_base&))
        {
            _Pfn(*this);
            return *this;
        }

        basic_ostream& operator<<(bool _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(short _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());
                ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

                long _Tmp;
                if(_Bfl == ios_base::oct || _Bfl == ios_base::hex)
                {
                    _Tmp = static_cast<long>(static_cast<unsigned short>(_Val));
                }
                else
                {
                    _Tmp = static_cast<long>(_Val);
                }

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(unsigned short _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val)).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(int _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());
                ios_base::fmtflags _Bfl = this->flags() & ios_base::basefield;

                long _Tmp;
                if(_Bfl == ios_base::oct || _Bfl == ios_base::hex)
                {
                    _Tmp = static_cast<long>(static_cast<unsigned int>(_Val));
                }
                else
                {
                    _Tmp = static_cast<long>(_Val);
                }

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Tmp).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(unsigned int _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<unsigned long>(_Val)).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(long _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(unsigned long _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(long long _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(unsigned long long _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(float _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), static_cast<double>(_Val)).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(double _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(long double _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(const void* _Val)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                const _Nput& _Nput_fac = ::std::use_facet<_Nput>(this->getloc());

                try
                {
                    if(_Nput_fac.put(_Iter(_Myios::rdbuf()), *this, _Myios::fill(), _Val).failed())
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& operator<<(_Mysb* _Strbuf)
        {
            ios_base::iostate _State = ios_base::goodbit;
            bool _Copied = false;
            const sentry _Ok(*this);

            if(_Ok && _Strbuf)
            {
                for(int_type _Meta = _Traits::eof();; _Copied = true)
                {
                    try
                    {
                        _Meta = _Traits::eq_int_type(_Traits::eof(), _Meta) ? _Strbuf->sgetc() : _Strbuf->snextc();
                    }
                    catch(...)
                    {
                        _Myios::setstate(ios_base::failbit);
                        throw;
                    }

                    if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                    {
                        break;
                    }

                    try
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Traits::to_char_type(_Meta))))
                        {
                            _State |= ios_base::badbit;
                            break;
                        }
                    }
                    catch(...)
                    {
                        _Myios::setstate(ios_base::badbit, true);
                    }
                }
            }

            this->width(0);
            int _Setstate_with;
            if(_Strbuf)
            {
                if(_Copied)
                {
                    _Setstate_with = _State;
                }
                else
                {
                    _Setstate_with = _State | ios_base::failbit;
                }
            }
            else
            {
                _Setstate_with = ios_base::badbit;
            }

            _Myios::setstate(_Setstate_with);
            return *this;
        }

        basic_ostream& put(_Elem _Ch)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(!_Ok)
            {
                _State |= ios_base::badbit;
            }
            else
            {
                try
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputc(_Ch)))
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& write(const _Elem* _Str, streamsize _Count)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const sentry _Ok(*this);

            if(!_Ok)
            {
                _State |= ios_base::badbit;
            }
            else if(0 < _Count)
            {
                try
                {
                    if(_Myios::rdbuf()->sputn(_Str, _Count) != _Count)
                    {
                        _State |= ios_base::badbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_ostream& flush()
        {
            const auto _Rdbuf = _Myios::rdbuf();
            if(_Rdbuf)
            {
                const sentry _Ok(*this);

                if(_Ok && _Rdbuf->pubsync() == -1)
                {
                    _Myios::setstate(ios_base::badbit);
                }
            }
            return *this;
        }

        basic_ostream& seekp(pos_type _Pos)
        {
            const sentry _Ok(*this);

            if(!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::out)) == -1)
            {
                _Myios::setstate(ios_base::failbit);
            }

            return *this;
        }

        basic_ostream& seekp(off_type _Off, ios_base::seekdir _Way)
        {
            const sentry _Ok(*this);

            if(!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::out)) == -1)
            {
                _Myios::setstate(ios_base::failbit);
            }

            return *this;
        }

        pos_type tellp()
        {
            const sentry _Ok(*this);

            if(!this->fail())
            {
                return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::out);
            }
            else
            {
                return pos_type(-1);
            }
        }
    };

#pragma vtordisp(pop)

    template class __declspec(dllimport) basic_ostream<char, char_traits<char>>;
    template class __declspec(dllimport) basic_ostream<wchar_t, char_traits<wchar_t>>;

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const char* _Val)
    {
        ios_base::iostate _State = ios_base::goodbit;
        streamsize _Count = static_cast<streamsize>(::strlen(_Val));
        streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
        const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

        if(!_Ok)
        {
            _State |= ios_base::badbit;
        }
        else
        {
            try
            {
                const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Ostr.getloc());
                if((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                            break;
                        }
                    }
                }

                for(; _State == ios_base::goodbit && 0 < _Count; --_Count, ++_Val)
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(*_Val))))
                    {
                        _State |= ios_base::badbit;
                    }
                }

                if(_State == ios_base::goodbit)
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                            break;
                        }
                    }
                }

                _Ostr.width(0);
            }
            catch(...)
            {
                (_Ostr).setstate(ios_base::badbit, true);
            }
        }

        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, char _Ch)
    {
        ios_base::iostate _State = ios_base::goodbit;
        const typename basic_ostream<_Elem, _Traits>::sentry _Ok(_Ostr);

        if(_Ok)
        {
            const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Ostr.getloc());
            streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

            try
            {
                if((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
                {
                    for(; _State == ios_base::goodbit && 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                        }
                    }
                }

                if(_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ctype_fac.widen(_Ch))))
                {
                    _State |= ios_base::badbit;
                }

                for(; _State == ios_base::goodbit && 0 < _Pad; --_Pad)
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                    {
                        _State |= ios_base::badbit;
                    }
                }
            }
            catch(...)
            {
                (_Ostr).setstate(ios_base::badbit, true);
            }
        }

        _Ostr.width(0);
        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Traits>
    basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const char* _Val)
    {
        using _Elem = char;
        using _Myos = basic_ostream<_Elem, _Traits>;

        ios_base::iostate _State = ios_base::goodbit;
        streamsize _Count = static_cast<streamsize>(_Traits::length(_Val));
        streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
        const typename _Myos::sentry _Ok(_Ostr);

        if(!_Ok)
        {
            _State |= ios_base::badbit;
        }
        else
        {
            try
            {
                if((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                            break;
                        }
                    }
                }

                if(_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
                {
                    _State |= ios_base::badbit;
                }

                if(_State == ios_base::goodbit)
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                            break;
                        }
                    }
                }

                _Ostr.width(0);
            }
            catch(...)
            {
                (_Ostr).setstate(ios_base::badbit, true);
            }
        }

        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Traits> basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, char _Ch)
    {
        using _Elem = char;
        using _Myos = basic_ostream<_Elem, _Traits>;

        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myos::sentry _Ok(_Ostr);

        if(_Ok)
        {
            streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

            try
            {
                if((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
                {
                    for(; _State == ios_base::goodbit && 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                        }
                    }
                }

                if(_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch)))
                {
                    _State |= ios_base::badbit;
                }

                for(; _State == ios_base::goodbit && 0 < _Pad; --_Pad)
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                    {
                        _State |= ios_base::badbit;
                    }
                }
            }
            catch(...)
            {
                (_Ostr).setstate(ios_base::badbit, true);
            }
        }

        _Ostr.width(0);
        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Elem* _Val)
    {
        using _Myos = basic_ostream<_Elem, _Traits>;

        ios_base::iostate _State = ios_base::goodbit;
        streamsize _Count = static_cast<streamsize>(_Traits::length(_Val));
        streamsize _Pad = _Ostr.width() <= 0 || _Ostr.width() <= _Count ? 0 : _Ostr.width() - _Count;
        const typename _Myos::sentry _Ok(_Ostr);

        if(!_Ok)
        {
            _State |= ios_base::badbit;
        }
        else
        {
            try
            {
                if((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                            break;
                        }
                    }
                }

                if(_State == ios_base::goodbit && _Ostr.rdbuf()->sputn(_Val, _Count) != _Count)
                {
                    _State |= ios_base::badbit;
                }

                if(_State == ios_base::goodbit)
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                            break;
                        }
                    }
                }

                _Ostr.width(0);
            }
            catch(...)
            {
                (_Ostr).setstate(ios_base::badbit, true);
            }
        }

        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, _Elem _Ch)
    {
        using _Myos = basic_ostream<_Elem, _Traits>;

        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myos::sentry _Ok(_Ostr);

        if(_Ok)
        {
            streamsize _Pad = _Ostr.width() <= 1 ? 0 : _Ostr.width() - 1;

            try
            {
                if((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
                {
                    for(; _State == ios_base::goodbit && 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                        }
                    }
                }

                if(_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ch)))
                {
                    _State |= ios_base::badbit;
                }

                for(; _State == ios_base::goodbit && 0 < _Pad; --_Pad)
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                    {
                        _State |= ios_base::badbit;
                    }
                }
            }
            catch(...)
            {
                (_Ostr).setstate(ios_base::badbit, true);
            }
        }

        _Ostr.width(0);
        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Traits>
    basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const signed char* _Val)
    {
        return _Ostr << reinterpret_cast<const char*>(_Val);
    }

    template <class _Traits>
    basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, signed char _Ch)
    {
        return _Ostr << static_cast<char>(_Ch);
    }

    template <class _Traits>
    basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, const unsigned char* _Val)
    {
        return _Ostr << reinterpret_cast<const char*>(_Val);
    }

    template <class _Traits>
    basic_ostream<char, _Traits>& operator<<(basic_ostream<char, _Traits>& _Ostr, unsigned char _Ch)
    {
        return _Ostr << static_cast<char>(_Ch);
    }

    template <class _Ostr, class _Ty, class = void> struct _Can_stream_out : false_type
    {
    };

    template <class _Ostr, class _Ty>
    struct _Can_stream_out<_Ostr, _Ty, void_t<decltype(::std::declval<_Ostr&>() << ::std::declval<const _Ty&>())>> : true_type
    {
    };

    template <class _Ostr, class _Ty, enable_if_t<conjunction_v<negation<is_lvalue_reference<_Ostr>>, is_base_of<ios_base, _Ostr>, _Can_stream_out<_Ostr, _Ty>>, int> = 0>
    _Ostr&& operator<<(_Ostr&& _Os, const _Ty& _Val)
    {
        _Os << _Val;
        return ::std::move(_Os);
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& __cdecl endl(basic_ostream<_Elem, _Traits>& _Ostr)
    {
        _Ostr.put(_Ostr.widen('\n'));
        _Ostr.flush();
        return _Ostr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& __cdecl ends(basic_ostream<_Elem, _Traits>& _Ostr)
    {
        _Ostr.put(_Elem());
        return _Ostr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& __cdecl flush(basic_ostream<_Elem, _Traits>& _Ostr)
    {
        _Ostr.flush();
        return _Ostr;
    }

    template <class _Elem, class _Traits>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const error_code& _Errcode)
    {
        return _Ostr << _Errcode.category().name() << ':' << _Errcode.value();
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
#pragma vtordisp(push, 2)

    template <class _Elem, class _Traits> class basic_istream : virtual public basic_ios<_Elem, _Traits>
    {
    public:
        using _Myios = basic_ios<_Elem, _Traits>;
        using _Mysb = basic_streambuf<_Elem, _Traits>;
        using _Iter = istreambuf_iterator<_Elem, _Traits>;
        using _Ctype = ctype<_Elem>;
        using _Nget = num_get<_Elem, _Iter>;

        explicit basic_istream(_Mysb* _Strbuf, bool _Isstd = false)

        : _Chcount(0)
        {
            _Myios::init(_Strbuf, _Isstd);
        }

        basic_istream(_Uninitialized)
        {
            this->_Addstd(this);
        }

    protected:
        basic_istream(basic_istream&& _Right) : _Chcount(_Right._Chcount)
        {
            _Myios::init();
            _Myios::move(::std::move(_Right));
            _Right._Chcount = 0;
        }

        basic_istream& operator=(basic_istream&& _Right)
        {
            this->swap(_Right);
            return *this;
        }

        void swap(basic_istream& _Right)
        {
            _Myios::swap(_Right);
            ::std::swap(_Chcount, _Right._Chcount);
        }

    public:
        basic_istream(const basic_istream&) = delete;
        basic_istream& operator=(const basic_istream&) = delete;

        virtual ~basic_istream() noexcept
        {
        }

        using int_type = typename _Traits::int_type;
        using pos_type = typename _Traits::pos_type;
        using off_type = typename _Traits::off_type;

        class _Sentry_base
        {
        public:
            _Sentry_base(basic_istream& _Istr) : _Myistr(_Istr)
            {
                const auto _Rdbuf = _Myistr.rdbuf();
                if(_Rdbuf)
                {
                    _Rdbuf->_Lock();
                }
            }

            ~_Sentry_base() noexcept
            {
                const auto _Rdbuf = _Myistr.rdbuf();
                if(_Rdbuf)
                {
                    _Rdbuf->_Unlock();
                }
            }

            basic_istream& _Myistr;

            _Sentry_base& operator=(const _Sentry_base&) = delete;
        };

        class sentry : public _Sentry_base
        {
        public:
            explicit sentry(basic_istream& _Istr, bool _Noskip = false)
            : _Sentry_base(_Istr), _Ok(_Sentry_base::_Myistr._Ipfx(_Noskip))
            {
            }

            explicit operator bool() const
            {
                return _Ok;
            }

            sentry(const sentry&) = delete;
            sentry& operator=(const sentry&) = delete;

        private:
            bool _Ok;
        };

        bool _Ipfx(bool _Noskip = false)
        {
            if(!this->good())
            {
                _Myios::setstate(ios_base::failbit);
                return false;
            }

            const auto _Tied = _Myios::tie();
            if(_Tied)
            {
                _Tied->flush();
            }

            bool _Eof = false;
            if(!_Noskip && this->flags() & ios_base::skipws)
            {
                const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(this->getloc());

                try
                {
                    int_type _Meta = _Myios::rdbuf()->sgetc();

                    for(;; _Meta = _Myios::rdbuf()->snextc())
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                        {
                            _Eof = true;
                            break;
                        }
                        else if(!_Ctype_fac.is(_Ctype::space, _Traits::to_char_type(_Meta)))
                        {
                            break;
                        }
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            if(_Eof)
            {
                _Myios::setstate(ios_base::eofbit | ios_base::failbit);
            }

            return this->good();
        }

        bool ipfx(bool _Noskip = false)
        {
            return _Ipfx(_Noskip);
        }

        void isfx()
        {
        }

        basic_istream& operator>>(basic_istream&(__cdecl* _Pfn)(basic_istream&))
        {
            return _Pfn(*this);
        }

        basic_istream& operator>>(_Myios&(__cdecl* _Pfn)(_Myios&))
        {
            _Pfn(*this);
            return *this;
        }

        basic_istream& operator>>(ios_base&(__cdecl* _Pfn)(ios_base&))
        {
            _Pfn(*this);
            return *this;
        }

    private:
        template <class _Ty> basic_istream& _Common_extract_with_num_get(_Ty& _Val)
        {
            ios_base::iostate _Err = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                try
                {
                    ::std::use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Val);
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_Err);
            return *this;
        }

    public:
        basic_istream& operator>>(bool& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(short& _Val)
        {
            ios_base::iostate _Err = ios_base::goodbit;
            const sentry _Ok(*this);

            if(_Ok)
            {
                try
                {
                    long _Lval;
                    ::std::use_facet<_Nget>(this->getloc()).get(*this, {}, *this, _Err, _Lval);
                    if(_Lval < (-32768))
                    {
                        _Err |= ios_base::failbit;
                        _Val = (-32768);
                    }
                    else if(_Lval > 32767)
                    {
                        _Err |= ios_base::failbit;
                        _Val = 32767;
                    }
                    else
                    {
                        _Val = static_cast<short>(_Lval);
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_Err);
            return *this;
        }

        basic_istream& operator>>(unsigned short& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(int& _Val)
        {
            static_assert(sizeof(int) == sizeof(long), "Bad overflow assumptions due to sizeof(int) != sizeof(long)");
            long _Result = _Val;
            _Common_extract_with_num_get(_Result);
            _Val = _Result;
            return *this;
        }

        basic_istream& operator>>(unsigned int& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(long& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(unsigned long& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(long long& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(unsigned long long& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(float& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(double& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(long double& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(void*& _Val)
        {
            return _Common_extract_with_num_get(_Val);
        }

        basic_istream& operator>>(_Mysb* _Strbuf)
        {
            _Chcount = 0;
            const sentry _Ok(*this, true);
            ios_base::iostate _State = ios_base::goodbit;
            if(_Ok && _Strbuf)
            {
                try
                {
                    for(int_type _Meta = _Myios::rdbuf()->sgetc();; _Meta = _Myios::rdbuf()->snextc())
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                        {
                            _State |= ios_base::eofbit;
                            break;
                        }

                        try
                        {
                            if(_Traits::eq_int_type(_Traits::eof(), _Strbuf->sputc(_Traits::to_char_type(_Meta))))
                            {
                                break;
                            }
                        }
                        catch(...)
                        {
                            break;
                        }

                        ++_Chcount;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            if(_Chcount == 0)
            {
                _State |= ios_base::failbit;
            }

            _Myios::setstate(_State);
            return *this;
        }

        int_type get()
        {
            int_type _Meta = 0;
            ios_base::iostate _State = ios_base::goodbit;
            _Chcount = 0;
            const sentry _Ok(*this, true);

            if(!_Ok)
            {
                _Meta = _Traits::eof();
            }
            else
            {
                try
                {
                    _Meta = _Myios::rdbuf()->sgetc();

                    if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                    {
                        _State |= ios_base::eofbit | ios_base::failbit;
                    }
                    else
                    {
                        _Myios::rdbuf()->sbumpc();
                        ++_Chcount;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return _Meta;
        }

        basic_istream& get(_Elem* _Str, streamsize _Count)
        {
            return get(_Str, _Count, _Myios::widen('\n'));
        }

        basic_istream& get(_Elem* _Str, streamsize _Count, _Elem _Delim)
        {
            ios_base::iostate _State = ios_base::goodbit;
            _Chcount = 0;
            const sentry _Ok(*this, true);

            if(_Ok && 0 < _Count)
            {
                try
                {
                    int_type _Meta = _Myios::rdbuf()->sgetc();

                    for(; 0 < --_Count; _Meta = _Myios::rdbuf()->snextc())
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                        {
                            _State |= ios_base::eofbit;
                            break;
                        }
                        else if(_Traits::to_char_type(_Meta) == _Delim)
                        {
                            break;
                        }
                        else
                        {
                            *_Str++ = _Traits::to_char_type(_Meta);
                            ++_Chcount;
                        }
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
            *_Str = _Elem();
            return *this;
        }

        basic_istream& get(_Elem& _Ch)
        {
            int_type _Meta = get();
            if(!_Traits::eq_int_type(_Traits::eof(), _Meta))
            {
                _Ch = _Traits::to_char_type(_Meta);
            }

            return *this;
        }

        basic_istream& get(_Mysb& _Strbuf)
        {
            return get(_Strbuf, _Myios::widen('\n'));
        }

        basic_istream& get(_Mysb& _Strbuf, _Elem _Delim)
        {
            ios_base::iostate _State = ios_base::goodbit;
            _Chcount = 0;
            const sentry _Ok(*this, true);

            if(_Ok)
            {
                try
                {
                    int_type _Meta = _Myios::rdbuf()->sgetc();

                    for(;; _Meta = _Myios::rdbuf()->snextc())
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                        {
                            _State |= ios_base::eofbit;
                            break;
                        }
                        else
                        {
                            try
                            {
                                _Elem _Ch = _Traits::to_char_type(_Meta);
                                if(_Ch == _Delim || _Traits::eq_int_type(_Traits::eof(), _Strbuf.sputc(_Ch)))
                                {
                                    break;
                                }
                            }
                            catch(...)
                            {
                                break;
                            }
                            ++_Chcount;
                        }
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            if(_Chcount == 0)
            {
                _State |= ios_base::failbit;
            }
            _Myios::setstate(_State);
            return *this;
        }

        basic_istream& getline(_Elem* _Str, streamsize _Count)
        {
            return getline(_Str, _Count, _Myios::widen('\n'));
        }

        basic_istream& getline(_Elem* _Str, streamsize _Count, _Elem _Delim)
        {
            ios_base::iostate _State = ios_base::goodbit;
            _Chcount = 0;
            const sentry _Ok(*this, true);

            if(_Ok && 0 < _Count)
            {
                int_type _Metadelim = _Traits::to_int_type(_Delim);

                try
                {
                    int_type _Meta = _Myios::rdbuf()->sgetc();

                    for(;; _Meta = _Myios::rdbuf()->snextc())
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                        {
                            _State |= ios_base::eofbit;
                            break;
                        }
                        else if(_Meta == _Metadelim)
                        {
                            ++_Chcount;
                            _Myios::rdbuf()->sbumpc();
                            break;
                        }
                        else if(--_Count <= 0)
                        {
                            _State |= ios_base::failbit;
                            break;
                        }
                        else
                        {
                            *_Str++ = _Traits::to_char_type(_Meta);
                            ++_Chcount;
                        }
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            *_Str = _Elem();
            _Myios::setstate(_Chcount == 0 ? _State | ios_base::failbit : _State);
            return *this;
        }

        basic_istream& ignore(streamsize _Count = 1, int_type _Metadelim = _Traits::eof())
        {
            ios_base::iostate _State = ios_base::goodbit;
            _Chcount = 0;
            const sentry _Ok(*this, true);

            if(_Ok && 0 < _Count)
            {
                try
                {
                    for(;;)
                    {
                        int_type _Meta;
                        if(_Count != (numeric_limits<streamsize>::max)() && --_Count < 0)
                        {
                            break;
                        }
                        else if(_Traits::eq_int_type(_Traits::eof(), _Meta = _Myios::rdbuf()->sbumpc()))
                        {
                            _State |= ios_base::eofbit;
                            break;
                        }
                        else
                        {
                            ++_Chcount;
                            if(_Meta == _Metadelim)
                            {
                                break;
                            }
                        }
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_istream& read(_Elem* _Str, streamsize _Count)
        {
            ios_base::iostate _State = ios_base::goodbit;
            _Chcount = 0;
            const sentry _Ok(*this, true);

            if(_Ok && 0 < _Count)
            {
                try
                {
                    const streamsize _Num = _Myios::rdbuf()->sgetn(_Str, _Count);
                    _Chcount += _Num;
                    if(_Num != _Count)
                    {
                        _State |= ios_base::eofbit | ios_base::failbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        streamsize readsome(_Elem* _Str, streamsize _Count)
        {
            ios_base::iostate _State = ios_base::goodbit;
            _Chcount = 0;
            const sentry _Ok(*this, true);
            streamsize _Num;

            if(!_Ok)
            {
                _State |= ios_base::failbit;
            }
            else if((_Num = _Myios::rdbuf()->in_avail()) < 0)
            {
                _State |= ios_base::eofbit;
            }
            else if(0 < _Count && 0 < _Num)
            {
                read(_Str, _Num < _Count ? _Num : _Count);
            }

            _Myios::setstate(_State);
            return gcount();
        }

        int_type peek()
        {
            ios_base::iostate _State = ios_base::goodbit;
            _Chcount = 0;
            int_type _Meta = 0;
            const sentry _Ok(*this, true);

            if(!_Ok)
            {
                _Meta = _Traits::eof();
            }
            else
            {
                try
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Meta = _Myios::rdbuf()->sgetc()))
                    {
                        _State |= ios_base::eofbit;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return _Meta;
        }

        basic_istream& putback(_Elem _Ch)
        {
            _Chcount = 0;
            ios_base::iostate _State = ios_base::goodbit;
            ios_base::iostate _Oldstate = _Myios::rdstate();
            _Myios::clear(_Oldstate & ~ios_base::eofbit);
            const sentry _Ok(*this, true);

            if(_Ok)
            {
                try
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sputbackc(_Ch)))
                    {
                        _State |= ios_base::badbit | _Oldstate;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        basic_istream& unget()
        {
            _Chcount = 0;
            ios_base::iostate _State = ios_base::goodbit;
            ios_base::iostate _Oldstate = _Myios::rdstate();
            _Myios::clear(_Oldstate & ~ios_base::eofbit);
            const sentry _Ok(*this, true);

            if(_Ok)
            {
                try
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Myios::rdbuf()->sungetc()))
                    {
                        _State |= ios_base::badbit | _Oldstate;
                    }
                }
                catch(...)
                {
                    _Myios::setstate(ios_base::badbit, true);
                }
            }

            _Myios::setstate(_State);
            return *this;
        }

        [[nodiscard]] streamsize gcount() const
        {
            return _Chcount;
        }

        int sync()
        {
            const sentry _Ok(*this, true);

            const auto _Rdbuf = _Myios::rdbuf();
            if(!_Rdbuf)
            {
                return -1;
            }

            bool _Sync_failed = true;
            try
            {
                _Sync_failed = _Rdbuf->pubsync() == -1;
            }
            catch(...)
            {
                _Myios::setstate(ios_base::badbit, true);
            }
            if(_Sync_failed)
            {
                _Myios::setstate(ios_base::badbit);
                return -1;
            }

            return 0;
        }

        basic_istream& seekg(pos_type _Pos)
        {
            ios_base::iostate _State = ios_base::goodbit;
            ios_base::iostate _Oldstate = _Myios::rdstate();
            _Myios::clear(_Oldstate & ~ios_base::eofbit);
            const sentry _Ok(*this, true);

            if(!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekpos(_Pos, ios_base::in)) == -1)
            {
                _Myios::setstate(_State | ios_base::failbit);
            }

            return *this;
        }

        basic_istream& seekg(off_type _Off, ios_base::seekdir _Way)
        {
            ios_base::iostate _State = ios_base::goodbit;
            ios_base::iostate _Oldstate = _Myios::rdstate();
            _Myios::clear(_Oldstate & ~ios_base::eofbit);
            const sentry _Ok(*this, true);

            if(!this->fail() && static_cast<off_type>(_Myios::rdbuf()->pubseekoff(_Off, _Way, ios_base::in)) == -1)
            {
                _Myios::setstate(_State | ios_base::failbit);
            }

            return *this;
        }

        pos_type tellg()
        {
            const sentry _Ok(*this, true);

            if(!this->fail())
            {
                return _Myios::rdbuf()->pubseekoff(0, ios_base::cur, ios_base::in);
            }
            else
            {
                return pos_type(-1);
            }
        }

    private:
        streamsize _Chcount;
    };

#pragma vtordisp(pop)

    template class __declspec(dllimport) basic_istream<char, char_traits<char>>;
    template class __declspec(dllimport) basic_istream<wchar_t, char_traits<wchar_t>>;

    template <class _Elem, class _Traits>
    class basic_iostream : public basic_istream<_Elem, _Traits>, public basic_ostream<_Elem, _Traits>
    {
    public:
        using _Myis = basic_istream<_Elem, _Traits>;
        using _Myos = basic_ostream<_Elem, _Traits>;
        using _Myios = basic_ios<_Elem, _Traits>;
        using char_type = _Elem;
        using traits_type = _Traits;
        using int_type = typename _Traits::int_type;
        using pos_type = typename _Traits::pos_type;
        using off_type = typename _Traits::off_type;

        explicit basic_iostream(basic_streambuf<_Elem, _Traits>* _Strbuf) : _Myis(_Strbuf, false), _Myos(_Noinit, false)
        {
        }

    protected:
        basic_iostream(basic_iostream&& _Right) : _Myis(_Right.rdbuf(), false), _Myos(_Noinit, false)
        {
            _Myios::init();
            _Myios::move(::std::move(_Right));
        }

        basic_iostream& operator=(basic_iostream&& _Right)
        {
            this->swap(_Right);
            return *this;
        }

        void swap(basic_iostream& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Myios::swap(_Right);
            }
        }

    public:
        basic_iostream(const basic_iostream&) = delete;
        basic_iostream& operator=(const basic_iostream&) = delete;

        virtual ~basic_iostream() noexcept
        {
        }
    };

    template class __declspec(dllimport) basic_iostream<char, char_traits<char>>;
    template class __declspec(dllimport) basic_iostream<wchar_t, char_traits<wchar_t>>;

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& _Istream_extract_into_buffer(basic_istream<_Elem, _Traits>& _Istr, size_t _Size, _Elem* _Str)
    {
        using _Myis = basic_istream<_Elem, _Traits>;
        using _Ctype = ctype<_Elem>;
        ios_base::iostate _State = ios_base::goodbit;
        size_t _Current = 0;
        const typename _Myis::sentry _Ok(_Istr);

        if(_Ok)
        {
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Istr.getloc());

            try
            {
                size_t _Count = _Size;
                const size_t _Width = static_cast<size_t>(_Istr.width());
                if(_Width > 0 && _Width < _Size)
                {
                    _Count = _Width;
                }

                typename _Myis::int_type _Meta = _Istr.rdbuf()->sgetc();
                _Elem _Ch;

                for(; _Current < _Count - 1; _Meta = _Istr.rdbuf()->snextc(), (void)++_Current)
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                    {
                        _State |= ios_base::eofbit;
                        break;
                    }
                    else if(_Ctype_fac.is(_Ctype::space, _Ch = _Traits::to_char_type(_Meta)) || _Ch == _Elem())
                    {
                        break;
                    }
                    else
                    {
                        _Str[_Current] = _Traits::to_char_type(_Meta);
                    }
                }
            }
            catch(...)
            {
                (_Istr).setstate(ios_base::badbit, true);
            }
        };
        _Str[_Current] = _Elem();
        _Istr.width(0);
        if(_Current == 0)
        {
            _State |= ios_base::failbit;
        }
        _Istr.setstate(_State);
        return _Istr;
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem* _Str)
    {
        return _Istream_extract_into_buffer(_Istr, 0xffffffffffffffffui64, _Str);
    }

    template <class _Traits>
    basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, signed char* _Str)
    {
        return _Istream_extract_into_buffer(_Istr, 0xffffffffffffffffui64, reinterpret_cast<char*>(_Str));
    }

    template <class _Traits>
    basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, unsigned char* _Str)
    {
        return _Istream_extract_into_buffer(_Istr, 0xffffffffffffffffui64, reinterpret_cast<char*>(_Str));
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, _Elem& _Ch)
    {
        using _Myis = basic_istream<_Elem, _Traits>;

        typename _Myis::int_type _Meta;
        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myis::sentry _Ok(_Istr);

        if(_Ok)
        {
            try
            {
                _Meta = _Istr.rdbuf()->sbumpc();
                if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                {
                    _State |= ios_base::eofbit | ios_base::failbit;
                }
                else
                {
                    _Ch = _Traits::to_char_type(_Meta);
                }
            }
            catch(...)
            {
                (_Istr).setstate(ios_base::badbit, true);
            }
        }

        _Istr.setstate(_State);
        return _Istr;
    }

    template <class _Traits>
    basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, signed char& _Ch)
    {
        return _Istr >> reinterpret_cast<char&>(_Ch);
    }

    template <class _Traits>
    basic_istream<char, _Traits>& operator>>(basic_istream<char, _Traits>& _Istr, unsigned char& _Ch)
    {
        return _Istr >> reinterpret_cast<char&>(_Ch);
    }

    template <class _Istr, class _Ty, class = void> struct _Can_stream_in : false_type
    {
    };

    template <class _Istr, class _Ty>
    struct _Can_stream_in<_Istr, _Ty, void_t<decltype(::std::declval<_Istr&>() >> ::std::declval<_Ty>())>> : true_type
    {
    };

    template <class _Istr, class _Ty, enable_if_t<conjunction_v<negation<is_lvalue_reference<_Istr>>, is_base_of<ios_base, _Istr>, _Can_stream_in<_Istr, _Ty>>, int> = 0>
    _Istr&& operator>>(_Istr&& _Is, _Ty&& _Val)
    {
        _Is >> ::std::forward<_Ty>(_Val);
        return ::std::move(_Is);
    }

    template <class _Elem, class _Traits>
    basic_istream<_Elem, _Traits>& __cdecl ws(basic_istream<_Elem, _Traits>& _Istr)
    {
        const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr, true);

        if(_Ok)
        {
            ios_base::iostate _State = ios_base::goodbit;
            const auto& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Istr.getloc());

            try
            {
                for(typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();; _Meta = _Istr.rdbuf()->snextc())
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                    {
                        _State |= ios_base::eofbit;
                        break;
                    }
                    else if(!_Ctype_fac.is(ctype<_Elem>::space, _Traits::to_char_type(_Meta)))
                    {
                        break;
                    }
                }
            }
            catch(...)
            {
                (_Istr).setstate(ios_base::badbit, true);
            }
            _Istr.setstate(_State);
        }

        return _Istr;
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    extern __declspec(dllimport) istream cin, *_Ptr_cin;
    extern __declspec(dllimport) ostream cout, *_Ptr_cout;
    extern __declspec(dllimport) ostream cerr, *_Ptr_cerr;
    extern __declspec(dllimport) ostream clog, *_Ptr_clog;

    extern __declspec(dllimport) wistream wcin, *_Ptr_wcin;
    extern __declspec(dllimport) wostream wcout, *_Ptr_wcout;
    extern __declspec(dllimport) wostream wcerr, *_Ptr_wcerr;
    extern __declspec(dllimport) wostream wclog, *_Ptr_wclog;

    class __declspec(dllimport) _Winit
    {
    public:
        __thiscall _Winit();
        __thiscall ~_Winit() noexcept;

    private:
        static int _Init_cnt;
    };
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    using ::isalnum;
    using ::isalpha;
    using ::iscntrl;
    using ::isdigit;
    using ::isgraph;
    using ::islower;
    using ::isprint;
    using ::ispunct;
    using ::isspace;
    using ::isupper;
    using ::isxdigit;
    using ::tolower;
    using ::toupper;

    using ::isblank;
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Elem, class _Traits, class _Alloc>
    basic_istream<_Elem, _Traits>&
    getline(basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str, const _Elem _Delim)
    {
        using _Myis = basic_istream<_Elem, _Traits>;

        typename _Myis::iostate _State = _Myis::goodbit;
        bool _Changed = false;
        const typename _Myis::sentry _Ok(_Istr, true);

        if(_Ok)
        {
            try
            {
                _Str.erase();
                const typename _Traits::int_type _Metadelim = _Traits::to_int_type(_Delim);
                typename _Traits::int_type _Meta = _Istr.rdbuf()->sgetc();

                for(;; _Meta = _Istr.rdbuf()->snextc())
                {
                    if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                    {
                        _State |= _Myis::eofbit;
                        break;
                    }
                    else if(_Traits::eq_int_type(_Meta, _Metadelim))
                    {
                        _Changed = true;
                        _Istr.rdbuf()->sbumpc();
                        break;
                    }
                    else if(_Str.max_size() <= _Str.size())
                    {
                        _State |= _Myis::failbit;
                        break;
                    }
                    else
                    {
                        _Str += _Traits::to_char_type(_Meta);
                        _Changed = true;
                    }
                }
            }
            catch(...)
            {
                (_Istr).setstate(_Myis::badbit, true);
            }
        }

        if(!_Changed)
        {
            _State |= _Myis::failbit;
        }

        _Istr.setstate(_State);
        return _Istr;
    }

    template <class _Elem, class _Traits, class _Alloc>
    basic_istream<_Elem, _Traits>& getline(basic_istream<_Elem, _Traits>&& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str)
    {
        return getline(_Istr, _Str, _Istr.widen('\n'));
    }

    template <class _Elem, class _Traits, class _Alloc>
    basic_istream<_Elem, _Traits>&
    getline(basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str, const _Elem _Delim)
    {
        return getline(::std::move(_Istr), _Str, _Delim);
    }

    template <class _Elem, class _Traits, class _Alloc>
    basic_istream<_Elem, _Traits>& getline(basic_istream<_Elem, _Traits>& _Istr, basic_string<_Elem, _Traits, _Alloc>& _Str)
    {
        return getline(::std::move(_Istr), _Str, _Istr.widen('\n'));
    }

    inline int stoi(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const char* _Ptr = _Str.c_str();
        char* _Eptr;
        _Errno_ref = 0;
        const long _Ans = ::strtol(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stoi argument");
        }

        if(_Errno_ref == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
        {
            _Xout_of_range("stoi argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return static_cast<int>(_Ans);
    }

    inline long stol(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const char* _Ptr = _Str.c_str();
        char* _Eptr;
        _Errno_ref = 0;
        const long _Ans = ::strtol(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stol argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stol argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline unsigned long stoul(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const char* _Ptr = _Str.c_str();
        char* _Eptr;
        _Errno_ref = 0;
        const unsigned long _Ans = ::strtoul(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stoul argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stoul argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline long long stoll(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const char* _Ptr = _Str.c_str();
        char* _Eptr;
        _Errno_ref = 0;
        const long long _Ans = ::strtoll(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stoll argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stoll argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline unsigned long long stoull(const string& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const char* _Ptr = _Str.c_str();
        char* _Eptr;
        _Errno_ref = 0;
        const unsigned long long _Ans = ::strtoull(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stoull argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stoull argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline float stof(const string& _Str, size_t* _Idx = nullptr)
    {
        int& _Errno_ref = (*_errno());
        const char* _Ptr = _Str.c_str();
        char* _Eptr;
        _Errno_ref = 0;
        const float _Ans = ::strtof(_Ptr, &_Eptr);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stof argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stof argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline double stod(const string& _Str, size_t* _Idx = nullptr)
    {
        int& _Errno_ref = (*_errno());
        const char* _Ptr = _Str.c_str();
        char* _Eptr;
        _Errno_ref = 0;
        const double _Ans = ::strtod(_Ptr, &_Eptr);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stod argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stod argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline long double stold(const string& _Str, size_t* _Idx = nullptr)
    {
        int& _Errno_ref = (*_errno());
        const char* _Ptr = _Str.c_str();
        char* _Eptr;
        _Errno_ref = 0;
        const long double _Ans = ::strtold(_Ptr, &_Eptr);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stold argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stold argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline int stoi(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const wchar_t* _Ptr = _Str.c_str();
        wchar_t* _Eptr;
        _Errno_ref = 0;
        const long _Ans = ::wcstol(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stoi argument");
        }

        if(_Errno_ref == 34 || _Ans < (-2147483647 - 1) || 2147483647 < _Ans)
        {
            _Xout_of_range("stoi argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return static_cast<int>(_Ans);
    }

    inline long stol(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const wchar_t* _Ptr = _Str.c_str();
        wchar_t* _Eptr;
        _Errno_ref = 0;
        const long _Ans = ::wcstol(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stol argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stol argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline unsigned long stoul(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const wchar_t* _Ptr = _Str.c_str();
        wchar_t* _Eptr;
        _Errno_ref = 0;
        const unsigned long _Ans = ::wcstoul(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stoul argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stoul argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline long long stoll(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const wchar_t* _Ptr = _Str.c_str();
        wchar_t* _Eptr;
        _Errno_ref = 0;
        const long long _Ans = ::wcstoll(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stoll argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stoll argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline unsigned long long stoull(const wstring& _Str, size_t* _Idx = nullptr, int _Base = 10)
    {
        int& _Errno_ref = (*_errno());
        const wchar_t* _Ptr = _Str.c_str();
        wchar_t* _Eptr;
        _Errno_ref = 0;
        const unsigned long long _Ans = ::wcstoull(_Ptr, &_Eptr, _Base);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stoull argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stoull argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline float stof(const wstring& _Str, size_t* _Idx = nullptr)
    {
        int& _Errno_ref = (*_errno());
        const wchar_t* _Ptr = _Str.c_str();
        wchar_t* _Eptr;
        _Errno_ref = 0;
        const float _Ans = ::wcstof(_Ptr, &_Eptr);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stof argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stof argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline double stod(const wstring& _Str, size_t* _Idx = nullptr)
    {
        int& _Errno_ref = (*_errno());
        const wchar_t* _Ptr = _Str.c_str();
        wchar_t* _Eptr;
        _Errno_ref = 0;
        const double _Ans = ::wcstod(_Ptr, &_Eptr);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stod argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stod argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    inline long double stold(const wstring& _Str, size_t* _Idx = nullptr)
    {
        int& _Errno_ref = (*_errno());
        const wchar_t* _Ptr = _Str.c_str();
        wchar_t* _Eptr;
        _Errno_ref = 0;
        const long double _Ans = ::wcstold(_Ptr, &_Eptr);

        if(_Ptr == _Eptr)
        {
            _Xinvalid_argument("invalid stold argument");
        }

        if(_Errno_ref == 34)
        {
            _Xout_of_range("stold argument out of range");
        }

        if(_Idx)
        {
            *_Idx = static_cast<size_t>(_Eptr - _Ptr);
        }

        return _Ans;
    }

    template <class _Elem, class _UTy> _Elem* _UIntegral_to_buff(_Elem* _RNext, _UTy _UVal)
    {
        static_assert(is_unsigned_v<_UTy>, "_UTy must be unsigned");

        auto _UVal_trunc = _UVal;

        do
        {
            *--_RNext = static_cast<_Elem>('0' + _UVal_trunc % 10);
            _UVal_trunc /= 10;
        } while(_UVal_trunc != 0);
        return _RNext;
    }

    template <class _Elem, class _Ty> basic_string<_Elem> _Integral_to_string(const _Ty _Val)
    {
        static_assert(is_integral_v<_Ty>, "_Ty must be integral");
        using _UTy = make_unsigned_t<_Ty>;
        _Elem _Buff[21];
        _Elem* const _Buff_end = ::std::end(_Buff);
        _Elem* _RNext = _Buff_end;
        const auto _UVal = static_cast<_UTy>(_Val);
        if(_Val < 0)
        {
            _RNext = _UIntegral_to_buff(_RNext, 0 - _UVal);
            *--_RNext = '-';
        }
        else
        {
            _RNext = _UIntegral_to_buff(_RNext, _UVal);
        }

        return basic_string<_Elem>(_RNext, _Buff_end);
    }

    [[nodiscard]] inline string to_string(int _Val)
    {
        return _Integral_to_string<char>(_Val);
    }

    [[nodiscard]] inline string to_string(unsigned int _Val)
    {
        return _Integral_to_string<char>(_Val);
    }

    [[nodiscard]] inline string to_string(long _Val)
    {
        return _Integral_to_string<char>(_Val);
    }

    [[nodiscard]] inline string to_string(unsigned long _Val)
    {
        return _Integral_to_string<char>(_Val);
    }

    [[nodiscard]] inline string to_string(long long _Val)
    {
        return _Integral_to_string<char>(_Val);
    }

    [[nodiscard]] inline string to_string(unsigned long long _Val)
    {
        return _Integral_to_string<char>(_Val);
    }

    [[nodiscard]] inline string to_string(double _Val)
    {
        const auto _Len = static_cast<size_t>(::_scprintf("%f", _Val));
        string _Str(_Len, '\0');
        ::sprintf_s(&_Str[0], _Len + 1, "%f", _Val);
        return _Str;
    }

    [[nodiscard]] inline string to_string(float _Val)
    {
        return ::std::to_string(static_cast<double>(_Val));
    }

    [[nodiscard]] inline string to_string(long double _Val)
    {
        return ::std::to_string(static_cast<double>(_Val));
    }

    [[nodiscard]] inline wstring to_wstring(int _Val)
    {
        return _Integral_to_string<wchar_t>(_Val);
    }

    [[nodiscard]] inline wstring to_wstring(unsigned int _Val)
    {
        return _Integral_to_string<wchar_t>(_Val);
    }

    [[nodiscard]] inline wstring to_wstring(long _Val)
    {
        return _Integral_to_string<wchar_t>(_Val);
    }

    [[nodiscard]] inline wstring to_wstring(unsigned long _Val)
    {
        return _Integral_to_string<wchar_t>(_Val);
    }

    [[nodiscard]] inline wstring to_wstring(long long _Val)
    {
        return _Integral_to_string<wchar_t>(_Val);
    }

    [[nodiscard]] inline wstring to_wstring(unsigned long long _Val)
    {
        return _Integral_to_string<wchar_t>(_Val);
    }

    [[nodiscard]] inline wstring to_wstring(double _Val)
    {
        const auto _Len = static_cast<size_t>(::_scwprintf(L"%f", _Val));
        wstring _Str(_Len, L'\0');
        ::swprintf_s(&_Str[0], _Len + 1, L"%f", _Val);
        return _Str;
    }

    [[nodiscard]] inline wstring to_wstring(float _Val)
    {
        return ::std::to_wstring(static_cast<double>(_Val));
    }

    [[nodiscard]] inline wstring to_wstring(long double _Val)
    {
        return ::std::to_wstring(static_cast<double>(_Val));
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Elem, class _Traits, class _Alloc> class basic_stringbuf : public basic_streambuf<_Elem, _Traits>
    {
    public:
        using allocator_type = _Alloc;
        using _Mysb = basic_streambuf<_Elem, _Traits>;
        using _Mystr = basic_string<_Elem, _Traits, _Alloc>;
        using _Mysize_type = typename _Mystr::size_type;

        explicit basic_stringbuf(ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : _Seekhigh(nullptr), _Mystate(_Getstate(_Mode)), _Al()
        {
        }

        explicit basic_stringbuf(const _Mystr& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : _Al(_Str.get_allocator())
        {
            _Init(_Str.c_str(), _Str.size(), _Getstate(_Mode));
        }

        basic_stringbuf(basic_stringbuf&& _Right)
        {
            _Assign_rv(::std::move(_Right));
        }

        basic_stringbuf& operator=(basic_stringbuf&& _Right)
        {
            _Assign_rv(::std::move(_Right));
            return *this;
        }

        void _Assign_rv(basic_stringbuf&& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Tidy();
                this->swap(_Right);
            }
        }

        void swap(basic_stringbuf& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Mysb::swap(_Right);
                ::std::swap(_Seekhigh, _Right._Seekhigh);
                ::std::swap(_Mystate, _Right._Mystate);
                _Swap_adl(_Al, _Right._Al);
            }
        }

        basic_stringbuf(const basic_stringbuf&) = delete;
        basic_stringbuf& operator=(const basic_stringbuf&) = delete;

        virtual ~basic_stringbuf() noexcept
        {
            _Tidy();
        }

        enum
        {
            _Allocated = 1,
            _Constant = 2,
            _Noread = 4,
            _Append = 8,
            _Atend = 16
        };

        using int_type = typename _Traits::int_type;
        using pos_type = typename _Traits::pos_type;
        using off_type = typename _Traits::off_type;

        [[nodiscard]] _Mystr str() const
        {
            _Mystr _Result(_Al);
            if(!(_Mystate & _Constant) && _Mysb::pptr())
            {
                const auto _Base = _Mysb::pbase();
                _Result.assign(_Base, static_cast<_Mysize_type>(_Max_value(_Mysb::pptr(), _Seekhigh) - _Base));
            }
            else if(!(_Mystate & _Noread) && _Mysb::gptr())
            {
                const auto _Base = _Mysb::eback();
                _Result.assign(_Base, static_cast<_Mysize_type>(_Mysb::egptr() - _Base));
            }

            return _Result;
        }

        void str(const _Mystr& _Newstr)
        {
            _Tidy();
            _Init(_Newstr.c_str(), _Newstr.size(), _Mystate);
        }

    protected:
        virtual int_type overflow(int_type _Meta = _Traits::eof())
        {
            if(_Mystate & _Constant)
            {
                return _Traits::eof();
            }

            if(_Traits::eq_int_type(_Traits::eof(), _Meta))
            {
                return _Traits::not_eof(_Meta);
            }

            const auto _Pptr = _Mysb::pptr();
            const auto _Epptr = _Mysb::epptr();
            if(_Pptr && _Pptr < _Epptr)
            {
                *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
                _Seekhigh = _Pptr + 1;
                return _Meta;
            }

            size_t _Oldsize = 0;
            const auto _Oldptr = _Mysb::eback();
            if(_Pptr)
            {
                _Oldsize = static_cast<size_t>(_Epptr - _Oldptr);
            }

            size_t _Newsize;
            if(_Oldsize < _MINSIZE)
            {
                _Newsize = _MINSIZE;
            }
            else if(_Oldsize < 2147483647 / 2)
            {
                _Newsize = _Oldsize << 1;
            }
            else if(_Oldsize < 2147483647)
            {
                _Newsize = 2147483647;
            }
            else
            {
                return _Traits::eof();
            }

            const auto _Newptr = _Unfancy(_Al.allocate(_Newsize));
            _Traits::copy(_Newptr, _Oldptr, _Oldsize);

            const auto _New_pnext = _Newptr + _Oldsize;
            _Seekhigh = _New_pnext + 1;

            _Mysb::setp(_Newptr, _New_pnext, _Newptr + _Newsize);
            if(_Mystate & _Noread)
            {
                _Mysb::setg(_Newptr, nullptr, _Newptr);
            }
            else
            {
                _Mysb::setg(_Newptr, _Newptr + (_Mysb::gptr() - _Oldptr), _Seekhigh);
            }

            if(_Mystate & _Allocated)
            {
                _Al.deallocate(_Ptr_traits::pointer_to(*_Oldptr), _Oldsize);
            }

            _Mystate |= _Allocated;
            *_Mysb::_Pninc() = _Traits::to_char_type(_Meta);
            return _Meta;
        }

        virtual int_type pbackfail(int_type _Meta = _Traits::eof())
        {
            const auto _Gptr = _Mysb::gptr();
            if(!_Gptr || _Gptr <= _Mysb::eback()
               || (!_Traits::eq_int_type(_Traits::eof(), _Meta) && !_Traits::eq(_Traits::to_char_type(_Meta), _Gptr[-1])
                   && (_Mystate & _Constant)))
            {
                return _Traits::eof();
            }

            _Mysb::gbump(-1);
            if(!_Traits::eq_int_type(_Traits::eof(), _Meta))
            {
                *_Mysb::gptr() = _Traits::to_char_type(_Meta);
            }

            return _Traits::not_eof(_Meta);
        }

        virtual int_type underflow()
        {
            const auto _Gptr = _Mysb::gptr();
            if(!_Gptr)
            {
                return _Traits::eof();
            }

            if(_Gptr < _Mysb::egptr())
            {
                return _Traits::to_int_type(*_Gptr);
            }

            const auto _Pptr = _Mysb::pptr();
            if(!_Pptr || (_Mystate & _Noread))
            {
                return _Traits::eof();
            }

            const auto _Local_highwater = _Max_value(_Seekhigh, _Pptr);
            if(_Local_highwater <= _Gptr)
            {
                return _Traits::eof();
            }

            _Seekhigh = _Local_highwater;
            _Mysb::setg(_Mysb::eback(), _Mysb::gptr(), _Local_highwater);
            return _Traits::to_int_type(*_Mysb::gptr());
        }

        virtual pos_type seekoff(off_type _Off, ios_base::seekdir _Way, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        {
            const auto _Gptr_old = _Mysb::gptr();
            const auto _Pptr_old = _Mysb::pptr();
            if(_Pptr_old && _Seekhigh < _Pptr_old)
            {
                _Seekhigh = _Pptr_old;
            }

            const auto _Seeklow = _Mysb::eback();
            const auto _Seekdist = _Seekhigh - _Seeklow;
            off_type _Newoff;
            switch(_Way)
            {
                case ios_base::beg:
                    _Newoff = 0;
                    break;
                case ios_base::end:
                    _Newoff = _Seekdist;
                    break;
                case ios_base::cur:
                {
                    constexpr auto _Both = ios_base::in | ios_base::out;
                    if((_Mode & _Both) != _Both)
                    {
                        if(_Mode & ios_base::in)
                        {
                            if(_Gptr_old || !_Seeklow)
                            {
                                _Newoff = _Gptr_old - _Seeklow;
                                break;
                            }
                        }
                        else if((_Mode & ios_base::out) && (_Pptr_old || !_Seeklow))
                        {
                            _Newoff = _Pptr_old - _Seeklow;
                            break;
                        }
                    }
                }

                default:
                    return pos_type(off_type(-1));
            }

            if(static_cast<unsigned long long>(_Off) + _Newoff > static_cast<unsigned long long>(_Seekdist))
            {
                return pos_type(off_type(-1));
            }

            _Off += _Newoff;
            if(_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old)))
            {
                return pos_type(off_type(-1));
            }

            const auto _Newptr = _Seeklow + _Off;
            if((_Mode & ios_base::in) && _Gptr_old)
            {
                _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);
            }

            if((_Mode & ios_base::out) && _Pptr_old)
            {
                _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());
            }

            return pos_type(_Off);
        }

        virtual pos_type seekpos(pos_type _Pos, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        {
            const auto _Off = static_cast<streamoff>(_Pos);
            const auto _Gptr_old = _Mysb::gptr();
            const auto _Pptr_old = _Mysb::pptr();
            if(_Pptr_old && _Seekhigh < _Pptr_old)
            {
                _Seekhigh = _Pptr_old;
            }

            const auto _Seeklow = _Mysb::eback();
            const auto _Seekdist = _Seekhigh - _Seeklow;
            if(static_cast<unsigned long long>(_Off) > static_cast<unsigned long long>(_Seekdist))
            {
                return pos_type(off_type(-1));
            }

            if(_Off != 0 && (((_Mode & ios_base::in) && !_Gptr_old) || ((_Mode & ios_base::out) && !_Pptr_old)))
            {
                return pos_type(off_type(-1));
            }

            const auto _Newptr = _Seeklow + _Off;
            if((_Mode & ios_base::in) && _Gptr_old)
            {
                _Mysb::setg(_Seeklow, _Newptr, _Seekhigh);
            }

            if((_Mode & ios_base::out) && _Pptr_old)
            {
                _Mysb::setp(_Seeklow, _Newptr, _Mysb::epptr());
            }

            return pos_type(_Off);
        }

    protected:
        void _Init(const _Elem* _Ptr, _Mysize_type _Count, int _State)
        {
            if(_Count > 2147483647)
            {
                _Xbad_alloc();
            }

            if(_Count != 0 && (_State & (_Noread | _Constant)) != (_Noread | _Constant))
            {
                const auto _Pnew = _Unfancy(_Al.allocate(_Count));
                _Traits::copy(_Pnew, _Ptr, _Count);
                _Seekhigh = _Pnew + _Count;

                if(!(_State & _Noread))
                {
                    _Mysb::setg(_Pnew, _Pnew, _Seekhigh);
                }

                if(!(_State & _Constant))
                {
                    _Mysb::setp(_Pnew, (_State & (_Atend | _Append)) ? _Seekhigh : _Pnew, _Seekhigh);

                    if(_State & _Noread)
                    {
                        _Mysb::setg(_Pnew, nullptr, _Pnew);
                    }
                }

                _State |= _Allocated;
            }
            else
            {
                _Seekhigh = nullptr;
            }

            _Mystate = _State;
        }

        void _Tidy() noexcept
        {
            if(_Mystate & _Allocated)
            {
                _Al.deallocate(_Ptr_traits::pointer_to(*_Mysb::eback()),
                               static_cast<typename allocator_traits<allocator_type>::size_type>(
                               (_Mysb::pptr() ? _Mysb::epptr() : _Mysb::egptr()) - _Mysb::eback()));
            }

            _Mysb::setg(nullptr, nullptr, nullptr);
            _Mysb::setp(nullptr, nullptr);
            _Seekhigh = nullptr;
            _Mystate &= ~_Allocated;
        }

    private:
        using _Ptr_traits = pointer_traits<typename allocator_traits<allocator_type>::pointer>;

        enum
        {
            _MINSIZE = 32
        };

        static int _Getstate(ios_base::openmode _Mode)
        {
            int _State = 0;
            if(!(_Mode & ios_base::in))
            {
                _State |= _Noread;
            }

            if(!(_Mode & ios_base::out))
            {
                _State |= _Constant;
            }

            if(_Mode & ios_base::app)
            {
                _State |= _Append;
            }

            if(_Mode & ios_base::ate)
            {
                _State |= _Atend;
            }

            return _State;
        }

        _Elem* _Seekhigh;
        int _Mystate;
        allocator_type _Al;
    };

    template <class _Elem, class _Traits, class _Alloc>
    void swap(basic_stringbuf<_Elem, _Traits, _Alloc>& _Left, basic_stringbuf<_Elem, _Traits, _Alloc>& _Right)
    {
        _Left.swap(_Right);
    }

    template <class _Elem, class _Traits, class _Alloc> class basic_istringstream : public basic_istream<_Elem, _Traits>
    {
    public:
        using _Mybase = basic_istream<_Elem, _Traits>;
        using allocator_type = _Alloc;
        using _Mysb = basic_stringbuf<_Elem, _Traits, _Alloc>;
        using _Mystr = basic_string<_Elem, _Traits, _Alloc>;

        explicit basic_istringstream(ios_base::openmode _Mode = ios_base::in)
        : _Mybase(::std::addressof(_Stringbuffer)), _Stringbuffer(_Mode | ios_base::in)
        {
        }

        explicit basic_istringstream(const _Mystr& _Str, ios_base::openmode _Mode = ios_base::in)
        : _Mybase(::std::addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode | ios_base::in)
        {
        }

        basic_istringstream(basic_istringstream&& _Right) : _Mybase(::std::addressof(_Stringbuffer))
        {
            _Assign_rv(::std::move(_Right));
        }

        basic_istringstream& operator=(basic_istringstream&& _Right)
        {
            _Assign_rv(::std::move(_Right));
            return *this;
        }

        void _Assign_rv(basic_istringstream&& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Stringbuffer.str(_Mystr());
                this->swap(_Right);
            }
        }

        void swap(basic_istringstream& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Mybase::swap(_Right);
                _Stringbuffer.swap(_Right._Stringbuffer);
            }
        }

        basic_istringstream(const basic_istringstream&) = delete;
        basic_istringstream& operator=(const basic_istringstream&) = delete;

        virtual ~basic_istringstream() noexcept
        {
        }

        [[nodiscard]] _Mysb* rdbuf() const
        {
            return const_cast<_Mysb*>(::std::addressof(_Stringbuffer));
        }

        [[nodiscard]] _Mystr str() const
        {
            return _Stringbuffer.str();
        }

        void str(const _Mystr& _Newstr)
        {
            _Stringbuffer.str(_Newstr);
        }

    private:
        _Mysb _Stringbuffer;
    };

    template <class _Elem, class _Traits, class _Alloc>
    void swap(basic_istringstream<_Elem, _Traits, _Alloc>& _Left, basic_istringstream<_Elem, _Traits, _Alloc>& _Right)
    {
        _Left.swap(_Right);
    }

    template <class _Elem, class _Traits, class _Alloc> class basic_ostringstream : public basic_ostream<_Elem, _Traits>
    {
    public:
        using _Mybase = basic_ostream<_Elem, _Traits>;
        using allocator_type = _Alloc;
        using _Mysb = basic_stringbuf<_Elem, _Traits, _Alloc>;
        using _Mystr = basic_string<_Elem, _Traits, _Alloc>;

        explicit basic_ostringstream(ios_base::openmode _Mode = ios_base::out)
        : _Mybase(::std::addressof(_Stringbuffer)), _Stringbuffer(_Mode | ios_base::out)
        {
        }

        explicit basic_ostringstream(const _Mystr& _Str, ios_base::openmode _Mode = ios_base::out)
        : _Mybase(::std::addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode | ios_base::out)
        {
        }

        basic_ostringstream(basic_ostringstream&& _Right) : _Mybase(::std::addressof(_Stringbuffer))
        {
            _Assign_rv(::std::move(_Right));
        }

        basic_ostringstream& operator=(basic_ostringstream&& _Right)
        {
            _Assign_rv(::std::move(_Right));
            return *this;
        }

        void _Assign_rv(basic_ostringstream&& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Stringbuffer.str(_Mystr());
                this->swap(_Right);
            }
        }

        void swap(basic_ostringstream& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Mybase::swap(_Right);
                _Stringbuffer.swap(_Right._Stringbuffer);
            }
        }

        basic_ostringstream(const basic_ostringstream&) = delete;
        basic_ostringstream& operator=(const basic_ostringstream&) = delete;

        virtual ~basic_ostringstream() noexcept
        {
        }

        [[nodiscard]] _Mysb* rdbuf() const
        {
            return const_cast<_Mysb*>(::std::addressof(_Stringbuffer));
        }

        [[nodiscard]] _Mystr str() const
        {
            return _Stringbuffer.str();
        }

        void str(const _Mystr& _Newstr)
        {
            _Stringbuffer.str(_Newstr);
        }

    private:
        _Mysb _Stringbuffer;
    };

    template <class _Elem, class _Traits, class _Alloc>
    void swap(basic_ostringstream<_Elem, _Traits, _Alloc>& _Left, basic_ostringstream<_Elem, _Traits, _Alloc>& _Right)
    {
        _Left.swap(_Right);
    }

    template <class _Elem, class _Traits, class _Alloc> class basic_stringstream : public basic_iostream<_Elem, _Traits>
    {
    public:
        using _Mybase = basic_iostream<_Elem, _Traits>;
        using char_type = _Elem;
        using traits_type = _Traits;
        using allocator_type = _Alloc;
        using int_type = typename _Traits::int_type;
        using pos_type = typename _Traits::pos_type;
        using off_type = typename _Traits::off_type;
        using _Mysb = basic_stringbuf<_Elem, _Traits, _Alloc>;
        using _Mystr = basic_string<_Elem, _Traits, _Alloc>;

        explicit basic_stringstream(ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : _Mybase(::std::addressof(_Stringbuffer)), _Stringbuffer(_Mode)
        {
        }

        explicit basic_stringstream(const _Mystr& _Str, ios_base::openmode _Mode = ios_base::in | ios_base::out)
        : _Mybase(::std::addressof(_Stringbuffer)), _Stringbuffer(_Str, _Mode)
        {
        }

        basic_stringstream(basic_stringstream&& _Right) : _Mybase(::std::addressof(_Stringbuffer))
        {
            _Assign_rv(::std::move(_Right));
        }

        basic_stringstream& operator=(basic_stringstream&& _Right)
        {
            _Assign_rv(::std::move(_Right));
            return *this;
        }

        void _Assign_rv(basic_stringstream&& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Stringbuffer.str(_Mystr());
                this->swap(_Right);
            }
        }

        void swap(basic_stringstream& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Mybase::swap(_Right);
                _Stringbuffer.swap(_Right._Stringbuffer);
            }
        }

        basic_stringstream(const basic_stringstream&) = delete;
        basic_stringstream& operator=(const basic_stringstream&) = delete;

        virtual ~basic_stringstream() noexcept
        {
        }

        [[nodiscard]] _Mysb* rdbuf() const
        {
            return const_cast<_Mysb*>(::std::addressof(_Stringbuffer));
        }

        [[nodiscard]] _Mystr str() const
        {
            return _Stringbuffer.str();
        }

        void str(const _Mystr& _Newstr)
        {
            _Stringbuffer.str(_Newstr);
        }

    private:
        _Mysb _Stringbuffer;
    };

    template <class _Elem, class _Traits, class _Alloc>
    void swap(basic_stringstream<_Elem, _Traits, _Alloc>& _Left, basic_stringstream<_Elem, _Traits, _Alloc>& _Right)
    {
        _Left.swap(_Right);
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    struct money_base : locale::facet
    {
        enum
        {
            symbol = '$',
            sign = '+',
            space = ' ',
            value = 'v',
            none = 'x'
        };
        using part = int;

        struct pattern
        {
            char field[4];
        };

        money_base(size_t _Refs = 0) : locale::facet(_Refs)
        {
        }
    };

    template <class _Elem> class _Mpunct : public money_base
    {
    public:
        friend _Tidy_guard<_Mpunct>;

    public:
        using char_type = _Elem;
        using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

        _Elem decimal_point() const
        {
            return do_decimal_point();
        }

        _Elem thousands_sep() const
        {
            return do_thousands_sep();
        }

        string grouping() const
        {
            return do_grouping();
        }

        string_type curr_symbol() const
        {
            return do_curr_symbol();
        }

        string_type positive_sign() const
        {
            return do_positive_sign();
        }

        string_type negative_sign() const
        {
            return do_negative_sign();
        }

        int frac_digits() const
        {
            return do_frac_digits();
        }

        pattern pos_format() const
        {
            return do_pos_format();
        }

        pattern neg_format() const
        {
            return do_neg_format();
        }

        explicit _Mpunct(size_t _Refs, bool _Intl) : money_base(_Refs), _International(_Intl)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        _Mpunct(const _Locinfo& _Lobj, size_t _Refs, bool _Intl, bool _Isdef = false)
        : money_base(_Refs), _International(_Intl)
        {
            _Init(_Lobj, _Isdef);
        }

    protected:
        _Mpunct(const char* _Locname, size_t _Refs, bool _Intl, bool _Isdef = false)
        : money_base(_Refs), _International(_Intl)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj(_Locname);
                _Init(_Lobj, _Isdef);
            }
        }

        virtual ~_Mpunct() noexcept
        {
            _Tidy();
        }

        template <class _Elem2> void _Getvals(_Elem2, const lconv* _Ptr)
        {
            _Currencysign
            = _Maklocstr(_International ? _Ptr->int_curr_symbol : _Ptr->currency_symbol, static_cast<_Elem2*>(nullptr), _Cvt);
            _Plussign = _Maklocstr(4 < static_cast<unsigned int>(_Ptr->p_sign_posn) ? "" : _Ptr->positive_sign,
                                   static_cast<_Elem2*>(nullptr), _Cvt);
            _Minussign = _Maklocstr(4 < static_cast<unsigned int>(_Ptr->n_sign_posn) ? "-" : _Ptr->negative_sign,
                                    static_cast<_Elem2*>(nullptr), _Cvt);
            _Decimalpoint = _Maklocchr(_Ptr->mon_decimal_point[0], static_cast<_Elem2*>(nullptr), _Cvt);
            _Kseparator = _Maklocchr(_Ptr->mon_thousands_sep[0], static_cast<_Elem2*>(nullptr), _Cvt);
        }

        void _Getvals(wchar_t, const lconv* _Ptr)
        {
            _Currencysign
            = reinterpret_cast<const _Elem*>(_Maklocwcs(_International ? _Ptr->_W_int_curr_symbol : _Ptr->_W_currency_symbol));
            _Plussign = reinterpret_cast<const _Elem*>(
            _Maklocwcs(4 < static_cast<unsigned int>(_Ptr->p_sign_posn) ? L"" : _Ptr->_W_positive_sign));
            _Minussign = reinterpret_cast<const _Elem*>(
            _Maklocwcs(4 < static_cast<unsigned int>(_Ptr->n_sign_posn) ? L"-" : _Ptr->_W_negative_sign));
            _Decimalpoint = static_cast<_Elem>(_Ptr->_W_mon_decimal_point[0]);
            _Kseparator = static_cast<_Elem>(_Ptr->_W_mon_thousands_sep[0]);
        }

        void _Init(const _Locinfo& _Lobj, bool _Isdef = false)
        {
            _Cvt = _Lobj._Getcvt();
            const lconv* _Ptr = _Lobj._Getlconv();

            _Grouping = nullptr;
            _Currencysign = nullptr;
            _Plussign = nullptr;
            _Minussign = nullptr;

            _Tidy_guard<_Mpunct> _Guard{ this };
            _Grouping = _Maklocstr(_Ptr->mon_grouping, static_cast<char*>(nullptr), _Cvt);
            _Getvals(_Elem{}, _Ptr);
            _Guard._Target = nullptr;

            _Fracdigits = _International ? _Ptr->int_frac_digits : _Ptr->frac_digits;
            if(_Fracdigits < 0 || 127 <= _Fracdigits)
            {
                _Fracdigits = 0;
            }

            _Makpat(_Plusformat, static_cast<unsigned int>(_Ptr->p_sep_by_space),
                    static_cast<unsigned int>(_Ptr->p_cs_precedes), static_cast<unsigned int>(_Ptr->p_sign_posn));
            _Makpat(_Minusformat, static_cast<unsigned int>(_Ptr->n_sep_by_space),
                    static_cast<unsigned int>(_Ptr->n_cs_precedes), static_cast<unsigned int>(_Ptr->n_sign_posn));

            if(_Isdef)
            {
                ::memcpy(&_Plusformat, "$+xv", 4);
                ::memcpy(&_Minusformat, "$+xv", 4);
            }
        }

        virtual _Elem do_decimal_point() const
        {
            return _Decimalpoint;
        }

        virtual _Elem do_thousands_sep() const
        {
            return _Kseparator;
        }

        virtual string do_grouping() const
        {
            return string(_Grouping);
        }

        virtual string_type do_curr_symbol() const
        {
            return string_type(_Currencysign);
        }

        virtual string_type do_positive_sign() const
        {
            return string_type(_Plussign);
        }

        virtual string_type do_negative_sign() const
        {
            return string_type(_Minussign);
        }

        virtual int do_frac_digits() const
        {
            return _Fracdigits;
        }

        virtual pattern do_pos_format() const
        {
            return _Plusformat;
        }

        virtual pattern do_neg_format() const
        {
            return _Minusformat;
        }

    private:
        void _Makpat(pattern& _Pattern, unsigned int _Sepbyspace, unsigned int _Symbolprecedes, unsigned int _Signposition)
        {
            const char* _Ptr;

            if(_International || 2 < _Sepbyspace || 1 < _Symbolprecedes || 4 < _Signposition)
            {
                _Ptr = "$+xv";
            }
            else
            {
                _Ptr = "+v$x"
                       "+v$x"
                       "v$+x"
                       "v+$x"
                       "v$+x"
                       "+$vx"
                       "+$vx"
                       "$v+x"
                       "+$vx"
                       "$+vx"
                       "+v $"
                       "+v $"
                       "v $+"
                       "v +$"
                       "v $+"
                       "+$ v"
                       "+$ v"
                       "$ v+"
                       "+$ v"
                       "$+ v"
                       "+xv$"
                       "+ v$"
                       "v$ +"
                       "v+ $"
                       "v$ +"
                       "+x$v"
                       "+ $v"
                       "$v +"
                       "+ $v"
                       "$ +v";

                _Ptr += _Signposition * 4 + _Symbolprecedes * 20 + _Sepbyspace * 40;
            }

            ::memcpy(_Pattern.field, _Ptr, sizeof(_Pattern.field));
        }

        void _Tidy() noexcept
        {
            ::free(const_cast<char*>(_Grouping));
            ::free(const_cast<_Elem*>(_Currencysign));
            ::free(const_cast<_Elem*>(_Plussign));
            ::free(const_cast<_Elem*>(_Minussign));
        }

        const char* _Grouping;
        _Elem _Decimalpoint;
        _Elem _Kseparator;
        const _Elem* _Currencysign;
        const _Elem* _Plussign;
        const _Elem* _Minussign;
        int _Fracdigits;
        pattern _Plusformat;
        pattern _Minusformat;
        bool _International;

        _Locinfo::_Cvtvec _Cvt;
    };

    template <class _Elem, bool _Intl = false> class moneypunct : public _Mpunct<_Elem>
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        __declspec(process) __declspec(dllimport) static const bool intl;
        __declspec(dllimport) static locale::id id;

        explicit moneypunct(size_t _Refs = 0) : _Mpunct<_Elem>(_Refs, _Intl)
        {
        }

        moneypunct(const _Locinfo& _Lobj, size_t _Refs = 0, bool _Isdef = false)
        : _Mpunct<_Elem>(_Lobj, _Refs, _Intl, _Isdef)
        {
        }

        static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new moneypunct<_Elem, _Intl>(_Locinfo(_Ploc->c_str()), 0, true);
            }

            return 3;
        }

    protected:
        moneypunct(const char* _Locname, size_t _Refs = 0) : _Mpunct<_Elem>(_Locname, _Refs, _Intl)
        {
        }

        virtual ~moneypunct() noexcept
        {
        }
    };

    template <class _Elem, bool _Intl> __declspec(process) const bool moneypunct<_Elem, _Intl>::intl = _Intl;

    template <class _Elem, bool _Intl> locale::id moneypunct<_Elem, _Intl>::id;

    template <class _Elem, bool _Intl = false> class moneypunct_byname : public moneypunct<_Elem, _Intl>
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        explicit moneypunct_byname(const char* _Locname, size_t _Refs = 0) : moneypunct<_Elem, _Intl>(_Locname, _Refs)
        {
        }

        explicit moneypunct_byname(const string& _Str, size_t _Refs = 0) : moneypunct<_Elem, _Intl>(_Str.c_str(), _Refs)
        {
        }

    protected:
        virtual ~moneypunct_byname() noexcept
        {
        }
    };

    template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
    class money_get : public locale::facet
    {
        using _Mypunct0 = moneypunct<_Elem, false>;
        using _Mypunct1 = moneypunct<_Elem, true>;

    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        using char_type = _Elem;
        using iter_type = _InIt;
        using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

        _InIt get(_InIt _First, _InIt _Last, bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State, long double& _Val) const
        {
            return do_get(_First, _Last, _Intl, _Iosbase, _State, _Val);
        }

        _InIt get(_InIt _First, _InIt _Last, bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State, string_type& _Val) const
        {
            return do_get(_First, _Last, _Intl, _Iosbase, _State, _Val);
        }

        __declspec(dllimport) static locale::id id;

        explicit money_get(size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        money_get(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new money_get<_Elem, _InIt>(_Locinfo(_Ploc->c_str()));
            }

            return 3;
        }

    protected:
        virtual ~money_get() noexcept
        {
        }

        void _Init(const _Locinfo&)
        {
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State, long double& _Val) const
        {
            _Elem _Atoms[sizeof("0123456789-")];
            string _Str = _Getmfld(_First, _Last, _Intl, _Iosbase, _Atoms);

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            if(_Str.size() == 0)
            {
                _State |= ios_base::failbit;
            }
            else
            {
                const char* _Eb = _Str.c_str();
                char* _Ep;
                int _Errno = 0;
                const long double _Ans = _Stodx_v2(_Eb, &_Ep, 0, &_Errno);

                if(_Ep == _Eb || _Errno != 0)
                {
                    _State |= ios_base::failbit;
                }
                else
                {
                    _Val = _Ans;
                }
            }
            return _First;
        }

        virtual _InIt do_get(_InIt _First, _InIt _Last, bool _Intl, ios_base& _Iosbase, ios_base::iostate& _State, string_type& _Val) const
        {
            _Elem _Atoms[sizeof("0123456789-")];
            string _Str = _Getmfld(_First, _Last, _Intl, _Iosbase, _Atoms);
            size_t _Len = _Str.size();

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            if(_Len == 0)
            {
                _State |= ios_base::failbit;
            }
            else
            {
                size_t _Idx = 0;
                _Val.resize(_Len);
                if(_Str[0] == '-')
                {
                    _Val[_Idx++] = _Atoms[10];
                }

                for(; _Idx < _Len; ++_Idx)
                {
                    _Val[_Idx] = _Atoms[_Str[_Idx] - '0'];
                }
            }
            return _First;
        }

    private:
        string _Getmfld(_InIt& _First, _InIt& _Last, bool _Intl, ios_base& _Iosbase, _Elem (&_Atoms)[12]) const
        {
            _Adl_verify_range(_First, _Last);
            const _Mpunct<_Elem>* _Ppunct_fac;
            if(_Intl)
            {
                _Ppunct_fac = ::std::addressof(::std::use_facet<_Mypunct1>(_Iosbase.getloc()));
            }
            else
            {
                _Ppunct_fac = ::std::addressof(::std::use_facet<_Mypunct0>(_Iosbase.getloc()));
            }

            bool _Bad = false, _Neg = false;
            string_type _Sign;
            const money_base::pattern _Pattern = _Ppunct_fac->neg_format();
            string _Val;
            size_t _Idx;
            static constexpr char _Src[] = "0123456789-";
            const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Iosbase.getloc());
            _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);

            for(size_t _Off = 0; !_Bad && _Off < 4; ++_Off)
            {
                switch(_Pattern.field[_Off])
                {
                    case money_base::symbol:
                    {
                        string_type _Symbol = _Ppunct_fac->curr_symbol();
                        typename string_type::const_iterator _Source;

                        if((!(_Iosbase.flags() & ios_base::showbase) && _First != _Last && *_First != *_Symbol.c_str())
                           || (_Off == 3 && _Sign.size() <= 1 && (_First == _Last || *_First != *_Symbol.c_str())))
                        {
                            _Symbol.erase();
                        }

                        _Source = _Symbol.begin();
                        while(_First != _Last && _Source != _Symbol.end() && *_First == *_Source)
                        {
                            ++_Source;
                            ++_First;
                        }

                        if(_Source != _Symbol.end())
                        {
                            _Bad = true;
                        }
                        break;
                    }

                    case money_base::sign:
                        if(_First != _Last)
                        {
                            if(0 < _Ppunct_fac->positive_sign().size() && _Ppunct_fac->positive_sign()[0] == *_First)
                            {
                                ++_First;
                                _Sign = _Ppunct_fac->positive_sign();
                            }
                            else if(0 < _Ppunct_fac->negative_sign().size() && _Ppunct_fac->negative_sign()[0] == *_First)
                            {
                                ++_First;
                                _Sign = _Ppunct_fac->negative_sign();
                                _Neg = true;
                            }
                            else if(0 != _Ppunct_fac->positive_sign().size() && 0 == _Ppunct_fac->negative_sign().size())
                            {
                                _Neg = true;
                            }
                        }

                        break;

                    case money_base::value:
                    {
                        int _Fracdigseen = 0;
                        int _Fracdigits = _Ppunct_fac->frac_digits();
                        const string _Grouping = _Ppunct_fac->grouping();
                        const _Elem _Kseparator = _Grouping.size() == 0 ? _Elem{} : _Ppunct_fac->thousands_sep();

                        if(_Kseparator == _Elem{} || 127 <= static_cast<unsigned char>(*_Grouping.c_str()))
                        {
                            for(; _First != _Last && (_Idx = _Find_elem(_Atoms, *_First)) < 10; ++_First)
                            {
                                _Val += _Src[_Idx];
                            }
                        }
                        else
                        {
                            string _Groups;
                            _Groups.push_back('\0');
                            size_t _Group = 0;

                            for(; _First != _Last; ++_First)
                            {
                                if((_Idx = _Find_elem(_Atoms, *_First)) < 10)
                                {
                                    _Val += _Src[_Idx];
                                    if(_Groups[_Group] != 127)
                                    {
                                        ++_Groups[_Group];
                                    }
                                }
                                else if(_Groups[_Group] == '\0' || *_First != _Kseparator)
                                {
                                    break;
                                }
                                else
                                {
                                    _Groups.push_back('\0');
                                    ++_Group;
                                }
                            }

                            if(_Group != 0)
                            {
                                if('\0' < _Groups[_Group])
                                {
                                    ++_Group;
                                }
                                else
                                {
                                    _Bad = true;
                                }
                            }

                            for(const char* _Pg = _Grouping.c_str(); !_Bad && 0 < _Group;)
                            {
                                if(*_Pg == 127)
                                {
                                    break;
                                }

                                if((0 < --_Group && *_Pg != _Groups[_Group]) || (0 == _Group && *_Pg < _Groups[_Group]))
                                {
                                    _Bad = true;
                                }
                                else if('\0' < _Pg[1])
                                {
                                    ++_Pg;
                                }
                            }

                            if(_Bad)
                            {
                                break;
                            }
                        }

                        const _Elem _Point = _Ppunct_fac->decimal_point();
                        if(_First != _Last && _Point != _Elem{} && *_First == _Point)
                        {
                            while(++_First != _Last && _Fracdigseen < _Fracdigits && (_Idx = _Find_elem(_Atoms, *_First)) < 10)
                            {
                                _Val += _Src[_Idx];
                                ++_Fracdigseen;
                            }

                            if(_Fracdigseen < _Fracdigits)
                            {
                                _Bad = true;
                            }
                        }

                        if(_Val.size() == 0)
                        {
                            _Bad = true;
                        }
                        else
                        {
                            for(; _Fracdigseen < _Fracdigits; ++_Fracdigseen)
                            {
                                _Val += '0';
                            }
                        }

                        break;
                    }

                    case money_base::space:
                    case money_base::none:
                    {
                        if(_Off == 3)
                        {
                            break;
                        }

                        bool _Seen = false;

                        for(; _First != _Last && _Ctype_fac.is(ctype_base::space, *_First); ++_First)
                        {
                            _Seen = true;
                        }

                        if(_Pattern.field[_Off] == money_base::space && !_Seen)
                        {
                            _Bad = true;
                        }
                    }
                }
            }

            if(!_Bad && 1 < _Sign.size())
            {
                auto _Source = _Sign.begin();

                while(++_Source != _Sign.end() && _First != _Last && *_First == *_Source)
                {
                    ++_First;
                }

                if(_Source != _Sign.end())
                {
                    _Bad = true;
                }
            }

            if(_Bad)
            {
                _Val.erase();
            }
            else if(_Neg)
            {
                _Val.insert(0, 1, '-');
            }

            return _Val;
        }
    };

    template <class _Elem, class _InIt> locale::id money_get<_Elem, _InIt>::id;

    template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
    class money_put : public locale::facet
    {
        using _Mypunct0 = moneypunct<_Elem, false>;
        using _Mypunct1 = moneypunct<_Elem, true>;

    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        using char_type = _Elem;
        using iter_type = _OutIt;
        using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

        _OutIt put(_OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill, long double _Val) const
        {
            return do_put(_Dest, _Intl, _Iosbase, _Fill, _Val);
        }

        _OutIt put(_OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill, const string_type& _Val) const
        {
            return do_put(_Dest, _Intl, _Iosbase, _Fill, _Val);
        }

        __declspec(dllimport) static locale::id id;

        explicit money_put(size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        money_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new money_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));
            }

            return 3;
        }

    protected:
        virtual ~money_put() noexcept
        {
        }

        void _Init(const _Locinfo&)
        {
        }

        virtual _OutIt do_put(_OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill, long double _Val) const
        {
            bool _Negative = false;
            if(_Val < 0)
            {
                _Negative = true;
                _Val = -_Val;
            }

            size_t _Exp;
            for(_Exp = 0; 1e35 <= _Val && _Exp < 5000; _Exp += 10)
            {
                _Val /= 1e10;
            }

            char _Buf[40];

            const auto _Count = static_cast<size_t>(::sprintf_s(_Buf, sizeof(_Buf), "%.0Lf", _Val));

            if(_Count < 0)
            {
                return _Dest;
            }

            const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Iosbase.getloc());
            const _Elem _E0 = _Ctype_fac.widen('0');

            string_type _Val2(_Count, _Elem{});
            _Ctype_fac.widen(&_Buf[0], &_Buf[_Count], &_Val2[0]);
            _Val2.append(_Exp, _E0);
            return _Putmfld(_Dest, _Intl, _Iosbase, _Fill, _Negative, _Val2, _E0);
        }

        virtual _OutIt do_put(_OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill, const string_type& _Val) const
        {
            static constexpr char _Src[] = "0123456789-";
            _Elem _Atoms[sizeof(_Src)];
            const ctype<_Elem>& _Ctype_fac = ::std::use_facet<ctype<_Elem>>(_Iosbase.getloc());
            _Ctype_fac.widen(&_Src[0], &_Src[sizeof(_Src)], _Atoms);

            bool _Negative = false;
            size_t _Idx0 = 0;
            if(!_Val.empty() && _Val[0] == _Atoms[10])
            {
                _Negative = true;
                ++_Idx0;
            }

            size_t _Size = _Val.size();
            size_t _Idx = _Idx0;
            for(; _Idx < _Size && _Find_elem(_Atoms, _Val[_Idx]) < 10; ++_Idx)
            {
            }

            string_type _Val2(&_Val[_Idx0], _Idx - _Idx0);
            if(_Val2.empty())
            {
                _Val2.push_back(_Atoms[0]);
            }

            return _Putmfld(_Dest, _Intl, _Iosbase, _Fill, _Negative, _Val2, _Atoms[0]);
        }

    private:
        _OutIt _Putmfld(_OutIt _Dest, bool _Intl, ios_base& _Iosbase, _Elem _Fill, bool _Neg, string_type _Val, _Elem _E0) const
        {
            const _Mpunct<_Elem>* _Ppunct_fac;
            if(_Intl)
            {
                _Ppunct_fac = ::std::addressof(::std::use_facet<_Mypunct1>(_Iosbase.getloc()));
            }
            else
            {
                _Ppunct_fac = ::std::addressof(::std::use_facet<_Mypunct0>(_Iosbase.getloc()));
            }

            const string _Grouping = _Ppunct_fac->grouping();
            int _Ifracdigits = _Ppunct_fac->frac_digits();
            const auto _Fracdigits = static_cast<unsigned int>(_Ifracdigits < 0 ? -_Ifracdigits : _Ifracdigits);

            if(_Val.size() <= _Fracdigits)
            {
                _Val.insert(0, _Fracdigits - _Val.size() + 1, _E0);
            }
            else if(*_Grouping.c_str() != 127 && '\0' < *_Grouping.c_str())
            {
                const _Elem _Kseparator = _Ppunct_fac->thousands_sep();
                const char* _Pg = _Grouping.c_str();
                size_t _Off = _Val.size() - _Fracdigits;

                while(*_Pg != 127 && '\0' < *_Pg && static_cast<size_t>(*_Pg) < _Off)
                {
                    _Val.insert(_Off -= *_Pg, 1, _Kseparator);
                    if('\0' < _Pg[1])
                    {
                        ++_Pg;
                    }
                }
            }

            money_base::pattern _Pattern;
            string_type _Sign;
            if(_Neg)
            {
                _Pattern = _Ppunct_fac->neg_format();
                _Sign = _Ppunct_fac->negative_sign();
            }
            else
            {
                _Pattern = _Ppunct_fac->pos_format();
                _Sign = _Ppunct_fac->positive_sign();
            }

            string_type _Symbol;
            if(_Iosbase.flags() & ios_base::showbase)
            {
                _Symbol = _Ppunct_fac->curr_symbol();
            }

            bool _Intern = false;
            size_t _Fillcount;
            size_t _Off;
            for(_Fillcount = 0, _Off = 0; _Off < 4; ++_Off)
            {
                switch(_Pattern.field[_Off])
                {
                    case money_base::symbol:
                        _Fillcount += _Symbol.size();
                        break;

                    case money_base::sign:
                        _Fillcount += _Sign.size();
                        break;

                    case money_base::value:
                        _Fillcount += _Val.size() + (0 < _Fracdigits ? 1 : 0)
                                      + (_Val.size() <= _Fracdigits ? _Fracdigits - _Val.size() + 1 : 0);
                        break;

                    case money_base::space:
                        ++_Fillcount;

                    case money_base::none:
                        if(_Off != 3)
                        {
                            _Intern = true;
                        }

                        break;
                }
            }

            if(_Iosbase.width() <= 0 || static_cast<size_t>(_Iosbase.width()) <= _Fillcount)
            {
                _Fillcount = 0;
            }
            else
            {
                _Fillcount = static_cast<size_t>(_Iosbase.width()) - _Fillcount;
            }

            ios_base::fmtflags _Afl = _Iosbase.flags() & ios_base::adjustfield;
            if(_Afl != ios_base::left && (_Afl != ios_base::internal || !_Intern))
            {
                _Dest = _Rep(_Dest, _Fill, _Fillcount);
                _Fillcount = 0;
            }

            for(_Off = 0; _Off < 4; ++_Off)
            {
                switch(_Pattern.field[_Off])
                {
                    case money_base::symbol:
                        _Dest = _Put(_Dest, _Symbol.begin(), _Symbol.size());
                        break;

                    case money_base::sign:
                        if(0 < _Sign.size())
                        {
                            _Dest = _Put(_Dest, _Sign.begin(), 1);
                        }

                        break;

                    case money_base::value:
                        if(_Fracdigits == 0)
                        {
                            _Dest = _Put(_Dest, _Val.begin(), _Val.size());
                        }
                        else if(_Val.size() <= _Fracdigits)
                        {
                            *_Dest++ = _E0;
                            *_Dest++ = _Ppunct_fac->decimal_point();
                            _Dest = _Rep(_Dest, _E0, _Fracdigits - _Val.size());
                            _Dest = _Put(_Dest, _Val.begin(), _Val.size());
                        }
                        else
                        {
                            _Dest = _Put(_Dest, _Val.begin(), _Val.size() - _Fracdigits);
                            *_Dest++ = _Ppunct_fac->decimal_point();
                            _Dest = _Put(_Dest, _Val.end() - static_cast<ptrdiff_t>(_Fracdigits), _Fracdigits);
                        }
                        break;

                    case money_base::space:
                        _Dest = _Rep(_Dest, _Fill, 1);

                    case money_base::none:
                        if(_Afl == ios_base::internal)
                        {
                            _Dest = _Rep(_Dest, _Fill, _Fillcount);
                            _Fillcount = 0;
                        }
                }
            }

            if(1 < _Sign.size())
            {
                _Dest = _Put(_Dest, _Sign.begin() + 1, _Sign.size() - 1);
            }

            _Iosbase.width(0);
            return _Rep(_Dest, _Fill, _Fillcount);
        }

        static _OutIt _Put(_OutIt _Dest, typename string_type::const_iterator _Source, size_t _Count)
        {
            for(; 0 < _Count; --_Count, (void)++_Dest, ++_Source)
            {
                *_Dest = *_Source;
            }

            return _Dest;
        }

        static _OutIt _Rep(_OutIt _Dest, _Elem _Ch, size_t _Count)
        {
            for(; 0 < _Count; --_Count, (void)++_Dest)
            {
                *_Dest = _Ch;
            }

            return _Dest;
        }
    };

    template <class _Elem, class _OutIt> locale::id money_put<_Elem, _OutIt>::id;

    template __declspec(process) const bool moneypunct<char, true>::intl;
    template __declspec(process) const bool moneypunct<char, false>::intl;
    template locale::id moneypunct<char, true>::id;
    template locale::id moneypunct<char, false>::id;
    template locale::id money_get<char, istreambuf_iterator<char, char_traits<char>>>::id;
    template locale::id money_put<char, ostreambuf_iterator<char, char_traits<char>>>::id;

    template __declspec(process) const bool moneypunct<wchar_t, true>::intl;
    template __declspec(process) const bool moneypunct<wchar_t, false>::intl;
    template locale::id moneypunct<wchar_t, true>::id;
    template locale::id moneypunct<wchar_t, false>::id;
    template locale::id money_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>::id;
    template locale::id money_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>::id;

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

__pragma(pack(push, 8)) extern "C"
{
    typedef long clock_t;

    struct _timespec32
    {
        __time32_t tv_sec;
        long tv_nsec;
    };

    struct _timespec64
    {
        __time64_t tv_sec;
        long tv_nsec;
    };

    struct timespec
    {
        time_t tv_sec;
        long tv_nsec;
    };

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_daylight"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) int* __cdecl __daylight(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_dstbias"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) long* __cdecl __dstbias(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_timezone"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) long* __cdecl __timezone(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_get_tzname"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char** __cdecl __tzname(void);

    __declspec(dllimport) errno_t __cdecl _get_daylight(int* _Daylight);

    __declspec(dllimport) errno_t __cdecl _get_dstbias(long* _DaylightSavingsBias);

    __declspec(dllimport) errno_t __cdecl _get_timezone(long* _TimeZone);

    __declspec(dllimport) errno_t __cdecl _get_tzname(size_t * _ReturnValue, char* _Buffer, size_t _SizeInBytes, int _Index);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "asctime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl asctime(struct tm const* _Tm);

    __declspec(dllimport) errno_t __cdecl asctime_s(char* _Buffer, size_t _SizeInBytes, struct tm const* _Tm);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl asctime_s(char (&_Buffer)[_Size], struct tm const* _Time) throw()
        {
            return asctime_s(_Buffer, _Size, _Time);
        }
    }

    __declspec(dllimport) clock_t __cdecl clock(void);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ctime32_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ctime32(__time32_t const* _Time);

    __declspec(dllimport) errno_t __cdecl _ctime32_s(char* _Buffer, size_t _SizeInBytes, __time32_t const* _Time);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _ctime32_s(char (&_Buffer)[_Size], __time32_t const* _Time) throw()
        {
            return _ctime32_s(_Buffer, _Size, _Time);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_ctime64_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _ctime64(__time64_t const* _Time);

    __declspec(dllimport) errno_t __cdecl _ctime64_s(char* _Buffer, size_t _SizeInBytes, __time64_t const* _Time);

    extern "C++"
    {
        template <size_t _Size>
        inline errno_t __cdecl _ctime64_s(char (&_Buffer)[_Size], __time64_t const* _Time) throw()
        {
            return _ctime64_s(_Buffer, _Size, _Time);
        }
    }

    __declspec(dllimport) double __cdecl _difftime32(__time32_t _Time1, __time32_t _Time2);

    __declspec(dllimport) double __cdecl _difftime64(__time64_t _Time1, __time64_t _Time2);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_gmtime32_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) struct tm* __cdecl _gmtime32(__time32_t const* _Time);

    __declspec(dllimport) errno_t __cdecl _gmtime32_s(struct tm * _Tm, __time32_t const* _Time);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_gmtime64_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) struct tm* __cdecl _gmtime64(__time64_t const* _Time);

    __declspec(dllimport) errno_t __cdecl _gmtime64_s(struct tm * _Tm, __time64_t const* _Time);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_localtime32_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) struct tm* __cdecl _localtime32(__time32_t const* _Time);

    __declspec(dllimport) errno_t __cdecl _localtime32_s(struct tm * _Tm, __time32_t const* _Time);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_localtime64_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) struct tm* __cdecl _localtime64(__time64_t const* _Time);

    __declspec(dllimport) errno_t __cdecl _localtime64_s(struct tm * _Tm, __time64_t const* _Time);

    __declspec(dllimport) __time32_t __cdecl _mkgmtime32(struct tm * _Tm);

    __declspec(dllimport) __time64_t __cdecl _mkgmtime64(struct tm * _Tm);

    __declspec(dllimport) __time32_t __cdecl _mktime32(struct tm * _Tm);

    __declspec(dllimport) __time64_t __cdecl _mktime64(struct tm * _Tm);

    __declspec(dllimport) size_t __cdecl strftime(char* _Buffer, size_t _SizeInBytes, char const* _Format, struct tm const* _Tm);

    __declspec(dllimport)
    size_t __cdecl _strftime_l(char* _Buffer, size_t _MaxSize, char const* _Format, struct tm const* _Tm, _locale_t _Locale);

    __declspec(dllimport) errno_t __cdecl _strdate_s(char* _Buffer, size_t _SizeInBytes);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _strdate_s(char (&_Buffer)[_Size]) throw()
        {
            return _strdate_s(_Buffer, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strdate_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strdate(char* _Buffer);

    __declspec(dllimport) errno_t __cdecl _strtime_s(char* _Buffer, size_t _SizeInBytes);

    extern "C++"
    {
        template <size_t _Size> inline errno_t __cdecl _strtime_s(char (&_Buffer)[_Size]) throw()
        {
            return _strtime_s(_Buffer, _Size);
        }
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "_strtime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) __declspec(dllimport) char* __cdecl _strtime(char* _Buffer);

    __declspec(dllimport) __time32_t __cdecl _time32(__time32_t * _Time);

    __declspec(dllimport) __time64_t __cdecl _time64(__time64_t * _Time);

    __declspec(dllimport) int __cdecl _timespec32_get(struct _timespec32 * _Ts, int _Base);

    __declspec(dllimport) int __cdecl _timespec64_get(struct _timespec64 * _Ts, int _Base);

    __declspec(dllimport) void __cdecl _tzset(void);

    __declspec(deprecated("This function or variable has been superceded by newer library "
                          "or operating system functionality. Consider using "
                          "GetLocalTime"
                          " "
                          "instead. See online help for details.")) __declspec(dllimport) unsigned __cdecl _getsystime(struct tm * _Tm);

    __declspec(deprecated(
    "This function or variable has been superceded by newer library "
    "or operating system functionality. Consider using "
    "SetLocalTime"
    " "
    "instead. See online help for details.")) __declspec(dllimport) unsigned __cdecl _setsystime(struct tm * _Tm, unsigned _Milliseconds);

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "ctime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) static __inline char* __cdecl ctime(time_t const* const _Time)
    {
#pragma warning(push)
#pragma warning(disable : 4996)
        return _ctime64(_Time);
#pragma warning(pop)
    }

    static __inline double __cdecl difftime(time_t const _Time1, time_t const _Time2)
    {
        return _difftime64(_Time1, _Time2);
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "gmtime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) static __inline struct tm* __cdecl gmtime(time_t const* const _Time)
    {
#pragma warning(push)
#pragma warning(disable : 4996)
        return _gmtime64(_Time);
#pragma warning(pop)
    }

    __declspec(deprecated("This function or variable may be unsafe. Consider using "
                          "localtime_s"
                          " instead. To disable deprecation, use _CRT_SECURE_NO_WARNINGS. "
                          "See online help for details.")) static __inline struct tm* __cdecl localtime(time_t const* const _Time)
    {
#pragma warning(push)
#pragma warning(disable : 4996)
        return _localtime64(_Time);
#pragma warning(pop)
    }

    static __inline time_t __cdecl _mkgmtime(struct tm* const _Tm)
    {
        return _mkgmtime64(_Tm);
    }

    static __inline time_t __cdecl mktime(struct tm* const _Tm)
    {
        return _mktime64(_Tm);
    }

    static __inline time_t __cdecl time(time_t* const _Time)
    {
        return _time64(_Time);
    }

    static __inline int __cdecl timespec_get(struct timespec* const _Ts, int const _Base)
    {
        return _timespec64_get((struct _timespec64*)_Ts, _Base);
    }

    static __inline errno_t __cdecl ctime_s(char* const _Buffer, size_t const _SizeInBytes, time_t const* const _Time)
    {
        return _ctime64_s(_Buffer, _SizeInBytes, _Time);
    }

    static __inline errno_t __cdecl gmtime_s(struct tm* const _Tm, time_t const* const _Time)
    {
        return _gmtime64_s(_Tm, _Time);
    }

    static __inline errno_t __cdecl localtime_s(struct tm* const _Tm, time_t const* const _Time)
    {
        return _localtime64_s(_Tm, _Time);
    }

    __declspec(deprecated("The POSIX name for this item is deprecated. Instead, use the ISO C "
                          "and C++ conformant name: "
                          "_tzset"
                          ". See online help for details.")) __declspec(dllimport) void __cdecl tzset(void);
}
__pragma(pack(pop))

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    using ::asctime;
    using ::clock;
    using ::clock_t;
    using ::ctime;
    using ::difftime;
    using ::gmtime;
    using ::localtime;
    using ::mktime;
    using ::size_t;
    using ::strftime;
    using ::time;
    using ::time_t;
    using ::tm;
}

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    struct __declspec(dllimport) time_base : locale::facet
    {
        enum dateorder
        {
            no_order,
            dmy,
            mdy,
            ymd,
            ydm
        };

        time_base(size_t _Refs = 0) : locale::facet(_Refs)
        {
        }

        ~time_base() noexcept
        {
        }
    };

    template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
    class time_get : public time_base
    {
    private:
        friend _Tidy_guard<time_get>;

    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        using char_type = _Elem;
        using iter_type = _InIt;
        using _Ctype = ctype<_Elem>;

        static locale::id id;

        dateorder date_order() const
        {
            return do_date_order();
        }

        _InIt get_time(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt) const
        {
            return do_get_time(_First, _Last, _Iosbase, _State, _Pt);
        }

        _InIt get_date(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt) const
        {
            return do_get_date(_First, _Last, _Iosbase, _State, _Pt);
        }

        _InIt get_weekday(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt) const
        {
            return do_get_weekday(_First, _Last, _Iosbase, _State, _Pt);
        }

        _InIt get_monthname(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt) const
        {
            return do_get_monthname(_First, _Last, _Iosbase, _State, _Pt);
        }

        _InIt get_year(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt) const
        {
            return do_get_year(_First, _Last, _Iosbase, _State, _Pt);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt, char _Specifier, char _Modifier = '\0') const
        {
            return do_get(_First, _Last, _Iosbase, _State, _Pt, _Specifier, _Modifier);
        }

        _InIt get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt, const _Elem* _Fmtfirst, const _Elem* _Fmtlast) const
        {
            _Adl_verify_range(_Fmtfirst, _Fmtlast);
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Iosbase.getloc());

            _State = ios_base::goodbit;

            for(; _Fmtfirst != _Fmtlast; ++_Fmtfirst)
            {
                if(_Ctype_fac.narrow(*_Fmtfirst) != '%')
                {
                    if(_Ctype_fac.is(_Ctype::space, *_Fmtfirst))
                    {
                        while(_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
                        {
                            ++_First;
                        }
                    }
                    else if(*_First != *_Fmtfirst)
                    {
                        _State |= ios_base::failbit;
                        break;
                    }
                    else
                    {
                        ++_First;
                    }
                }
                else if(++_Fmtfirst == _Fmtlast)
                {
                    if(*_First != _Fmtfirst[-1])
                    {
                        _State |= ios_base::failbit;
                    }
                    else
                    {
                        ++_First;
                    }
                    break;
                }
                else
                {
                    char _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                    char _Modifier = '\0';
                    _Elem _Percent = _Fmtfirst[-1];

                    if(_Specifier == 'E' || _Specifier == 'O' || _Specifier == 'Q' || _Specifier == '#')
                    {
                        if(++_Fmtfirst == _Fmtlast)
                        {
                            if(*_First != _Percent || ++_First == _Last || _Ctype_fac.narrow(*_First) != _Specifier)
                            {
                                _State |= ios_base::failbit;
                            }
                            else
                            {
                                ++_First;
                            }

                            break;
                        }
                        else
                        {
                            _Modifier = _Specifier;
                            _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                        }
                    }

                    _First = do_get(_First, _Last, _Iosbase, _State, _Pt, _Specifier, _Modifier);
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        explicit time_get(size_t _Refs = 0) : time_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        time_get(const _Locinfo& _Lobj, size_t _Refs = 0) : time_base(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new time_get<_Elem, _InIt>(_Locinfo(_Ploc->c_str()));
            }

            return 5;
        }

    protected:
        virtual ~time_get() noexcept
        {
            _Tidy();
        }

        time_get(const char* _Locname, size_t _Refs = 0) : time_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj(_Locname);
                _Init(_Lobj);
            }
        }

        template <class _Elem2> void _Getvals(_Elem2, const _Locinfo& _Lobj)
        {
            _Cvt = _Lobj._Getcvt();

            if(is_same_v<_Elem2, wchar_t>)
            {
                _Days = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getdays())));
                _Months = reinterpret_cast<const _Elem*>(_Maklocwcs(reinterpret_cast<const wchar_t*>(_Lobj._W_Getmonths())));
                _Ampm = reinterpret_cast<const _Elem*>(_Maklocwcs(L":AM:am:PM:pm"));
            }
            else
            {
                _Days = _Maklocstr(_Lobj._Getdays(), static_cast<_Elem*>(nullptr), _Cvt);
                _Months = _Maklocstr(_Lobj._Getmonths(), static_cast<_Elem*>(nullptr), _Cvt);
                _Ampm = _Maklocstr(":AM:am:PM:pm", static_cast<_Elem*>(nullptr), _Cvt);
            }
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Days = nullptr;
            _Months = nullptr;
            _Ampm = nullptr;

            _Tidy_guard<time_get> _Guard{ this };
            _Getvals(_Elem{}, _Lobj);
            _Dateorder = static_cast<dateorder>(_Lobj._Getdateorder());
            _Guard._Target = nullptr;
        }

        virtual dateorder do_date_order() const
        {
            return _Dateorder;
        }

        virtual _InIt do_get_time(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt) const
        {
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Iosbase.getloc());

            _State |= _Getint(_First, _Last, 0, 23, _Pt->tm_hour, _Ctype_fac);

            if(_State != ios_base::goodbit || _Ctype_fac.narrow(*_First) != ':')
            {
                _State |= ios_base::failbit;
            }
            else
            {
                _State |= _Getint(++_First, _Last, 0, 59, _Pt->tm_min, _Ctype_fac);
            }

            if(_State != ios_base::goodbit || _Ctype_fac.narrow(*_First) != ':')
            {
                _State |= ios_base::failbit;
            }
            else
            {
                _State |= _Getint(++_First, _Last, 0, 59, _Pt->tm_sec, _Ctype_fac);
            }

            return _First;
        }

        virtual _InIt do_get_date(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt) const
        {
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Iosbase.getloc());

            dateorder _Dorder = date_order();
            if(_Dorder == no_order)
            {
                _Dorder = mdy;
            }

            if(_First != _Last)
            {
                if(!_Ctype_fac.is(_Ctype::digit, *_First))
                {
                    _First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
                    _Dorder = mdy;
                }
                else if(_Dorder == mdy)
                {
                    _State |= _Getint(_First, _Last, 1, 12, _Pt->tm_mon, _Ctype_fac);
                    --_Pt->tm_mon;
                }
                else if(_Dorder == dmy)
                {
                    _State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
                }
                else
                {
                    _First = get_year(_First, _Last, _Iosbase, _State, _Pt);
                }
            }

            while(_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
            {
                ++_First;
            }

            if(_First != _Last)
            {
                char _Ch = _Ctype_fac.narrow(*_First);
                if(_Ch == ':' || _Ch == ',' || _Ch == '/')
                {
                    ++_First;
                }
            }

            while(_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
            {
                ++_First;
            }

            if(_First != _Last)
            {
                if(!_Ctype_fac.is(_Ctype::digit, *_First))
                {
                    if(_Dorder == mdy)
                    {
                        _State |= ios_base::failbit;
                    }
                    else
                    {
                        _First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
                        if(_Dorder == ydm)
                        {
                            _Dorder = ymd;
                        }
                    }
                }
                else if(_Dorder == dmy || _Dorder == ymd)
                {
                    _State |= _Getint(_First, _Last, 1, 12, _Pt->tm_mon, _Ctype_fac);
                    --_Pt->tm_mon;
                }
                else
                {
                    _State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
                }
            }

            while(_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
            {
                ++_First;
            }

            if(_First != _Last)
            {
                char _Ch = _Ctype_fac.narrow(*_First);
                if(_Ch == ':' || _Ch == ',' || _Ch == '/')
                {
                    ++_First;
                }
            }

            while(_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
            {
                ++_First;
            }

            if(_First == _Last)
            {
                _State |= ios_base::failbit;
            }
            else if(!_Ctype_fac.is(_Ctype::digit, *_First))
            {
                if(_Dorder != ydm)
                {
                    _State |= ios_base::failbit;
                }
                else
                {
                    _First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
                }
            }
            else if(_Dorder == ydm)
            {
                _State |= _Getint(_First, _Last, 1, 12, _Pt->tm_mon, _Ctype_fac);
                --_Pt->tm_mon;
            }
            else if(_Dorder == ymd)
            {
                _State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
            }
            else
            {
                _First = get_year(_First, _Last, _Iosbase, _State, _Pt);
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        virtual _InIt do_get_weekday(_InIt _First, _InIt _Last, ios_base&, ios_base::iostate& _State, tm* _Pt) const
        {
            int _Num = _Getloctxt(_First, _Last, 0, _Days);
            if(_Num < 0)
            {
                _State |= ios_base::failbit;
            }
            else
            {
                _Pt->tm_wday = _Num >> 1;
            }

            return _First;
        }

        virtual _InIt do_get_monthname(_InIt _First, _InIt _Last, ios_base&, ios_base::iostate& _State, tm* _Pt) const
        {
            int _Num = _Getloctxt(_First, _Last, 0, _Months);

            if(_Num < 0)
            {
                _State |= ios_base::failbit;
            }
            else
            {
                _Pt->tm_mon = _Num >> 1;
            }

            return _First;
        }

        virtual _InIt do_get_year(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt) const
        {
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Iosbase.getloc());

            int _Ans = 0;
            ios_base::iostate _Res = _Getint(_First, _Last, 0, 9999, _Ans, _Ctype_fac);

            _State |= _Res;
            if(!(_Res & ios_base::failbit))
            {
                if(_Ans < 69)
                {
                    _Pt->tm_year = _Ans + 100;
                }
                else if(_Ans < 100)
                {
                    _Pt->tm_year = _Ans;
                }
                else
                {
                    _Pt->tm_year = _Ans - 1900;
                }
            }

            return _First;
        }

        virtual _InIt
        do_get(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt, char _Specifier, char = 0) const
        {
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Iosbase.getloc());
            int _Ans = 0;

            _State = ios_base::goodbit;

            switch(_Specifier)
            {
                case 'a':
                case 'A':
                    _First = get_weekday(_First, _Last, _Iosbase, _State, _Pt);
                    break;

                case 'b':
                case 'B':
                case 'h':
                    _First = get_monthname(_First, _Last, _Iosbase, _State, _Pt);
                    break;

                case 'c':
                    _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%b %d %H : %M : %S %Y");
                    break;

                case 'C':
                    _State |= _Getint(_First, _Last, 0, 99, _Ans, _Ctype_fac);
                    if(!(_State & ios_base::failbit))
                    {
                        _Pt->tm_year = _Ans * 100 - 1900;
                    }

                    break;

                case 'd':
                case 'e':
                    _State |= _Getint(_First, _Last, 1, 31, _Pt->tm_mday, _Ctype_fac);
                    break;

                case 'D':
                    _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%m / %d / %y");
                    break;

                case 'H':
                    _State |= _Getint(_First, _Last, 0, 23, _Pt->tm_hour, _Ctype_fac);
                    break;

                case 'I':
                    _State |= _Getint(_First, _Last, 1, 12, _Ans, _Ctype_fac);
                    if(!(_State & ios_base::failbit))
                    {
                        _Pt->tm_hour = _Ans == 12 ? 0 : _Ans;
                    }

                    break;

                case 'j':
                    _State |= _Getint(_First, _Last, 1, 366, _Pt->tm_yday, _Ctype_fac);
                    break;

                case 'm':
                    _State |= _Getint(_First, _Last, 1, 12, _Ans, _Ctype_fac);
                    if(!(_State & ios_base::failbit))
                    {
                        _Pt->tm_mon = _Ans - 1;
                    }

                    break;

                case 'M':
                    _State |= _Getint(_First, _Last, 0, 59, _Pt->tm_min, _Ctype_fac);
                    break;

                case 'n':
                case 't':
                    _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, " ");
                    break;

                case 'p':
                    _Ans = _Getloctxt(_First, _Last, 0, ":AM:am:PM:pm");
                    if(_Ans < 0)
                    {
                        _State |= ios_base::failbit;
                    }
                    else if(1 < _Ans)
                    {
                        _Pt->tm_hour += 12;
                    }

                    break;

                case 'r':
                    _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%I : %M : %S %p");
                    break;

                case 'R':
                    _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%H : %M");
                    break;

                case 'S':
                    _State |= _Getint(_First, _Last, 0, 60, _Pt->tm_sec, _Ctype_fac);
                    break;

                case 'T':
                case 'X':
                    _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%H : %M : %S");
                    break;

                case 'U':
                    _State |= _Getint(_First, _Last, 0, 53, _Pt->tm_yday, _Ctype_fac);
                    break;

                case 'w':
                    _State |= _Getint(_First, _Last, 0, 6, _Pt->tm_wday, _Ctype_fac);
                    break;

                case 'W':
                    _State |= _Getint(_First, _Last, 0, 53, _Pt->tm_yday, _Ctype_fac);
                    break;

                case 'x':
                    _First = _Getfmt(_First, _Last, _Iosbase, _State, _Pt, "%d / %m / %y");
                    break;

                case 'y':
                    _State |= _Getint(_First, _Last, 0, 99, _Ans, _Ctype_fac);
                    if(!(_State & ios_base::failbit))
                    {
                        _Pt->tm_year = _Ans < 69 ? _Ans + 100 : _Ans;
                    }

                    break;

                case 'Y':
                    _First = get_year(_First, _Last, _Iosbase, _State, _Pt);
                    break;

                default:
                    _State |= ios_base::failbit;
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

        _InIt _Getfmt(_InIt _First, _InIt _Last, ios_base& _Iosbase, ios_base::iostate& _State, tm* _Pt, const char* _Fmtfirst) const
        {
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Iosbase.getloc());

            for(; *_Fmtfirst != '\0'; ++_Fmtfirst)
            {
                if(*_Fmtfirst == '%')
                {
                    _First = do_get(_First, _Last, _Iosbase, _State, _Pt, *++_Fmtfirst);
                }
                else if(*_Fmtfirst == ' ')
                {
                    while(_First != _Last && _Ctype_fac.is(_Ctype::space, *_First))
                    {
                        ++_First;
                    }
                }
                else if(_Ctype_fac.narrow(*_First) != *_Fmtfirst)
                {
                    _State |= ios_base::failbit;
                    break;
                }
                else
                {
                    ++_First;
                }
            }

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            return _First;
        }

    private:
        ios_base::iostate __cdecl _Getint(_InIt& _First, _InIt& _Last, int _Lo, int _Hi, int& _Val, const _Ctype& _Ctype_fac) const
        {
            char _Ac[32], *_Ep;
            char* _Ptr = _Ac;
            char _Ch;

            if(_First != _Last)
            {
                if((_Ch = _Ctype_fac.narrow(*_First)) == '+')
                {
                    *_Ptr++ = '+';
                    ++_First;
                }
                else if(_Ch == '-')
                {
                    *_Ptr++ = '-';
                    ++_First;
                }
            }

            bool _Seendigit = false;

            for(; _First != _Last && _Ctype_fac.narrow(*_First) == '0'; ++_First)
            {
                _Seendigit = true;
            }

            if(_Seendigit)
            {
                *_Ptr++ = '0';
            }

            for(char* const _Pe = &_Ac[32 - 1]; _First != _Last && '0' <= (_Ch = _Ctype_fac.narrow(*_First)) && _Ch <= '9';
                _Seendigit = true, (void)++_First)
            {
                *_Ptr = _Ch;
                if(_Ptr < _Pe)
                {
                    ++_Ptr;
                }
            }

            if(!_Seendigit)
            {
                _Ptr = _Ac;
            }

            *_Ptr = '\0';
            int _Errno = 0;
            const long _Ans = ::_Stolx(_Ac, &_Ep, 10, &_Errno);
            ios_base::iostate _State = ios_base::goodbit;

            if(_First == _Last)
            {
                _State |= ios_base::eofbit;
            }

            if(_Ep == _Ac || _Errno != 0 || _Ans < _Lo || _Hi < _Ans)
            {
                _State |= ios_base::failbit;
            }
            else
            {
                _Val = _Ans;
            }

            return _State;
        }

        void _Tidy() noexcept
        {
            ::free(const_cast<_Elem*>(_Days));
            ::free(const_cast<_Elem*>(_Months));
            ::free(const_cast<_Elem*>(_Ampm));
        }

        const _Elem* _Days;
        const _Elem* _Months;
        const _Elem* _Ampm;
        dateorder _Dateorder;
        _Locinfo::_Cvtvec _Cvt;
    };

    template <class _Elem, class _InIt> locale::id time_get<_Elem, _InIt>::id;

    template <class _Elem, class _InIt = istreambuf_iterator<_Elem, char_traits<_Elem>>>
    class time_get_byname : public time_get<_Elem, _InIt>
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        explicit time_get_byname(const char* _Locname, size_t _Refs = 0) : time_get<_Elem, _InIt>(_Locname, _Refs)
        {
        }

        explicit time_get_byname(const string& _Str, size_t _Refs = 0)
        : time_get<_Elem, _InIt>(_Locinfo(_Str.c_str()), _Refs)
        {
        }

    protected:
        virtual ~time_get_byname() noexcept
        {
        }
    };

    template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
    class time_put : public locale::facet
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        using char_type = _Elem;
        using iter_type = _OutIt;
        using _Ctype = ctype<_Elem>;

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const tm* _Pt, const _Elem* _Fmtfirst, const _Elem* _Fmtlast) const
        {
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Iosbase.getloc());

            for(; _Fmtfirst != _Fmtlast; ++_Fmtfirst)
            {
                if(_Ctype_fac.narrow(*_Fmtfirst) != '%')
                {
                    *_Dest++ = *_Fmtfirst;
                }
                else if(++_Fmtfirst == _Fmtlast)
                {
                    *_Dest++ = _Fmtfirst[-1];
                    break;
                }
                else
                {
                    char _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                    char _Modifier = '\0';
                    _Elem _Percent = _Fmtfirst[-1];

                    if(_Specifier == 'E' || _Specifier == 'O' || _Specifier == 'Q' || _Specifier == '#')
                    {
                        if(++_Fmtfirst == _Fmtlast)
                        {
                            *_Dest++ = _Percent;
                            *_Dest++ = _Specifier;
                            break;
                        }

                        _Modifier = _Specifier;
                        _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                    }

                    _Dest = do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier);
                }
            }

            return _Dest;
        }

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const tm* _Pt, char _Specifier, char _Modifier = '\0') const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier);
        }

        static locale::id id;

        explicit time_put(size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        time_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new time_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));
            }

            return 5;
        }

    protected:
        virtual ~time_put() noexcept
        {
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Tnames = _Lobj._Gettnames();
        }

        virtual _OutIt do_put(_OutIt _Dest, ios_base&, _Elem, const tm* _Pt, char _Specifier, char _Modifier = '\0') const
        {
            char _Fmt[5] = "!%x\0";
            size_t _Count;
            size_t _Num;
            string _Str;

            if(_Modifier == '\0')
            {
                _Fmt[2] = _Specifier;
            }
            else
            {
                _Fmt[2] = _Modifier;
                _Fmt[3] = _Specifier;
            }

            for(_Num = 16;; _Num *= 2)
            {
                _Str.append(_Num, '\0');
                if(0 < (_Count = _Strftime(&_Str[0], _Str.size(), _Fmt, _Pt, _Tnames._Getptr())))
                {
                    break;
                }
            }

            return ::std::copy(&_Str[1], &_Str[_Count], _Dest);
        }

    private:
        _Locinfo::_Timevec _Tnames;
    };

    template <class _Elem, class _OutIt> locale::id time_put<_Elem, _OutIt>::id;

    template <class _OutIt> class __declspec(dllimport) time_put<wchar_t, _OutIt> : public locale::facet
    {
    public:
        using _Elem = wchar_t;
        using char_type = _Elem;
        using iter_type = _OutIt;
        using _Ctype = ctype<_Elem>;

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const tm* _Pt, const _Elem* _Fmtfirst, const _Elem* _Fmtlast) const
        {
            const _Ctype& _Ctype_fac = ::std::use_facet<_Ctype>(_Iosbase.getloc());

            for(; _Fmtfirst != _Fmtlast; ++_Fmtfirst)
            {
                if(_Ctype_fac.narrow(*_Fmtfirst) != '%')
                {
                    *_Dest++ = *_Fmtfirst;
                }
                else if(++_Fmtfirst == _Fmtlast)
                {
                    *_Dest++ = _Fmtfirst[-1];
                    break;
                }
                else
                {
                    _Elem _Raw = *_Fmtfirst;
                    char _Specifier = _Ctype_fac.narrow(_Raw);
                    char _Modifier = '\0';
                    _Elem _Percent = _Fmtfirst[-1];

                    if(_Specifier == 'E' || _Specifier == 'O' || _Specifier == 'Q' || _Specifier == '#')
                    {
                        if(++_Fmtfirst == _Fmtlast)
                        {
                            *_Dest++ = _Percent;
                            *_Dest++ = _Raw;
                            break;
                        }

                        _Modifier = _Specifier;
                        _Specifier = _Ctype_fac.narrow(*_Fmtfirst);
                    }

                    _Dest = do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier);
                }
            }

            return _Dest;
        }

        _OutIt put(_OutIt _Dest, ios_base& _Iosbase, _Elem _Fill, const tm* _Pt, char _Specifier, char _Modifier = '\0') const
        {
            return do_put(_Dest, _Iosbase, _Fill, _Pt, _Specifier, _Modifier);
        }

        static locale::id id;

        explicit time_put(size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        time_put(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t __cdecl _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new time_put<_Elem, _OutIt>(_Locinfo(_Ploc->c_str()));
            }

            return 5;
        }

    protected:
        virtual ~time_put() noexcept
        {
        }

        time_put(const char* _Locname, size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj(_Locname);
                _Init(_Lobj);
            }
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Tnames = _Lobj._W_Gettnames();
        }

        virtual _OutIt do_put(_OutIt _Dest, ios_base&, _Elem, const tm* _Pt, char _Specifier, char _Modifier = '\0') const
        {
            wchar_t _Fmt[5] = L"!%x\0";
            size_t _Count;
            size_t _Num;
            wstring _Str;

            if(_Modifier == '\0')
            {
                _Fmt[2] = static_cast<_Elem>(_Specifier);
            }
            else
            {
                _Fmt[2] = static_cast<_Elem>(_Modifier);
                _Fmt[3] = static_cast<_Elem>(_Specifier);
            }

            for(_Num = 16;; _Num *= 2)
            {
                _Str.append(_Num, '\0');
                if(0 < (_Count = _Wcsftime(&_Str[0], _Str.size(), _Fmt, _Pt, _Tnames._Getptr())))
                {
                    break;
                }
            }
            return ::std::copy(&_Str[1], &_Str[_Count], _Dest);
        }

    private:
        _Locinfo::_Timevec _Tnames;
    };

    template <class _OutIt> locale::id time_put<wchar_t, _OutIt>::id;

    template <class _Elem, class _OutIt = ostreambuf_iterator<_Elem, char_traits<_Elem>>>
    class time_put_byname : public time_put<_Elem, _OutIt>
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        explicit time_put_byname(const char* _Locname, size_t _Refs = 0) : time_put<_Elem, _OutIt>(_Locname, _Refs)
        {
        }

        explicit time_put_byname(const string& _Str, size_t _Refs = 0) : time_put<_Elem, _OutIt>(_Str.c_str(), _Refs)
        {
        }

    protected:
        virtual ~time_put_byname() noexcept
        {
        }
    };

    template class __declspec(dllimport) time_get<char, istreambuf_iterator<char, char_traits<char>>>;
    template class __declspec(dllimport) time_put<char, ostreambuf_iterator<char, char_traits<char>>>;
    template void time_get<char, istreambuf_iterator<char, char_traits<char>>>::_Getvals(wchar_t, const _Locinfo&);

    template class __declspec(dllimport) time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
    template class __declspec(dllimport) time_put<wchar_t, ostreambuf_iterator<wchar_t, char_traits<wchar_t>>>;
    template void time_get<wchar_t, istreambuf_iterator<wchar_t, char_traits<wchar_t>>>::_Getvals(wchar_t, const _Locinfo&);

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Elem> struct _Fillobj
    {
        _Fillobj(_Elem _Ch) : _Fill(_Ch)
        {
        }

        _Elem _Fill;
    };

    template <class _Elem>[[nodiscard]] _Fillobj<_Elem> setfill(_Elem _Ch)
    {
        return _Fillobj<_Elem>(_Ch);
    }

    template <class _Elem, class _Traits, class _Elem2>
    basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, const _Fillobj<_Elem2>& _Manip)
    {
        static_assert(is_same_v<_Elem, _Elem2>, "wrong character type for setfill");

        _Istr.fill(_Manip._Fill);
        return _Istr;
    }

    template <class _Elem, class _Traits, class _Elem2>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Fillobj<_Elem2>& _Manip)
    {
        static_assert(is_same_v<_Elem, _Elem2>, "wrong character type for setfill");

        _Ostr.fill(_Manip._Fill);
        return _Ostr;
    }

    template <class _Money> struct _Monobj
    {
        _Monobj(_Money& _Val_arg, bool _Intl_arg) : _Val(_Val_arg), _Intl(_Intl_arg)
        {
        }

        _Money& _Val;
        bool _Intl;

        _Monobj& operator=(const _Monobj&) = delete;
    };

    template <class _Money>[[nodiscard]] _Monobj<_Money> get_money(_Money& _Val_arg, bool _Intl_arg = false)
    {
        return _Monobj<_Money>(_Val_arg, _Intl_arg);
    }

    template <class _Elem, class _Traits, class _Money>
    basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, const _Monobj<_Money>& _Manip)
    {
        using _Myis = basic_istream<_Elem, _Traits>;
        using _Iter = istreambuf_iterator<_Elem, _Traits>;
        using _Mymget = money_get<_Elem, _Iter>;

        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myis::sentry _Ok(_Istr);

        if(_Ok)
        {
            const _Mymget& _Mget_fac = ::std::use_facet<_Mymget>(_Istr.getloc());
            try
            {
                _Mget_fac.get(_Iter(_Istr.rdbuf()), _Iter(nullptr), _Manip._Intl, _Istr, _State, _Manip._Val);
            }
            catch(...)
            {
                (_Istr).setstate(ios_base::badbit, true);
            }
        }

        _Istr.setstate(_State);
        return _Istr;
    }

    template <class _Money>[[nodiscard]] _Monobj<const _Money> put_money(const _Money& _Val_arg, bool _Intl_arg = false)
    {
        return _Monobj<const _Money>(_Val_arg, _Intl_arg);
    }

    template <class _Elem, class _Traits, class _Money>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Monobj<_Money>& _Manip)
    {
        using _Myos = basic_ostream<_Elem, _Traits>;
        using _Iter = ostreambuf_iterator<_Elem, _Traits>;
        using _Mymput = money_put<_Elem, _Iter>;

        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myos::sentry _Ok(_Ostr);

        if(_Ok)
        {
            const _Mymput& _Mput_fac = ::std::use_facet<_Mymput>(_Ostr.getloc());
            try
            {
                if(_Mput_fac.put(_Iter(_Ostr.rdbuf()), _Manip._Intl, _Ostr, _Ostr.fill(), _Manip._Val).failed())
                {
                    _State |= ios_base::badbit;
                }
            }
            catch(...)
            {
                (_Ostr).setstate(ios_base::badbit, true);
            }
        }

        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Elem, class _Ptr> struct _Timeobj
    {
        _Timeobj(_Ptr _Tptr_arg, const _Elem* _Fmt_arg) : _Tptr(_Tptr_arg), _Fmtfirst(_Fmt_arg)
        {
            for(_Fmtlast = _Fmtfirst; *_Fmtlast != 0; ++_Fmtlast)
            {
            }
        }

        _Ptr _Tptr;
        const _Elem* _Fmtfirst;
        const _Elem* _Fmtlast;
    };

    template <class _Elem>[[nodiscard]] _Timeobj<_Elem, tm*> get_time(tm* _Tptr_arg, const _Elem* _Fmt_arg)
    {
        return _Timeobj<_Elem, tm*>(_Tptr_arg, _Fmt_arg);
    }

    template <class _Elem, class _Traits, class _Elem2>
    basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, const _Timeobj<_Elem2, tm*>& _Manip)
    {
        using _Myis = basic_istream<_Elem, _Traits>;
        using _Iter = istreambuf_iterator<_Elem, _Traits>;
        using _Mytget = time_get<_Elem2, _Iter>;

        static_assert(is_same_v<_Elem, _Elem2>, "wrong character type for get_time");

        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myis::sentry _Ok(_Istr);

        if(_Ok)
        {
            const _Mytget& _Tget_fac = ::std::use_facet<_Mytget>(_Istr.getloc());
            try
            {
                _Tget_fac.get(_Iter(_Istr.rdbuf()), _Iter(nullptr), _Istr, _State, _Manip._Tptr, _Manip._Fmtfirst,
                              _Manip._Fmtlast);
            }
            catch(...)
            {
                (_Istr).setstate(ios_base::badbit, true);
            }
        }

        _Istr.setstate(_State);
        return _Istr;
    }

    template <class _Elem>[[nodiscard]] _Timeobj<_Elem, const tm*> put_time(const tm* _Tptr_arg, const _Elem* _Fmt_arg)
    {
        return _Timeobj<_Elem, const tm*>(_Tptr_arg, _Fmt_arg);
    }

    template <class _Elem, class _Traits, class _Elem2>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Timeobj<_Elem2, const tm*>& _Manip)
    {
        using _Myos = basic_ostream<_Elem, _Traits>;
        using _Iter = ostreambuf_iterator<_Elem, _Traits>;
        using _Mytput = time_put<_Elem2, _Iter>;

        static_assert(is_same_v<_Elem, _Elem2>, "wrong character type for put_time");

        ios_base::iostate _State = ios_base::goodbit;
        const typename _Myos::sentry _Ok(_Ostr);

        if(_Ok)
        {
            const _Mytput& _Tput_fac = ::std::use_facet<_Mytput>(_Ostr.getloc());
            try
            {
                if(_Tput_fac
                   .put(_Iter(_Ostr.rdbuf()), _Ostr, _Ostr.fill(), _Manip._Tptr, _Manip._Fmtfirst, _Manip._Fmtlast)
                   .failed())
                {
                    _State |= ios_base::badbit;
                }
            }
            catch(...)
            {
                (_Ostr).setstate(ios_base::badbit, true);
            }
        }

        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Elem, class _Traits, class _Alloc> struct _Quote_in
    {
        using _Mystr = basic_string<_Elem, _Traits, _Alloc>;

        _Quote_in(_Mystr& _Str_obj, _Elem _Delim_obj, _Elem _Escape_obj)
        : _Str(_Str_obj), _Delim(_Delim_obj), _Escape(_Escape_obj)
        {
        }

        _Mystr& _Str;
        _Elem _Delim;
        _Elem _Escape;

        _Quote_in& operator=(const _Quote_in&) = delete;
    };

    template <class _Elem, class _Traits, class _Sizet> struct _Quote_out
    {
        _Quote_out(const _Elem* _Ptr_obj, _Sizet _Size_obj, _Elem _Delim_obj, _Elem _Escape_obj)
        : _Ptr(_Ptr_obj), _Size(_Size_obj), _Delim(_Delim_obj), _Escape(_Escape_obj)
        {
        }

        const _Elem* _Ptr;
        _Sizet _Size;
        _Elem _Delim;
        _Elem _Escape;

        _Quote_out& operator=(const _Quote_out&) = delete;
    };

    template <class _Elem>
    [[nodiscard]] _Quote_out<_Elem, void, size_t> quoted(const _Elem* _Ptr, _Elem _Delim = _Elem('"'), _Elem _Escape = _Elem('\\'))
    {
        size_t _Size = 0;
        while(_Ptr[_Size] != _Elem(0))
        {
            ++_Size;
        }

        return _Quote_out<_Elem, void, size_t>(_Ptr, _Size, _Delim, _Escape);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] _Quote_out<_Elem, _Traits, typename basic_string<_Elem, _Traits, _Alloc>::size_type>
    quoted(const basic_string<_Elem, _Traits, _Alloc>& _Str, _Elem _Delim = _Elem('"'), _Elem _Escape = _Elem('\\'))
    {
        using _Qobj = _Quote_out<_Elem, _Traits, typename basic_string<_Elem, _Traits, _Alloc>::size_type>;
        return _Qobj(_Str.c_str(), _Str.size(), _Delim, _Escape);
    }

    template <class _Elem, class _Traits, class _Alloc>
    [[nodiscard]] _Quote_in<_Elem, _Traits, _Alloc>
    quoted(basic_string<_Elem, _Traits, _Alloc>& _Str, _Elem _Delim = _Elem('"'), _Elem _Escape = _Elem('\\'))
    {
        return _Quote_in<_Elem, _Traits, _Alloc>(_Str, _Delim, _Escape);
    }

    template <class _Elem, class _Traits, class _QuTraits, class _Sizet>
    basic_ostream<_Elem, _Traits>&
    operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Quote_out<_Elem, _QuTraits, _Sizet>& _Manip)
    {
        static_assert(is_void_v<_QuTraits> || is_same_v<_QuTraits, _Traits>,
                      "quoted() traits must match basic_ostream traits");

        using _Myos = basic_ostream<_Elem, _Traits>;

        const _Elem* const _Last = _Manip._Ptr + _Manip._Size;

        _Sizet _Size = _Manip._Size + 2;
        for(const _Elem* _Ptr = _Manip._Ptr; _Ptr != _Last; ++_Ptr)
        {
            if(_Traits::eq(*_Ptr, _Manip._Delim) || _Traits::eq(*_Ptr, _Manip._Escape))
            {
                ++_Size;
            }
        }

        ios_base::iostate _State = ios_base::goodbit;

        _Sizet _Pad;
        if(_Ostr.width() <= 0 || static_cast<_Sizet>(_Ostr.width()) <= _Size)
        {
            _Pad = 0;
        }
        else
        {
            _Pad = static_cast<_Sizet>(_Ostr.width()) - _Size;
        }

        const typename _Myos::sentry _Ok(_Ostr);

        if(!_Ok)
        {
            _State |= ios_base::badbit;
        }
        else
        {
            try
            {
                if((_Ostr.flags() & ios_base::adjustfield) != ios_base::left)
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                            break;
                        }
                    }
                }

                if(_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Manip._Delim)))
                {
                    _State |= ios_base::badbit;
                }

                for(const _Elem* _Ptr = _Manip._Ptr; _Ptr != _Last; ++_Ptr)
                {
                    if((_Traits::eq(*_Ptr, _Manip._Delim) || _Traits::eq(*_Ptr, _Manip._Escape)) && _State == ios_base::goodbit
                       && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Manip._Escape)))
                    {
                        _State |= ios_base::badbit;
                        break;
                    }

                    if(_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(*_Ptr)))
                    {
                        _State |= ios_base::badbit;
                        break;
                    }
                }

                if(_State == ios_base::goodbit && _Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Manip._Delim)))
                {
                    _State |= ios_base::badbit;
                }

                if(_State == ios_base::goodbit)
                {
                    for(; 0 < _Pad; --_Pad)
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Ostr.rdbuf()->sputc(_Ostr.fill())))
                        {
                            _State |= ios_base::badbit;
                            break;
                        }
                    }
                }

                _Ostr.width(0);
            }
            catch(...)
            {
                (_Ostr).setstate(ios_base::badbit, true);
            }
        }

        _Ostr.setstate(_State);
        return _Ostr;
    }

    template <class _Elem, class _Traits, class _Alloc>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Quote_in<_Elem, _Traits, _Alloc>& _Manip)
    {
        using _Mystr = basic_string<_Elem, _Traits, _Alloc>;

        const _Mystr& _Ref = _Manip._Str;
        return _Ostr << ::std::quoted(_Ref, _Manip._Delim, _Manip._Escape);
    }

    template <class _Elem, class _Traits, class _Alloc>
    basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, const _Quote_in<_Elem, _Traits, _Alloc>& _Manip)
    {
        ios_base::iostate _State = ios_base::goodbit;
        const typename basic_istream<_Elem, _Traits>::sentry _Ok(_Istr);

        if(_Ok)
        {
            try
            {
                const auto _Buf = _Istr.rdbuf();
                auto& _Str = _Manip._Str;
                const auto _Delim = _Traits::to_int_type(_Manip._Delim);
                auto _Meta = _Buf->sgetc();

                if(!_Traits::eq_int_type(_Meta, _Delim))
                {
                    return _Istr >> _Str;
                }

                const auto _Escape = _Traits::to_int_type(_Manip._Escape);
                _Str.clear();
                for(;;)
                {
                    _Meta = _Buf->snextc();
                    if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                    {
                        _State = ios_base::eofbit | ios_base::failbit;
                        break;
                    }
                    else if(_Traits::eq_int_type(_Meta, _Escape))
                    {
                        _Meta = _Buf->snextc();
                        if(_Traits::eq_int_type(_Traits::eof(), _Meta))
                        {
                            _State = ios_base::eofbit | ios_base::failbit;
                            break;
                        }
                    }
                    else if(_Traits::eq_int_type(_Meta, _Delim))
                    {
                        if(_Traits::eq_int_type(_Traits::eof(), _Buf->sbumpc()))
                        {
                            _State = ios_base::eofbit;
                        }

                        break;
                    }

                    _Str.push_back(_Traits::to_char_type(_Meta));
                }
            }
            catch(...)
            {
                (_Istr).setstate(ios_base::badbit, true);
            }
        }

        _Istr.setstate(_State);
        return _Istr;
    }

    template <class _Arg> struct _Smanip
    {
        _Smanip(void(__cdecl* _Left)(ios_base&, _Arg), _Arg _Val) : _Pfun(_Left), _Manarg(_Val)
        {
        }

        void(__cdecl* _Pfun)(ios_base&, _Arg);
        _Arg _Manarg;
    };

    template <class _Elem, class _Traits, class _Arg>
    basic_istream<_Elem, _Traits>& operator>>(basic_istream<_Elem, _Traits>& _Istr, const _Smanip<_Arg>& _Manip)
    {
        (*_Manip._Pfun)(_Istr, _Manip._Manarg);
        return _Istr;
    }

    template <class _Elem, class _Traits, class _Arg>
    basic_ostream<_Elem, _Traits>& operator<<(basic_ostream<_Elem, _Traits>& _Ostr, const _Smanip<_Arg>& _Manip)
    {
        (*_Manip._Pfun)(_Ostr, _Manip._Manarg);
        return _Ostr;
    }

    [[nodiscard]] _Smanip<ios_base::fmtflags> __cdecl resetiosflags(ios_base::fmtflags);
    [[nodiscard]] _Smanip<ios_base::fmtflags> __cdecl setiosflags(ios_base::fmtflags);
    [[nodiscard]] _Smanip<int> __cdecl setbase(int);
    [[nodiscard]] _Smanip<streamsize> __cdecl setprecision(streamsize);
    [[nodiscard]] _Smanip<streamsize> __cdecl setw(streamsize);
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Myvec> class _Vector_const_iterator : public _Iterator_base
    {
    public:
        using iterator_category = random_access_iterator_tag;
        using value_type = typename _Myvec::value_type;
        using difference_type = typename _Myvec::difference_type;
        using pointer = typename _Myvec::const_pointer;
        using reference = const value_type&;

        using _Tptr = typename _Myvec::pointer;

        _Vector_const_iterator() noexcept : _Ptr()
        {
        }

        _Vector_const_iterator(_Tptr _Parg, const _Container_base* _Pvector) noexcept : _Ptr(_Parg)
        {
            this->_Adopt(_Pvector);
        }

        [[nodiscard]] reference operator*() const
        {
            return *_Ptr;
        }

        [[nodiscard]] pointer operator->() const
        {
            return _Ptr;
        }

        _Vector_const_iterator& operator++()
        {
            ++_Ptr;
            return *this;
        }

        _Vector_const_iterator operator++(int)
        {
            _Vector_const_iterator _Tmp = *this;
            ++*this;
            return _Tmp;
        }

        _Vector_const_iterator& operator--()
        {
            --_Ptr;
            return *this;
        }

        _Vector_const_iterator operator--(int)
        {
            _Vector_const_iterator _Tmp = *this;
            --*this;
            return _Tmp;
        }

        void _Verify_offset(const difference_type _Off) const
        {
            (void)_Off;
        }

        _Vector_const_iterator& operator+=(const difference_type _Off)
        {
            _Verify_offset(_Off);
            _Ptr += _Off;
            return *this;
        }

        [[nodiscard]] _Vector_const_iterator operator+(const difference_type _Off) const
        {
            _Vector_const_iterator _Tmp = *this;
            return _Tmp += _Off;
        }

        _Vector_const_iterator& operator-=(const difference_type _Off)
        {
            return *this += -_Off;
        }

        [[nodiscard]] _Vector_const_iterator operator-(const difference_type _Off) const
        {
            _Vector_const_iterator _Tmp = *this;
            return _Tmp -= _Off;
        }

        [[nodiscard]] difference_type operator-(const _Vector_const_iterator& _Right) const
        {
            _Compat(_Right);
            return _Ptr - _Right._Ptr;
        }

        [[nodiscard]] reference operator[](const difference_type _Off) const
        {
            return *(*this + _Off);
        }

        [[nodiscard]] bool operator==(const _Vector_const_iterator& _Right) const
        {
            _Compat(_Right);
            return _Ptr == _Right._Ptr;
        }

        [[nodiscard]] bool operator!=(const _Vector_const_iterator& _Right) const
        {
            return !(*this == _Right);
        }

        [[nodiscard]] bool operator<(const _Vector_const_iterator& _Right) const
        {
            _Compat(_Right);
            return _Ptr < _Right._Ptr;
        }

        [[nodiscard]] bool operator>(const _Vector_const_iterator& _Right) const
        {
            return _Right < *this;
        }

        [[nodiscard]] bool operator<=(const _Vector_const_iterator& _Right) const
        {
            return !(_Right < *this);
        }

        [[nodiscard]] bool operator>=(const _Vector_const_iterator& _Right) const
        {
            return !(*this < _Right);
        }

        void _Compat(const _Vector_const_iterator& _Right) const
        {
            (void)_Right;
        }

        using _Prevent_inheriting_unwrap = _Vector_const_iterator;

        [[nodiscard]] const value_type* _Unwrapped() const
        {
            return _Unfancy(_Ptr);
        }

        void _Seek_to(const value_type* _It)
        {
            _Ptr = _Refancy<_Tptr>(const_cast<value_type*>(_It));
        }

        _Tptr _Ptr;
    };

    template <class _Myvec>
    [[nodiscard]] _Vector_const_iterator<_Myvec>
    operator+(typename _Vector_const_iterator<_Myvec>::difference_type _Off, _Vector_const_iterator<_Myvec> _Next)
    {
        return _Next += _Off;
    }

    template <class _Myvec> class _Vector_iterator : public _Vector_const_iterator<_Myvec>
    {
    public:
        using _Mybase = _Vector_const_iterator<_Myvec>;

        using iterator_category = random_access_iterator_tag;
        using value_type = typename _Myvec::value_type;
        using difference_type = typename _Myvec::difference_type;
        using pointer = typename _Myvec::pointer;
        using reference = value_type&;

        using _Mybase::_Mybase;

        [[nodiscard]] reference operator*() const
        {
            return const_cast<reference>(_Mybase::operator*());
        }

        [[nodiscard]] pointer operator->() const
        {
            return _Const_cast(_Mybase::operator->());
        }

        _Vector_iterator& operator++()
        {
            _Mybase::operator++();
            return *this;
        }

        _Vector_iterator operator++(int)
        {
            _Vector_iterator _Tmp = *this;
            _Mybase::operator++();
            return _Tmp;
        }

        _Vector_iterator& operator--()
        {
            _Mybase::operator--();
            return *this;
        }

        _Vector_iterator operator--(int)
        {
            _Vector_iterator _Tmp = *this;
            _Mybase::operator--();
            return _Tmp;
        }

        _Vector_iterator& operator+=(const difference_type _Off)
        {
            _Mybase::operator+=(_Off);
            return *this;
        }

        [[nodiscard]] _Vector_iterator operator+(const difference_type _Off) const
        {
            _Vector_iterator _Tmp = *this;
            return _Tmp += _Off;
        }

        _Vector_iterator& operator-=(const difference_type _Off)
        {
            _Mybase::operator-=(_Off);
            return *this;
        }

        using _Mybase::operator-;

        [[nodiscard]] _Vector_iterator operator-(const difference_type _Off) const
        {
            _Vector_iterator _Tmp = *this;
            return _Tmp -= _Off;
        }

        [[nodiscard]] reference operator[](const difference_type _Off) const
        {
            return const_cast<reference>(_Mybase::operator[](_Off));
        }

        using _Prevent_inheriting_unwrap = _Vector_iterator;

        [[nodiscard]] value_type* _Unwrapped() const
        {
            return _Unfancy(this->_Ptr);
        }
    };

    template <class _Myvec>
    [[nodiscard]] _Vector_iterator<_Myvec>
    operator+(typename _Vector_iterator<_Myvec>::difference_type _Off, _Vector_iterator<_Myvec> _Next)
    {
        return _Next += _Off;
    }

    template <class _Value_type, class _Size_type, class _Difference_type, class _Pointer, class _Const_pointer, class _Reference, class _Const_reference>
    struct _Vec_iter_types
    {
        using value_type = _Value_type;
        using size_type = _Size_type;
        using difference_type = _Difference_type;
        using pointer = _Pointer;
        using const_pointer = _Const_pointer;
    };

    struct _Value_init_tag
    {
    };

    template <class _Val_types> class _Vector_val : public _Container_base
    {
    public:
        using value_type = typename _Val_types::value_type;
        using size_type = typename _Val_types::size_type;
        using difference_type = typename _Val_types::difference_type;
        using pointer = typename _Val_types::pointer;
        using const_pointer = typename _Val_types::const_pointer;
        using reference = value_type&;
        using const_reference = const value_type&;

        _Vector_val() noexcept : _Myfirst(), _Mylast(), _Myend()
        {
        }

        void _Swap_val(_Vector_val& _Right) noexcept
        {
            this->_Swap_proxy_and_iterators(_Right);
            _Swap_adl(_Myfirst, _Right._Myfirst);
            _Swap_adl(_Mylast, _Right._Mylast);
            _Swap_adl(_Myend, _Right._Myend);
        }

        void _Take_contents(_Vector_val& _Right) noexcept
        {
            this->_Swap_proxy_and_iterators(_Right);
            _Myfirst = _Right._Myfirst;
            _Mylast = _Right._Mylast;
            _Myend = _Right._Myend;

            _Right._Myfirst = pointer();
            _Right._Mylast = pointer();
            _Right._Myend = pointer();
        }

        pointer _Myfirst;
        pointer _Mylast;
        pointer _Myend;
    };

    template <class _Ptrty> auto _Unfancy_maybe_null(_Ptrty _Ptr)
    {
        return _Ptr ? ::std::addressof(*_Ptr) : nullptr;
    }

    template <class _Ty> _Ty* _Unfancy_maybe_null(_Ty* _Ptr)
    {
        return _Ptr;
    }

    template <class _Ty, class _Alloc = allocator<_Ty>> class vector
    {
    private:
        template <class> friend class _Vb_val;
        friend _Tidy_guard<vector>;

        using _Alty = _Rebind_alloc_t<_Alloc, _Ty>;
        using _Alty_traits = allocator_traits<_Alty>;

    public:
        static_assert(!0 || is_same_v<_Ty, typename _Alloc::value_type>,
                      "vector<T, Allocator>"
                      " requires that Allocator's value_type match "
                      "T"
                      " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)"
                      " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0"
                      " to suppress this diagnostic.");

        using value_type = _Ty;
        using allocator_type = _Alloc;
        using pointer = typename _Alty_traits::pointer;
        using const_pointer = typename _Alty_traits::const_pointer;
        using reference = _Ty&;
        using const_reference = const _Ty&;
        using size_type = typename _Alty_traits::size_type;
        using difference_type = typename _Alty_traits::difference_type;

    private:
        using _Scary_val
        = _Vector_val<conditional_t<_Is_simple_alloc_v<_Alty>, _Simple_types<_Ty>, _Vec_iter_types<_Ty, size_type, difference_type, pointer, const_pointer, _Ty&, const _Ty&>>>;

    public:
        using iterator = _Vector_iterator<_Scary_val>;
        using const_iterator = _Vector_const_iterator<_Scary_val>;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;

        vector() noexcept(is_nothrow_default_constructible_v<_Alty>) : _Mypair(_Zero_then_variadic_args_t())
        {
            _Mypair._Myval2._Alloc_proxy(_Fake_allocator());
        }

        explicit vector(const _Alloc& _Al) noexcept : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            _Mypair._Myval2._Alloc_proxy(_Fake_allocator());
        }

    private:
        template <class _Ty2> void _Construct_n_copies_of_ty(const size_type _Count, const _Ty2& _Val)
        {
            auto&& _Alproxy = _Fake_allocator();
            auto& _My_data = _Mypair._Myval2;
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
            if(_Count != 0)
            {
                _Buy_nonzero(_Count);
                _Tidy_guard<vector> _Guard{ this };
                _My_data._Mylast = _Ufill(_My_data._Myfirst, _Count, _Val);
                _Guard._Target = nullptr;
            }

            _Proxy._Release();
        }

    public:
        explicit vector(const size_type _Count, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            _Construct_n_copies_of_ty(_Count, _Value_init_tag{});
        }

        vector(const size_type _Count, const _Ty& _Val, const _Alloc& _Al = _Alloc())
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            _Construct_n_copies_of_ty(_Count, _Val);
        }

    private:
        template <class _Iter> void _Range_construct_or_tidy(_Iter _First, _Iter _Last, input_iterator_tag)
        {
            _Tidy_guard<vector> _Guard{ this };
            for(; _First != _Last; ++_First)
            {
                emplace_back(*_First);
            }

            _Guard._Target = nullptr;
        }

        template <class _Iter> void _Range_construct_or_tidy(_Iter _First, _Iter _Last, forward_iterator_tag)
        {
            const auto _Count = _Convert_size<size_type>(static_cast<size_t>(::std::distance(_First, _Last)));
            if(_Count != 0)
            {
                _Buy_nonzero(_Count);
                _Tidy_guard<vector> _Guard{ this };
                auto& _My_data = _Mypair._Myval2;
                _My_data._Mylast = _Ucopy(_First, _Last, _My_data._Myfirst);
                _Guard._Target = nullptr;
            }
        }

    public:
        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
        vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Adl_verify_range(_First, _Last);
            _Range_construct_or_tidy(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
            _Proxy._Release();
        }

        vector(initializer_list<_Ty> _Ilist, const _Alloc& _Al = _Alloc()) : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Range_construct_or_tidy(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
            _Proxy._Release();
        }

        vector(const vector& _Right)
        : _Mypair(_One_then_variadic_args_t(), _Alty_traits::select_on_container_copy_construction(_Right._Getal()))
        {
            auto&& _Alproxy = _Fake_allocator();
            auto& _My_data = _Mypair._Myval2;
            const auto& _Right_data = _Right._Mypair._Myval2;
            const pointer _Rightfirst = _Right_data._Myfirst;
            const pointer _Rightlast = _Right_data._Mylast;
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
            if(_Rightfirst != _Rightlast)
            {
                _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));
                _Tidy_guard<vector> _Guard{ this };
                _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);
                _Guard._Target = nullptr;
            }

            _Proxy._Release();
        }

        vector(const vector& _Right, const _Alloc& _Al) : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            auto& _My_data = _Mypair._Myval2;
            const auto& _Right_data = _Right._Mypair._Myval2;
            const pointer _Rightfirst = _Right_data._Myfirst;
            const pointer _Rightlast = _Right_data._Mylast;
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _My_data);
            if(_Rightfirst != _Rightlast)
            {
                _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));
                _Tidy_guard<vector> _Guard{ this };
                _My_data._Mylast = _Ucopy(_Rightfirst, _Rightlast, _My_data._Myfirst);
                _Guard._Target = nullptr;
            }

            _Proxy._Release();
        }

    private:
        void _Move_construct(vector& _Right, true_type) noexcept
        {
            _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
        }

        void _Move_construct(vector& _Right, false_type)
        {
            if constexpr(!_Alty_traits::is_always_equal::value)
            {
                if(_Getal() != _Right._Getal())
                {
                    const auto& _Right_data = _Right._Mypair._Myval2;
                    const pointer _Rightfirst = _Right_data._Myfirst;
                    const pointer _Rightlast = _Right_data._Mylast;
                    if(_Rightfirst != _Rightlast)
                    {
                        _Buy_raw(static_cast<size_type>(_Rightlast - _Rightfirst));
                        _Tidy_guard<vector> _Guard{ this };
                        auto& _My_data = _Mypair._Myval2;
                        _My_data._Mylast = _Umove(_Rightfirst, _Rightlast, _My_data._Myfirst);
                        _Guard._Target = nullptr;
                    }
                    return;
                }
            }

            _Move_construct(_Right, true_type{});
        }

    public:
        vector(vector&& _Right) noexcept : _Mypair(_One_then_variadic_args_t(), ::std::move(_Right._Getal()))
        {
            _Mypair._Myval2._Alloc_proxy(_Fake_allocator());
            _Move_construct(_Right, true_type{});
        }

        vector(vector&& _Right, const _Alloc& _Al) noexcept(_Alty_traits::is_always_equal::value)
        : _Mypair(_One_then_variadic_args_t(), _Al)
        {
            auto&& _Alproxy = _Fake_allocator();
            _Container_proxy_ptr<_Alty> _Proxy(_Alproxy, _Mypair._Myval2);
            _Move_construct(_Right, typename _Alty_traits::is_always_equal::type{});
            _Proxy._Release();
        }

    private:
        void _Move_assign(vector& _Right, _Equal_allocators) noexcept
        {
            _Tidy();
            _Pocma(_Getal(), _Right._Getal());
            _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
        }

        void _Move_assign(vector& _Right, _Propagate_allocators) noexcept
        {
            _Tidy();

            _Pocma(_Getal(), _Right._Getal());
            _Mypair._Myval2._Take_contents(_Right._Mypair._Myval2);
        }

        void _Move_assign(vector& _Right, _No_propagate_allocators)
        {
            if(_Getal() == _Right._Getal())
            {
                _Move_assign(_Right, _Equal_allocators{});
            }
            else
            {
                auto& _Right_data = _Right._Mypair._Myval2;
                const pointer _First = _Right_data._Myfirst;
                const pointer _Last = _Right_data._Mylast;
                const auto _Newsize = static_cast<size_type>(_Last - _First);

                auto& _My_data = _Mypair._Myval2;
                pointer& _Myfirst = _My_data._Myfirst;
                pointer& _Mylast = _My_data._Mylast;

                _My_data._Orphan_all();

                const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);

                if constexpr(conjunction_v<bool_constant<_Ptr_copy_cat<_Ty*, _Ty*>::_Trivially_copyable>,
                                           _Uses_default_construct<_Alty, _Ty*, _Ty>, _Uses_default_destroy<_Alty, _Ty*>>)
                {
                    if(_Newsize > _Oldcapacity)
                    {
                        _Clear_and_reserve_geometric(_Newsize);
                    }

                    _Mylast = _Refancy<pointer>(_Copy_memmove(_Unfancy(_First), _Unfancy(_Last), _Unfancy(_Myfirst)));
                }
                else
                {
                    auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

                    if(_Newsize > _Oldsize)
                    {
                        if(_Newsize > _Oldcapacity)
                        {
                            _Clear_and_reserve_geometric(_Newsize);
                            _Oldsize = 0;
                        }

                        const pointer _Mid = _First + _Oldsize;
                        _Move_unchecked(_First, _Mid, _Myfirst);
                        _Mylast = _Umove(_Mid, _Last, _Mylast);
                    }
                    else
                    {
                        const pointer _Newlast = _Myfirst + _Newsize;
                        _Move_unchecked(_First, _Last, _Myfirst);
                        _Destroy(_Newlast, _Mylast);
                        _Mylast = _Newlast;
                    }
                }
            }
        }

    public:
        vector& operator=(vector&& _Right) noexcept(noexcept(_Move_assign(_Right, _Choose_pocma<_Alty>{})))
        {
            if(this != ::std::addressof(_Right))
            {
                _Move_assign(_Right, _Choose_pocma<_Alty>{});
            }

            return *this;
        }

        ~vector() noexcept
        {
            _Tidy();
        }

    private:
        template <class... _Valty> decltype(auto) _Emplace_back_with_unused_capacity(_Valty&&... _Val)
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Mylast = _My_data._Mylast;
            ;
            _Alty_traits::construct(_Getal(), _Unfancy(_Mylast), ::std::forward<_Valty>(_Val)...);
            _Orphan_range(_Mylast, _Mylast);
            _Ty& _Result = *_Mylast;
            ++_Mylast;

            (void)_Result;
        }

    public:
        template <class... _Valty> decltype(auto) emplace_back(_Valty&&... _Val)
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Mylast = _My_data._Mylast;
            if(_Mylast != _My_data._Myend)
            {
                return _Emplace_back_with_unused_capacity(::std::forward<_Valty>(_Val)...);
            }

            _Ty& _Result = *_Emplace_reallocate(_Mylast, ::std::forward<_Valty>(_Val)...);

            (void)_Result;
        }

        void push_back(const _Ty& _Val)
        {
            emplace_back(_Val);
        }

        void push_back(_Ty&& _Val)
        {
            emplace_back(::std::move(_Val));
        }

        template <class... _Valty> pointer _Emplace_reallocate(const pointer _Whereptr, _Valty&&... _Val)
        {
            _Alty& _Al = _Getal();
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;

            ;

            const auto _Whereoff = static_cast<size_type>(_Whereptr - _Myfirst);
            const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

            if(_Oldsize == max_size())
            {
                _Xlength();
            }

            const size_type _Newsize = _Oldsize + 1;
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec = _Al.allocate(_Newcapacity);
            const pointer _Constructed_last = _Newvec + _Whereoff + 1;
            pointer _Constructed_first = _Constructed_last;

            try
            {
                _Alty_traits::construct(_Al, _Unfancy(_Newvec + _Whereoff), ::std::forward<_Valty>(_Val)...);
                _Constructed_first = _Newvec + _Whereoff;

                if(_Whereptr == _Mylast)
                {
                    _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
                }
                else
                {
                    _Umove(_Myfirst, _Whereptr, _Newvec);
                    _Constructed_first = _Newvec;
                    _Umove(_Whereptr, _Mylast, _Newvec + _Whereoff + 1);
                }
            }
            catch(...)
            {
                _Destroy(_Constructed_first, _Constructed_last);
                _Al.deallocate(_Newvec, _Newcapacity);
                throw;
            }

            _Change_array(_Newvec, _Newsize, _Newcapacity);
            return _Newvec + _Whereoff;
        }

        template <class... _Valty> iterator emplace(const_iterator _Where, _Valty&&... _Val)
        {
            const pointer _Whereptr = _Where._Ptr;
            auto& _My_data = _Mypair._Myval2;
            const pointer _Oldlast = _My_data._Mylast;

            if(_Oldlast != _My_data._Myend)
            {
                if(_Whereptr == _Oldlast)
                {
                    _Emplace_back_with_unused_capacity(::std::forward<_Valty>(_Val)...);
                }
                else
                {
                    auto& _Al = _Getal();
                    _Alloc_temporary<_Alty> _Obj(_Al, ::std::forward<_Valty>(_Val)...);

                    _Orphan_range(_Whereptr, _Oldlast);
                    _Alty_traits::construct(_Al, _Unfancy(_Oldlast), ::std::move(_Oldlast[-1]));
                    ++_My_data._Mylast;
                    _Move_backward_unchecked(_Whereptr, _Oldlast - 1, _Oldlast);
                    *_Whereptr = ::std::move(_Obj._Storage._Value);
                }

                return _Make_iterator(_Whereptr);
            }

            return _Make_iterator(_Emplace_reallocate(_Whereptr, ::std::forward<_Valty>(_Val)...));
        }

        iterator insert(const_iterator _Where, const _Ty& _Val)
        {
            return emplace(_Where, _Val);
        }

        iterator insert(const_iterator _Where, _Ty&& _Val)
        {
            return emplace(_Where, ::std::move(_Val));
        }

        iterator insert(const_iterator _Where, const size_type _Count, const _Ty& _Val)
        {
            const pointer _Whereptr = _Where._Ptr;

            auto& _My_data = _Mypair._Myval2;
            pointer& _Mylast = _My_data._Mylast;

            const pointer _Oldfirst = _My_data._Myfirst;
            const pointer _Oldlast = _Mylast;

            const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);
            const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);
            const bool _One_at_back = _Count == 1 && _Whereptr == _Oldlast;
            if(_Count == 0)
            {
            }
            else if(_Count > _Unused_capacity)
            {
                const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

                if(_Count > max_size() - _Oldsize)
                {
                    _Xlength();
                }

                const size_type _Newsize = _Oldsize + _Count;
                const size_type _Newcapacity = _Calculate_growth(_Newsize);

                const pointer _Newvec = _Getal().allocate(_Newcapacity);
                const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
                pointer _Constructed_first = _Constructed_last;

                try
                {
                    _Ufill(_Newvec + _Whereoff, _Count, _Val);
                    _Constructed_first = _Newvec + _Whereoff;

                    if(_One_at_back)
                    {
                        _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
                    }
                    else
                    {
                        _Umove(_Oldfirst, _Whereptr, _Newvec);
                        _Constructed_first = _Newvec;
                        _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
                    }
                }
                catch(...)
                {
                    _Destroy(_Constructed_first, _Constructed_last);
                    _Getal().deallocate(_Newvec, _Newcapacity);
                    throw;
                }

                _Change_array(_Newvec, _Newsize, _Newcapacity);
            }
            else if(_One_at_back)
            {
                _Emplace_back_with_unused_capacity(_Val);
            }
            else
            {
                const _Alloc_temporary<_Alty> _Tmp_storage(_Getal(), _Val);
                const auto& _Tmp = _Tmp_storage._Storage._Value;
                const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);
                _Orphan_range(_Whereptr, _Oldlast);

                if(_Count > _Affected_elements)
                {
                    _Mylast = _Ufill(_Oldlast, _Count - _Affected_elements, _Tmp);
                    _Mylast = _Umove(_Whereptr, _Oldlast, _Mylast);
                    ::std::fill(_Whereptr, _Oldlast, _Tmp);
                }
                else
                {
                    _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                    _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                    ::std::fill(_Whereptr, _Whereptr + _Count, _Tmp);
                }
            }

            return _Make_iterator_offset(_Whereoff);
        }

    private:
        template <class _Iter> void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
        {
            if(_First == _Last)
            {
                return;
            }

            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;
            const auto _Whereoff = static_cast<size_type>(_Where._Ptr - _Myfirst);
            const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

            for(; _First != _Last; ++_First)
            {
                emplace_back(*_First);
            }

            _Orphan_range(_Myfirst + _Whereoff, _Myfirst + _Oldsize);

            ::std::rotate(_Myfirst + _Whereoff, _Myfirst + _Oldsize, _Mylast);
        }

        template <class _Iter>
        void _Insert_range(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
        {
            const pointer _Whereptr = _Where._Ptr;
            const auto _Count = _Convert_size<size_type>(static_cast<size_t>(::std::distance(_First, _Last)));

            auto& _My_data = _Mypair._Myval2;
            pointer& _Mylast = _My_data._Mylast;

            const pointer _Oldfirst = _My_data._Myfirst;
            const pointer _Oldlast = _Mylast;
            const auto _Unused_capacity = static_cast<size_type>(_My_data._Myend - _Oldlast);

            if(_Count == 0)
            {
            }
            else if(_Count > _Unused_capacity)
            {
                const auto _Oldsize = static_cast<size_type>(_Oldlast - _Oldfirst);

                if(_Count > max_size() - _Oldsize)
                {
                    _Xlength();
                }

                const size_type _Newsize = _Oldsize + _Count;
                const size_type _Newcapacity = _Calculate_growth(_Newsize);

                const pointer _Newvec = _Getal().allocate(_Newcapacity);
                const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);
                const pointer _Constructed_last = _Newvec + _Whereoff + _Count;
                pointer _Constructed_first = _Constructed_last;

                try
                {
                    _Ucopy(_First, _Last, _Newvec + _Whereoff);
                    _Constructed_first = _Newvec + _Whereoff;

                    if(_Count == 1 && _Whereptr == _Oldlast)
                    {
                        _Umove_if_noexcept(_Oldfirst, _Oldlast, _Newvec);
                    }
                    else
                    {
                        _Umove(_Oldfirst, _Whereptr, _Newvec);
                        _Constructed_first = _Newvec;
                        _Umove(_Whereptr, _Oldlast, _Newvec + _Whereoff + _Count);
                    }
                }
                catch(...)
                {
                    _Destroy(_Constructed_first, _Constructed_last);
                    _Getal().deallocate(_Newvec, _Newcapacity);
                    throw;
                }

                _Change_array(_Newvec, _Newsize, _Newcapacity);
            }
            else
            {
                const auto _Affected_elements = static_cast<size_type>(_Oldlast - _Whereptr);

                if(_Count < _Affected_elements)
                {
                    _Mylast = _Umove(_Oldlast - _Count, _Oldlast, _Oldlast);
                    _Move_backward_unchecked(_Whereptr, _Oldlast - _Count, _Oldlast);
                    _Destroy(_Whereptr, _Whereptr + _Count);

                    try
                    {
                        _Ucopy(_First, _Last, _Whereptr);
                    }
                    catch(...)
                    {
                        try
                        {
                            _Umove(_Whereptr + _Count, _Whereptr + 2 * _Count, _Whereptr);
                        }
                        catch(...)
                        {
                            _Orphan_range(_Whereptr, _Oldlast);
                            _Destroy(_Whereptr + _Count, _Mylast);
                            _Mylast = _Whereptr;
                            throw;
                        }

                        _Move_unchecked(_Whereptr + 2 * _Count, _Mylast, _Whereptr + _Count);
                        _Destroy(_Oldlast, _Mylast);
                        _Mylast = _Oldlast;
                        throw;
                    }
                }
                else
                {
                    const pointer _Relocated = _Whereptr + _Count;
                    _Mylast = _Umove(_Whereptr, _Oldlast, _Relocated);
                    _Destroy(_Whereptr, _Oldlast);

                    try
                    {
                        _Ucopy(_First, _Last, _Whereptr);
                    }
                    catch(...)
                    {
                        try
                        {
                            _Umove(_Relocated, _Mylast, _Whereptr);
                        }
                        catch(...)
                        {
                            _Orphan_range(_Whereptr, _Oldlast);
                            _Destroy(_Relocated, _Mylast);
                            _Mylast = _Whereptr;
                            throw;
                        }

                        _Destroy(_Relocated, _Mylast);
                        _Mylast = _Oldlast;
                        throw;
                    }
                }

                _Orphan_range(_Whereptr, _Oldlast);
            }
        }

    public:
        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
        iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
        {
            const pointer _Whereptr = _Where._Ptr;
            auto& _My_data = _Mypair._Myval2;
            const pointer _Oldfirst = _My_data._Myfirst;

            _Adl_verify_range(_First, _Last);
            const auto _Whereoff = static_cast<size_type>(_Whereptr - _Oldfirst);
            _Insert_range(_Where, _Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
            return _Make_iterator_offset(_Whereoff);
        }

        iterator insert(const_iterator _Where, initializer_list<_Ty> _Ilist)
        {
            return insert(_Where, _Ilist.begin(), _Ilist.end());
        }

        void assign(const size_type _Newsize, const _Ty& _Val)
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;

            _My_data._Orphan_all();

            auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
            if(_Newsize > _Oldsize)
            {
                const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
                if(_Newsize > _Oldcapacity)
                {
                    _Clear_and_reserve_geometric(_Newsize);
                    _Oldsize = 0;
                }
                else
                {
                    ::std::fill(_Myfirst, _Mylast, _Val);
                }

                _Mylast = _Ufill(_Mylast, _Newsize - _Oldsize, _Val);
            }
            else
            {
                const pointer _Newlast = _Myfirst + _Newsize;
                ::std::fill(_Myfirst, _Newlast, _Val);
                _Destroy(_Newlast, _Mylast);
                _Mylast = _Newlast;
            }
        }

    private:
        template <class _Iter> void _Assign_range(_Iter _First, _Iter _Last, input_iterator_tag)
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;

            _My_data._Orphan_all();

            pointer _Next = _Myfirst;

            for(; _First != _Last && _Next != _Mylast; ++_First, (void)++_Next)
            {
                *_Next = *_First;
            }

            _Destroy(_Next, _Mylast);
            _Mylast = _Next;

            for(; _First != _Last; ++_First)
            {
                emplace_back(*_First);
            }
        }

        template <class _Iter> void _Assign_range(_Iter _First, _Iter _Last, forward_iterator_tag)
        {
            const auto _Newsize = _Convert_size<size_type>(static_cast<size_t>(::std::distance(_First, _Last)));
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;
            pointer& _Myend = _My_data._Myend;

            _My_data._Orphan_all();

            if constexpr(conjunction_v<bool_constant<_Ptr_copy_cat<_Iter, _Ty*>::_Trivially_copyable>,
                                       _Uses_default_construct<_Alty, _Ty*, decltype(*_First)>, _Uses_default_destroy<_Alty, _Ty*>>)
            {
                const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
                if(_Newsize > _Oldcapacity)
                {
                    _Clear_and_reserve_geometric(_Newsize);
                }

                _Mylast = _Refancy<pointer>(_Copy_memmove(_First, _Last, _Unfancy(_Myfirst)));
            }
            else
            {
                auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);

                if(_Newsize > _Oldsize)
                {
                    const auto _Oldcapacity = static_cast<size_type>(_Myend - _Myfirst);
                    if(_Newsize > _Oldcapacity)
                    {
                        _Clear_and_reserve_geometric(_Newsize);
                        _Oldsize = 0;
                    }

                    const _Iter _Mid = ::std::next(_First, static_cast<difference_type>(_Oldsize));
                    _Copy_unchecked(_First, _Mid, _Myfirst);
                    _Mylast = _Ucopy(_Mid, _Last, _Mylast);
                }
                else
                {
                    const pointer _Newlast = _Myfirst + _Newsize;
                    _Copy_unchecked(_First, _Last, _Myfirst);
                    _Destroy(_Newlast, _Mylast);
                    _Mylast = _Newlast;
                }
            }
        }

    public:
        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0> void assign(_Iter _First, _Iter _Last)
        {
            _Adl_verify_range(_First, _Last);
            _Assign_range(_Get_unwrapped(_First), _Get_unwrapped(_Last), _Iter_cat_t<_Iter>{});
        }

        void assign(initializer_list<_Ty> _Ilist)
        {
            _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
        }

    private:
        void _Copy_assign(const vector& _Right, false_type)
        {
            _Pocca(_Getal(), _Right._Getal());
            auto& _Right_data = _Right._Mypair._Myval2;
            assign(_Right_data._Myfirst, _Right_data._Mylast);
        }

        void _Copy_assign(const vector& _Right, true_type)
        {
            if(_Getal() != _Right._Getal())
            {
                _Tidy();
                _Mypair._Myval2._Reload_proxy(_Fake_allocator(), _Fake_allocator());
            }

            _Copy_assign(_Right, false_type{});
        }

    public:
        vector& operator=(const vector& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                _Copy_assign(_Right, _Choose_pocca<_Alty>{});
            }

            return *this;
        }

        vector& operator=(initializer_list<_Ty> _Ilist)
        {
            _Assign_range(_Ilist.begin(), _Ilist.end(), random_access_iterator_tag{});
            return *this;
        }

    private:
        template <class _Ty2> void _Resize_reallocate(const size_type _Newsize, const _Ty2& _Val)
        {
            if(_Newsize > max_size())
            {
                _Xlength();
            }

            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;

            const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            const pointer _Newvec = _Getal().allocate(_Newcapacity);
            const pointer _Appended_first = _Newvec + _Oldsize;
            pointer _Appended_last = _Appended_first;

            try
            {
                _Appended_last = _Ufill(_Appended_first, _Newsize - _Oldsize, _Val);
                _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
            }
            catch(...)
            {
                _Destroy(_Appended_first, _Appended_last);
                _Getal().deallocate(_Newvec, _Newcapacity);
                throw;
            }

            _Change_array(_Newvec, _Newsize, _Newcapacity);
        }

        template <class _Ty2> void _Resize(const size_type _Newsize, const _Ty2& _Val)
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;
            const auto _Oldsize = static_cast<size_type>(_Mylast - _Myfirst);
            if(_Newsize < _Oldsize)
            {
                const pointer _Newlast = _Myfirst + _Newsize;
                _Orphan_range(_Newlast, _Mylast);
                _Destroy(_Newlast, _Mylast);
                _Mylast = _Newlast;
                return;
            }

            if(_Newsize > _Oldsize)
            {
                const auto _Oldcapacity = static_cast<size_type>(_My_data._Myend - _Myfirst);
                if(_Newsize > _Oldcapacity)
                {
                    _Resize_reallocate(_Newsize, _Val);
                    return;
                }

                const pointer _Oldlast = _Mylast;
                _Mylast = _Ufill(_Oldlast, _Newsize - _Oldsize, _Val);
                _Orphan_range(_Oldlast, _Oldlast);
            }
        }

    public:
        void resize(const size_type _Newsize)
        {
            _Resize(_Newsize, _Value_init_tag{});
        }

        void resize(const size_type _Newsize, const _Ty& _Val)
        {
            _Resize(_Newsize, _Val);
        }

    private:
        void _Reallocate_exactly(const size_type _Newcapacity)
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;

            const auto _Size = static_cast<size_type>(_Mylast - _Myfirst);

            const pointer _Newvec = _Getal().allocate(_Newcapacity);

            try
            {
                _Umove_if_noexcept(_Myfirst, _Mylast, _Newvec);
            }
            catch(...)
            {
                _Getal().deallocate(_Newvec, _Newcapacity);
                throw;
            }

            _Change_array(_Newvec, _Size, _Newcapacity);
        }

        void _Clear_and_reserve_geometric(const size_type _Newsize)
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;
            pointer& _Myend = _My_data._Myend;

            if(_Newsize > max_size())
            {
                _Xlength();
            }

            const size_type _Newcapacity = _Calculate_growth(_Newsize);

            if(_Myfirst)
            {
                _Destroy(_Myfirst, _Mylast);
                _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

                _Myfirst = pointer();
                _Mylast = pointer();
                _Myend = pointer();
            }

            _Buy_raw(_Newcapacity);
        }

    public:
        void reserve(const size_type _Newcapacity)
        {
            if(_Newcapacity > capacity())
            {
                if(_Newcapacity > max_size())
                {
                    _Xlength();
                }

                _Reallocate_exactly(_Newcapacity);
            }
        }

        void shrink_to_fit()
        {
            auto& _My_data = _Mypair._Myval2;
            const pointer _Oldlast = _My_data._Mylast;
            if(_Oldlast != _My_data._Myend)
            {
                const pointer _Oldfirst = _My_data._Myfirst;
                if(_Oldfirst == _Oldlast)
                {
                    _Tidy();
                }
                else
                {
                    _Reallocate_exactly(static_cast<size_type>(_Oldlast - _Oldfirst));
                }
            }
        }

        void pop_back() noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Mylast = _My_data._Mylast;

            _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
            --_Mylast;
        }

        iterator erase(const_iterator _Where) noexcept(is_nothrow_move_assignable_v<value_type>)
        {
            const pointer _Whereptr = _Where._Ptr;
            auto& _My_data = _Mypair._Myval2;
            pointer& _Mylast = _My_data._Mylast;

            _Move_unchecked(_Whereptr + 1, _Mylast, _Whereptr);
            _Alty_traits::destroy(_Getal(), _Unfancy(_Mylast - 1));
            --_Mylast;
            return iterator(_Whereptr, ::std::addressof(_My_data));
        }

        iterator erase(const_iterator _First, const_iterator _Last) noexcept(is_nothrow_move_assignable_v<value_type>)
        {
            const pointer _Firstptr = _First._Ptr;
            const pointer _Lastptr = _Last._Ptr;
            auto& _My_data = _Mypair._Myval2;
            pointer& _Mylast = _My_data._Mylast;

            if(_Firstptr != _Lastptr)
            {
                _Orphan_range(_Firstptr, _Mylast);

                const pointer _Newlast = _Move_unchecked(_Lastptr, _Mylast, _Firstptr);
                _Destroy(_Newlast, _Mylast);
                _Mylast = _Newlast;
            }

            return iterator(_Firstptr, ::std::addressof(_My_data));
        }

        void clear() noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;

            _My_data._Orphan_all();
            _Destroy(_Myfirst, _Mylast);
            _Mylast = _Myfirst;
        }

    public:
        void swap(vector& _Right) noexcept
        {
            if(this != ::std::addressof(_Right))
            {
                _Pocs(_Getal(), _Right._Getal());
                _Mypair._Myval2._Swap_val(_Right._Mypair._Myval2);
            }
        }

        [[nodiscard]] _Ty* data() noexcept
        {
            return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
        }

        [[nodiscard]] const _Ty* data() const noexcept
        {
            return _Unfancy_maybe_null(_Mypair._Myval2._Myfirst);
        }

        [[nodiscard]] iterator begin() noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            return iterator(_My_data._Myfirst, ::std::addressof(_My_data));
        }

        [[nodiscard]] const_iterator begin() const noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            return const_iterator(_My_data._Myfirst, ::std::addressof(_My_data));
        }

        [[nodiscard]] iterator end() noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            return iterator(_My_data._Mylast, ::std::addressof(_My_data));
        }

        [[nodiscard]] const_iterator end() const noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            return const_iterator(_My_data._Mylast, ::std::addressof(_My_data));
        }

        [[nodiscard]] reverse_iterator rbegin() noexcept
        {
            return reverse_iterator(end());
        }

        [[nodiscard]] const_reverse_iterator rbegin() const noexcept
        {
            return const_reverse_iterator(end());
        }

        [[nodiscard]] reverse_iterator rend() noexcept
        {
            return reverse_iterator(begin());
        }

        [[nodiscard]] const_reverse_iterator rend() const noexcept
        {
            return const_reverse_iterator(begin());
        }

        [[nodiscard]] const_iterator cbegin() const noexcept
        {
            return begin();
        }

        [[nodiscard]] const_iterator cend() const noexcept
        {
            return end();
        }

        [[nodiscard]] const_reverse_iterator crbegin() const noexcept
        {
            return rbegin();
        }

        [[nodiscard]] const_reverse_iterator crend() const noexcept
        {
            return rend();
        }

        pointer _Unchecked_begin() noexcept
        {
            return _Mypair._Myval2._Myfirst;
        }

        const_pointer _Unchecked_begin() const noexcept
        {
            return _Mypair._Myval2._Myfirst;
        }

        pointer _Unchecked_end() noexcept
        {
            return _Mypair._Myval2._Mylast;
        }

        const_pointer _Unchecked_end() const noexcept
        {
            return _Mypair._Myval2._Mylast;
        }

        [[nodiscard]] bool empty() const noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            return _My_data._Myfirst == _My_data._Mylast;
        }

        [[nodiscard]] size_type size() const noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            return static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst);
        }

        [[nodiscard]] size_type max_size() const noexcept
        {
            return _Min_value(static_cast<size_type>((numeric_limits<difference_type>::max)()), _Alty_traits::max_size(_Getal()));
        }

        [[nodiscard]] size_type capacity() const noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            return static_cast<size_type>(_My_data._Myend - _My_data._Myfirst);
        }

        [[nodiscard]] _Ty& operator[](const size_type _Pos) noexcept
        {
            auto& _My_data = _Mypair._Myval2;

            return _My_data._Myfirst[_Pos];
        }

        [[nodiscard]] const _Ty& operator[](const size_type _Pos) const noexcept
        {
            auto& _My_data = _Mypair._Myval2;

            return _My_data._Myfirst[_Pos];
        }

        [[nodiscard]] _Ty& at(const size_type _Pos)
        {
            auto& _My_data = _Mypair._Myval2;
            if(static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos)
            {
                _Xrange();
            }

            return _My_data._Myfirst[_Pos];
        }

        [[nodiscard]] const _Ty& at(const size_type _Pos) const
        {
            auto& _My_data = _Mypair._Myval2;
            if(static_cast<size_type>(_My_data._Mylast - _My_data._Myfirst) <= _Pos)
            {
                _Xrange();
            }

            return _My_data._Myfirst[_Pos];
        }

        [[nodiscard]] _Ty& front() noexcept
        {
            auto& _My_data = _Mypair._Myval2;

            return *_My_data._Myfirst;
        }

        [[nodiscard]] const _Ty& front() const noexcept
        {
            auto& _My_data = _Mypair._Myval2;

            return *_My_data._Myfirst;
        }

        [[nodiscard]] _Ty& back() noexcept
        {
            auto& _My_data = _Mypair._Myval2;

            return _My_data._Mylast[-1];
        }

        [[nodiscard]] const _Ty& back() const noexcept
        {
            auto& _My_data = _Mypair._Myval2;

            return _My_data._Mylast[-1];
        }

        [[nodiscard]] allocator_type get_allocator() const noexcept
        {
            return static_cast<allocator_type>(_Getal());
        }

    private:
        pointer _Ufill(pointer _Dest, const size_type _Count, const _Ty& _Val)
        {
            return _Uninitialized_fill_n(_Dest, _Count, _Val, _Getal());
        }

        pointer _Ufill(pointer _Dest, const size_type _Count, _Value_init_tag)
        {
            return _Uninitialized_value_construct_n(_Dest, _Count, _Getal());
        }

        template <class _Iter> pointer _Ucopy(_Iter _First, _Iter _Last, pointer _Dest)
        {
            return _Uninitialized_copy(_First, _Last, _Dest, _Getal());
        }

        pointer _Umove(pointer _First, pointer _Last, pointer _Dest)
        {
            return _Uninitialized_move(_First, _Last, _Dest, _Getal());
        }

        void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, true_type)
        {
            _Uninitialized_move(_First, _Last, _Dest, _Getal());
        }

        void _Umove_if_noexcept1(pointer _First, pointer _Last, pointer _Dest, false_type)
        {
            _Uninitialized_copy(_First, _Last, _Dest, _Getal());
        }

        void _Umove_if_noexcept(pointer _First, pointer _Last, pointer _Dest)
        {
            _Umove_if_noexcept1(
            _First, _Last, _Dest,
            bool_constant<disjunction_v<is_nothrow_move_constructible<_Ty>, negation<is_copy_constructible<_Ty>>>>{});
        }

        void _Destroy(pointer _First, pointer _Last)
        {
            _Destroy_range(_First, _Last, _Getal());
        }

        size_type _Calculate_growth(const size_type _Newsize) const
        {
            const size_type _Oldcapacity = capacity();

            if(_Oldcapacity > max_size() - _Oldcapacity / 2)
            {
                return _Newsize;
            }

            const size_type _Geometric = _Oldcapacity + _Oldcapacity / 2;

            if(_Geometric < _Newsize)
            {
                return _Newsize;
            }

            return _Geometric;
        }

        void _Buy_raw(const size_type _Newcapacity)
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;
            pointer& _Myend = _My_data._Myend;

            ;
            ;

            const auto _Newvec = _Getal().allocate(_Newcapacity);
            _Myfirst = _Newvec;
            _Mylast = _Newvec;
            _Myend = _Newvec + _Newcapacity;
        }

        void _Buy_nonzero(const size_type _Newcapacity)
        {
            if(_Newcapacity > max_size())
            {
                _Xlength();
            }

            _Buy_raw(_Newcapacity);
        }

        void _Change_array(const pointer _Newvec, const size_type _Newsize, const size_type _Newcapacity)
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;
            pointer& _Myend = _My_data._Myend;

            _My_data._Orphan_all();

            if(_Myfirst)
            {
                _Destroy(_Myfirst, _Mylast);
                _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));
            }

            _Myfirst = _Newvec;
            _Mylast = _Newvec + _Newsize;
            _Myend = _Newvec + _Newcapacity;
        }

        void _Tidy() noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            pointer& _Myfirst = _My_data._Myfirst;
            pointer& _Mylast = _My_data._Mylast;
            pointer& _Myend = _My_data._Myend;

            _My_data._Orphan_all();

            if(_Myfirst)
            {
                _Destroy(_Myfirst, _Mylast);
                _Getal().deallocate(_Myfirst, static_cast<size_type>(_Myend - _Myfirst));

                _Myfirst = pointer();
                _Mylast = pointer();
                _Myend = pointer();
            }
        }

        [[noreturn]] static void _Xlength()
        {
            _Xlength_error("vector too long");
        }

        [[noreturn]] static void _Xrange()
        {
            _Xout_of_range("invalid vector subscript");
        }

        void _Orphan_range(pointer _First, pointer _Last) const
        {
            (void)_First;
            (void)_Last;
        }

        _Alty& _Getal() noexcept
        {
            return _Mypair._Get_first();
        }

        const _Alty& _Getal() const noexcept
        {
            return _Mypair._Get_first();
        }

        iterator _Make_iterator(const pointer _Ptr) noexcept
        {
            return iterator(_Ptr, ::std::addressof(_Mypair._Myval2));
        }

        iterator _Make_iterator_offset(const size_type _Offset) noexcept
        {
            auto& _My_data = _Mypair._Myval2;
            return iterator(_My_data._Myfirst + _Offset, ::std::addressof(_My_data));
        }

        _Compressed_pair<_Alty, _Scary_val> _Mypair;
    };

    template <class _Ty, class _Alloc> void swap(vector<_Ty, _Alloc>& _Left, vector<_Ty, _Alloc>& _Right) noexcept
    {
        _Left.swap(_Right);
    }

    template <class _Ty, class _Alloc>
    [[nodiscard]] bool operator==(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right)
    {
        return _Left.size() == _Right.size()
               && ::std::equal(_Left._Unchecked_begin(), _Left._Unchecked_end(), _Right._Unchecked_begin());
    }

    template <class _Ty, class _Alloc>
    [[nodiscard]] bool operator!=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right)
    {
        return !(_Left == _Right);
    }

    template <class _Ty, class _Alloc>
    [[nodiscard]] bool operator<(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right)
    {
        return ::std::lexicographical_compare(_Left._Unchecked_begin(), _Left._Unchecked_end(),
                                              _Right._Unchecked_begin(), _Right._Unchecked_end());
    }

    template <class _Ty, class _Alloc>
    [[nodiscard]] bool operator>(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right)
    {
        return _Right < _Left;
    }

    template <class _Ty, class _Alloc>
    [[nodiscard]] bool operator<=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right)
    {
        return !(_Right < _Left);
    }

    template <class _Ty, class _Alloc>
    [[nodiscard]] bool operator>=(const vector<_Ty, _Alloc>& _Left, const vector<_Ty, _Alloc>& _Right)
    {
        return !(_Left < _Right);
    }

    using _Vbase = unsigned int;
    constexpr int _VBITS = 8 * sizeof(_Vbase);

    template <class _Alloc0> struct _Wrap_alloc
    {
        using _Alloc = _Alloc0;
    };

    template <class _Alvbase_wrapped> class _Vb_iter_base : public _Iterator_base
    {
    public:
        using _Alvbase = typename _Alvbase_wrapped::_Alloc;
        using _Size_type = typename allocator_traits<_Alvbase>::size_type;
        using _Difference_type = typename allocator_traits<_Alvbase>::difference_type;
        using _Mycont = vector<bool, _Rebind_alloc_t<_Alvbase, bool>>;

        _Vb_iter_base() = default;

        _Vb_iter_base(const _Vbase* _Ptr, _Size_type _Off, const _Container_base* _Mypvbool) noexcept
        : _Myptr(_Ptr), _Myoff(_Off)
        {
            this->_Adopt(_Mypvbool);
        }

        void _Advance(_Size_type _Off)
        {
            _Myoff += _Off;
            _Myptr += _Myoff / _VBITS;
            _Myoff %= _VBITS;
        }

        const _Vbase* _Myptr = nullptr;
        _Size_type _Myoff = 0;
    };

    template <class _Alvbase_wrapped> class _Vb_reference : public _Vb_iter_base<_Alvbase_wrapped>
    {
        using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;
        using _Mycont = typename _Mybase::_Mycont;
        using _Difference_type = typename _Mybase::_Difference_type;

        _Vb_reference() = default;

    public:
        _Vb_reference(const _Mybase& _Right) noexcept : _Mybase(_Right._Myptr, _Right._Myoff, _Right._Getcont())
        {
        }

        _Vb_reference& operator=(const _Vb_reference& _Right) noexcept
        {
            return *this = static_cast<bool>(_Right);
        }

        _Vb_reference& operator=(bool _Val) noexcept
        {
            if(_Val)
            {
                *const_cast<_Vbase*>(_Getptr()) |= _Mask();
            }
            else
            {
                *const_cast<_Vbase*>(_Getptr()) &= ~_Mask();
            }

            return *this;
        }

        void flip() noexcept
        {
            *const_cast<_Vbase*>(_Getptr()) ^= _Mask();
        }

        operator bool() const noexcept
        {
            return (*_Getptr() & _Mask()) != 0;
        }

        const _Vbase* _Getptr() const
        {
            return this->_Myptr;
        }

        friend void swap(_Vb_reference _Left, _Vb_reference _Right) noexcept
        {
            bool _Val = _Left;
            _Left = _Right;
            _Right = _Val;
        }

    protected:
        _Vbase _Mask() const
        {
            return static_cast<_Vbase>(1) << this->_Myoff;
        }
    };

    template <class _Alvbase_wrapped> class _Vb_const_iterator : public _Vb_iter_base<_Alvbase_wrapped>
    {
    private:
        using _Mybase = _Vb_iter_base<_Alvbase_wrapped>;

    public:
        using _Mycont = typename _Mybase::_Mycont;
        using _Difference_type = typename _Mybase::_Difference_type;
        using _Size_type = typename _Mybase::_Size_type;
        using _Reft = _Vb_reference<_Alvbase_wrapped>;
        using const_reference = bool;

        using iterator_category = random_access_iterator_tag;
        using value_type = bool;
        using difference_type = typename _Mybase::_Difference_type;
        using pointer = const_reference*;
        using reference = const_reference;

        _Vb_const_iterator() = default;

        _Vb_const_iterator(const _Vbase* _Ptr, const _Container_base* _Mypvbool) noexcept : _Mybase(_Ptr, 0, _Mypvbool)
        {
        }

        [[nodiscard]] const_reference operator*() const
        {
            return _Reft(*this);
        }

        _Vb_const_iterator& operator++()
        {
            _Inc();
            return *this;
        }

        _Vb_const_iterator operator++(int)
        {
            _Vb_const_iterator _Tmp = *this;
            _Inc();
            return _Tmp;
        }

        _Vb_const_iterator& operator--()
        {
            _Dec();
            return *this;
        }

        _Vb_const_iterator operator--(int)
        {
            _Vb_const_iterator _Tmp = *this;
            _Dec();
            return _Tmp;
        }

        _Vb_const_iterator& operator+=(const difference_type _Off)
        {
            if(_Off < 0 && this->_Myoff < 0 - static_cast<_Size_type>(_Off))
            {
                this->_Myoff += _Off;
                this->_Myptr -= 1 + (static_cast<_Size_type>(-1) - this->_Myoff) / _VBITS;
                this->_Myoff %= _VBITS;
            }
            else
            {
                this->_Myoff += _Off;
                this->_Myptr += this->_Myoff / _VBITS;
                this->_Myoff %= _VBITS;
            }
            return *this;
        }

        [[nodiscard]] _Vb_const_iterator operator+(const difference_type _Off) const
        {
            _Vb_const_iterator _Tmp = *this;
            return _Tmp += _Off;
        }

        _Vb_const_iterator& operator-=(const difference_type _Off)
        {
            return *this += -_Off;
        }

        [[nodiscard]] _Vb_const_iterator operator-(const difference_type _Off) const
        {
            _Vb_const_iterator _Tmp = *this;
            return _Tmp -= _Off;
        }

        [[nodiscard]] difference_type operator-(const _Vb_const_iterator& _Right) const
        {
            _Compat(_Right);
            return static_cast<difference_type>(_VBITS * (this->_Myptr - _Right._Myptr))
                   + static_cast<difference_type>(this->_Myoff) - static_cast<difference_type>(_Right._Myoff);
        }

        [[nodiscard]] const_reference operator[](const difference_type _Off) const
        {
            return *(*this + _Off);
        }

        [[nodiscard]] bool operator==(const _Vb_const_iterator& _Right) const
        {
            _Compat(_Right);
            return this->_Myptr == _Right._Myptr && this->_Myoff == _Right._Myoff;
        }

        [[nodiscard]] bool operator!=(const _Vb_const_iterator& _Right) const
        {
            return !(*this == _Right);
        }

        [[nodiscard]] bool operator<(const _Vb_const_iterator& _Right) const
        {
            _Compat(_Right);
            return this->_Myptr < _Right._Myptr || (this->_Myptr == _Right._Myptr && this->_Myoff < _Right._Myoff);
        }

        [[nodiscard]] bool operator>(const _Vb_const_iterator& _Right) const
        {
            return _Right < *this;
        }

        [[nodiscard]] bool operator<=(const _Vb_const_iterator& _Right) const
        {
            return !(_Right < *this);
        }

        [[nodiscard]] bool operator>=(const _Vb_const_iterator& _Right) const
        {
            return !(*this < _Right);
        }

        void _Compat(const _Vb_const_iterator& _Right) const
        {
            (void)_Right;
        }

        void _Dec()
        {
            if(this->_Myoff != 0)
            {
                --this->_Myoff;
            }
            else
            {
                this->_Myoff = _VBITS - 1;
                --this->_Myptr;
            }
        }

        void _Inc()
        {
            if(this->_Myoff < _VBITS - 1)
            {
                ++this->_Myoff;
            }
            else
            {
                this->_Myoff = 0;
                ++this->_Myptr;
            }
        }
    };

    template <class _Alvbase_wrapped>
    [[nodiscard]] _Vb_const_iterator<_Alvbase_wrapped>
    operator+(typename _Vb_const_iterator<_Alvbase_wrapped>::difference_type _Off, _Vb_const_iterator<_Alvbase_wrapped> _Right)
    {
        return _Right += _Off;
    }

    template <class _Alvbase_wrapped> class _Vb_iterator : public _Vb_const_iterator<_Alvbase_wrapped>
    {
    public:
        using _Mybase = _Vb_const_iterator<_Alvbase_wrapped>;
        using _Mycont = typename _Mybase::_Mycont;
        using _Difference_type = typename _Mybase::_Difference_type;

        using _Reft = _Vb_reference<_Alvbase_wrapped>;
        using const_reference = bool;

        using iterator_category = random_access_iterator_tag;
        using value_type = bool;
        using difference_type = typename _Mybase::difference_type;
        using pointer = _Reft*;
        using reference = _Reft;

        using _Mybase::_Mybase;

        [[nodiscard]] reference operator*() const
        {
            return _Reft(*this);
        }

        _Vb_iterator& operator++()
        {
            _Mybase::operator++();
            return *this;
        }

        _Vb_iterator operator++(int)
        {
            _Vb_iterator _Tmp = *this;
            _Mybase::operator++();
            return _Tmp;
        }

        _Vb_iterator& operator--()
        {
            _Mybase::operator--();
            return *this;
        }

        _Vb_iterator operator--(int)
        {
            _Vb_iterator _Tmp = *this;
            _Mybase::operator--();
            return _Tmp;
        }

        _Vb_iterator& operator+=(const difference_type _Off)
        {
            _Mybase::operator+=(_Off);
            return *this;
        }

        [[nodiscard]] _Vb_iterator operator+(const difference_type _Off) const
        {
            _Vb_iterator _Tmp = *this;
            return _Tmp += _Off;
        }

        _Vb_iterator& operator-=(const difference_type _Off)
        {
            _Mybase::operator-=(_Off);
            return *this;
        }

        using _Mybase::operator-;

        [[nodiscard]] _Vb_iterator operator-(const difference_type _Off) const
        {
            _Vb_iterator _Tmp = *this;
            return _Tmp -= _Off;
        }

        [[nodiscard]] reference operator[](const difference_type _Off) const
        {
            return *(*this + _Off);
        }

        using _Prevent_inheriting_unwrap = _Vb_iterator;
    };

    template <class _Alvbase_wrapped>
    [[nodiscard]] _Vb_iterator<_Alvbase_wrapped>
    operator+(typename _Vb_iterator<_Alvbase_wrapped>::difference_type _Off, _Vb_iterator<_Alvbase_wrapped> _Right)
    {
        return _Right += _Off;
    }

    template <class _Alloc> class _Vb_val : public _Container_base
    {
    public:
        using _Alvbase = _Rebind_alloc_t<_Alloc, _Vbase>;
        using _Alvbase_traits = allocator_traits<_Alvbase>;
        using _Vectype = vector<_Vbase, _Alvbase>;
        using _Alvbase_wrapped = _Wrap_alloc<_Alvbase>;
        using size_type = typename _Alvbase_traits::size_type;

        _Vb_val() noexcept(is_nothrow_default_constructible_v<_Vectype>) : _Myvec(), _Mysize(0)
        {
            this->_Alloc_proxy(_Fake_allocator());
        }

        _Vb_val(const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Vectype, _Alvbase>)
        : _Myvec(static_cast<_Alvbase>(_Al)), _Mysize(0)
        {
            this->_Alloc_proxy(_Fake_allocator());
        }

        _Vb_val(size_type _Count, const bool& _Val)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0)), _Mysize(0)
        {
            this->_Alloc_proxy(_Fake_allocator());
        }

        _Vb_val(size_type _Count, const bool& _Val, const _Alloc& _Al)
        : _Myvec(_Nw(_Count), static_cast<_Vbase>(_Val ? -1 : 0), static_cast<_Alvbase>(_Al)), _Mysize(0)
        {
            this->_Alloc_proxy(_Fake_allocator());
        }

        _Vb_val(const _Vb_val& _Right) : _Myvec(_Right._Myvec), _Mysize(_Right._Mysize)
        {
            this->_Alloc_proxy(_Fake_allocator());
        }

        _Vb_val(const _Vb_val& _Right, const _Alloc& _Al)
        : _Myvec(_Right._Myvec, static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize)
        {
            this->_Alloc_proxy(_Fake_allocator());
        }

        _Vb_val(_Vb_val&& _Right) noexcept(is_nothrow_move_constructible_v<_Vectype>)
        : _Myvec(::std::move(_Right._Myvec)), _Mysize(::std::exchange(_Right._Mysize, size_type{ 0 }))
        {
            this->_Alloc_proxy(_Fake_allocator());
        }

        _Vb_val(_Vb_val&& _Right, const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Vectype, _Vectype, _Alvbase>)
        : _Myvec(::std::move(_Right._Myvec), static_cast<_Alvbase>(_Al)), _Mysize(_Right._Mysize)
        {
            if(_Right._Myvec.empty())
            {
                _Right._Mysize = 0;
            }

            this->_Alloc_proxy(_Fake_allocator());
        }

        ~_Vb_val() noexcept
        {
        }

        _Alvbase& _Getal() noexcept
        {
            return _Myvec._Getal();
        }

        const _Alvbase& _Getal() const noexcept
        {
            return _Myvec._Getal();
        }

        static size_type _Nw(size_type _Count)
        {
            return (_Count + _VBITS - 1) / _VBITS;
        }

        _Vectype _Myvec;
        size_type _Mysize;
    };

    template <class _Alloc> class vector<bool, _Alloc> : public _Vb_val<_Alloc>
    {
    public:
        static_assert(!0 || is_same_v<bool, typename _Alloc::value_type>,
                      "vector<bool, Allocator>"
                      " requires that Allocator's value_type match "
                      "bool"
                      " (See N4659 26.2.1 [container.requirements.general]/16 allocator_type)"
                      " Either fix the allocator value_type or define _ENFORCE_MATCHING_ALLOCATORS=0"
                      " to suppress this diagnostic.");

        using _Mybase = _Vb_val<_Alloc>;
        using _Alvbase_wrapped = typename _Mybase::_Alvbase_wrapped;
        using _Alvbase = typename _Mybase::_Alvbase;
        using _Alvbase_traits = typename _Mybase::_Alvbase_traits;

        using size_type = typename _Alvbase_traits::size_type;
        using difference_type = typename _Alvbase_traits::difference_type;
        using allocator_type = _Alloc;

        using reference = _Vb_reference<_Alvbase_wrapped>;
        using const_reference = bool;
        using value_type = bool;

        using _Reft = reference;
        using iterator = _Vb_iterator<_Alvbase_wrapped>;
        using const_iterator = _Vb_const_iterator<_Alvbase_wrapped>;

        using pointer = iterator;
        using const_pointer = const_iterator;
        using reverse_iterator = ::std::reverse_iterator<iterator>;
        using const_reverse_iterator = ::std::reverse_iterator<const_iterator>;

        static const int _VBITS = ::std::_VBITS;
        enum
        {
            _EEN_VBITS = _VBITS
        };

        vector() noexcept(is_nothrow_default_constructible_v<_Mybase>) : _Mybase()
        {
        }

        explicit vector(const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Mybase, const _Alloc&>) : _Mybase(_Al)
        {
        }

        explicit vector(size_type _Count, const _Alloc& _Al = _Alloc()) : _Mybase(_Count, false, _Al)
        {
            _Trim(_Count);
        }

        vector(size_type _Count, const bool& _Val, const _Alloc& _Al = _Alloc()) : _Mybase(_Count, _Val, _Al)
        {
            _Trim(_Count);
        }

        vector(const vector& _Right) : _Mybase(_Right)
        {
        }

        vector(const vector& _Right, const _Alloc& _Al) : _Mybase(_Right, _Al)
        {
        }

        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
        vector(_Iter _First, _Iter _Last, const _Alloc& _Al = _Alloc()) : _Mybase(_Al)
        {
            _BConstruct(_First, _Last);
        }

        template <class _Iter> void _BConstruct(_Iter _First, _Iter _Last)
        {
            insert(begin(), _First, _Last);
        }

        vector(vector&& _Right) noexcept(is_nothrow_move_constructible_v<_Mybase>) : _Mybase(::std::move(_Right))
        {
            this->_Swap_proxy_and_iterators(_Right);
        }

        vector(vector&& _Right, const _Alloc& _Al) noexcept(is_nothrow_constructible_v<_Mybase, _Mybase, const _Alloc&>)
        : _Mybase(::std::move(_Right), _Al)
        {
            if constexpr(!_Alvbase_traits::is_always_equal::value)
            {
                if(this->_Getal() != _Right._Getal())
                {
                    return;
                }
            }

            this->_Swap_proxy_and_iterators(_Right);
        }

    private:
    public:
        vector& operator=(vector&& _Right) noexcept(is_nothrow_move_assignable_v<_Mybase>)
        {
            if(this != ::std::addressof(_Right))
            {
                this->_Myvec = ::std::move(_Right._Myvec);
                this->_Mysize = ::std::exchange(_Right._Mysize, size_type{ 0 });
            }
            return *this;
        }

        template <class... _Valty> decltype(auto) emplace_back(_Valty&&... _Val)
        {
            bool _Tmp(::std::forward<_Valty>(_Val)...);
            push_back(_Tmp);
        }

        template <class... _Valty> iterator emplace(const_iterator _Where, _Valty&&... _Val)
        {
            bool _Tmp(::std::forward<_Valty>(_Val)...);
            return insert(_Where, _Tmp);
        }

        vector(initializer_list<bool> _Ilist, const _Alloc& _Al = allocator_type()) : _Mybase(0, false, _Al)
        {
            insert(begin(), _Ilist.begin(), _Ilist.end());
        }

        vector& operator=(initializer_list<bool> _Ilist)
        {
            assign(_Ilist.begin(), _Ilist.end());
            return *this;
        }

        void assign(initializer_list<bool> _Ilist)
        {
            assign(_Ilist.begin(), _Ilist.end());
        }

        iterator insert(const_iterator _Where, initializer_list<bool> _Ilist)
        {
            return insert(_Where, _Ilist.begin(), _Ilist.end());
        }

        ~vector() noexcept
        {
        }

    private:
    public:
        vector& operator=(const vector& _Right)
        {
            if(this != ::std::addressof(_Right))
            {
                this->_Myvec = _Right._Myvec;
                this->_Mysize = _Right._Mysize;
            }

            return *this;
        }

        void reserve(size_type _Count)
        {
            this->_Myvec.reserve(this->_Nw(_Count));
        }

        [[nodiscard]] size_type capacity() const noexcept
        {
            return this->_Myvec.capacity() * _VBITS;
        }

        [[nodiscard]] iterator begin() noexcept
        {
            return iterator(this->_Myvec.data(), this);
        }

        [[nodiscard]] const_iterator begin() const noexcept
        {
            return const_iterator(this->_Myvec.data(), this);
        }

        [[nodiscard]] iterator end() noexcept
        {
            return begin() + static_cast<difference_type>(this->_Mysize);
        }

        [[nodiscard]] const_iterator end() const noexcept
        {
            return begin() + static_cast<difference_type>(this->_Mysize);
        }

        [[nodiscard]] const_iterator cbegin() const noexcept
        {
            return begin();
        }

        [[nodiscard]] const_iterator cend() const noexcept
        {
            return end();
        }

        [[nodiscard]] const_reverse_iterator crbegin() const noexcept
        {
            return rbegin();
        }

        [[nodiscard]] const_reverse_iterator crend() const noexcept
        {
            return rend();
        }

        [[nodiscard]] iterator _Unchecked_begin() noexcept
        {
            return iterator(this->_Myvec.data(), this);
        }

        [[nodiscard]] const_iterator _Unchecked_begin() const noexcept
        {
            return const_iterator(this->_Myvec.data(), this);
        }

        [[nodiscard]] iterator _Unchecked_end() noexcept
        {
            return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
        }

        [[nodiscard]] const_iterator _Unchecked_end() const noexcept
        {
            return _Unchecked_begin() + static_cast<difference_type>(this->_Mysize);
        }

        void shrink_to_fit()
        {
            if(this->_Myvec.capacity() != this->_Myvec.size())
            {
                this->_Orphan_all();
                this->_Myvec.shrink_to_fit();
            }
        }

        iterator _Make_iter(const_iterator _Where) noexcept
        {
            iterator _Tmp = begin();
            if(0 < this->_Mysize)
            {
                _Tmp += _Where - begin();
            }

            return _Tmp;
        }

        [[nodiscard]] reverse_iterator rbegin() noexcept
        {
            return reverse_iterator(end());
        }

        [[nodiscard]] const_reverse_iterator rbegin() const noexcept
        {
            return const_reverse_iterator(end());
        }

        [[nodiscard]] reverse_iterator rend() noexcept
        {
            return reverse_iterator(begin());
        }

        [[nodiscard]] const_reverse_iterator rend() const noexcept
        {
            return const_reverse_iterator(begin());
        }

        void resize(size_type _Newsize, bool _Val = false)
        {
            if(size() < _Newsize)
            {
                _Insert_n(end(), _Newsize - size(), _Val);
            }
            else if(_Newsize < size())
            {
                erase(begin() + static_cast<difference_type>(_Newsize), end());
            }
        }

        [[nodiscard]] size_type size() const noexcept
        {
            return this->_Mysize;
        }

        [[nodiscard]] size_type max_size() const noexcept
        {
            constexpr auto _Diff_max = static_cast<size_type>((numeric_limits<difference_type>::max)());
            const size_type _Ints_max = this->_Myvec.max_size();
            if(_Ints_max > _Diff_max / _VBITS)
            {
                return _Diff_max;
            }

            return _Ints_max * _VBITS;
        }

        [[nodiscard]] bool empty() const noexcept
        {
            return size() == 0;
        }

        [[nodiscard]] allocator_type get_allocator() const noexcept
        {
            return static_cast<allocator_type>(this->_Myvec.get_allocator());
        }

        [[nodiscard]] const_reference at(size_type _Off) const
        {
            if(size() <= _Off)
            {
                _Xran();
            }

            return (*this)[_Off];
        }

        [[nodiscard]] reference at(size_type _Off)
        {
            if(size() <= _Off)
            {
                _Xran();
            }

            return (*this)[_Off];
        }

        [[nodiscard]] const_reference operator[](size_type _Off) const noexcept
        {
            const_iterator _It = begin();
            _It._Advance(_Off);
            return *_It;
        }

        [[nodiscard]] reference operator[](size_type _Off) noexcept
        {
            iterator _It = begin();
            _It._Advance(_Off);
            return *_It;
        }

        [[nodiscard]] reference front() noexcept
        {
            return *begin();
        }

        [[nodiscard]] const_reference front() const noexcept
        {
            return *begin();
        }

        [[nodiscard]] reference back() noexcept
        {
            return *(end() - 1);
        }

        [[nodiscard]] const_reference back() const noexcept
        {
            return *(end() - 1);
        }

        void push_back(const bool& _Val)
        {
            insert(end(), _Val);
        }

        void pop_back() noexcept
        {
            erase(end() - 1);
        }

        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0> void assign(_Iter _First, _Iter _Last)
        {
            clear();
            insert(begin(), _First, _Last);
        }

        void assign(size_type _Count, const bool& _Val)
        {
            clear();
            _Insert_n(begin(), _Count, _Val);
        }

        iterator insert(const_iterator _Where, const bool& _Val)
        {
            return _Insert_n(_Where, static_cast<size_type>(1), _Val);
        }

        iterator insert(const_iterator _Where, size_type _Count, const bool& _Val)
        {
            return _Insert_n(_Where, _Count, _Val);
        }

        template <class _Iter, enable_if_t<_Is_iterator_v<_Iter>, int> = 0>
        iterator insert(const_iterator _Where, _Iter _First, _Iter _Last)
        {
            difference_type _Off = _Where - begin();
            _Insert(_Where, _First, _Last, _Iter_cat_t<_Iter>());
            return begin() + _Off;
        }

        template <class _Iter> void _Insert(const_iterator _Where, _Iter _First, _Iter _Last, input_iterator_tag)
        {
            difference_type _Off = _Where - begin();

            for(; _First != _Last; ++_First, (void)++_Off)
            {
                insert(begin() + _Off, *_First);
            }
        }

        template <class _Iter> void _Insert(const_iterator _Where, _Iter _First, _Iter _Last, forward_iterator_tag)
        {
            _Adl_verify_range(_First, _Last);
            auto _Count = _Convert_size<size_type>(static_cast<size_t>(::std::distance(_First, _Last)));
            size_type _Off = _Insert_x(_Where, _Count);
            _Copy_unchecked(_Get_unwrapped(_First), _Get_unwrapped(_Last), begin() + static_cast<difference_type>(_Off));
        }

        iterator erase(const_iterator _Where_arg) noexcept
        {
            iterator _Where = _Make_iter(_Where_arg);
            difference_type _Off = _Where - begin();

            ::std::copy(_Where + 1, end(), _Where);

            _Trim(this->_Mysize - 1);
            return begin() + _Off;
        }

        iterator erase(const_iterator _First_arg, const_iterator _Last_arg) noexcept
        {
            iterator _First = _Make_iter(_First_arg);
            iterator _Last = _Make_iter(_Last_arg);
            difference_type _Off = _First - begin();

            if(_First != _Last)
            {
                iterator _Next = ::std::copy(_Last, end(), _First);
                _Trim(static_cast<size_type>(_Next - begin()));
            }
            return begin() + _Off;
        }

        void clear() noexcept
        {
            this->_Orphan_all();
            this->_Myvec.clear();
            this->_Mysize = 0;
        }

        void flip() noexcept
        {
            for(auto& _Elem : this->_Myvec)
            {
                _Elem = ~_Elem;
            }

            _Trim(this->_Mysize);
        }

        void swap(vector& _Right) noexcept
        {
            if(this != ::std::addressof(_Right))
            {
                this->_Swap_proxy_and_iterators(_Right);
                this->_Myvec.swap(_Right._Myvec);
                ::std::swap(this->_Mysize, _Right._Mysize);
            }
        }

        static void swap(reference _Left, reference _Right) noexcept
        {
            bool _Val = _Left;
            _Left = _Right;
            _Right = _Val;
        }

        friend hash<vector<bool, _Alloc>>;

        iterator _Insert_n(const_iterator _Where, size_type _Count, const bool& _Val)
        {
            size_type _Off = _Insert_x(_Where, _Count);
            const auto _Result = begin() + static_cast<difference_type>(_Off);
            ::std::fill(_Result, _Result + static_cast<difference_type>(_Count), _Val);
            return _Result;
        }

        size_type _Insert_x(const_iterator _Where, size_type _Count)
        {
            difference_type _Off = _Where - begin();

            if(_Count != 0)
            {
                if(max_size() - size() < _Count)
                {
                    _Xlen();
                }

                this->_Myvec.resize(this->_Nw(size() + _Count), 0);
                if(empty())
                {
                    this->_Mysize += _Count;
                }
                else
                {
                    iterator _Oldend = end();
                    this->_Mysize += _Count;
                    ::std::copy_backward(begin() + _Off, _Oldend, end());
                }
            }

            return static_cast<size_type>(_Off);
        }

        void _Orphan_range(size_type, size_type) const
        {
        }

        void _Trim(size_type _Size)
        {
            if(max_size() < _Size)
            {
                _Xlen();
            }

            const size_type _Words = this->_Nw(_Size);
            if(_Words < this->_Myvec.size())
            {
                this->_Myvec.erase(this->_Myvec.begin() + static_cast<difference_type>(_Words), this->_Myvec.end());
            }

            this->_Mysize = _Size;
            _Size %= _VBITS;
            if(0 < _Size)
            {
                this->_Myvec[_Words - 1] &= (static_cast<_Vbase>(1) << _Size) - 1;
            }
        }

        [[noreturn]] void _Xlen() const
        {
            _Xlength_error("vector<bool> too long");
        }

        [[noreturn]] void _Xran() const
        {
            _Xout_of_range("invalid vector<bool> subscript");
        }
    };

    template <class _Alloc>
    [[nodiscard]] bool operator==(const vector<bool, _Alloc>& _Left, const vector<bool, _Alloc>& _Right)
    {
        return _Left.size() == _Right.size() && _Left._Myvec == _Right._Myvec;
    }

    template <class _Alloc>
    [[nodiscard]] bool operator!=(const vector<bool, _Alloc>& _Left, const vector<bool, _Alloc>& _Right)
    {
        return !(_Left == _Right);
    }

    template <class _Alloc> struct hash<vector<bool, _Alloc>>
    {
        typedef vector<bool, _Alloc> argument_type;
        typedef size_t result_type;

        [[nodiscard]] size_t operator()(const vector<bool, _Alloc>& _Keyval) const noexcept
        {
            return _Hash_array_representation(_Keyval._Myvec.data(), _Keyval._Myvec.size());
        }
    };

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <bool _Same, class _Dest, class... _Srcs> constexpr bool _Tuple_conditional_explicit_v0 = false;

    template <class... _Dests, class... _Srcs>
    constexpr bool _Tuple_conditional_explicit_v0<true, tuple<_Dests...>, _Srcs...> = !conjunction_v<is_convertible<_Srcs, _Dests>...>;

    template <class _Dest, class... _Srcs>
    constexpr bool _Tuple_conditional_explicit_v
    = _Tuple_conditional_explicit_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

    template <bool _Same, class _Dest, class... _Srcs> constexpr bool _Tuple_constructible_v0 = false;

    template <class... _Dests, class... _Srcs>
    constexpr bool _Tuple_constructible_v0<true, tuple<_Dests...>, _Srcs...> = conjunction_v<is_constructible<_Dests, _Srcs>...>;

    template <class _Dest, class... _Srcs>
    constexpr bool _Tuple_constructible_v = _Tuple_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

    template <class _Dest, class... _Srcs>
    struct _Tuple_constructible_val : bool_constant<_Tuple_constructible_v<_Dest, _Srcs...>>
    {
    };

    template <bool _Same, class _Dest, class... _Srcs> constexpr bool _Tuple_nothrow_constructible_v0 = false;

    template <class... _Dests, class... _Srcs>
    constexpr bool _Tuple_nothrow_constructible_v0<true, tuple<_Dests...>, _Srcs...> = conjunction_v<is_nothrow_constructible<_Dests, _Srcs>...>;

    template <class _Dest, class... _Srcs>
    constexpr bool _Tuple_nothrow_constructible_v
    = _Tuple_nothrow_constructible_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

    template <bool _Same, class _Dest, class... _Srcs> constexpr bool _Tuple_assignable_v0 = false;

    template <class... _Dests, class... _Srcs>
    constexpr bool _Tuple_assignable_v0<true, tuple<_Dests...>, _Srcs...> = conjunction_v<is_assignable<_Dests&, _Srcs>...>;

    template <class _Dest, class... _Srcs>
    constexpr bool _Tuple_assignable_v = _Tuple_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

    template <class _Dest, class... _Srcs>
    struct _Tuple_assignable_val : bool_constant<_Tuple_assignable_v<_Dest, _Srcs...>>
    {
    };

    template <bool _Same, class _Dest, class... _Srcs> constexpr bool _Tuple_nothrow_assignable_v0 = false;

    template <class... _Dests, class... _Srcs>
    constexpr bool _Tuple_nothrow_assignable_v0<true, tuple<_Dests...>, _Srcs...> = conjunction_v<is_nothrow_assignable<_Dests&, _Srcs>...>;

    template <class _Dest, class... _Srcs>
    constexpr bool _Tuple_nothrow_assignable_v
    = _Tuple_nothrow_assignable_v0<tuple_size_v<_Dest> == sizeof...(_Srcs), _Dest, _Srcs...>;

    template <class _Myself, class... _Other> struct _Tuple_convert_copy_val : true_type
    {
    };

    template <class _This, class _Uty>
    struct _Tuple_convert_copy_val<tuple<_This>, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, const tuple<_Uty>&>, is_convertible<const tuple<_Uty>&, _This>>>
    {
    };

    template <class _Myself, class... _Other> struct _Tuple_convert_move_val : true_type
    {
    };

    template <class _This, class _Uty>
    struct _Tuple_convert_move_val<tuple<_This>, _Uty>
    : bool_constant<!disjunction_v<is_same<_This, _Uty>, is_constructible<_This, tuple<_Uty>>, is_convertible<tuple<_Uty>, _This>>>
    {
    };

    template <class _Myself, class _This2, class... _Rest2> struct _Tuple_perfect_val : true_type
    {
    };

    template <class _Myself, class _This2>
    struct _Tuple_perfect_val<_Myself, _This2> : bool_constant<!is_same_v<_Myself, remove_const_t<remove_reference_t<_This2>>>>
    {
    };

    struct _Ignore
    {
        template <class _Ty> constexpr const _Ignore& operator=(const _Ty&) const noexcept
        {
            return *this;
        }
    };

    constexpr _Ignore ignore{};

    template <class _Ty> struct _Tuple_val
    {
        constexpr _Tuple_val() : _Val()
        {
        }

        template <class _Other> constexpr _Tuple_val(_Other&& _Arg) : _Val(::std::forward<_Other>(_Arg))
        {
        }

        template <class _Alloc, class... _Other, enable_if_t<!uses_allocator_v<_Ty, _Alloc>, int> = 0>
        _Tuple_val(const _Alloc&, allocator_arg_t, _Other&&... _Arg) : _Val(::std::forward<_Other>(_Arg)...)
        {
        }

        template <class _Alloc, class... _Other, enable_if_t<conjunction_v<uses_allocator<_Ty, _Alloc>, is_constructible<_Ty, allocator_arg_t, const _Alloc&, _Other...>>, int> = 0>
        _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg)
        : _Val(allocator_arg, _Al, ::std::forward<_Other>(_Arg)...)
        {
        }

        template <class _Alloc,
                  class... _Other,
                  enable_if_t<conjunction_v<uses_allocator<_Ty, _Alloc>, negation<is_constructible<_Ty, allocator_arg_t, const _Alloc&, _Other...>>>, int> = 0>
        _Tuple_val(const _Alloc& _Al, allocator_arg_t, _Other&&... _Arg) : _Val(::std::forward<_Other>(_Arg)..., _Al)
        {
        }

        _Ty _Val;
    };

    struct _Exact_args_t
    {
    };

    struct _Unpack_tuple_t
    {
    };

    struct _Alloc_exact_args_t
    {
    };

    struct _Alloc_unpack_tuple_t
    {
    };

    template <class... _Types> class tuple;

    template <> class tuple<>
    {
    public:
        constexpr tuple() noexcept
        {
        }

        constexpr tuple(const tuple&) noexcept
        {
        }

        template <class _Alloc> tuple(allocator_arg_t, const _Alloc&) noexcept
        {
        }

        template <class _Alloc> tuple(allocator_arg_t, const _Alloc&, const tuple&) noexcept
        {
        }

        template <class _Tag, enable_if_t<is_same_v<_Tag, _Exact_args_t>, int> = 0> constexpr tuple(_Tag) noexcept
        {
        }

        template <class _Tag, class _Alloc, enable_if_t<is_same_v<_Tag, _Alloc_exact_args_t>, int> = 0>
        tuple(_Tag, const _Alloc&) noexcept
        {
        }

        void swap(tuple&) noexcept
        {
        }

        constexpr bool _Equals(const tuple&) const noexcept
        {
            return true;
        }

        constexpr bool _Less(const tuple&) const noexcept
        {
            return false;
        }
    };

    template <class _This, class... _Rest> class tuple<_This, _Rest...> : private tuple<_Rest...>
    {
    public:
        using _This_type = _This;
        using _Mybase = tuple<_Rest...>;

        template <class _Tag, class _This2, class... _Rest2, enable_if_t<is_same_v<_Tag, _Exact_args_t>, int> = 0>
        constexpr tuple(_Tag, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Exact_args_t{}, ::std::forward<_Rest2>(_Rest_arg)...), _Myfirst(::std::forward<_This2>(_This_arg))
        {
        }

        template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int> = 0>
        constexpr tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>);

        template <class _Tag, class _Tpl, enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int> = 0>
        constexpr tuple(_Tag, _Tpl&& _Right)
        : tuple(_Unpack_tuple_t{}, ::std::forward<_Tpl>(_Right), make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{})
        {
        }

        template <class _Tag, class _Alloc, class _This2, class... _Rest2, enable_if_t<is_same_v<_Tag, _Alloc_exact_args_t>, int> = 0>
        tuple(_Tag, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : _Mybase(_Alloc_exact_args_t{}, _Al, ::std::forward<_Rest2>(_Rest_arg)...),
          _Myfirst(_Al, allocator_arg, ::std::forward<_This2>(_This_arg))
        {
        }

        template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int> = 0>
        tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>);

        template <class _Tag, class _Alloc, class _Tpl, enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int> = 0>
        tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std::forward<_Tpl>(_Right), make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>{})
        {
        }

        template <class _This2 = _This, enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...>, int> = 0>
        constexpr explicit(!conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple() noexcept(conjunction_v<is_nothrow_default_constructible<_This2>, is_nothrow_default_constructible<_Rest>...>)
        : _Mybase(), _Myfirst()
        {
        }

        template <class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
        constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>)
        tuple(const _This& _This_arg, const _Rest&... _Rest_arg) noexcept(
        conjunction_v<is_nothrow_copy_constructible<_This2>, is_nothrow_copy_constructible<_Rest>...>)
        : tuple(_Exact_args_t{}, _This_arg, _Rest_arg...)
        {
        }

        template <class _This2, class... _Rest2, enable_if_t<conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_constructible_val<tuple, _This2, _Rest2...>>, int> = 0>
        constexpr explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>)
        tuple(_This2&& _This_arg, _Rest2&&... _Rest_arg) noexcept(_Tuple_nothrow_constructible_v<tuple, _This2, _Rest2...>)
        : tuple(_Exact_args_t{}, ::std::forward<_This2>(_This_arg), ::std::forward<_Rest2>(_Rest_arg)...)
        {
        }

        tuple(const tuple&) = default;
        tuple(tuple&&) = default;

        template <class... _Other, enable_if_t<conjunction_v<_Tuple_constructible_val<tuple, const _Other&...>, _Tuple_convert_copy_val<tuple, _Other...>>, int> = 0>
        constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(const tuple<_Other...>& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, const _Other&...>)
        : tuple(_Unpack_tuple_t{}, _Right)
        {
        }

        template <class... _Other, enable_if_t<conjunction_v<_Tuple_constructible_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>, int> = 0>
        constexpr explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(tuple<_Other...>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _Other...>)
        : tuple(_Unpack_tuple_t{}, ::std::move(_Right))
        {
        }

        template <class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
        constexpr explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(const pair<_First, _Second>& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, const _First&, const _Second&>)
        : tuple(_Unpack_tuple_t{}, _Right)
        {
        }

        template <class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
        constexpr explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>)
        tuple(pair<_First, _Second>&& _Right) noexcept(_Tuple_nothrow_constructible_v<tuple, _First, _Second>)
        : tuple(_Unpack_tuple_t{}, ::std::move(_Right))
        {
        }

        template <class _Alloc, class _This2 = _This, enable_if_t<conjunction_v<is_default_constructible<_This2>, is_default_constructible<_Rest>...>, int> = 0>
        explicit(!conjunction_v<_Is_implicitly_default_constructible<_This2>, _Is_implicitly_default_constructible<_Rest>...>)
        tuple(allocator_arg_t, const _Alloc& _Al)
        : _Mybase(allocator_arg, _Al), _Myfirst(_Al, allocator_arg)
        {
        }

        template <class _Alloc, class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
        explicit(_Tuple_conditional_explicit_v<tuple, const _This2&, const _Rest&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const _This& _This_arg, const _Rest&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, _This_arg, _Rest_arg...)
        {
        }

        template <class _Alloc, class _This2, class... _Rest2, enable_if_t<conjunction_v<_Tuple_perfect_val<tuple, _This2, _Rest2...>, _Tuple_constructible_val<tuple, _This2, _Rest2...>>, int> = 0>
        explicit(_Tuple_conditional_explicit_v<tuple, _This2, _Rest2...>)
        tuple(allocator_arg_t, const _Alloc& _Al, _This2&& _This_arg, _Rest2&&... _Rest_arg)
        : tuple(_Alloc_exact_args_t{}, _Al, ::std::forward<_This2>(_This_arg), ::std::forward<_Rest2>(_Rest_arg)...)
        {
        }

        template <class _Alloc, class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, const _This2&, const _Rest&...>, int> = 0>
        tuple(allocator_arg_t, const _Alloc& _Al, const tuple& _Right) : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
        {
        }

        template <class _Alloc, class _This2 = _This, enable_if_t<_Tuple_constructible_v<tuple, _This2, _Rest...>, int> = 0>
        tuple(allocator_arg_t, const _Alloc& _Al, tuple&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std::move(_Right))
        {
        }

        template <class _Alloc, class... _Other, enable_if_t<conjunction_v<_Tuple_constructible_val<tuple, const _Other&...>, _Tuple_convert_copy_val<tuple, _Other...>>, int> = 0>
        explicit(_Tuple_conditional_explicit_v<tuple, const _Other&...>)
        tuple(allocator_arg_t, const _Alloc& _Al, const tuple<_Other...>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
        {
        }

        template <class _Alloc, class... _Other, enable_if_t<conjunction_v<_Tuple_constructible_val<tuple, _Other...>, _Tuple_convert_move_val<tuple, _Other...>>, int> = 0>
        explicit(_Tuple_conditional_explicit_v<tuple, _Other...>)
        tuple(allocator_arg_t, const _Alloc& _Al, tuple<_Other...>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std::move(_Right))
        {
        }

        template <class _Alloc, class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, const _First&, const _Second&>, int> = 0>
        explicit(_Tuple_conditional_explicit_v<tuple, const _First&, const _Second&>)
        tuple(allocator_arg_t, const _Alloc& _Al, const pair<_First, _Second>& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, _Right)
        {
        }

        template <class _Alloc, class _First, class _Second, enable_if_t<_Tuple_constructible_v<tuple, _First, _Second>, int> = 0>
        explicit(_Tuple_conditional_explicit_v<tuple, _First, _Second>)
        tuple(allocator_arg_t, const _Alloc& _Al, pair<_First, _Second>&& _Right)
        : tuple(_Alloc_unpack_tuple_t{}, _Al, ::std::move(_Right))
        {
        }

        tuple& operator=(const volatile tuple&) = delete;

        template <class _Myself = tuple,
                  class _This2 = _This,
                  enable_if_t<conjunction_v<_Is_copy_assignable_no_precondition_check<_This2>, _Is_copy_assignable_no_precondition_check<_Rest>...>, int> = 0>
        tuple& operator=(_Identity_t<const _Myself&> _Right) noexcept(
        conjunction_v<is_nothrow_copy_assignable<_This2>, is_nothrow_copy_assignable<_Rest>...>)
        {
            _Myfirst._Val = _Right._Myfirst._Val;
            _Get_rest() = _Right._Get_rest();
            return *this;
        }

        template <class _Myself = tuple,
                  class _This2 = _This,
                  enable_if_t<conjunction_v<_Is_move_assignable_no_precondition_check<_This2>, _Is_move_assignable_no_precondition_check<_Rest>...>, int> = 0>
        tuple& operator=(_Identity_t<_Myself&&> _Right) noexcept(
        conjunction_v<is_nothrow_move_assignable<_This2>, is_nothrow_move_assignable<_Rest>...>)
        {
            _Myfirst._Val = ::std::forward<_This>(_Right._Myfirst._Val);
            _Get_rest() = ::std::forward<_Mybase>(_Right._Get_rest());
            return *this;
        }

        template <class... _Other, enable_if_t<conjunction_v<negation<is_same<tuple, tuple<_Other...>>>, _Tuple_assignable_val<tuple, const _Other&...>>, int> = 0>
        tuple& operator=(const tuple<_Other...>& _Right) noexcept(_Tuple_nothrow_assignable_v<tuple, const _Other&...>)
        {
            _Myfirst._Val = _Right._Myfirst._Val;
            _Get_rest() = _Right._Get_rest();
            return *this;
        }

        template <class... _Other, enable_if_t<conjunction_v<negation<is_same<tuple, tuple<_Other...>>>, _Tuple_assignable_val<tuple, _Other...>>, int> = 0>
        tuple& operator=(tuple<_Other...>&& _Right) noexcept(_Tuple_nothrow_assignable_v<tuple, _Other...>)
        {
            _Myfirst._Val = ::std::forward<typename tuple<_Other...>::_This_type>(_Right._Myfirst._Val);
            _Get_rest() = ::std::forward<typename tuple<_Other...>::_Mybase>(_Right._Get_rest());
            return *this;
        }

        template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<tuple, const _First&, const _Second&>, int> = 0>
        tuple& operator=(const pair<_First, _Second>& _Right) noexcept(_Tuple_nothrow_assignable_v<tuple, const _First&, const _Second&>)
        {
            _Myfirst._Val = _Right.first;
            _Get_rest()._Myfirst._Val = _Right.second;
            return *this;
        }

        template <class _First, class _Second, enable_if_t<_Tuple_assignable_v<tuple, _First, _Second>, int> = 0>
        tuple& operator=(pair<_First, _Second>&& _Right) noexcept(_Tuple_nothrow_assignable_v<tuple, _First, _Second>)
        {
            _Myfirst._Val = ::std::forward<_First>(_Right.first);
            _Get_rest()._Myfirst._Val = ::std::forward<_Second>(_Right.second);
            return *this;
        }

        void swap(tuple& _Right) noexcept(conjunction_v<_Is_nothrow_swappable<_This>, _Is_nothrow_swappable<_Rest>...>)
        {
            _Swap_adl(_Myfirst._Val, _Right._Myfirst._Val);
            _Mybase::swap(_Right._Get_rest());
        }

        _Mybase& _Get_rest() noexcept
        {
            return *this;
        }

        constexpr const _Mybase& _Get_rest() const noexcept
        {
            return *this;
        }

        template <class... _Other> constexpr bool _Equals(const tuple<_Other...>& _Right) const
        {
            return _Myfirst._Val == _Right._Myfirst._Val && _Mybase::_Equals(_Right._Get_rest());
        }

        template <class... _Other> constexpr bool _Less(const tuple<_Other...>& _Right) const
        {
            return _Myfirst._Val < _Right._Myfirst._Val
                   || (!(_Right._Myfirst._Val < _Myfirst._Val) && _Mybase::_Less(_Right._Get_rest()));
        }

        template <size_t _Index, class... _Types>
        friend constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept;

        template <size_t _Index, class... _Types>
        friend constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept;

        template <size_t _Index, class... _Types>
        friend constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept;

        template <size_t _Index, class... _Types>
        friend constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept;

        template <class _Ty, class... _Types> friend constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept;

        template <class _Ty, class... _Types> friend constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept;

        template <class _Ty, class... _Types> friend constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept;

        template <class _Ty, class... _Types>
        friend constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept;

        _Tuple_val<_This> _Myfirst;
    };

    template <class... _Types1, class... _Types2>
    [[nodiscard]] constexpr bool operator==(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
    {
        static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
        return _Left._Equals(_Right);
    }

    template <class... _Types1, class... _Types2>
    [[nodiscard]] constexpr bool operator!=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
    {
        return !(_Left == _Right);
    }

    template <class... _Types1, class... _Types2>
    [[nodiscard]] constexpr bool operator<(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
    {
        static_assert(sizeof...(_Types1) == sizeof...(_Types2), "cannot compare tuples of different sizes");
        return _Left._Less(_Right);
    }

    template <class... _Types1, class... _Types2>
    [[nodiscard]] constexpr bool operator>=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
    {
        return !(_Left < _Right);
    }

    template <class... _Types1, class... _Types2>
    [[nodiscard]] constexpr bool operator>(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
    {
        return _Right < _Left;
    }

    template <class... _Types1, class... _Types2>
    [[nodiscard]] constexpr bool operator<=(const tuple<_Types1...>& _Left, const tuple<_Types2...>& _Right)
    {
        return !(_Right < _Left);
    }

    template <class... _Types, enable_if_t<conjunction_v<_Is_swappable<_Types>...>, int> = 0>
    void swap(tuple<_Types...>& _Left, tuple<_Types...>& _Right) noexcept(noexcept(_Left.swap(_Right)))
    {
        return _Left.swap(_Right);
    }

    template <class _Ty, class _Tuple> struct _Tuple_element
    {
    };

    template <class _This, class... _Rest> struct _Tuple_element<_This, tuple<_This, _Rest...>>
    {
        static_assert(!_Is_any_of_v<_This, _Rest...>, "duplicate type T in get<T>(tuple)");
        using _Ttype = tuple<_This, _Rest...>;
    };

    template <class _Ty, class _This, class... _Rest> struct _Tuple_element<_Ty, tuple<_This, _Rest...>>
    {
        using _Ttype = typename _Tuple_element<_Ty, tuple<_Rest...>>::_Ttype;
    };

    template <size_t _Index, class... _Types>
    [[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>& get(tuple<_Types...>& _Tuple) noexcept
    {
        using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
        return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
    }

    template <size_t _Index, class... _Types>
    [[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>& get(const tuple<_Types...>& _Tuple) noexcept
    {
        using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
        return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
    }

    template <size_t _Index, class... _Types>
    [[nodiscard]] constexpr tuple_element_t<_Index, tuple<_Types...>>&& get(tuple<_Types...>&& _Tuple) noexcept
    {
        using _Ty = tuple_element_t<_Index, tuple<_Types...>>;
        using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
        return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
    }

    template <size_t _Index, class... _Types>
    [[nodiscard]] constexpr const tuple_element_t<_Index, tuple<_Types...>>&& get(const tuple<_Types...>&& _Tuple) noexcept
    {
        using _Ty = tuple_element_t<_Index, tuple<_Types...>>;
        using _Ttype = typename tuple_element<_Index, tuple<_Types...>>::_Ttype;
        return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
    }

    template <class _Ty, class... _Types>[[nodiscard]] constexpr _Ty& get(tuple<_Types...>& _Tuple) noexcept
    {
        using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
        return static_cast<_Ttype&>(_Tuple)._Myfirst._Val;
    }

    template <class _Ty, class... _Types>[[nodiscard]] constexpr const _Ty& get(const tuple<_Types...>& _Tuple) noexcept
    {
        using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
        return static_cast<const _Ttype&>(_Tuple)._Myfirst._Val;
    }

    template <class _Ty, class... _Types>[[nodiscard]] constexpr _Ty&& get(tuple<_Types...>&& _Tuple) noexcept
    {
        using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
        return static_cast<_Ty&&>(static_cast<_Ttype&>(_Tuple)._Myfirst._Val);
    }

    template <class _Ty, class... _Types>
    [[nodiscard]] constexpr const _Ty&& get(const tuple<_Types...>&& _Tuple) noexcept
    {
        using _Ttype = typename _Tuple_element<_Ty, tuple<_Types...>>::_Ttype;
        return static_cast<const _Ty&&>(static_cast<const _Ttype&>(_Tuple)._Myfirst._Val);
    }

    template <class _This, class... _Rest>
    template <class _Tag, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, _Unpack_tuple_t>, int>>
    constexpr tuple<_This, _Rest...>::tuple(_Tag, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Exact_args_t{}, ::std::get<_Indices>(::std::forward<_Tpl>(_Right))...)
    {
    }

    template <class _This, class... _Rest>
    template <class _Tag, class _Alloc, class _Tpl, size_t... _Indices, enable_if_t<is_same_v<_Tag, _Alloc_unpack_tuple_t>, int>>
    tuple<_This, _Rest...>::tuple(_Tag, const _Alloc& _Al, _Tpl&& _Right, index_sequence<_Indices...>)
    : tuple(_Alloc_exact_args_t{}, _Al, ::std::get<_Indices>(::std::forward<_Tpl>(_Right))...)
    {
    }

    template <class... _Types>[[nodiscard]] constexpr tuple<_Unrefwrap_t<_Types>...> make_tuple(_Types&&... _Args)
    {
        using _Ttype = tuple<_Unrefwrap_t<_Types>...>;
        return _Ttype(::std::forward<_Types>(_Args)...);
    }

    template <class... _Types>[[nodiscard]] constexpr tuple<_Types&...> tie(_Types&... _Args) noexcept
    {
        using _Ttype = tuple<_Types&...>;
        return _Ttype(_Args...);
    }

    template <class... _Types>[[nodiscard]] constexpr tuple<_Types&&...> forward_as_tuple(_Types&&... _Args) noexcept
    {
        return tuple<_Types&&...>(::std::forward<_Types>(_Args)...);
    }

    template <class _Seq_type1, class _Seq_type2> struct _Cat_sequences;

    template <size_t... _Indexes1, size_t... _Indexes2>
    struct _Cat_sequences<index_sequence<_Indexes1...>, index_sequence<_Indexes2...>>
    {
        using type = index_sequence<_Indexes1..., _Indexes2...>;
    };

    template <class _Ty, size_t _Size> class array;

    template <size_t _Idx, class _Ty, size_t _Size>[[nodiscard]] constexpr _Ty& get(array<_Ty, _Size>& _Arr) noexcept;

    template <size_t _Idx, class _Ty, size_t _Size>
    [[nodiscard]] constexpr const _Ty& get(const array<_Ty, _Size>& _Arr) noexcept;

    template <size_t _Idx, class _Ty, size_t _Size>[[nodiscard]] constexpr _Ty&& get(array<_Ty, _Size>&& _Arr) noexcept;

    template <size_t _Idx, class _Ty, size_t _Size>
    [[nodiscard]] constexpr const _Ty&& get(const array<_Ty, _Size>&& _Arr) noexcept;

    template <class _Ty, class... _For_array> struct _View_as_tuple
    {
        static_assert(_Always_false<_Ty>, "Unsupported tuple_cat arguments.");
    };

    template <class... _Types> struct _View_as_tuple<tuple<_Types...>>
    {
        using type = tuple<_Types...>;
    };

    template <class _Ty1, class _Ty2> struct _View_as_tuple<pair<_Ty1, _Ty2>>
    {
        using type = tuple<_Ty1, _Ty2>;
    };

    template <class _Ty, class... _Types> struct _View_as_tuple<array<_Ty, 0>, _Types...>
    {
        using type = tuple<_Types...>;
    };

    template <class _Ty, size_t _Size, class... _Types>
    struct _View_as_tuple<array<_Ty, _Size>, _Types...> : _View_as_tuple<array<_Ty, _Size - 1>, _Ty, _Types...>
    {
    };

    template <size_t _Nx, class _Ty> struct _Repeat_for : integral_constant<size_t, _Nx>
    {
    };

    template <class _Ret, class _Kx_arg, class _Ix_arg, size_t _Ix_next, class... _Tuples> struct _Tuple_cat2
    {
        static_assert(sizeof...(_Tuples) == 0, "Unsupported tuple_cat arguments.");
        using type = _Ret;
        using _Kx_arg_seq = _Kx_arg;
        using _Ix_arg_seq = _Ix_arg;
    };

    template <class... _Types1, class _Kx_arg, size_t... _Ix, size_t _Ix_next, class... _Types2, class... _Rest>
    struct _Tuple_cat2<tuple<_Types1...>, _Kx_arg, index_sequence<_Ix...>, _Ix_next, tuple<_Types2...>, _Rest...>
    : _Tuple_cat2<tuple<_Types1..., _Types2...>,
                  typename _Cat_sequences<_Kx_arg, index_sequence_for<_Types2...>>::type,
                  index_sequence<_Ix..., _Repeat_for<_Ix_next, _Types2>::value...>,
                  _Ix_next + 1,
                  _Rest...>
    {
    };

    template <class... _Tuples>
    struct _Tuple_cat1
    : _Tuple_cat2<tuple<>, index_sequence<>, index_sequence<>, 0, typename _View_as_tuple<decay_t<_Tuples>>::type...>
    {
    };

#pragma warning(push)
#pragma warning(disable : 4100)
    template <class _Ret, size_t... _Kx, size_t... _Ix, class _Ty>
    constexpr _Ret _Tuple_cat(index_sequence<_Kx...>, index_sequence<_Ix...>, _Ty&& _Arg)
    {
        return _Ret(::std::get<_Kx>(::std::get<_Ix>(::std::forward<_Ty>(_Arg)))...);
    }
#pragma warning(pop)

    template <class... _Tuples>
    [[nodiscard]] constexpr typename _Tuple_cat1<_Tuples...>::type tuple_cat(_Tuples&&... _Tpls)
    {
        using _Cat1 = _Tuple_cat1<_Tuples...>;
        return _Tuple_cat<typename _Cat1::type>(typename _Cat1::_Kx_arg_seq(), typename _Cat1::_Ix_arg_seq(),
                                                ::std::forward_as_tuple(::std::forward<_Tuples>(_Tpls)...));
    }

    template <class _Tpl, class _Fx, size_t... _Indices>
    void _For_each_tuple_element_impl(_Tpl&& _Tuple, _Fx _Func, index_sequence<_Indices...>)
    {
        int _Ignored[] = { (static_cast<void>(_Func(::std::get<_Indices>(::std::forward<_Tpl>(_Tuple)))), 0)... };
        (void)_Ignored;
    }

    template <class _Tpl, class _Fx> void _For_each_tuple_element(_Tpl&& _Tuple, _Fx _Func)
    {
        _For_each_tuple_element_impl(::std::forward<_Tpl>(_Tuple), _Func,
                                     make_index_sequence<tuple_size_v<remove_reference_t<_Tpl>>>());
    }

#pragma warning(push)
#pragma warning(disable : 4100)

    template <class _Ty1, class _Ty2>
    template <class _Tuple1, class _Tuple2, size_t... _Indexes1, size_t... _Indexes2>
    pair<_Ty1, _Ty2>::pair(_Tuple1& _Val1, _Tuple2& _Val2, index_sequence<_Indexes1...>, index_sequence<_Indexes2...>)
    : first(::std::get<_Indexes1>(::std::move(_Val1))...), second(::std::get<_Indexes2>(::std::move(_Val2))...)
    {
    }
#pragma warning(pop)

    template <class _Ty1, class _Ty2>
    template <class... _Types1, class... _Types2>
    pair<_Ty1, _Ty2>::pair(piecewise_construct_t, tuple<_Types1...> _Val1, tuple<_Types2...> _Val2)
    : pair(_Val1, _Val2, index_sequence_for<_Types1...>(), index_sequence_for<_Types2...>())
    {
    }

    template <class... _Types, class _Alloc> struct uses_allocator<tuple<_Types...>, _Alloc> : true_type
    {
    };

    namespace [[deprecated(
    "warning STL4002: "
    "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
    "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1
    {
        using ::std::get;
        using ::std::ignore;
        using ::std::make_tuple;
        using ::std::ref;
        using ::std::tie;
        using ::std::tuple;
    }// namespace tr1

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Ty = void> struct divides
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left / _Right;
        }
    };

    template <class _Ty = void> struct modulus
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left % _Right;
        }
    };

    template <class _Ty = void> struct negate
    {
        typedef _Ty argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left) const
        {
            return -_Left;
        }
    };

    template <class _Ty = void> struct logical_and
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;

        constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left && _Right;
        }
    };

    template <class _Ty = void> struct logical_or
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef bool result_type;

        constexpr bool operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left || _Right;
        }
    };

    template <class _Ty = void> struct logical_not
    {
        typedef _Ty argument_type;
        typedef bool result_type;

        constexpr bool operator()(const _Ty& _Left) const
        {
            return !_Left;
        }
    };

    template <class _Ty = void> struct bit_and
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left & _Right;
        }
    };

    template <class _Ty = void> struct bit_or
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left | _Right;
        }
    };

    template <class _Ty = void> struct bit_xor
    {
        typedef _Ty first_argument_type;
        typedef _Ty second_argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left, const _Ty& _Right) const
        {
            return _Left ^ _Right;
        }
    };

    template <class _Ty = void> struct bit_not
    {
        typedef _Ty argument_type;
        typedef _Ty result_type;

        constexpr _Ty operator()(const _Ty& _Left) const
        {
            return ~_Left;
        }
    };

    template <> struct divides<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std::forward<_Ty1>(_Left) / ::std::forward<_Ty2>(_Right))
        {
            return ::std::forward<_Ty1>(_Left) / ::std::forward<_Ty2>(_Right);
        }
    };

    template <> struct modulus<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std::forward<_Ty1>(_Left) % ::std::forward<_Ty2>(_Right))
        {
            return ::std::forward<_Ty1>(_Left) % ::std::forward<_Ty2>(_Right);
        }
    };

    template <> struct negate<void>
    {
        using is_transparent = int;

        template <class _Ty> constexpr auto operator()(_Ty&& _Left) const -> decltype(-::std::forward<_Ty>(_Left))
        {
            return -::std::forward<_Ty>(_Left);
        }
    };

    template <> struct logical_and<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std::forward<_Ty1>(_Left) && ::std::forward<_Ty2>(_Right))
        {
            return ::std::forward<_Ty1>(_Left) && ::std::forward<_Ty2>(_Right);
        }
    };

    template <> struct logical_or<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std::forward<_Ty1>(_Left) || ::std::forward<_Ty2>(_Right))
        {
            return ::std::forward<_Ty1>(_Left) || ::std::forward<_Ty2>(_Right);
        }
    };

    template <> struct logical_not<void>
    {
        using is_transparent = int;

        template <class _Ty> constexpr auto operator()(_Ty&& _Left) const -> decltype(!::std::forward<_Ty>(_Left))
        {
            return !::std::forward<_Ty>(_Left);
        }
    };

    template <> struct bit_and<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std::forward<_Ty1>(_Left) & ::std::forward<_Ty2>(_Right))
        {
            return ::std::forward<_Ty1>(_Left) & ::std::forward<_Ty2>(_Right);
        }
    };

    template <> struct bit_or<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std::forward<_Ty1>(_Left) | ::std::forward<_Ty2>(_Right))
        {
            return ::std::forward<_Ty1>(_Left) | ::std::forward<_Ty2>(_Right);
        }
    };

    template <> struct bit_xor<void>
    {
        using is_transparent = int;

        template <class _Ty1, class _Ty2>
        constexpr auto operator()(_Ty1&& _Left, _Ty2&& _Right) const
        -> decltype(::std::forward<_Ty1>(_Left) ^ ::std::forward<_Ty2>(_Right))
        {
            return ::std::forward<_Ty1>(_Left) ^ ::std::forward<_Ty2>(_Right);
        }
    };

    template <> struct bit_not<void>
    {
        using is_transparent = int;

        template <class _Ty> constexpr auto operator()(_Ty&& _Left) const -> decltype(~::std::forward<_Ty>(_Left))
        {
            return ~::std::forward<_Ty>(_Left);
        }
    };

    __pragma(warning(push)) __pragma(warning(disable : 4996))

    template <class _Fn>
    class unary_negate
    {
    public:
        using argument_type = typename _Fn::argument_type;
        using result_type = bool;

        constexpr explicit unary_negate(const _Fn& _Func) : _Functor(_Func)
        {
        }

        constexpr bool operator()(const argument_type& _Left) const
        {
            return !_Functor(_Left);
        }

    private:
        _Fn _Functor;
    };

    template <class _Fn>[[nodiscard]] constexpr unary_negate<_Fn> not1(const _Fn& _Func)
    {
        return unary_negate<_Fn>(_Func);
    }

    template <class _Fn> class binary_negate
    {
    public:
        using first_argument_type = typename _Fn::first_argument_type;
        using second_argument_type = typename _Fn::second_argument_type;
        using result_type = bool;

        constexpr explicit binary_negate(const _Fn& _Func) : _Functor(_Func)
        {
        }

        constexpr bool operator()(const first_argument_type& _Left, const second_argument_type& _Right) const
        {
            return !_Functor(_Left, _Right);
        }

    private:
        _Fn _Functor;
    };

    template <class _Fn>[[nodiscard]] constexpr binary_negate<_Fn> not2(const _Fn& _Func)
    {
        return binary_negate<_Fn>(_Func);
    }
    __pragma(warning(pop))

    __pragma(warning(push)) __pragma(warning(disable : 4996))

    template <class _Fn>
    class binder1st : public unary_function<typename _Fn::second_argument_type, typename _Fn::result_type>
    {
    public:
        using _Base = unary_function<typename _Fn::second_argument_type, typename _Fn::result_type>;
        using argument_type = typename _Base::argument_type;
        using result_type = typename _Base::result_type;

        binder1st(const _Fn& _Func, const typename _Fn::first_argument_type& _Left) : op(_Func), value(_Left)
        {
        }

        result_type operator()(const argument_type& _Right) const
        {
            return op(value, _Right);
        }

        result_type operator()(argument_type& _Right) const
        {
            return op(value, _Right);
        }

    protected:
        _Fn op;
        typename _Fn::first_argument_type value;
    };

    template <class _Fn, class _Ty>[[nodiscard]] binder1st<_Fn> bind1st(const _Fn& _Func, const _Ty& _Left)
    {
        typename _Fn::first_argument_type _Val(_Left);
        return binder1st<_Fn>(_Func, _Val);
    }

    template <class _Fn>
    class binder2nd : public unary_function<typename _Fn::first_argument_type, typename _Fn::result_type>
    {
    public:
        using _Base = unary_function<typename _Fn::first_argument_type, typename _Fn::result_type>;
        using argument_type = typename _Base::argument_type;
        using result_type = typename _Base::result_type;

        binder2nd(const _Fn& _Func, const typename _Fn::second_argument_type& _Right) : op(_Func), value(_Right)
        {
        }

        result_type operator()(const argument_type& _Left) const
        {
            return op(_Left, value);
        }

        result_type operator()(argument_type& _Left) const
        {
            return op(_Left, value);
        }

    protected:
        _Fn op;
        typename _Fn::second_argument_type value;
    };

    template <class _Fn, class _Ty>[[nodiscard]] binder2nd<_Fn> bind2nd(const _Fn& _Func, const _Ty& _Right)
    {
        typename _Fn::second_argument_type _Val(_Right);
        return binder2nd<_Fn>(_Func, _Val);
    }
    __pragma(warning(pop))

    template <class _Arg, class _Result, class _Fn = _Result(*)(_Arg)>
    class pointer_to_unary_function : public unary_function<_Arg, _Result>
    {
    public:
        explicit pointer_to_unary_function(_Fn _Left) : _Pfun(_Left)
        {
        }

        _Result operator()(_Arg _Left) const
        {
            return _Pfun(_Left);
        }

    protected:
        _Fn _Pfun;
    };

    template <class _Arg1, class _Arg2, class _Result, class _Fn = _Result (*)(_Arg1, _Arg2)>
    class pointer_to_binary_function : public binary_function<_Arg1, _Arg2, _Result>
    {
    public:
        explicit pointer_to_binary_function(_Fn _Left) : _Pfun(_Left)
        {
        }

        _Result operator()(_Arg1 _Left, _Arg2 _Right) const
        {
            return _Pfun(_Left, _Right);
        }

    protected:
        _Fn _Pfun;
    };

    template <class _Arg, class _Result>
    [[nodiscard]] pointer_to_unary_function<_Arg, _Result, _Result(__cdecl*)(_Arg)> ptr_fun(_Result(__cdecl* _Left)(_Arg))
    {
        return pointer_to_unary_function<_Arg, _Result, _Result(__cdecl*)(_Arg)>(_Left);
    }
    template <class _Arg1, class _Arg2, class _Result>
    [[nodiscard]] pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__cdecl*)(_Arg1, _Arg2)>
    ptr_fun(_Result(__cdecl* _Left)(_Arg1, _Arg2))
    {
        return pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__cdecl*)(_Arg1, _Arg2)>(_Left);
    }
    template <class _Arg, class _Result>
    [[nodiscard]] pointer_to_unary_function<_Arg, _Result, _Result(__clrcall*)(_Arg)> ptr_fun(_Result(__clrcall* _Left)(_Arg))
    {
        return pointer_to_unary_function<_Arg, _Result, _Result(__clrcall*)(_Arg)>(_Left);
    }
    template <class _Arg1, class _Arg2, class _Result>
    [[nodiscard]] pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__clrcall*)(_Arg1, _Arg2)>
    ptr_fun(_Result(__clrcall* _Left)(_Arg1, _Arg2))
    {
        return pointer_to_binary_function<_Arg1, _Arg2, _Result, _Result(__clrcall*)(_Arg1, _Arg2)>(_Left);
    }

    template <class _Result, class _Ty> class mem_fun_t : public unary_function<_Ty*, _Result>
    {
    public:
        explicit mem_fun_t(_Result (_Ty::*_Pm)()) : _Pmemfun(_Pm)
        {
        }

        _Result operator()(_Ty* _Pleft) const
        {
            return (_Pleft->*_Pmemfun)();
        }

    private:
        _Result (_Ty::*_Pmemfun)();
    };

    template <class _Result, class _Ty, class _Arg> class mem_fun1_t : public binary_function<_Ty*, _Arg, _Result>
    {
    public:
        explicit mem_fun1_t(_Result (_Ty::*_Pm)(_Arg)) : _Pmemfun(_Pm)
        {
        }

        _Result operator()(_Ty* _Pleft, _Arg _Right) const
        {
            return (_Pleft->*_Pmemfun)(_Right);
        }

    private:
        _Result (_Ty::*_Pmemfun)(_Arg);
    };

    template <class _Result, class _Ty> class const_mem_fun_t : public unary_function<const _Ty*, _Result>
    {
    public:
        explicit const_mem_fun_t(_Result (_Ty::*_Pm)() const) : _Pmemfun(_Pm)
        {
        }

        _Result operator()(const _Ty* _Pleft) const
        {
            return (_Pleft->*_Pmemfun)();
        }

    private:
        _Result (_Ty::*_Pmemfun)() const;
    };

    template <class _Result, class _Ty, class _Arg>
    class const_mem_fun1_t : public binary_function<const _Ty*, _Arg, _Result>
    {
    public:
        explicit const_mem_fun1_t(_Result (_Ty::*_Pm)(_Arg) const) : _Pmemfun(_Pm)
        {
        }

        _Result operator()(const _Ty* _Pleft, _Arg _Right) const
        {
            return (_Pleft->*_Pmemfun)(_Right);
        }

    private:
        _Result (_Ty::*_Pmemfun)(_Arg) const;
    };

    template <class _Result, class _Ty>[[nodiscard]] mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)())
    {
        return mem_fun_t<_Result, _Ty>(_Pm);
    }

    template <class _Result, class _Ty, class _Arg>
    [[nodiscard]] mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg))
    {
        return mem_fun1_t<_Result, _Ty, _Arg>(_Pm);
    }

    template <class _Result, class _Ty>[[nodiscard]] const_mem_fun_t<_Result, _Ty> mem_fun(_Result (_Ty::*_Pm)() const)
    {
        return const_mem_fun_t<_Result, _Ty>(_Pm);
    }

    template <class _Result, class _Ty, class _Arg>
    [[nodiscard]] const_mem_fun1_t<_Result, _Ty, _Arg> mem_fun(_Result (_Ty::*_Pm)(_Arg) const)
    {
        return const_mem_fun1_t<_Result, _Ty, _Arg>(_Pm);
    }

    template <class _Result, class _Ty> class mem_fun_ref_t : public unary_function<_Ty, _Result>
    {
    public:
        explicit mem_fun_ref_t(_Result (_Ty::*_Pm)()) : _Pmemfun(_Pm)
        {
        }

        _Result operator()(_Ty& _Left) const
        {
            return (_Left.*_Pmemfun)();
        }

    private:
        _Result (_Ty::*_Pmemfun)();
    };

    template <class _Result, class _Ty, class _Arg> class mem_fun1_ref_t : public binary_function<_Ty, _Arg, _Result>
    {
    public:
        explicit mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg)) : _Pmemfun(_Pm)
        {
        }

        _Result operator()(_Ty& _Left, _Arg _Right) const
        {
            return (_Left.*_Pmemfun)(_Right);
        }

    private:
        _Result (_Ty::*_Pmemfun)(_Arg);
    };

    template <class _Result, class _Ty> class const_mem_fun_ref_t : public unary_function<_Ty, _Result>
    {
    public:
        explicit const_mem_fun_ref_t(_Result (_Ty::*_Pm)() const) : _Pmemfun(_Pm)
        {
        }

        _Result operator()(const _Ty& _Left) const
        {
            return (_Left.*_Pmemfun)();
        }

    private:
        _Result (_Ty::*_Pmemfun)() const;
    };

    template <class _Result, class _Ty, class _Arg>
    class const_mem_fun1_ref_t : public binary_function<_Ty, _Arg, _Result>
    {
    public:
        explicit const_mem_fun1_ref_t(_Result (_Ty::*_Pm)(_Arg) const) : _Pmemfun(_Pm)
        {
        }

        _Result operator()(const _Ty& _Left, _Arg _Right) const
        {
            return (_Left.*_Pmemfun)(_Right);
        }

    private:
        _Result (_Ty::*_Pmemfun)(_Arg) const;
    };

    template <class _Result, class _Ty>[[nodiscard]] mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)())
    {
        return mem_fun_ref_t<_Result, _Ty>(_Pm);
    }

    template <class _Result, class _Ty, class _Arg>
    [[nodiscard]] mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun_ref(_Result (_Ty::*_Pm)(_Arg))
    {
        return mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm);
    }

    template <class _Result, class _Ty>
    [[nodiscard]] const_mem_fun_ref_t<_Result, _Ty> mem_fun_ref(_Result (_Ty::*_Pm)() const)
    {
        return const_mem_fun_ref_t<_Result, _Ty>(_Pm);
    }

    template <class _Result, class _Ty, class _Arg>
    [[nodiscard]] const_mem_fun1_ref_t<_Result, _Ty, _Arg> mem_fun_ref(_Result (_Ty::*_Pm)(_Arg) const)
    {
        return const_mem_fun1_ref_t<_Result, _Ty, _Arg>(_Pm);
    }

    template <class _Memptr> class _Mem_fn : public _Weak_types<_Memptr>::type
    {
    private:
        _Memptr _Pm;

    public:
        explicit _Mem_fn(_Memptr _Val) noexcept : _Pm(_Val)
        {
        }

        template <class... _Types>
        auto operator()(_Types&&... _Args) const noexcept(noexcept(::std::invoke(_Pm, ::std::forward<_Types>(_Args)...)))
        -> decltype(::std::invoke(_Pm, ::std::forward<_Types>(_Args)...))
        {
            return ::std::invoke(_Pm, ::std::forward<_Types>(_Args)...);
        }
    };

    template <class _Rx, class _Ty>[[nodiscard]] _Mem_fn<_Rx _Ty::*> mem_fn(_Rx _Ty::*_Pm) noexcept
    {
        return _Mem_fn<_Rx _Ty::*>(_Pm);
    }

    class bad_function_call : public exception
    {
    public:
        bad_function_call() noexcept
        {
        }

        [[nodiscard]] virtual const char* what() const noexcept override
        {
            return "bad function call";
        }
    };

    [[noreturn]] void __cdecl _Xbad_function_call();

    template <class _Fty> class function;

    template <class _Ty>
    constexpr bool _Testable_callable_v
    = disjunction_v<is_pointer<_Ty>, _Is_specialization<_Ty, function>, is_member_pointer<_Ty>>;

    template <class _Ty> bool _Test_callable(const _Ty& _Arg) noexcept
    {
        if constexpr(_Testable_callable_v<_Ty>)
        {
            return !!_Arg;
        }
        else
        {
            (void)_Arg;
            return true;
        }
    }

#pragma warning(push)
#pragma warning(disable : 4265)

    template <class _Rx, class... _Types> class __declspec(novtable) _Func_base
    {
    public:
        virtual _Func_base* _Copy(void*) const = 0;
        virtual _Func_base* _Move(void*) noexcept = 0;
        virtual _Rx _Do_call(_Types&&...) = 0;
        virtual const type_info& _Target_type() const noexcept = 0;
        virtual void _Delete_this(bool) noexcept = 0;

        const void* _Target(const type_info& _Info) const noexcept
        {
            return _Target_type() == _Info ? _Get() : nullptr;
        }

        _Func_base() = default;
        _Func_base(const _Func_base&) = delete;
        _Func_base& operator=(const _Func_base&) = delete;

    private:
        virtual const void* _Get() const noexcept = 0;
    };
#pragma warning(pop)

    constexpr size_t _Space_size = (_Small_object_num_ptrs - 1) * sizeof(void*);

    template <class _Impl> constexpr bool _Is_large = (_Space_size < sizeof(_Impl)) || !_Impl::_Nothrow_move::value;

#pragma warning(push)
#pragma warning(disable : 4265)

    template <class _Callable, class _Alloc, class _Rx, class... _Types>
    class _Func_impl final : public _Func_base<_Rx, _Types...>
    {
    public:
        using _Mybase = _Func_base<_Rx, _Types...>;
        using _Myalty = _Rebind_alloc_t<_Alloc, _Func_impl>;
        using _Myalty_traits = allocator_traits<_Myalty>;
        using _Nothrow_move = is_nothrow_move_constructible<_Callable>;

        template <class _Other1, class _Other2>
        _Func_impl(_Other1&& _Val, _Other2&& _Ax)
        : _Mypair(_One_then_variadic_args_t(), ::std::forward<_Other2>(_Ax), ::std::forward<_Other1>(_Val))
        {
        }

    private:
        virtual _Mybase* _Copy(void* _Where) const override
        {
            auto& _Myax = _Mypair._Get_first();
            if constexpr(_Is_large<_Func_impl>)
            {
                (void)_Where;
                _Myalty _Rebound(_Myax);
                _Alloc_construct_ptr<_Myalty> _Constructor{ _Rebound };
                _Constructor._Allocate();
                _Construct_in_place(*_Constructor._Ptr, _Mypair._Myval2, _Myax);
                return _Constructor._Release();
            }
            else
            {
                const auto _Ptr = static_cast<_Func_impl*>(_Where);
                _Construct_in_place(*_Ptr, _Mypair._Myval2, _Myax);
                return _Ptr;
            }
        }

        virtual _Mybase* _Move(void* _Where) noexcept override
        {
            if constexpr(_Is_large<_Func_impl>)
            {
                (void)_Where;
                return nullptr;
            }
            else
            {
                const auto _Ptr = static_cast<_Func_impl*>(_Where);
                _Construct_in_place(*_Ptr, ::std::move(_Mypair._Myval2), ::std::move(_Mypair._Get_first()));
                return _Ptr;
            }
        }

        virtual _Rx _Do_call(_Types&&... _Args) override
        {
            return _Invoker_ret<_Rx>::_Call(_Mypair._Myval2, ::std::forward<_Types>(_Args)...);
        }

        virtual const type_info& _Target_type() const noexcept override
        {
            return typeid(_Callable);
        }

        virtual const void* _Get() const noexcept override
        {
            return ::std::addressof(_Mypair._Myval2);
        }

        virtual void _Delete_this(bool _Deallocate) noexcept override
        {
            _Myalty _Al(_Mypair._Get_first());
            _Destroy_in_place(*this);
            if(_Deallocate)
            {
                _Deallocate_plain(_Al, this);
            }
        }

        _Compressed_pair<_Alloc, _Callable> _Mypair;
    };

    template <class _Callable, class _Rx, class... _Types>
    class _Func_impl_no_alloc final : public _Func_base<_Rx, _Types...>
    {
    public:
        using _Mybase = _Func_base<_Rx, _Types...>;
        using _Nothrow_move = is_nothrow_move_constructible<_Callable>;

        template <class _Other, enable_if_t<!is_same_v<_Func_impl_no_alloc, decay_t<_Other>>, int> = 0>
        explicit _Func_impl_no_alloc(_Other&& _Val) : _Callee(::std::forward<_Other>(_Val))
        {
        }

    private:
        virtual _Mybase* _Copy(void* _Where) const override
        {
            if constexpr(_Is_large<_Func_impl_no_alloc>)
            {
                (void)_Where;
                return _Global_new<_Func_impl_no_alloc>(_Callee);
            }
            else
            {
                return ::new(_Where) _Func_impl_no_alloc(_Callee);
            }
        }

        virtual _Mybase* _Move(void* _Where) noexcept override
        {
            if constexpr(_Is_large<_Func_impl_no_alloc>)
            {
                (void)_Where;
                return nullptr;
            }
            else
            {
                return ::new(_Where) _Func_impl_no_alloc(::std::move(_Callee));
            }
        }

        virtual _Rx _Do_call(_Types&&... _Args) override
        {
            return _Invoker_ret<_Rx>::_Call(_Callee, ::std::forward<_Types>(_Args)...);
        }

        virtual const type_info& _Target_type() const noexcept override
        {
            return typeid(_Callable);
        }

        virtual const void* _Get() const noexcept override
        {
            return ::std::addressof(_Callee);
        }

        virtual void _Delete_this(bool _Dealloc) noexcept override
        {
            this->~_Func_impl_no_alloc();
            if(_Dealloc)
            {
                _Deallocate<alignof(_Func_impl_no_alloc)>(this, sizeof(_Func_impl_no_alloc));
            }
        }

        _Callable _Callee;
    };
#pragma warning(pop)

    template <class _Ret, class... _Types> class _Func_class : public _Arg_types<_Types...>
    {
    public:
        using result_type = _Ret;

        using _Ptrt = _Func_base<_Ret, _Types...>;

        _Func_class() noexcept
        {
            _Set(nullptr);
        }

        _Ret operator()(_Types... _Args) const
        {
            if(_Empty())
            {
                _Xbad_function_call();
            }
            const auto _Impl = _Getimpl();
            return _Impl->_Do_call(::std::forward<_Types>(_Args)...);
        }

        ~_Func_class() noexcept
        {
            _Tidy();
        }

    protected:
        template <class _Fx, class _Function>
        using _Enable_if_callable_t
        = enable_if_t<conjunction_v<negation<is_same<decay_t<_Fx>, _Function>>, _Is_invocable_r<_Ret, _Fx, _Types...>>, int>;

        bool _Empty() const noexcept
        {
            return !_Getimpl();
        }

        void _Reset_copy(const _Func_class& _Right)
        {
            if(!_Right._Empty())
            {
                _Set(_Right._Getimpl()->_Copy(&_Mystorage));
            }
        }

        void _Reset_move(_Func_class&& _Right) noexcept
        {
            if(!_Right._Empty())
            {
                if(_Right._Local())
                {
                    _Set(_Right._Getimpl()->_Move(&_Mystorage));
                    _Right._Tidy();
                }
                else
                {
                    _Set(_Right._Getimpl());
                    _Right._Set(nullptr);
                }
            }
        }

        template <class _Fx> void _Reset(_Fx&& _Val)
        {
            if(!_Test_callable(_Val))
            {
                return;
            }

            using _Impl = _Func_impl_no_alloc<decay_t<_Fx>, _Ret, _Types...>;
            if constexpr(_Is_large<_Impl>)
            {
                _Set(_Global_new<_Impl>(::std::forward<_Fx>(_Val)));
            }
            else
            {
                _Set(::new(static_cast<void*>(&_Mystorage)) _Impl(::std::forward<_Fx>(_Val)));
            }
        }

        template <class _Fx, class _Alloc> void _Reset_alloc(_Fx&& _Val, const _Alloc& _Ax)
        {
            if(!_Test_callable(_Val))
            {
                return;
            }

            using _Myimpl = _Func_impl<decay_t<_Fx>, _Alloc, _Ret, _Types...>;
            if constexpr(_Is_large<_Myimpl>)
            {
                using _Alimpl = _Rebind_alloc_t<_Alloc, _Myimpl>;
                _Alimpl _Al(_Ax);
                _Alloc_construct_ptr<_Alimpl> _Constructor{ _Al };
                _Constructor._Allocate();
                _Construct_in_place(*_Constructor._Ptr, ::std::forward<_Fx>(_Val), _Ax);
                _Set(_Unfancy(_Constructor._Release()));
            }
            else
            {
                const auto _Ptr = reinterpret_cast<_Myimpl*>(&_Mystorage);
                _Construct_in_place(*_Ptr, ::std::forward<_Fx>(_Val), _Ax);
                _Set(_Ptr);
            }
        }

        void _Tidy() noexcept
        {
            if(!_Empty())
            {
                _Getimpl()->_Delete_this(!_Local());
                _Set(nullptr);
            }
        }

        void _Swap(_Func_class& _Right) noexcept
        {
            if(!_Local() && !_Right._Local())
            {
                _Ptrt* _Temp = _Getimpl();
                _Set(_Right._Getimpl());
                _Right._Set(_Temp);
            }
            else
            {
                _Func_class _Temp;
                _Temp._Reset_move(::std::move(*this));
                _Reset_move(::std::move(_Right));
                _Right._Reset_move(::std::move(_Temp));
            }
        }

        const type_info& _Target_type() const noexcept
        {
            return _Getimpl() ? _Getimpl()->_Target_type() : typeid(void);
        }

        const void* _Target(const type_info& _Info) const noexcept
        {
            return _Getimpl() ? _Getimpl()->_Target(_Info) : nullptr;
        }

    private:
        bool _Local() const noexcept
        {
            return _Getimpl() == static_cast<const void*>(&_Mystorage);
        }

        union _Storage
        {
            max_align_t _Dummy1;
            char _Dummy2[_Space_size];
            _Ptrt* _Ptrs[_Small_object_num_ptrs];
        };

        _Storage _Mystorage;
        enum
        {
            _EEN_IMPL = _Small_object_num_ptrs - 1
        };
        _Ptrt* _Getimpl() const noexcept
        {
            return _Mystorage._Ptrs[_Small_object_num_ptrs - 1];
        }

        void _Set(_Ptrt* _Ptr) noexcept
        {
            _Mystorage._Ptrs[_Small_object_num_ptrs - 1] = _Ptr;
        }
    };

    template <class _Tx> struct _Get_function_impl
    {
        static_assert(_Always_false<_Tx>, "std::function does not accept non-function types as template arguments.");
    };

    template <class _Ret, class... _Types> struct _Get_function_impl<_Ret __cdecl(_Types...)>
    {
        using type = _Func_class<_Ret, _Types...>;
    };
    template <class _Ret, class... _Types> struct _Get_function_impl<_Ret __clrcall(_Types...)>
    {
        using type = _Func_class<_Ret, _Types...>;
    };

    template <class _Fty> class function : public _Get_function_impl<_Fty>::type
    {
    private:
        using _Mybase = typename _Get_function_impl<_Fty>::type;

    public:
        function() noexcept
        {
        }

        function(nullptr_t) noexcept
        {
        }

        function(const function& _Right)
        {
            this->_Reset_copy(_Right);
        }

        template <class _Fx, typename _Mybase::template _Enable_if_callable_t<_Fx&, function> = 0>

        function(_Fx _Func)
        {
            this->_Reset(::std::move(_Func));
        }

        template <class _Alloc> function(allocator_arg_t, const _Alloc&) noexcept
        {
        }

        template <class _Alloc> function(allocator_arg_t, const _Alloc&, nullptr_t) noexcept
        {
        }

        template <class _Alloc> function(allocator_arg_t, const _Alloc& _Ax, const function& _Right)
        {
            this->_Reset_alloc(_Right, _Ax);
        }

        template <class _Fx, class _Alloc, typename _Mybase::template _Enable_if_callable_t<_Fx&, function> = 0>

        function(allocator_arg_t, const _Alloc& _Ax, _Fx _Func)
        {
            this->_Reset_alloc(::std::move(_Func), _Ax);
        }

        function& operator=(const function& _Right)
        {
            function(_Right).swap(*this);
            return *this;
        }

        function(function&& _Right) noexcept
        {
            this->_Reset_move(::std::move(_Right));
        }

        template <class _Alloc> function(allocator_arg_t, const _Alloc& _Al, function&& _Right)
        {
            this->_Reset_alloc(::std::move(_Right), _Al);
        }

        function& operator=(function&& _Right) noexcept
        {
            if(this != ::std::addressof(_Right))
            {
                this->_Tidy();
                this->_Reset_move(::std::move(_Right));
            }
            return *this;
        }

        template <class _Fx, typename _Mybase::template _Enable_if_callable_t<decay_t<_Fx>&, function> = 0>

        function& operator=(_Fx&& _Func)
        {
            function(::std::forward<_Fx>(_Func)).swap(*this);
            return *this;
        }

        template <class _Fx, class _Alloc> void assign(_Fx&& _Func, const _Alloc& _Ax)
        {
            function(allocator_arg, _Ax, ::std::forward<_Fx>(_Func)).swap(*this);
        }

        function& operator=(nullptr_t) noexcept
        {
            this->_Tidy();
            return *this;
        }

        template <class _Fx> function& operator=(reference_wrapper<_Fx> _Func) noexcept
        {
            this->_Tidy();
            this->_Reset(_Func);
            return *this;
        }

        void swap(function& _Right) noexcept
        {
            this->_Swap(_Right);
        }

        explicit operator bool() const noexcept
        {
            return !this->_Empty();
        }

        [[nodiscard]] const type_info& target_type() const noexcept
        {
            return this->_Target_type();
        }

        template <class _Fx>[[nodiscard]] _Fx* target() noexcept
        {
            return reinterpret_cast<_Fx*>(const_cast<void*>(this->_Target(typeid(_Fx))));
        }

        template <class _Fx>[[nodiscard]] const _Fx* target() const noexcept
        {
            return reinterpret_cast<const _Fx*>(this->_Target(typeid(_Fx)));
        }
    };

    template <class _Fty> void swap(function<_Fty>& _Left, function<_Fty>& _Right) noexcept
    {
        _Left.swap(_Right);
    }

    template <class _Fty>[[nodiscard]] bool operator==(const function<_Fty>& _Other, nullptr_t) noexcept
    {
        return !_Other;
    }

    template <class _Fty>[[nodiscard]] bool operator==(nullptr_t, const function<_Fty>& _Other) noexcept
    {
        return !_Other;
    }

    template <class _Fty>[[nodiscard]] bool operator!=(const function<_Fty>& _Other, nullptr_t) noexcept
    {
        return static_cast<bool>(_Other);
    }

    template <class _Fty>[[nodiscard]] bool operator!=(nullptr_t, const function<_Fty>& _Other) noexcept
    {
        return static_cast<bool>(_Other);
    }

    template <int _Nx> struct _Ph
    {
    };

    template <class _Tx> struct is_placeholder : integral_constant<int, 0>
    {
    };

    template <int _Nx> struct is_placeholder<_Ph<_Nx>> : integral_constant<int, _Nx>
    {
    };

    template <class _Tx> struct is_placeholder<const _Tx> : is_placeholder<_Tx>::type
    {
    };

    template <class _Tx> struct is_placeholder<volatile _Tx> : is_placeholder<_Tx>::type
    {
    };

    template <class _Tx> struct is_placeholder<const volatile _Tx> : is_placeholder<_Tx>::type
    {
    };

    template <class _Ty> constexpr int is_placeholder_v = is_placeholder<_Ty>::value;

    template <class _Ret, class _Fx, class... _Types> class _Binder;

    template <class _Tx> struct is_bind_expression : false_type
    {
    };

    template <class _Ret, class _Fx, class... _Types>
    struct is_bind_expression<_Binder<_Ret, _Fx, _Types...>> : true_type
    {
    };

    template <class _Tx> struct is_bind_expression<const _Tx> : is_bind_expression<_Tx>::type
    {
    };

    template <class _Tx> struct is_bind_expression<volatile _Tx> : is_bind_expression<_Tx>::type
    {
    };

    template <class _Tx> struct is_bind_expression<const volatile _Tx> : is_bind_expression<_Tx>::type
    {
    };

    template <class _Ty> constexpr bool is_bind_expression_v = is_bind_expression<_Ty>::value;

    template <class _Cv_TiD, bool = _Is_specialization_v<remove_cv_t<_Cv_TiD>, reference_wrapper>, bool = is_bind_expression_v<_Cv_TiD>, int = is_placeholder_v<_Cv_TiD>>
    struct _Select_fixer;

    template <class _Cv_TiD> struct _Select_fixer<_Cv_TiD, true, false, 0>
    {
        template <class _Untuple> static auto _Fix(_Cv_TiD& _Tid, _Untuple &&) -> typename _Cv_TiD::type&
        {
            return _Tid.get();
        }
    };

    template <class _Cv_TiD> struct _Select_fixer<_Cv_TiD, false, true, 0>
    {
#pragma warning(push)
#pragma warning(disable : 4100)
        template <class _Untuple, size_t... _Jx>
        static auto _Apply(_Cv_TiD& _Tid, _Untuple&& _Ut, index_sequence<_Jx...>)
        -> decltype(_Tid(::std::get<_Jx>(::std::move(_Ut))...))
        {
            return _Tid(::std::get<_Jx>(::std::move(_Ut))...);
        }
#pragma warning(pop)

        template <class _Untuple>
        static auto _Fix(_Cv_TiD& _Tid, _Untuple&& _Ut)
        -> decltype(_Apply(_Tid, ::std::move(_Ut), make_index_sequence<tuple_size_v<_Untuple>>()))
        {
            return _Apply(_Tid, ::std::move(_Ut), make_index_sequence<tuple_size_v<_Untuple>>());
        }
    };

    template <class _Cv_TiD> struct _Select_fixer<_Cv_TiD, false, false, 0>
    {
        template <class _Untuple> static _Cv_TiD& _Fix(_Cv_TiD& _Tid, _Untuple&&)
        {
            return _Tid;
        }
    };

    template <class _Cv_TiD, int _Jx> struct _Select_fixer<_Cv_TiD, false, false, _Jx>
    {
        static_assert(_Jx > 0, "invalid is_placeholder value");

        template <class _Untuple>
        static auto _Fix(_Cv_TiD&, _Untuple&& _Ut) -> decltype(::std::get<_Jx - 1>(::std::move(_Ut)))
        {
            return ::std::get<_Jx - 1>(::std::move(_Ut));
        }
    };

    template <class _Cv_TiD, class _Untuple>
    auto _Fix_arg(_Cv_TiD& _Tid, _Untuple&& _Ut) -> decltype(_Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std::move(_Ut)))
    {
        return _Select_fixer<_Cv_TiD>::_Fix(_Tid, ::std::move(_Ut));
    }

#pragma warning(push)
#pragma warning(disable : 4100)

    template <class _Ret, size_t... _Ix, class _Cv_FD, class _Cv_tuple_TiD, class _Untuple>
    auto _Call_binder(_Invoker_ret<_Ret>, index_sequence<_Ix...>, _Cv_FD& _Obj, _Cv_tuple_TiD& _Tpl, _Untuple&& _Ut)
    -> decltype(_Invoker_ret<_Ret>::_Call(_Obj, _Fix_arg(::std::get<_Ix>(_Tpl), ::std::move(_Ut))...))
    {
        return _Invoker_ret<_Ret>::_Call(_Obj, _Fix_arg(::std::get<_Ix>(_Tpl), ::std::move(_Ut))...);
    }
#pragma warning(pop)

    template <class _Ret> struct _Forced_result_type
    {
        typedef _Ret result_type;
    };

    template <class _Ret, class _Fx> struct _Binder_result_type
    {
        using _Decayed = decay_t<_Fx>;

        using _All_weak_types = typename _Weak_types<_Decayed>::type;

        using type = conditional_t<is_same_v<_Ret, _Unforced>, _Weak_result_type<_All_weak_types>, _Forced_result_type<_Ret>>;
    };

    template <class _Ret, class _Fx, class... _Types> class _Binder : public _Binder_result_type<_Ret, _Fx>::type
    {
    private:
        using _Seq = index_sequence_for<_Types...>;
        using _First = decay_t<_Fx>;
        using _Second = tuple<decay_t<_Types>...>;

        _Compressed_pair<_First, _Second> _Mypair;

    public:
        explicit _Binder(_Fx&& _Func, _Types&&... _Args)
        : _Mypair(_One_then_variadic_args_t(), ::std::forward<_Fx>(_Func), ::std::forward<_Types>(_Args)...)
        {
        }

        template <class... _Unbound>
        auto operator()(_Unbound&&... _Unbargs)
        -> decltype(_Call_binder(_Invoker_ret<_Ret>(),
                                 _Seq(),
                                 _Mypair._Get_first(),
                                 _Mypair._Myval2,
                                 ::std::forward_as_tuple(::std::forward<_Unbound>(_Unbargs)...)))
        {
            return _Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Myval2,
                                ::std::forward_as_tuple(::std::forward<_Unbound>(_Unbargs)...));
        }
        template <class... _Unbound>
        auto operator()(_Unbound&&... _Unbargs) const
        -> decltype(_Call_binder(_Invoker_ret<_Ret>(),
                                 _Seq(),
                                 _Mypair._Get_first(),
                                 _Mypair._Myval2,
                                 ::std::forward_as_tuple(::std::forward<_Unbound>(_Unbargs)...)))
        {
            return _Call_binder(_Invoker_ret<_Ret>(), _Seq(), _Mypair._Get_first(), _Mypair._Myval2,
                                ::std::forward_as_tuple(::std::forward<_Unbound>(_Unbargs)...));
        }
    };

    template <class _Fx, class... _Types>
    [[nodiscard]] _Binder<_Unforced, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args)
    {
        return _Binder<_Unforced, _Fx, _Types...>(::std::forward<_Fx>(_Func), ::std::forward<_Types>(_Args)...);
    }

    template <class _Ret, class _Fx, class... _Types>
    [[nodiscard]] _Binder<_Ret, _Fx, _Types...> bind(_Fx&& _Func, _Types&&... _Args)
    {
        return _Binder<_Ret, _Fx, _Types...>(::std::forward<_Fx>(_Func), ::std::forward<_Types>(_Args)...);
    }

    namespace placeholders
    {
        constexpr _Ph<1> _1{};
        constexpr _Ph<2> _2{};
        constexpr _Ph<3> _3{};
        constexpr _Ph<4> _4{};
        constexpr _Ph<5> _5{};
        constexpr _Ph<6> _6{};
        constexpr _Ph<7> _7{};
        constexpr _Ph<8> _8{};
        constexpr _Ph<9> _9{};
        constexpr _Ph<10> _10{};
        constexpr _Ph<11> _11{};
        constexpr _Ph<12> _12{};
        constexpr _Ph<13> _13{};
        constexpr _Ph<14> _14{};
        constexpr _Ph<15> _15{};
        constexpr _Ph<16> _16{};
        constexpr _Ph<17> _17{};
        constexpr _Ph<18> _18{};
        constexpr _Ph<19> _19{};
        constexpr _Ph<20> _20{};
    }// namespace placeholders

    template <class _Fty, class _Alloc> struct uses_allocator<function<_Fty>, _Alloc> : true_type
    {
    };

    namespace [[deprecated(
    "warning STL4002: "
    "The non-Standard std::tr1 namespace and TR1-only machinery are deprecated and will be REMOVED. You can "
    "define _SILENCE_TR1_NAMESPACE_DEPRECATION_WARNING to acknowledge that you have received this warning.")]] tr1
    {
        using ::std::bad_function_call;
        using ::std::bind;
        using ::std::function;
        using ::std::is_bind_expression;
        using ::std::is_placeholder;
        using ::std::mem_fn;
        using ::std::swap;
        namespace placeholders
        {
            using namespace ::std::placeholders;
        }
    }// namespace tr1

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    __pragma(warning(push)) __pragma(warning(disable : 4996))

    template <class _Codecvt, class _Elem = wchar_t, class _Traits = char_traits<_Elem>>
    class wbuffer_convert : public basic_streambuf<_Elem, _Traits>
    {
        enum _Mode
        {
            _Unused,
            _Wrote,
            _Need,
            _Got,
            _Eof
        };
        enum
        {
            _STRING_INC = 8
        };

    public:
        using _Mysb = streambuf;
        using _Byte_traits = char_traits<char>;

        using int_type = typename _Traits::int_type;
        using pos_type = typename _Traits::pos_type;
        using off_type = typename _Traits::off_type;
        using state_type = typename _Codecvt::state_type;

        explicit wbuffer_convert(_Mysb* _Strbuf = nullptr)
        : _State(), _Pcvt(new _Codecvt), _Mystrbuf(_Strbuf), _Status(_Unused), _Nback(0)
        {
            _Loc = locale(_Loc, _Pcvt);
        }

        wbuffer_convert(_Mysb* _Strbuf, const _Codecvt* _Pcvt_arg)
        : _State(), _Pcvt(_Pcvt_arg), _Mystrbuf(_Strbuf), _Status(_Unused), _Nback(0)
        {
            _Loc = locale(_Loc, _Pcvt);
        }

        wbuffer_convert(_Mysb* _Strbuf, const _Codecvt* _Pcvt_arg, state_type _State_arg)
        : _State(_State_arg), _Pcvt(_Pcvt_arg), _Mystrbuf(_Strbuf), _Status(_Unused), _Nback(0)
        {
            _Loc = locale(_Loc, _Pcvt);
        }

        virtual ~wbuffer_convert() noexcept
        {
            while(_Status == _Wrote)
            {
                if(_Str.size() < _STRING_INC)
                {
                    _Str.assign(_STRING_INC, '\0');
                }

                char* _Buf = &_Str[0];
                char* _Dest;
                switch(_Pcvt->unshift(_State, _Buf, _Buf + _Str.size(), _Dest))
                {
                    case _Codecvt::ok:
                        _Status = _Unused;

                    case _Codecvt::partial:
                    {
                        ptrdiff_t _Count = _Dest - _Buf;
                        if(0 < _Count
                           && _Byte_traits::eq_int_type(_Byte_traits::eof(),
                                                        static_cast<_Byte_traits::int_type>(_Mystrbuf->sputn(_Buf, _Count))))
                        {
                            return;
                        }

                        if(_Status == _Wrote && _Count == 0)
                        {
                            _Str.append(_STRING_INC, '\0');
                        }

                        break;
                    }

                    case _Codecvt::noconv:
                        return;

                    default:
                        return;
                }
            }
        }

        [[nodiscard]] _Mysb* rdbuf() const
        {
            return _Mystrbuf;
        }

        _Mysb* rdbuf(_Mysb* _Strbuf)
        {
            _Mysb* _Oldstrbuf = _Mystrbuf;
            _Mystrbuf = _Strbuf;
            return _Oldstrbuf;
        }

        [[nodiscard]] state_type state() const
        {
            return _State;
        }

        wbuffer_convert(const wbuffer_convert&) = delete;
        wbuffer_convert& operator=(const wbuffer_convert&) = delete;

    protected:
        virtual int_type overflow(int_type _Meta = _Traits::eof())
        {
            if(_Traits::eq_int_type(_Traits::eof(), _Meta))
            {
                return _Traits::not_eof(_Meta);
            }
            else if(!_Mystrbuf || 0 < _Nback || (_Status != _Unused && _Status != _Wrote))
            {
                return _Traits::eof();
            }
            else
            {
                const _Elem _Ch = _Traits::to_char_type(_Meta);

                if(_Str.size() < _STRING_INC)
                {
                    _Str.assign(_STRING_INC, '\0');
                }

                for(_Status = _Wrote;;)
                {
                    char* _Buf = &_Str[0];
                    const _Elem* _Src;
                    char* _Dest;
                    switch(_Pcvt->out(_State, &_Ch, &_Ch + 1, _Src, _Buf, _Buf + _Str.size(), _Dest))
                    {
                        case _Codecvt::partial:
                        case _Codecvt::ok:
                        {
                            ptrdiff_t _Count = _Dest - _Buf;
                            if(0 < _Count
                               && _Byte_traits::eq_int_type(
                               _Byte_traits::eof(), static_cast<_Byte_traits::int_type>(_Mystrbuf->sputn(_Buf, _Count))))
                            {
                                return _Traits::eof();
                            }

                            if(_Src != &_Ch)
                            {
                                return _Meta;
                            }

                            if(0 >= _Count)
                            {
                                if(_Str.size() >= 4 * _STRING_INC)
                                {
                                    return _Traits::eof();
                                }

                                _Str.append(_STRING_INC, '\0');
                            }

                            break;
                        }

                        case _Codecvt::noconv:
                            if(_Traits::eq_int_type(
                               _Traits::eof(), static_cast<int_type>(_Mystrbuf->sputn(reinterpret_cast<const char*>(&_Ch),
                                                                                      static_cast<streamsize>(sizeof(_Elem))))))
                            {
                                return _Traits::eof();
                            }

                            return _Meta;

                        default:
                            return _Traits::eof();
                    }
                }
            }
        }

        virtual int_type pbackfail(int_type _Meta = _Traits::eof())
        {
            if(sizeof(_Myback) / sizeof(_Myback[0]) <= _Nback || _Status == _Wrote)
            {
                return _Traits::eof();
            }
            else
            {
                if(!_Traits::eq_int_type(_Traits::eof(), _Meta))
                {
                    _Myback[_Nback] = _Traits::to_char_type(_Meta);
                }

                ++_Nback;
                if(_Status == _Unused)
                {
                    _Status = _Got;
                }

                return _Meta;
            }
        }

        virtual int_type underflow()
        {
            int_type _Meta;

            if(0 >= _Nback)
            {
                if(_Traits::eq_int_type(_Traits::eof(), _Meta = _Get_elem()))
                {
                    return _Meta;
                }

                _Myback[_Nback++] = _Traits::to_char_type(_Meta);
            }

            return _Traits::to_int_type(_Myback[_Nback - 1]);
        }

#pragma warning(push)
#pragma warning(disable : 6385)

        virtual int_type uflow()
        {
            int_type _Meta;

            if(0 >= _Nback)
            {
                if(_Traits::eq_int_type(_Traits::eof(), _Meta = _Get_elem()))
                {
                    return _Meta;
                }

                _Myback[_Nback++] = _Traits::to_char_type(_Meta);
            }

            return _Traits::to_int_type(_Myback[--_Nback]);
        }
#pragma warning(pop)

        virtual pos_type
        seekoff(off_type, ios_base::seekdir, ios_base::openmode = static_cast<ios_base::openmode>(ios_base::in | ios_base::out))
        {
            return pos_type(-1);
        }

        virtual pos_type seekpos(pos_type, ios_base::openmode = static_cast<ios_base::openmode>(ios_base::in | ios_base::out))
        {
            return pos_type(-1);
        }

    private:
        int_type _Get_elem()
        {
            if(_Mystrbuf && _Status != _Wrote)
            {
                if(_Status != _Eof)
                {
                    if(_Str.empty())
                    {
                        _Status = _Need;
                    }
                    else
                    {
                        _Status = _Got;
                    }
                }

                while(_Status != _Eof)
                {
                    char* _Buf = &_Str[0];
                    _Elem _Ch;
                    _Elem* _Dest;
                    const char* _Src;
                    int _Meta;

                    if(_Status == _Need)
                    {
                        if(_Byte_traits::eq_int_type(_Byte_traits::eof(), _Meta = _Mystrbuf->sbumpc()))
                        {
                            _Status = _Eof;
                        }
                        else
                        {
                            _Str.push_back(_Byte_traits::to_char_type(_Meta));
                        }
                    }

                    switch(_Pcvt->in(_State, _Buf, _Buf + _Str.size(), _Src, &_Ch, &_Ch + 1, _Dest))
                    {
                        case _Codecvt::partial:
                        case _Codecvt::ok:
                            _Str.erase(0, static_cast<size_t>(_Src - _Buf));
                            if(_Dest != &_Ch)
                            {
                                return _Traits::to_int_type(_Ch);
                            }

                            break;

                        case _Codecvt::noconv:
                            if(_Str.size() < sizeof(_Elem))
                            {
                                break;
                            }

                            ::memcpy(&_Ch, _Buf, sizeof(_Elem));
                            _Str.erase(0, sizeof(_Elem));
                            return _Traits::to_int_type(_Ch);

                        default:
                            _Status = _Eof;
                            break;
                    }
                }
            }

            return _Traits::eof();
        }

        state_type _State;
        const _Codecvt* _Pcvt;
        _Mysb* _Mystrbuf;
        _Mode _Status;
        size_t _Nback;
        _Elem _Myback[8];
        string _Str;
        locale _Loc;
    };

    template <class _Codecvt, class _Elem = wchar_t, class _Walloc = allocator<_Elem>, class _Balloc = allocator<char>>
    class wstring_convert
    {
        enum
        {
            _BUF_INC = 8,
            _BUF_MAX = 16
        };
        void _Init(const _Codecvt* _Pcvt_arg = new _Codecvt)
        {
            _State = state_type{};
            _Pcvt = _Pcvt_arg;
            _Loc = locale(_Loc, _Pcvt);
            _Nconv = 0;
        }

    public:
        using byte_string = basic_string<char, char_traits<char>, _Balloc>;
        using wide_string = basic_string<_Elem, char_traits<_Elem>, _Walloc>;
        using state_type = typename _Codecvt::state_type;
        using int_type = typename wide_string::traits_type::int_type;

        wstring_convert() : _Has_state(false), _Has_berr(false), _Has_werr(false)
        {
            _Init();
        }

        explicit wstring_convert(const _Codecvt* _Pcvt_arg) : _Has_state(false), _Has_berr(false), _Has_werr(false)
        {
            _Init(_Pcvt_arg);
        }

        wstring_convert(const _Codecvt* _Pcvt_arg, state_type _State_arg)
        : _Has_state(true), _Has_berr(false), _Has_werr(false)
        {
            _Init(_Pcvt_arg);
            _State = _State_arg;
        }

        explicit wstring_convert(const byte_string& _Berr_arg)
        : _Berr(_Berr_arg), _Has_state(false), _Has_berr(true), _Has_werr(false)
        {
            _Init();
        }

        wstring_convert(const byte_string& _Berr_arg, const wide_string& _Werr_arg)
        : _Berr(_Berr_arg), _Werr(_Werr_arg), _Has_state(false), _Has_berr(true), _Has_werr(true)
        {
            _Init();
        }

        virtual ~wstring_convert() noexcept
        {
        }

        [[nodiscard]] size_t converted() const noexcept
        {
            return _Nconv;
        }

        [[nodiscard]] state_type state() const
        {
            return _State;
        }

        [[nodiscard]] wide_string from_bytes(char _Byte)
        {
            return from_bytes(&_Byte, &_Byte + 1);
        }

        [[nodiscard]] wide_string from_bytes(const char* _Ptr)
        {
            return from_bytes(_Ptr, _Ptr + ::strlen(_Ptr));
        }

        [[nodiscard]] wide_string from_bytes(const byte_string& _Bstr)
        {
            const char* _Ptr = _Bstr.c_str();
            return from_bytes(_Ptr, _Ptr + _Bstr.size());
        }

        [[nodiscard]] wide_string from_bytes(const char* _First, const char* _Last)
        {
            wide_string _Wbuf;
            wide_string _Wstr;
            const char* _First_sav = _First;

            if(!_Has_state)
            {
                _State = state_type{};
            }

            _Wbuf.append(_BUF_INC, _Elem{});
            for(_Nconv = 0; _First != _Last; _Nconv = static_cast<size_t>(_First - _First_sav))
            {
                _Elem* _Dest = &_Wbuf[0];
                _Elem* _Dnext;

                switch(_Pcvt->in(_State, _First, _Last, _First, _Dest, _Dest + _Wbuf.size(), _Dnext))
                {
                    case _Codecvt::partial:
                    case _Codecvt::ok:
                        if(_Dest < _Dnext)
                        {
                            _Wstr.append(_Dest, static_cast<size_t>(_Dnext - _Dest));
                        }
                        else if(_Wbuf.size() < _BUF_MAX)
                        {
                            _Wbuf.append(_BUF_INC, _Elem{});
                        }
                        else if(_Has_werr)
                        {
                            return _Werr;
                        }
                        else
                        {
                            _Throw_range_error("bad conversion");
                        }

                        break;

                    case _Codecvt::noconv:
                        for(; _First != _Last; ++_First)
                        {
                            _Wstr.push_back(static_cast<_Elem>(static_cast<unsigned char>(*_First)));
                        }

                        break;

                    default:
                        if(_Has_werr)
                        {
                            return _Werr;
                        }
                        else
                        {
                            _Throw_range_error("bad conversion");
                        }
                }
            }
            return _Wstr;
        }

        [[nodiscard]] byte_string to_bytes(_Elem _Char)
        {
            return to_bytes(&_Char, &_Char + 1);
        }

        [[nodiscard]] byte_string to_bytes(const _Elem* _Wptr)
        {
            const _Elem* _Next = _Wptr;
            while(*_Next != 0)
            {
                ++_Next;
            }

            return to_bytes(_Wptr, _Next);
        }

        [[nodiscard]] byte_string to_bytes(const wide_string& _Wstr)
        {
            const _Elem* _Wptr = _Wstr.c_str();
            return to_bytes(_Wptr, _Wptr + _Wstr.size());
        }

        [[nodiscard]] byte_string to_bytes(const _Elem* _First, const _Elem* _Last)
        {
            byte_string _Bbuf;
            byte_string _Bstr;
            const _Elem* _First_sav = _First;

            if(!_Has_state)
            {
                _State = state_type{};
            }

            _Bbuf.append(_BUF_INC, '\0');
            for(_Nconv = 0; _First != _Last; _Nconv = static_cast<size_t>(_First - _First_sav))
            {
                char* _Dest = &_Bbuf[0];
                char* _Dnext;

                switch(_Pcvt->out(_State, _First, _Last, _First, _Dest, _Dest + _Bbuf.size(), _Dnext))
                {
                    case _Codecvt::partial:
                    case _Codecvt::ok:
                        if(_Dest < _Dnext)
                        {
                            _Bstr.append(_Dest, static_cast<size_t>(_Dnext - _Dest));
                        }
                        else if(_Bbuf.size() < _BUF_MAX)
                        {
                            _Bbuf.append(_BUF_INC, '\0');
                        }
                        else if(_Has_berr)
                        {
                            return _Berr;
                        }
                        else
                        {
                            _Throw_range_error("bad conversion");
                        }

                        break;

                    case _Codecvt::noconv:
                        for(; _First != _Last; ++_First)
                        {
                            _Bstr.push_back(static_cast<char>(static_cast<int_type>(*_First)));
                        }

                        break;

                    default:
                        if(_Has_berr)
                        {
                            return _Berr;
                        }
                        else
                        {
                            _Throw_range_error("bad conversion");
                        }
                }
            }
            return _Bstr;
        }

        wstring_convert(const wstring_convert&) = delete;
        wstring_convert& operator=(const wstring_convert&) = delete;

    private:
        const _Codecvt* _Pcvt;
        locale _Loc;
        byte_string _Berr;
        wide_string _Werr;
        state_type _State;
        bool _Has_state;
        bool _Has_berr;
        bool _Has_werr;
        size_t _Nconv;
    };
    __pragma(warning(pop))
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    struct messages_base : locale::facet
    {
        using catalog = int;

        explicit messages_base(size_t _Refs = 0) : locale::facet(_Refs)
        {
        }
    };

    template <class _Elem> class messages : public messages_base
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        using char_type = _Elem;
        using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

        catalog open(const string& _Catname, const locale& _Loc) const
        {
            return do_open(_Catname, _Loc);
        }

        string_type get(catalog _Catval, int _Set, int _Message, const string_type& _Dflt) const
        {
            return do_get(_Catval, _Set, _Message, _Dflt);
        }

        void close(catalog _Catval) const
        {
            do_close(_Catval);
        }

        __declspec(dllimport) static locale::id id;

        explicit messages(size_t _Refs = 0) : messages_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        messages(const _Locinfo& _Lobj, size_t _Refs = 0) : messages_base(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new messages<_Elem>(_Locinfo(_Ploc->c_str()));
            }

            return 6;
        }

    protected:
        messages(const char* _Locname, size_t _Refs = 0) : messages_base(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj(_Locname);
                _Init(_Lobj);
            }
        }

        virtual ~messages() noexcept
        {
        }

        void _Init(const _Locinfo&)
        {
        }

        virtual catalog do_open(const string&, const locale&) const
        {
            return -1;
        }

        virtual string_type do_get(catalog, int, int, const string_type& _Dflt) const
        {
            return _Dflt;
        }

        virtual void do_close(catalog) const
        {
        }
    };

    template <class _Elem> locale::id messages<_Elem>::id;

    template <class _Elem> class messages_byname : public messages<_Elem>
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        explicit messages_byname(const char* _Locname, size_t _Refs = 0) : messages<_Elem>(_Locname, _Refs)
        {
        }

        explicit messages_byname(const string& _Str, size_t _Refs = 0) : messages<_Elem>(_Str.c_str(), _Refs)
        {
        }

    protected:
        virtual ~messages_byname() noexcept
        {
        }
    };

    template locale::id messages<char>::id;
    template locale::id messages<wchar_t>::id;

}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

namespace std
{
    template <class _Elem> class collate : public locale::facet
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t, unsigned short>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        using char_type = _Elem;
        using string_type = basic_string<_Elem, char_traits<_Elem>, allocator<_Elem>>;

        int compare(const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2) const
        {
            return do_compare(_First1, _Last1, _First2, _Last2);
        }

        string_type transform(const _Elem* _First, const _Elem* _Last) const
        {
            return do_transform(_First, _Last);
        }

        long hash(const _Elem* _First, const _Elem* _Last) const
        {
            return do_hash(_First, _Last);
        }

        __declspec(dllimport) static locale::id id;

        explicit collate(size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj;
                _Init(_Lobj);
            }
        }

        collate(const _Locinfo& _Lobj, size_t _Refs = 0) : locale::facet(_Refs)
        {
            _Init(_Lobj);
        }

        static size_t _Getcat(const locale::facet** _Ppf = nullptr, const locale* _Ploc = nullptr)
        {
            if(_Ppf && !*_Ppf)
            {
                *_Ppf = new collate<_Elem>(_Locinfo(_Ploc->name().c_str()));
            }

            return 1;
        }

    protected:
        ~collate() noexcept
        {
            ::free(_Coll._LocaleName);
        }

        collate(const char* _Locname, size_t _Refs = 0) : locale::facet(_Refs)
        {
            {
                ::std::_Lockit _Lock(0);
                _Locinfo _Lobj(_Locname);
                _Init(_Lobj);
            }
        }

        void _Init(const _Locinfo& _Lobj)
        {
            _Coll = _Lobj._Getcoll();
        }

        virtual int do_compare(const _Elem* _First1, const _Elem* _Last1, const _Elem* _First2, const _Elem* _Last2) const
        {
            _Adl_verify_range(_First1, _Last1);
            _Adl_verify_range(_First2, _Last2);
            int _Ans = _LStrcoll(_First1, _Last1, _First2, _Last2, &_Coll);
            return _Ans < 0 ? -1 : _Ans == 0 ? 0 : +1;
        }

        virtual string_type do_transform(const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            size_t _Count;
            string_type _Str;

            for(_Count = static_cast<size_t>(_Last - _First); 0 < _Count;)
            {
                _Str.resize(_Count);
                if((_Count = _LStrxfrm(&_Str[0], &_Str[0] + _Str.size(), _First, _Last, &_Coll)) <= _Str.size())
                {
                    break;
                }
            }
            _Str.resize(_Count);
            return _Str;
        }

        virtual long do_hash(const _Elem* _First, const _Elem* _Last) const
        {
            _Adl_verify_range(_First, _Last);
            return static_cast<long>(_Hash_array_representation(_First, static_cast<size_t>(_Last - _First)));
        }

    private:
        _Locinfo::_Collvec _Coll;
    };

    template <class _Elem> locale::id collate<_Elem>::id;

    template locale::id collate<char>::id;
    template locale::id collate<wchar_t>::id;

    template <class _Elem> class collate_byname : public collate<_Elem>
    {
    public:
        static_assert(!0 || _Is_any_of_v<_Elem, char, wchar_t>,
                      "Unsupported facet specialization; see N4800 27.3.1.1.1 [locale.category]. "
                      "Either use a Standard specialization or define _ENFORCE_FACET_SPECIALIZATIONS=0 "
                      "to suppress this diagnostic.");

        explicit collate_byname(const char* _Locname, size_t _Refs = 0) : collate<_Elem>(_Locname, _Refs)
        {
        }

        explicit collate_byname(const string& _Str, size_t _Refs = 0) : collate<_Elem>(_Locinfo(_Str.c_str()), _Refs)
        {
        }

    protected:
        virtual ~collate_byname() noexcept
        {
        }
    };

    template <class _Facet> bool has_facet(const locale& _Loc) noexcept
    {
        {
            ::std::_Lockit _Lock(0);
            size_t _Id = _Facet::id;
            return _Loc._Getfacet(_Id) || _Facet::_Getcat() != static_cast<size_t>(-1);
        }
    }

    template <class _Elem> bool(isalnum)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::alnum, _Ch);
    }

    template <class _Elem> bool(isalpha)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::alpha, _Ch);
    }

    template <class _Elem> bool(isblank)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::blank, _Ch);
    }

    template <class _Elem> bool(iscntrl)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::cntrl, _Ch);
    }

    template <class _Elem> bool(isdigit)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::digit, _Ch);
    }

    template <class _Elem> bool(isgraph)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::graph, _Ch);
    }

    template <class _Elem> bool(islower)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::lower, _Ch);
    }

    template <class _Elem> bool(isprint)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::print, _Ch);
    }

    template <class _Elem> bool(ispunct)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::punct, _Ch);
    }

    template <class _Elem> bool(isspace)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::space, _Ch);
    }

    template <class _Elem> bool(isupper)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::upper, _Ch);
    }

    template <class _Elem> bool(isxdigit)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).is(ctype_base::xdigit, _Ch);
    }

    template <class _Elem> _Elem(tolower)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).tolower(_Ch);
    }

    template <class _Elem> _Elem(toupper)(_Elem _Ch, const locale& _Loc)
    {
        return ::std::use_facet<ctype<_Elem>>(_Loc).toupper(_Ch);
    }
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma pack(push, 8)
#pragma warning(push, 3)
#pragma warning( \
disable : 4180 4412 4455 4472 4494 4514 4571 4574 4582 4583 4587 4588 4619 4623 4625 4626 4643 4702 4793 4820 4988 5026 5027 5045 4984 5053)

#pragma warning(disable : 4127)

namespace std
{
    enum codecvt_mode
    {
        consume_header = 4,
        generate_header = 2,
        little_endian = 1
    };

    using _Statype = ::mbstate_t;

    __pragma(warning(push)) __pragma(warning(disable : 4996))

    template <class _Elem, unsigned long _Mymax = 0x10ffff, codecvt_mode _Mymode = codecvt_mode{}>
    class codecvt_utf8 : public codecvt<_Elem, char, _Statype>
    {
    public:
        using _Mybase = codecvt<_Elem, char, _Statype>;
        using result = typename _Mybase::result;
        using _Byte = char;
        using intern_type = _Elem;
        using extern_type = _Byte;
        using state_type = _Statype;

        explicit codecvt_utf8(size_t _Refs = 0) : _Mybase(_Refs)
        {
        }

        virtual ~codecvt_utf8() noexcept
        {
        }

    protected:
        virtual result
        do_in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1, _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const override
        {
            char* _Pstate = reinterpret_cast<char*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                unsigned long _By = static_cast<unsigned char>(*_Mid1);
                unsigned long _Ch;
                int _Nextra;

                if(_By < 0x80u)
                {
                    _Ch = _By;
                    _Nextra = 0;
                }
                else if(_By < 0xc0u)
                {
                    ++_Mid1;
                    return _Mybase::error;
                }
                else if(_By < 0xe0u)
                {
                    _Ch = _By & 0x1f;
                    _Nextra = 1;
                }
                else if(_By < 0xf0u)
                {
                    _Ch = _By & 0x0f;
                    _Nextra = 2;
                }
                else if(_By < 0xf8u)
                {
                    _Ch = _By & 0x07;
                    _Nextra = 3;
                }
                else
                {
                    _Ch = _By & 0x03;
                    _Nextra = _By < 0xfc ? 4 : 5;
                }

                if(_Nextra == 0)
                {
                    ++_Mid1;
                }
                else if(_Last1 - _Mid1 < _Nextra + 1)
                {
                    break;
                }
                else
                {
                    for(++_Mid1; 0 < _Nextra; --_Nextra, ++_Mid1)
                    {
                        if((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By)
                        {
                            return _Mybase::error;
                        }
                        else
                        {
                            _Ch = _Ch << 6 | (_By & 0x3f);
                        }
                    }
                }

                if(*_Pstate == 0)
                {
                    *_Pstate = 1;

                    constexpr bool _Consuming = (_Mymode & consume_header) != 0;
                    if constexpr(_Consuming)
                    {
                        if(_Ch == 0xfeff)
                        {
                            const result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                            if(_Ans == _Mybase::partial)
                            {
                                *_Pstate = 0;
                                _Mid1 = _First1;
                            }

                            return _Ans;
                        }
                    }
                }

                if(_Mymax < _Ch)
                {
                    return _Mybase::error;
                }

                *_Mid2++ = static_cast<_Elem>(_Ch);
            }

            return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
        }

        virtual result
        do_out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const override
        {
            char* _Pstate = reinterpret_cast<char*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                _Byte _By;
                int _Nextra;
                unsigned long _Ch = static_cast<unsigned long>(*_Mid1);

                if(_Mymax < _Ch)
                {
                    return _Mybase::error;
                }

                if(_Ch < 0x0080u)
                {
                    _By = static_cast<_Byte>(_Ch);
                    _Nextra = 0;
                }
                else if(_Ch < 0x0800u)
                {
                    _By = static_cast<_Byte>(0xc0 | _Ch >> 6);
                    _Nextra = 1;
                }
                else if(_Ch < 0x00010000u)
                {
                    _By = static_cast<_Byte>(0xe0 | _Ch >> 12);
                    _Nextra = 2;
                }
                else if(_Ch < 0x00200000u)
                {
                    _By = static_cast<_Byte>(0xf0 | _Ch >> 18);
                    _Nextra = 3;
                }
                else if(_Ch < 0x04000000u)
                {
                    _By = static_cast<_Byte>(0xf8 | _Ch >> 24);
                    _Nextra = 4;
                }
                else
                {
                    _By = static_cast<_Byte>(0xfc | (_Ch >> 30 & 0x03));
                    _Nextra = 5;
                }

                if(*_Pstate == 0)
                {
                    *_Pstate = 1;
                    constexpr bool _Generating = (_Mymode & generate_header) != 0;
                    if constexpr(_Generating)
                    {
                        if(_Last2 - _Mid2 < 3 + 1 + _Nextra)
                        {
                            return _Mybase::partial;
                        }

                        *_Mid2++ = '\xef';
                        *_Mid2++ = '\xbb';
                        *_Mid2++ = '\xbf';
                    }
                }

                if(_Last2 - _Mid2 < 1 + _Nextra)
                {
                    break;
                }

                ++_Mid1;
                for(*_Mid2++ = _By; 0 < _Nextra;)
                {
                    *_Mid2++ = static_cast<_Byte>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
                }
            }

            return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
        }

        virtual result do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const override
        {
            _Mid2 = _First2;
            return _Mybase::noconv;
        }

        friend int _Codecvt_do_length<>(const codecvt_utf8&, _Statype&, const _Byte*, const _Byte*, size_t);

        virtual int do_length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const noexcept override
        {
            return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
        }

        virtual bool do_always_noconv() const noexcept override
        {
            return false;
        }

        virtual int do_max_length() const noexcept override
        {
            return (_Mymode & (consume_header | generate_header)) != 0 ? 9 : 6;
        }

        virtual int do_encoding() const noexcept override
        {
            return (_Mymode & (consume_header | generate_header)) != 0 ? -1 : 0;
        }
    };

    template <class _Elem, unsigned long _Mymax = 0x10ffff, codecvt_mode _Mymode = codecvt_mode{}>
    class codecvt_utf16 : public codecvt<_Elem, char, _Statype>
    {
        enum
        {
            _Bytes_per_word = 2
        };

    public:
        using _Mybase = codecvt<_Elem, char, _Statype>;
        using result = typename _Mybase::result;
        using _Byte = char;
        using intern_type = _Elem;
        using extern_type = _Byte;
        using state_type = _Statype;

        explicit codecvt_utf16(size_t _Refs = 0) : _Mybase(_Refs)
        {
        }

        virtual ~codecvt_utf16() noexcept
        {
        }

    protected:
        virtual result
        do_in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1, _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const override
        {
            char* _Pstate = reinterpret_cast<char*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            while(_Bytes_per_word <= _Last1 - _Mid1 && _Mid2 != _Last2)
            {
                const auto _Ptr = reinterpret_cast<const unsigned char*>(_Mid1);
                unsigned long _Ch;
                unsigned short _Ch0;
                unsigned short _Ch1;

                if(*_Pstate == 1)
                {
                    _Ch0 = static_cast<unsigned short>(_Ptr[1] << 8 | _Ptr[0]);
                }
                else if(*_Pstate == 2)
                {
                    _Ch0 = static_cast<unsigned short>(_Ptr[0] << 8 | _Ptr[1]);
                }
                else
                {
                    constexpr bool _Prefer_LE = (_Mymode & little_endian) != 0;
                    constexpr char _Default_endian = _Prefer_LE ? 1 : 2;

                    if constexpr(_Prefer_LE)
                    {
                        _Ch0 = static_cast<unsigned short>(_Ptr[1] << 8 | _Ptr[0]);
                    }
                    else
                    {
                        _Ch0 = static_cast<unsigned short>(_Ptr[0] << 8 | _Ptr[1]);
                    }

                    *_Pstate = _Default_endian;
                    constexpr bool _Consuming = (_Mymode & consume_header) != 0;
                    if constexpr(_Consuming)
                    {
                        if(_Ch0 == 0xfffeu)
                        {
                            *_Pstate = 3 - _Default_endian;
                        }

                        if(_Ch0 == 0xfffeu || _Ch0 == 0xfeffu)
                        {
                            _Mid1 += _Bytes_per_word;
                            result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                            if(_Ans == _Mybase::partial)
                            {
                                *_Pstate = 0;
                                _Mid1 = _First1;
                            }

                            return _Ans;
                        }
                    }
                }

                if(_Ch0 < 0xd800u || 0xdc00u <= _Ch0)
                {
                    _Mid1 += _Bytes_per_word;
                    _Ch = _Ch0;
                }
                else if(_Last1 - _Mid1 < 2 * _Bytes_per_word)
                {
                    break;
                }
                else
                {
                    if(*_Pstate == 1)
                    {
                        _Ch1 = static_cast<unsigned short>(_Ptr[3] << 8 | _Ptr[2]);
                    }
                    else
                    {
                        _Ch1 = static_cast<unsigned short>(_Ptr[2] << 8 | _Ptr[3]);
                    }

                    if(_Ch1 < 0xdc00u || 0xe000u <= _Ch1)
                    {
                        return _Mybase::error;
                    }

                    _Mid1 += 2 * _Bytes_per_word;
                    _Ch = static_cast<unsigned long>(_Ch0 - 0xd800 + 0x0040) << 10 | (_Ch1 - 0xdc00);
                }

                if(_Mymax < _Ch)
                {
                    return _Mybase::error;
                }

                *_Mid2++ = static_cast<_Elem>(_Ch);
            }

            return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
        }

        virtual result
        do_out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const override
        {
            char* _Pstate = reinterpret_cast<char*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            if(*_Pstate == 0)
            {
                *_Pstate = (_Mymode & little_endian) != 0 ? 1 : 2;
                constexpr bool _Generating = (_Mymode & generate_header) != 0;
                if constexpr(_Generating)
                {
                    if(_Last2 - _Mid2 < 3 * _Bytes_per_word)
                    {
                        return _Mybase::partial;
                    }

                    if(*_Pstate == 1)
                    {
                        *_Mid2++ = '\xff';
                        *_Mid2++ = '\xfe';
                    }
                    else
                    {
                        *_Mid2++ = '\xfe';
                        *_Mid2++ = '\xff';
                    }
                }
            }

            while(_Mid1 != _Last1 && _Bytes_per_word <= _Last2 - _Mid2)
            {
                bool _Extra = false;
                unsigned long _Ch = static_cast<unsigned long>(*_Mid1++);

                if((_Mymax < 0x10ffffu ? _Mymax : 0x10ffffu) < _Ch)
                {
                    return _Mybase::error;
                }

                if(_Ch <= 0xffffu)
                {
                    if(0xd800u <= _Ch && _Ch < 0xdc00u)
                    {
                        return _Mybase::error;
                    }
                }
                else if(_Last2 - _Mid2 < 2 * _Bytes_per_word)
                {
                    --_Mid1;
                    return _Mybase::partial;
                }
                else
                {
                    _Extra = true;
                }

                if(*_Pstate == 1)
                {
                    if(_Extra)
                    {
                        unsigned short _Ch0 = static_cast<unsigned short>(0xd800 | static_cast<unsigned short>(_Ch >> 10) - 0x0040);
                        *_Mid2++ = static_cast<_Byte>(_Ch0);
                        *_Mid2++ = static_cast<_Byte>(_Ch0 >> 8);

                        _Ch0 = static_cast<unsigned short>(0xdc00 | (static_cast<unsigned short>(_Ch) & 0x03ff));
                        *_Mid2++ = static_cast<_Byte>(_Ch0);
                        *_Mid2++ = static_cast<_Byte>(_Ch0 >> 8);
                    }
                    else
                    {
                        *_Mid2++ = static_cast<_Byte>(_Ch);
                        *_Mid2++ = static_cast<_Byte>(_Ch >> 8);
                    }
                }
                else
                {
                    if(_Extra)
                    {
                        unsigned short _Ch0 = static_cast<unsigned short>(0xd800 | static_cast<unsigned short>(_Ch >> 10) - 0x0040);
                        *_Mid2++ = static_cast<_Byte>(_Ch0 >> 8);
                        *_Mid2++ = static_cast<_Byte>(_Ch0);

                        _Ch0 = static_cast<unsigned short>(0xdc00 | (static_cast<unsigned short>(_Ch) & 0x03ff));
                        *_Mid2++ = static_cast<_Byte>(_Ch0 >> 8);
                        *_Mid2++ = static_cast<_Byte>(_Ch0);
                    }
                    else
                    {
                        *_Mid2++ = static_cast<_Byte>(_Ch >> 8);
                        *_Mid2++ = static_cast<_Byte>(_Ch);
                    }
                }
            }

            return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
        }

        virtual result do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const override
        {
            _Mid2 = _First2;
            return _Mybase::noconv;
        }

        friend int _Codecvt_do_length<>(const codecvt_utf16&, _Statype&, const _Byte*, const _Byte*, size_t);

        virtual int do_length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const noexcept override
        {
            return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
        }

        virtual bool do_always_noconv() const noexcept override
        {
            return false;
        }

        virtual int do_max_length() const noexcept override
        {
            return (_Mymode & (consume_header | generate_header)) != 0 ? 3 * _Bytes_per_word : 6 * _Bytes_per_word;
        }

        virtual int do_encoding() const noexcept override
        {
            if((_Mymode & (consume_header | generate_header)) != 0)
            {
                return -1;
            }
            else
            {
                return 0;
            }
        }
    };

    template <class _Elem, unsigned long _Mymax = 0x10ffff, codecvt_mode _Mymode = codecvt_mode{}>
    class codecvt_utf8_utf16 : public codecvt<_Elem, char, _Statype>
    {
    public:
        using _Mybase = codecvt<_Elem, char, _Statype>;
        using result = typename _Mybase::result;
        using _Byte = char;
        using intern_type = _Elem;
        using extern_type = _Byte;
        using state_type = _Statype;

        static_assert(sizeof(unsigned short) <= sizeof(state_type), "state_type too small");

        explicit codecvt_utf8_utf16(size_t _Refs = 0) : _Mybase(_Refs)
        {
        }

        virtual ~codecvt_utf8_utf16() noexcept
        {
        }

    protected:
        virtual result
        do_in(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, const _Byte*& _Mid1, _Elem* _First2, _Elem* _Last2, _Elem*& _Mid2) const override
        {
            unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                unsigned long _By = static_cast<unsigned char>(*_Mid1);
                unsigned long _Ch;
                int _Nextra;
                int _Nskip;

                if(*_Pstate > 1u)
                {
                    if(_By < 0x80u || 0xc0u <= _By)
                    {
                        return _Mybase::error;
                    }

                    ++_Mid1;
                    *_Mid2++ = static_cast<_Elem>(*_Pstate | (_By & 0x3f));
                    *_Pstate = 1;
                    continue;
                }

                if(_By < 0x80u)
                {
                    _Ch = _By;
                    _Nextra = 0;
                }
                else if(_By < 0xc0u)
                {
                    ++_Mid1;
                    return _Mybase::error;
                }
                else if(_By < 0xe0u)
                {
                    _Ch = _By & 0x1f;
                    _Nextra = 1;
                }
                else if(_By < 0xf0u)
                {
                    _Ch = _By & 0x0f;
                    _Nextra = 2;
                }
                else if(_By < 0xf8u)
                {
                    _Ch = _By & 0x07;
                    _Nextra = 3;
                }
                else
                {
                    _Ch = _By & 0x03;
                    _Nextra = _By < 0xfc ? 4 : 5;
                }

                _Nskip = _Nextra < 3 ? 0 : 1;
                _First1 = _Mid1;

                if(_Nextra == 0)
                {
                    ++_Mid1;
                }
                else if(_Last1 - _Mid1 < _Nextra + 1 - _Nskip)
                {
                    break;
                }
                else
                {
                    for(++_Mid1; _Nskip < _Nextra; --_Nextra, ++_Mid1)
                    {
                        if((_By = static_cast<unsigned char>(*_Mid1)) < 0x80u || 0xc0u <= _By)
                        {
                            return _Mybase::error;
                        }

                        _Ch = _Ch << 6 | (_By & 0x3f);
                    }
                }

                if(0 < _Nskip)
                {
                    _Ch <<= 6;
                }

                if((_Mymax < 0x10ffffu ? _Mymax : 0x10ffffu) < _Ch)
                {
                    return _Mybase::error;
                }

                if(0xffffu < _Ch)
                {
                    unsigned short _Ch0 = static_cast<unsigned short>(0xd800 | (_Ch >> 10) - 0x0040);

                    *_Mid2++ = static_cast<_Elem>(_Ch0);
                    *_Pstate = static_cast<unsigned short>(0xdc00 | (_Ch & 0x03ff));
                    continue;
                }

                if(_Nskip != 0)
                {
                    if(_Mid1 == _Last1)
                    {
                        _Mid1 = _First1;
                        break;
                    }

                    if((_By = static_cast<unsigned char>(*_Mid1++)) < 0x80u || 0xc0u <= _By)
                    {
                        return _Mybase::error;
                    }

                    _Ch |= _By & 0x3f;
                }

                if(*_Pstate == 0u)
                {
                    *_Pstate = 1;

                    constexpr bool _Consuming = (_Mymode & consume_header) != 0;
                    if constexpr(_Consuming)
                    {
                        if(_Ch == 0xfeffu)
                        {
                            result _Ans = do_in(_State, _Mid1, _Last1, _Mid1, _First2, _Last2, _Mid2);

                            if(_Ans == _Mybase::partial)
                            {
                                *_Pstate = 0;
                                _Mid1 = _First1;
                            }

                            return _Ans;
                        }
                    }
                }

                *_Mid2++ = static_cast<_Elem>(_Ch);
            }

            return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
        }

        virtual result
        do_out(_Statype& _State, const _Elem* _First1, const _Elem* _Last1, const _Elem*& _Mid1, _Byte* _First2, _Byte* _Last2, _Byte*& _Mid2) const override
        {
            unsigned short* _Pstate = reinterpret_cast<unsigned short*>(&_State);
            _Mid1 = _First1;
            _Mid2 = _First2;

            while(_Mid1 != _Last1 && _Mid2 != _Last2)
            {
                unsigned long _Ch;
                unsigned short _Ch1 = static_cast<unsigned short>(*_Mid1);
                bool _Save = false;

                if(1u < *_Pstate)
                {
                    if(_Ch1 < 0xdc00u || 0xe000u <= _Ch1)
                    {
                        return _Mybase::error;
                    }

                    _Ch = static_cast<unsigned long>((*_Pstate << 10) | (_Ch1 - 0xdc00));
                }
                else if(0xd800u <= _Ch1 && _Ch1 < 0xdc00u)
                {
                    _Ch = static_cast<unsigned long>((_Ch1 - 0xd800 + 0x0040) << 10);
                    _Save = true;
                }
                else
                {
                    _Ch = _Ch1;
                }

                _Byte _By;
                int _Nextra;

                if(_Ch < 0x0080u)
                {
                    _By = static_cast<_Byte>(_Ch);
                    _Nextra = 0;
                }
                else if(_Ch < 0x0800u)
                {
                    _By = static_cast<_Byte>(0xc0 | _Ch >> 6);
                    _Nextra = 1;
                }
                else if(_Ch < 0x10000u)
                {
                    _By = static_cast<_Byte>(0xe0 | _Ch >> 12);
                    _Nextra = 2;
                }
                else
                {
                    _By = static_cast<_Byte>(0xf0 | _Ch >> 18);
                    _Nextra = 3;
                }

                int _Nput = _Nextra < 3 ? _Nextra + 1 : _Save ? 1 : 3;

                if(_Last2 - _Mid2 < _Nput)
                {
                    break;
                }

                if(*_Pstate == 0u && (_Mymode & generate_header) != 0)
                {
                    if(_Last2 - _Mid2 < 3 + _Nput)
                    {
                        break;
                    }

                    *_Mid2++ = '\xef';
                    *_Mid2++ = '\xbb';
                    *_Mid2++ = '\xbf';
                }

                ++_Mid1;
                if(_Save || _Nextra < 3)
                {
                    *_Mid2++ = _By;
                    --_Nput;
                }

                for(; 0 < _Nput; --_Nput)
                {
                    *_Mid2++ = static_cast<_Byte>((_Ch >> 6 * --_Nextra & 0x3f) | 0x80);
                }

                *_Pstate = static_cast<unsigned short>(_Save ? _Ch >> 10 : 1);
            }

            return _First1 == _Mid1 ? _Mybase::partial : _Mybase::ok;
        }

        virtual result do_unshift(_Statype&, _Byte* _First2, _Byte*, _Byte*& _Mid2) const override
        {
            _Mid2 = _First2;
            return _Mybase::noconv;
        }

        friend int _Codecvt_do_length<>(const codecvt_utf8_utf16&, _Statype&, const _Byte*, const _Byte*, size_t);

        virtual int do_length(_Statype& _State, const _Byte* _First1, const _Byte* _Last1, size_t _Count) const noexcept override
        {
            return _Codecvt_do_length(*this, _State, _First1, _Last1, _Count);
        }

        virtual bool do_always_noconv() const noexcept override
        {
            return false;
        }

        virtual int do_max_length() const noexcept override
        {
            if((_Mymode & consume_header) != 0)
            {
                return 9;
            }

            if((_Mymode & generate_header) != 0)
            {
                return 7;
            }

            return 6;
        }

        virtual int do_encoding() const noexcept override
        {
            return 0;
        }
    };
    __pragma(warning(pop))
}// namespace std

#pragma warning(pop)
#pragma pack(pop)

#pragma once

#pragma once

#pragma once

#pragma once

template <class T> struct gcroot
{
    typedef System::Runtime::InteropServices::GCHandle GCHandle;

    [System::Diagnostics::DebuggerStepThroughAttribute][System::Security::SecuritySafeCritical] gcroot()
    {
        _handle = ((GCHandle::operator System::IntPtr(GCHandle::Alloc(nullptr))).ToPointer());
    }

    gcroot(T t)
    {
        _handle = ((GCHandle::operator System::IntPtr(GCHandle::Alloc(t))).ToPointer());
    }

    gcroot(const gcroot& r)
    {
        _handle
        = ((GCHandle::operator System::IntPtr(GCHandle::Alloc((GCHandle::operator GCHandle(System::IntPtr(r._handle))).Target)))
           .ToPointer());
    }

    [System::Diagnostics::DebuggerStepThroughAttribute][System::Security::SecurityCritical] ~gcroot()
    {
        GCHandle g = (GCHandle::operator GCHandle(System::IntPtr(_handle)));
        g.Free();
        _handle = 0;
    }

    [System::Diagnostics::DebuggerStepThroughAttribute][System::Security::SecurityCritical] gcroot& operator=(T t)
    {
        (GCHandle::operator GCHandle(System::IntPtr(_handle))).Target = t;
        return *this;
    }

    gcroot& operator=(const gcroot& r)
    {
        T t = (T)r;
        (GCHandle::operator GCHandle(System::IntPtr(_handle))).Target = t;
        return *this;
    }

    void swap(gcroot<T>& _right)
    {
        using std::swap;
        swap(_handle, _right._handle);
    }

    [System::Security::SecuritySafeCritical] operator T() const
    {
        return static_cast<T>((GCHandle::operator GCHandle(System::IntPtr(_handle))).Target);
    }

    [System::Security::SecuritySafeCritical] T operator->() const
    {
        return static_cast<T>((GCHandle::operator GCHandle(System::IntPtr(_handle))).Target);
    }

private:
    void* _handle;
    T* operator&();
};

template <typename T> void swap(gcroot<T>& _left, gcroot<T>& _right)
{
    _left.swap(_right);
}

namespace msclr
{
    using ::gcroot;
}

#pragma warning(push)
#pragma warning(disable : 4400)

typedef cli::interior_ptr<const System::Char> __const_Char_ptr;
typedef cli::interior_ptr<const System::Byte> __const_Byte_ptr;
typedef cli::interior_ptr<System::Byte> _Byte_ptr;
typedef const System::String ^ __const_String_handle;

inline __const_Char_ptr PtrToStringChars(__const_String_handle s)
{
    _Byte_ptr bp = const_cast<_Byte_ptr>(reinterpret_cast<__const_Byte_ptr>(s));
    if(bp != nullptr)
    {
        bp += System::Runtime::CompilerServices::RuntimeHelpers::OffsetToStringData;
    }
    return reinterpret_cast<__const_Char_ptr>(bp);
}

#pragma warning(pop)

#pragma once

#using < system.dll>

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma once

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma once

#pragma warning(pop)

#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4668)
#pragma warning(disable : 4001)

#pragma once

#pragma warning(pop)

#pragma once

#pragma region Application Family or OneCore Family

#pragma warning(disable : 4514)

#pragma warning(disable : 4103)

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)

#pragma once

#pragma warning(push)
#pragma warning(disable : 4514 4820)

__pragma(pack(push, 8)) extern "C"
{
    typedef enum _EXCEPTION_DISPOSITION
    {
        ExceptionContinueExecution,
        ExceptionContinueSearch,
        ExceptionNestedException,
        ExceptionCollidedUnwind
    } EXCEPTION_DISPOSITION;

    struct _EXCEPTION_RECORD;
    struct _CONTEXT;
    struct _DISPATCHER_CONTEXT;

    EXCEPTION_DISPOSITION __cdecl __C_specific_handler(struct _EXCEPTION_RECORD * ExceptionRecord,
                                                       void* EstablisherFrame, struct _CONTEXT* ContextRecord,
                                                       struct _DISPATCHER_CONTEXT* DispatcherContext);

    unsigned long __cdecl _exception_code(void);
    void* __cdecl _exception_info(void);
    int __cdecl _abnormal_termination(void);
}
__pragma(pack(pop))

#pragma warning(pop)

#pragma once

#pragma warning(push)
#pragma warning(disable : 4514 4820)

__pragma(pack(push, 8)) extern "C"
{
}
__pragma(pack(pop))

#pragma warning(pop)

#pragma once

extern "C"
{
#pragma once

#pragma once

#pragma warning(push)
#pragma warning(disable : 4668)

    extern "C"
    {
    }

#pragma once

#pragma once

    extern "C"
    {
    }

#pragma warning(pop)

#pragma region Application Family or OneCore Family

    extern "C"
    {
        typedef unsigned long ULONG;
        typedef ULONG* PULONG;
        typedef unsigned short USHORT;
        typedef USHORT* PUSHORT;
        typedef unsigned char UCHAR;
        typedef UCHAR* PUCHAR;
        typedef char* PSZ;

        typedef unsigned long DWORD;
        typedef int BOOL;
        typedef unsigned char BYTE;
        typedef unsigned short WORD;
        typedef float FLOAT;
        typedef FLOAT* PFLOAT;
        typedef BOOL* PBOOL;
        typedef BOOL* LPBOOL;
        typedef BYTE* PBYTE;
        typedef BYTE* LPBYTE;
        typedef int* PINT;
        typedef int* LPINT;
        typedef WORD* PWORD;
        typedef WORD* LPWORD;
        typedef long* LPLONG;
        typedef DWORD* PDWORD;
        typedef DWORD* LPDWORD;
        typedef void* LPVOID;
        typedef const void* LPCVOID;

        typedef int INT;
        typedef unsigned int UINT;
        typedef unsigned int* PUINT;

#pragma warning(push)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)
#pragma warning(disable : 4200)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)

        extern "C"
        {
#pragma once

            extern "C"
            {
            }

#pragma warning(push)
#pragma warning(disable : 4668)

            typedef unsigned __int64 POINTER_64_INT;

#pragma once

            extern "C"
            {
                typedef signed char INT8, *PINT8;
                typedef signed short INT16, *PINT16;
                typedef signed int INT32, *PINT32;
                typedef signed __int64 INT64, *PINT64;
                typedef unsigned char UINT8, *PUINT8;
                typedef unsigned short UINT16, *PUINT16;
                typedef unsigned int UINT32, *PUINT32;
                typedef unsigned __int64 UINT64, *PUINT64;

                typedef signed int LONG32, *PLONG32;

                typedef unsigned int ULONG32, *PULONG32;
                typedef unsigned int DWORD32, *PDWORD32;

                typedef __int64 INT_PTR, *PINT_PTR;
                typedef unsigned __int64 UINT_PTR, *PUINT_PTR;

                typedef __int64 LONG_PTR, *PLONG_PTR;
                typedef unsigned __int64 ULONG_PTR, *PULONG_PTR;

                typedef __int64 SHANDLE_PTR;
                typedef unsigned __int64 HANDLE_PTR;
                typedef unsigned int UHALF_PTR, *PUHALF_PTR;
                typedef int HALF_PTR, *PHALF_PTR;

                __inline unsigned long HandleToULong(const void* h)
                {
                    return ((unsigned long)(ULONG_PTR)h);
                }

                __inline long HandleToLong(const void* h)
                {
                    return ((long)(LONG_PTR)h);
                }

                __inline void* ULongToHandle(const unsigned long h)
                {
                    return ((void*)(UINT_PTR)h);
                }

                __inline void* LongToHandle(const long h)
                {
                    return ((void*)(INT_PTR)h);
                }

                __inline unsigned long PtrToUlong(const void* p)
                {
                    return ((unsigned long)(ULONG_PTR)p);
                }

                __inline unsigned int PtrToUint(const void* p)
                {
                    return ((unsigned int)(UINT_PTR)p);
                }

                __inline unsigned short PtrToUshort(const void* p)
                {
                    return ((unsigned short)(unsigned long)(ULONG_PTR)p);
                }

                __inline long PtrToLong(const void* p)
                {
                    return ((long)(LONG_PTR)p);
                }

                __inline int PtrToInt(const void* p)
                {
                    return ((int)(INT_PTR)p);
                }

                __inline short PtrToShort(const void* p)
                {
                    return ((short)(long)(LONG_PTR)p);
                }

                __inline void* IntToPtr(const int i)

                {
                    return ((void*)(INT_PTR)i);
                }

                __inline void* UIntToPtr(const unsigned int ui)

                {
                    return ((void*)(UINT_PTR)ui);
                }

                __inline void* LongToPtr(const long l)

                {
                    return ((void*)(LONG_PTR)l);
                }

                __inline void* ULongToPtr(const unsigned long ul)

                {
                    return ((void*)(ULONG_PTR)ul);
                }

                __inline void* Ptr32ToPtr(const void* __ptr32 p)
                {
                    return ((void*)(ULONG_PTR)(unsigned long)p);
                }

                __inline void* Handle32ToHandle(const void* __ptr32 h)
                {
                    return ((void*)(LONG_PTR)(long)h);
                }

                __inline void* __ptr32 PtrToPtr32(const void* p)
                {
                    return ((void* __ptr32)(unsigned long)(ULONG_PTR)p);
                }

                typedef ULONG_PTR SIZE_T, *PSIZE_T;
                typedef LONG_PTR SSIZE_T, *PSSIZE_T;

                typedef ULONG_PTR DWORD_PTR, *PDWORD_PTR;

                typedef __int64 LONG64, *PLONG64;

                typedef unsigned __int64 ULONG64, *PULONG64;
                typedef unsigned __int64 DWORD64, *PDWORD64;

                typedef ULONG_PTR KAFFINITY;
                typedef KAFFINITY* PKAFFINITY;
            }

#pragma warning(pop)

            typedef void* PVOID;
            typedef void* __ptr64 PVOID64;

            typedef char CHAR;
            typedef short SHORT;
            typedef long LONG;

            typedef int INT;

            typedef wchar_t WCHAR;

            typedef WCHAR *PWCHAR, *LPWCH, *PWCH;
            typedef const WCHAR *LPCWCH, *PCWCH;

            typedef WCHAR *NWPSTR, *LPWSTR, *PWSTR;
            typedef PWSTR* PZPWSTR;
            typedef const PWSTR* PCZPWSTR;
            typedef WCHAR __unaligned *LPUWSTR, *PUWSTR;
            typedef const WCHAR *LPCWSTR, *PCWSTR;
            typedef PCWSTR* PZPCWSTR;
            typedef const PCWSTR* PCZPCWSTR;
            typedef const WCHAR __unaligned *LPCUWSTR, *PCUWSTR;

            typedef WCHAR* PZZWSTR;
            typedef const WCHAR* PCZZWSTR;
            typedef WCHAR __unaligned* PUZZWSTR;
            typedef const WCHAR __unaligned* PCUZZWSTR;

            typedef WCHAR* PNZWCH;
            typedef const WCHAR* PCNZWCH;
            typedef WCHAR __unaligned* PUNZWCH;
            typedef const WCHAR __unaligned* PCUNZWCH;

            typedef const WCHAR *LPCWCHAR, *PCWCHAR;
            typedef const WCHAR __unaligned *LPCUWCHAR, *PCUWCHAR;

            typedef unsigned long UCSCHAR;

            typedef UCSCHAR* PUCSCHAR;
            typedef const UCSCHAR* PCUCSCHAR;

            typedef UCSCHAR* PUCSSTR;
            typedef UCSCHAR __unaligned* PUUCSSTR;

            typedef const UCSCHAR* PCUCSSTR;
            typedef const UCSCHAR __unaligned* PCUUCSSTR;

            typedef UCSCHAR __unaligned* PUUCSCHAR;
            typedef const UCSCHAR __unaligned* PCUUCSCHAR;

            typedef CHAR *PCHAR, *LPCH, *PCH;
            typedef const CHAR *LPCCH, *PCCH;

            typedef CHAR *NPSTR, *LPSTR, *PSTR;
            typedef PSTR* PZPSTR;
            typedef const PSTR* PCZPSTR;
            typedef const CHAR *LPCSTR, *PCSTR;
            typedef PCSTR* PZPCSTR;
            typedef const PCSTR* PCZPCSTR;

            typedef CHAR* PZZSTR;
            typedef const CHAR* PCZZSTR;

            typedef CHAR* PNZCH;
            typedef const CHAR* PCNZCH;

            typedef char TCHAR, *PTCHAR;
            typedef unsigned char TBYTE, *PTBYTE;

            typedef LPCH LPTCH, PTCH;
            typedef LPCCH LPCTCH, PCTCH;
            typedef LPSTR PTSTR, LPTSTR, PUTSTR, LPUTSTR;
            typedef LPCSTR PCTSTR, LPCTSTR, PCUTSTR, LPCUTSTR;
            typedef PZZSTR PZZTSTR, PUZZTSTR;
            typedef PCZZSTR PCZZTSTR, PCUZZTSTR;
            typedef PZPSTR PZPTSTR;
            typedef PNZCH PNZTCH, PUNZTCH;
            typedef PCNZCH PCNZTCH, PCUNZTCH;

            typedef SHORT* PSHORT;
            typedef LONG* PLONG;

            typedef struct _PROCESSOR_NUMBER
            {
                WORD Group;
                BYTE Number;
                BYTE Reserved;
            } PROCESSOR_NUMBER, *PPROCESSOR_NUMBER;

            typedef struct _GROUP_AFFINITY
            {
                KAFFINITY Mask;
                WORD Group;
                WORD Reserved[3];
            } GROUP_AFFINITY, *PGROUP_AFFINITY;

            typedef void* HANDLE;

            typedef HANDLE* PHANDLE;

            typedef BYTE FCHAR;
            typedef WORD FSHORT;
            typedef DWORD FLONG;

            typedef long HRESULT;

            typedef char CCHAR;
            typedef DWORD LCID;
            typedef PDWORD PLCID;
            typedef WORD LANGID;

            typedef enum
            {
                UNSPECIFIED_COMPARTMENT_ID = 0,
                DEFAULT_COMPARTMENT_ID
            } COMPARTMENT_ID,
            *PCOMPARTMENT_ID;

            typedef struct _FLOAT128
            {
                __int64 LowPart;
                __int64 HighPart;
            } FLOAT128;

            typedef FLOAT128* PFLOAT128;

            typedef __int64 LONGLONG;
            typedef unsigned __int64 ULONGLONG;

            typedef LONGLONG* PLONGLONG;
            typedef ULONGLONG* PULONGLONG;

            typedef LONGLONG USN;

            typedef union _LARGE_INTEGER
            {
                struct
                {
                    DWORD LowPart;
                    LONG HighPart;
                };
                struct
                {
                    DWORD LowPart;
                    LONG HighPart;
                } u;
                LONGLONG QuadPart;
            } LARGE_INTEGER;

            typedef LARGE_INTEGER* PLARGE_INTEGER;

            typedef union _ULARGE_INTEGER
            {
                struct
                {
                    DWORD LowPart;
                    DWORD HighPart;
                };
                struct
                {
                    DWORD LowPart;
                    DWORD HighPart;
                } u;
                ULONGLONG QuadPart;
            } ULARGE_INTEGER;

            typedef ULARGE_INTEGER* PULARGE_INTEGER;

            typedef LONG_PTR RTL_REFERENCE_COUNT, *PRTL_REFERENCE_COUNT;
            typedef LONG RTL_REFERENCE_COUNT32, *PRTL_REFERENCE_COUNT32;

            typedef struct _LUID
            {
                DWORD LowPart;
                LONG HighPart;
            } LUID, *PLUID;

            typedef ULONGLONG DWORDLONG;
            typedef DWORDLONG* PDWORDLONG;

            extern "C"
            {
                unsigned char __cdecl _rotl8(unsigned char Value, unsigned char Shift);

                unsigned short __cdecl _rotl16(unsigned short Value, unsigned char Shift);

                unsigned char __cdecl _rotr8(unsigned char Value, unsigned char Shift);

                unsigned short __cdecl _rotr16(unsigned short Value, unsigned char Shift);

#pragma intrinsic(_rotl8)
#pragma intrinsic(_rotl16)
#pragma intrinsic(_rotr8)
#pragma intrinsic(_rotr16)

                unsigned int __cdecl _rotl(unsigned int Value, int Shift);

                unsigned __int64 __cdecl _rotl64(unsigned __int64 Value, int Shift);

                unsigned int __cdecl _rotr(unsigned int Value, int Shift);

                unsigned __int64 __cdecl _rotr64(unsigned __int64 Value, int Shift);

#pragma intrinsic(_rotl)
#pragma intrinsic(_rotl64)
#pragma intrinsic(_rotr)
#pragma intrinsic(_rotr64)
            }

            typedef BYTE BOOLEAN;
            typedef BOOLEAN* PBOOLEAN;

            typedef struct _LIST_ENTRY
            {
                struct _LIST_ENTRY* Flink;
                struct _LIST_ENTRY* Blink;
            } LIST_ENTRY, *PLIST_ENTRY, *PRLIST_ENTRY;

            typedef struct _SINGLE_LIST_ENTRY
            {
                struct _SINGLE_LIST_ENTRY* Next;
            } SINGLE_LIST_ENTRY, *PSINGLE_LIST_ENTRY;

            typedef struct LIST_ENTRY32
            {
                DWORD Flink;
                DWORD Blink;
            } LIST_ENTRY32;
            typedef LIST_ENTRY32* PLIST_ENTRY32;

            typedef struct LIST_ENTRY64
            {
                ULONGLONG Flink;
                ULONGLONG Blink;
            } LIST_ENTRY64;
            typedef LIST_ENTRY64* PLIST_ENTRY64;

            typedef struct _GUID
            {
                unsigned long Data1;
                unsigned short Data2;
                unsigned short Data3;
                unsigned char Data4[8];
            } GUID;

            typedef GUID* LPGUID;

            typedef const GUID* LPCGUID;

            typedef GUID IID;
            typedef IID* LPIID;

            typedef GUID CLSID;
            typedef CLSID* LPCLSID;

            typedef GUID FMTID;
            typedef FMTID* LPFMTID;

            __inline int InlineIsEqualGUID(const GUID& rguid1, const GUID& rguid2)
            {
                return (((unsigned long*)&rguid1)[0] == ((unsigned long*)&rguid2)[0]
                        && ((unsigned long*)&rguid1)[1] == ((unsigned long*)&rguid2)[1]
                        && ((unsigned long*)&rguid1)[2] == ((unsigned long*)&rguid2)[2]
                        && ((unsigned long*)&rguid1)[3] == ((unsigned long*)&rguid2)[3]);
            }

            __inline int IsEqualGUID(const GUID& rguid1, const GUID& rguid2)
            {
                return !memcmp(&rguid1, &rguid2, sizeof(GUID));
            }

            __inline bool operator==(const GUID& guidOne, const GUID& guidOther)
            {
                return !!IsEqualGUID(guidOne, guidOther);
            }

            __inline bool operator!=(const GUID& guidOne, const GUID& guidOther)
            {
                return !(guidOne == guidOther);
            }

            typedef struct _OBJECTID
            {
                GUID Lineage;
                DWORD Uniquifier;
            } OBJECTID;

#pragma region Application Family or OneCore Family

            extern "C++" template <typename T, size_t N> char (*RtlpNumberOf(__unaligned T (&)[N]))[N];

#pragma endregion

            typedef

            EXCEPTION_DISPOSITION __stdcall EXCEPTION_ROUTINE(struct _EXCEPTION_RECORD* ExceptionRecord,
                                                              PVOID EstablisherFrame,
                                                              struct _CONTEXT* ContextRecord,
                                                              PVOID DispatcherContext);

            typedef EXCEPTION_ROUTINE* PEXCEPTION_ROUTINE;

            extern "C++"
            {
                template <size_t S> struct _ENUM_FLAG_INTEGER_FOR_SIZE;

                template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<1>
                {
                    typedef INT8 type;
                };

                template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<2>
                {
                    typedef INT16 type;
                };

                template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<4>
                {
                    typedef INT32 type;
                };

                template <> struct _ENUM_FLAG_INTEGER_FOR_SIZE<8>
                {
                    typedef INT64 type;
                };

                template <class T> struct _ENUM_FLAG_SIZED_INTEGER
                {
                    typedef typename _ENUM_FLAG_INTEGER_FOR_SIZE<sizeof(T)>::type type;
                };
            }

            typedef ULONG_PTR KSPIN_LOCK;
            typedef KSPIN_LOCK* PKSPIN_LOCK;

            typedef struct __declspec(align(16)) _M128A
            {
                ULONGLONG Low;
                LONGLONG High;
            } M128A, *PM128A;

            typedef struct __declspec(align(16)) _XSAVE_FORMAT
            {
                WORD ControlWord;
                WORD StatusWord;
                BYTE TagWord;
                BYTE Reserved1;
                WORD ErrorOpcode;
                DWORD ErrorOffset;
                WORD ErrorSelector;
                WORD Reserved2;
                DWORD DataOffset;
                WORD DataSelector;
                WORD Reserved3;
                DWORD MxCsr;
                DWORD MxCsr_Mask;
                M128A FloatRegisters[8];

                M128A XmmRegisters[16];
                BYTE Reserved4[96];

            } XSAVE_FORMAT, *PXSAVE_FORMAT;

            typedef struct _XSAVE_CET_U_FORMAT
            {
                DWORD64 Ia32CetUMsr;
                DWORD64 Ia32Pl3SspMsr;
            } XSAVE_CET_U_FORMAT, *PXSAVE_CET_U_FORMAT;

            typedef struct __declspec(align(8)) _XSAVE_AREA_HEADER
            {
                DWORD64 Mask;
                DWORD64 CompactionMask;
                DWORD64 Reserved2[6];
            } XSAVE_AREA_HEADER, *PXSAVE_AREA_HEADER;

            typedef struct __declspec(align(16)) _XSAVE_AREA
            {
                XSAVE_FORMAT LegacyState;
                XSAVE_AREA_HEADER Header;
            } XSAVE_AREA, *PXSAVE_AREA;

            typedef struct _XSTATE_CONTEXT
            {
                DWORD64 Mask;
                DWORD Length;
                DWORD Reserved1;
                PXSAVE_AREA Area;

                PVOID Buffer;

            } XSTATE_CONTEXT, *PXSTATE_CONTEXT;

            typedef struct _SCOPE_TABLE_AMD64
            {
                DWORD Count;
                struct
                {
                    DWORD BeginAddress;
                    DWORD EndAddress;
                    DWORD HandlerAddress;
                    DWORD JumpTarget;
                } ScopeRecord[1];
            } SCOPE_TABLE_AMD64, *PSCOPE_TABLE_AMD64;

            extern "C"
            {
                BOOLEAN
                _bittest(LONG const* Base, LONG Offset);

                BOOLEAN
                _bittestandcomplement(LONG* Base, LONG Offset);

                BOOLEAN
                _bittestandset(LONG* Base, LONG Offset);

                BOOLEAN
                _bittestandreset(LONG* Base, LONG Offset);

                BOOLEAN
                _interlockedbittestandset(LONG volatile* Base, LONG Offset);

                BOOLEAN
                _interlockedbittestandreset(LONG volatile* Base, LONG Offset);

                BOOLEAN
                _bittest64(LONG64 const* Base, LONG64 Offset);

                BOOLEAN
                _bittestandcomplement64(LONG64* Base, LONG64 Offset);

                BOOLEAN
                _bittestandset64(LONG64* Base, LONG64 Offset);

                BOOLEAN
                _bittestandreset64(LONG64* Base, LONG64 Offset);

                BOOLEAN
                _interlockedbittestandset64(LONG64 volatile* Base, LONG64 Offset);

                BOOLEAN
                _interlockedbittestandreset64(LONG64 volatile* Base, LONG64 Offset);

#pragma intrinsic(_bittest)
#pragma intrinsic(_bittestandcomplement)
#pragma intrinsic(_bittestandset)
#pragma intrinsic(_bittestandreset)
#pragma intrinsic(_interlockedbittestandset)
#pragma intrinsic(_interlockedbittestandreset)

#pragma intrinsic(_bittest64)
#pragma intrinsic(_bittestandcomplement64)
#pragma intrinsic(_bittestandset64)
#pragma intrinsic(_bittestandreset64)
#pragma intrinsic(_interlockedbittestandset64)
#pragma intrinsic(_interlockedbittestandreset64)

                BOOLEAN
                _BitScanForward(DWORD* Index, DWORD Mask);

                BOOLEAN
                _BitScanReverse(DWORD* Index, DWORD Mask);

                BOOLEAN
                _BitScanForward64(DWORD* Index, DWORD64 Mask);

                BOOLEAN
                _BitScanReverse64(DWORD* Index, DWORD64 Mask);

#pragma intrinsic(_BitScanForward)
#pragma intrinsic(_BitScanReverse)
#pragma intrinsic(_BitScanForward64)
#pragma intrinsic(_BitScanReverse64)

                SHORT
                _InterlockedIncrement16(SHORT volatile* Addend);

                SHORT
                _InterlockedDecrement16(SHORT volatile* Addend);

                SHORT
                _InterlockedCompareExchange16(SHORT volatile* Destination, SHORT ExChange, SHORT Comperand);

                LONG _InterlockedAnd(LONG volatile* Destination, LONG Value);

                LONG _InterlockedOr(LONG volatile* Destination, LONG Value);

                LONG _InterlockedXor(LONG volatile* Destination, LONG Value);

                LONG64
                _InterlockedAnd64(LONG64 volatile* Destination, LONG64 Value);

                LONG64
                _InterlockedOr64(LONG64 volatile* Destination, LONG64 Value);

                LONG64
                _InterlockedXor64(LONG64 volatile* Destination, LONG64 Value);

                LONG _InterlockedIncrement(LONG volatile* Addend);

                LONG _InterlockedDecrement(LONG volatile* Addend);

                LONG _InterlockedExchange(LONG volatile* Target, LONG Value);

                LONG _InterlockedExchangeAdd(LONG volatile* Addend, LONG Value);

                __forceinline LONG _InlineInterlockedAdd(LONG volatile* Addend, LONG Value)

                {
                    return _InterlockedExchangeAdd(Addend, Value) + Value;
                }

                LONG _InterlockedCompareExchange(LONG volatile* Destination, LONG ExChange, LONG Comperand);

                LONG64
                _InterlockedIncrement64(LONG64 volatile* Addend);

                LONG64
                _InterlockedDecrement64(LONG64 volatile* Addend);

                LONG64
                _InterlockedExchange64(LONG64 volatile* Target, LONG64 Value);

                LONG64
                _InterlockedExchangeAdd64(LONG64 volatile* Addend, LONG64 Value);

                __forceinline LONG64 _InlineInterlockedAdd64(LONG64 volatile* Addend, LONG64 Value)

                {
                    return _InterlockedExchangeAdd64(Addend, Value) + Value;
                }

                LONG64
                _InterlockedCompareExchange64(LONG64 volatile* Destination, LONG64 ExChange, LONG64 Comperand);

                BOOLEAN
                _InterlockedCompareExchange128(LONG64 volatile* Destination, LONG64 ExchangeHigh, LONG64 ExchangeLow, LONG64* ComparandResult);

                PVOID
                _InterlockedCompareExchangePointer(

                PVOID volatile* Destination, PVOID Exchange, PVOID Comperand);

                PVOID
                _InterlockedExchangePointer(

                PVOID volatile* Target, PVOID Value);

#pragma intrinsic(_InterlockedIncrement16)
#pragma intrinsic(_InterlockedDecrement16)
#pragma intrinsic(_InterlockedCompareExchange16)
#pragma intrinsic(_InterlockedAnd)
#pragma intrinsic(_InterlockedOr)
#pragma intrinsic(_InterlockedXor)
#pragma intrinsic(_InterlockedIncrement)
#pragma intrinsic(_InterlockedDecrement)
#pragma intrinsic(_InterlockedExchange)
#pragma intrinsic(_InterlockedExchangeAdd)
#pragma intrinsic(_InterlockedCompareExchange)
#pragma intrinsic(_InterlockedAnd64)
#pragma intrinsic(_InterlockedOr64)
#pragma intrinsic(_InterlockedXor64)
#pragma intrinsic(_InterlockedIncrement64)
#pragma intrinsic(_InterlockedDecrement64)
#pragma intrinsic(_InterlockedExchange64)
#pragma intrinsic(_InterlockedExchangeAdd64)
#pragma intrinsic(_InterlockedCompareExchange64)

#pragma intrinsic(_InterlockedCompareExchange128)

#pragma intrinsic(_InterlockedExchangePointer)
#pragma intrinsic(_InterlockedCompareExchangePointer)

                CHAR _InterlockedExchange8(CHAR volatile* Target, CHAR Value);

                SHORT
                _InterlockedExchange16(SHORT volatile* Destination, SHORT ExChange);

#pragma intrinsic(_InterlockedExchange8)
#pragma intrinsic(_InterlockedExchange16)

                char _InterlockedExchangeAdd8(char volatile* _Addend, char _Value);

                char _InterlockedAnd8(char volatile* Destination, char Value);

                char _InterlockedOr8(char volatile* Destination, char Value);

                char _InterlockedXor8(char volatile* Destination, char Value);

                SHORT
                _InterlockedAnd16(SHORT volatile* Destination, SHORT Value);

                SHORT
                _InterlockedOr16(SHORT volatile* Destination, SHORT Value);

                SHORT
                _InterlockedXor16(SHORT volatile* Destination, SHORT Value);

#pragma intrinsic(_InterlockedExchangeAdd8)
#pragma intrinsic(_InterlockedAnd8)
#pragma intrinsic(_InterlockedOr8)
#pragma intrinsic(_InterlockedXor8)
#pragma intrinsic(_InterlockedAnd16)
#pragma intrinsic(_InterlockedOr16)
#pragma intrinsic(_InterlockedXor16)

                void __cpuidex(int CPUInfo[4], int Function, int SubLeaf);

#pragma intrinsic(__cpuidex)

                void _mm_clflush(void const* Address);

#pragma intrinsic(_mm_clflush)

                void _ReadWriteBarrier(void);

#pragma intrinsic(_ReadWriteBarrier)

                void __faststorefence(void);

                void _mm_lfence(void);

                void _mm_mfence(void);

                void _mm_sfence(void);

                void _mm_pause(void);

                void _mm_prefetch(CHAR const* a, int sel);

                void _m_prefetchw(volatile const void* Source);

#pragma intrinsic(__faststorefence)

#pragma intrinsic(_mm_pause)
#pragma intrinsic(_mm_prefetch)
#pragma intrinsic(_mm_lfence)
#pragma intrinsic(_mm_mfence)
#pragma intrinsic(_mm_sfence)
#pragma intrinsic(_m_prefetchw)

                unsigned int _mm_getcsr(void);

                void _mm_setcsr(unsigned int MxCsr);

#pragma intrinsic(_mm_getcsr)
#pragma intrinsic(_mm_setcsr)

                unsigned __int32 __getcallerseflags(void);

#pragma intrinsic(__getcallerseflags)

                DWORD
                __segmentlimit(DWORD Selector);

#pragma intrinsic(__segmentlimit)

                DWORD64
                __readpmc(DWORD Counter);

#pragma intrinsic(__readpmc)

                DWORD64
                __rdtsc(void);

#pragma intrinsic(__rdtsc)

                void __movsb(PBYTE Destination, BYTE const* Source, SIZE_T Count);

                void __movsw(PWORD Destination, WORD const* Source, SIZE_T Count);

                void __movsd(PDWORD Destination, DWORD const* Source, SIZE_T Count);

                void __movsq(PDWORD64 Destination, DWORD64 const* Source, SIZE_T Count);

#pragma intrinsic(__movsb)
#pragma intrinsic(__movsw)
#pragma intrinsic(__movsd)
#pragma intrinsic(__movsq)

                void __stosb(PBYTE Destination, BYTE Value, SIZE_T Count);

                void __stosw(PWORD Destination, WORD Value, SIZE_T Count);

                void __stosd(PDWORD Destination, DWORD Value, SIZE_T Count);

                void __stosq(PDWORD64 Destination, DWORD64 Value, SIZE_T Count);

#pragma intrinsic(__stosb)
#pragma intrinsic(__stosw)
#pragma intrinsic(__stosd)
#pragma intrinsic(__stosq)

                LONGLONG
                __mulh(LONG64 Multiplier, LONG64 Multiplicand);

                ULONGLONG
                __umulh(DWORD64 Multiplier, DWORD64 Multiplicand);

#pragma intrinsic(__mulh)
#pragma intrinsic(__umulh)

                DWORD64
                __popcnt64(DWORD64 operand);

#pragma intrinsic(__popcnt64)

                DWORD64
                __shiftleft128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift);

                DWORD64
                __shiftright128(DWORD64 LowPart, DWORD64 HighPart, BYTE Shift);

#pragma intrinsic(__shiftleft128)
#pragma intrinsic(__shiftright128)

                LONG64
                _mul128(LONG64 Multiplier, LONG64 Multiplicand, LONG64* HighProduct);

#pragma intrinsic(_mul128)

                DWORD64
                _umul128(DWORD64 Multiplier, DWORD64 Multiplicand, DWORD64* HighProduct);

#pragma intrinsic(_umul128)

                __forceinline LONG64 MultiplyExtract128(LONG64 Multiplier, LONG64 Multiplicand, BYTE Shift)

                {
                    LONG64 extractedProduct;
                    LONG64 highProduct;
                    LONG64 lowProduct;
                    BOOLEAN negate;
                    DWORD64 uhighProduct;
                    DWORD64 ulowProduct;

                    lowProduct = _mul128(Multiplier, Multiplicand, &highProduct);
                    negate = 0;
                    uhighProduct = (DWORD64)highProduct;
                    ulowProduct = (DWORD64)lowProduct;
                    if(highProduct < 0)
                    {
                        negate = 1;
                        uhighProduct = (DWORD64)(-highProduct);
                        ulowProduct = (DWORD64)(-lowProduct);
                        if(ulowProduct != 0)
                        {
                            uhighProduct -= 1;
                        }
                    }

                    extractedProduct = (LONG64)__shiftright128(ulowProduct, uhighProduct, Shift);
                    if(negate != 0)
                    {
                        extractedProduct = -extractedProduct;
                    }

                    return extractedProduct;
                }

                __forceinline DWORD64 UnsignedMultiplyExtract128(DWORD64 Multiplier, DWORD64 Multiplicand, BYTE Shift)

                {
                    DWORD64 extractedProduct;
                    DWORD64 highProduct;
                    DWORD64 lowProduct;

                    lowProduct = _umul128(Multiplier, Multiplicand, &highProduct);
                    extractedProduct = __shiftright128(lowProduct, highProduct, Shift);
                    return extractedProduct;
                }

                BYTE __readgsbyte(DWORD Offset);

                WORD __readgsword(DWORD Offset);

                DWORD
                __readgsdword(DWORD Offset);

                DWORD64
                __readgsqword(DWORD Offset);

                void __writegsbyte(DWORD Offset, BYTE Data);

                void __writegsword(DWORD Offset, WORD Data);

                void __writegsdword(DWORD Offset, DWORD Data);

                void __writegsqword(DWORD Offset, DWORD64 Data);

#pragma intrinsic(__readgsbyte)
#pragma intrinsic(__readgsword)
#pragma intrinsic(__readgsdword)
#pragma intrinsic(__readgsqword)
#pragma intrinsic(__writegsbyte)
#pragma intrinsic(__writegsword)
#pragma intrinsic(__writegsdword)
#pragma intrinsic(__writegsqword)
            }

            typedef XSAVE_FORMAT XMM_SAVE_AREA32, *PXMM_SAVE_AREA32;

            typedef struct __declspec(align(16)) _CONTEXT
            {
                DWORD64 P1Home;
                DWORD64 P2Home;
                DWORD64 P3Home;
                DWORD64 P4Home;
                DWORD64 P5Home;
                DWORD64 P6Home;

                DWORD ContextFlags;
                DWORD MxCsr;

                WORD SegCs;
                WORD SegDs;
                WORD SegEs;
                WORD SegFs;
                WORD SegGs;
                WORD SegSs;
                DWORD EFlags;

                DWORD64 Dr0;
                DWORD64 Dr1;
                DWORD64 Dr2;
                DWORD64 Dr3;
                DWORD64 Dr6;
                DWORD64 Dr7;

                DWORD64 Rax;
                DWORD64 Rcx;
                DWORD64 Rdx;
                DWORD64 Rbx;
                DWORD64 Rsp;
                DWORD64 Rbp;
                DWORD64 Rsi;
                DWORD64 Rdi;
                DWORD64 R8;
                DWORD64 R9;
                DWORD64 R10;
                DWORD64 R11;
                DWORD64 R12;
                DWORD64 R13;
                DWORD64 R14;
                DWORD64 R15;

                DWORD64 Rip;

                union
                {
                    XMM_SAVE_AREA32 FltSave;
                    struct
                    {
                        M128A Header[2];
                        M128A Legacy[8];
                        M128A Xmm0;
                        M128A Xmm1;
                        M128A Xmm2;
                        M128A Xmm3;
                        M128A Xmm4;
                        M128A Xmm5;
                        M128A Xmm6;
                        M128A Xmm7;
                        M128A Xmm8;
                        M128A Xmm9;
                        M128A Xmm10;
                        M128A Xmm11;
                        M128A Xmm12;
                        M128A Xmm13;
                        M128A Xmm14;
                        M128A Xmm15;
                    };
                };

                M128A VectorRegister[26];
                DWORD64 VectorControl;

                DWORD64 DebugControl;
                DWORD64 LastBranchToRip;
                DWORD64 LastBranchFromRip;
                DWORD64 LastExceptionToRip;
                DWORD64 LastExceptionFromRip;
            } CONTEXT, *PCONTEXT;

            typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY RUNTIME_FUNCTION, *PRUNTIME_FUNCTION;
            typedef SCOPE_TABLE_AMD64 SCOPE_TABLE, *PSCOPE_TABLE;

            typedef struct _UNWIND_HISTORY_TABLE_ENTRY
            {
                DWORD64 ImageBase;
                PRUNTIME_FUNCTION FunctionEntry;
            } UNWIND_HISTORY_TABLE_ENTRY, *PUNWIND_HISTORY_TABLE_ENTRY;

            typedef struct _UNWIND_HISTORY_TABLE
            {
                DWORD Count;
                BYTE LocalHint;
                BYTE GlobalHint;
                BYTE Search;
                BYTE Once;
                DWORD64 LowAddress;
                DWORD64 HighAddress;
                UNWIND_HISTORY_TABLE_ENTRY Entry[12];
            } UNWIND_HISTORY_TABLE, *PUNWIND_HISTORY_TABLE;

            typedef

            PRUNTIME_FUNCTION
            GET_RUNTIME_FUNCTION_CALLBACK(DWORD64 ControlPc, PVOID Context);
            typedef GET_RUNTIME_FUNCTION_CALLBACK* PGET_RUNTIME_FUNCTION_CALLBACK;

            typedef

            DWORD
            OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK(HANDLE Process, PVOID TableAddress, PDWORD Entries, PRUNTIME_FUNCTION* Functions);
            typedef OUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK* POUT_OF_PROCESS_FUNCTION_TABLE_CALLBACK;

            typedef struct _DISPATCHER_CONTEXT
            {
                DWORD64 ControlPc;
                DWORD64 ImageBase;
                PRUNTIME_FUNCTION FunctionEntry;
                DWORD64 EstablisherFrame;
                DWORD64 TargetIp;
                PCONTEXT ContextRecord;
                PEXCEPTION_ROUTINE LanguageHandler;
                PVOID HandlerData;
                PUNWIND_HISTORY_TABLE HistoryTable;
                DWORD ScopeIndex;
                DWORD Fill0;
            } DISPATCHER_CONTEXT, *PDISPATCHER_CONTEXT;

            struct _EXCEPTION_POINTERS;
            typedef LONG (*PEXCEPTION_FILTER)(struct _EXCEPTION_POINTERS* ExceptionPointers, PVOID EstablisherFrame);

            typedef void (*PTERMINATION_HANDLER)(BOOLEAN _abnormal_termination, PVOID EstablisherFrame);

            typedef struct _KNONVOLATILE_CONTEXT_POINTERS
            {
                union
                {
                    PM128A FloatingContext[16];
                    struct
                    {
                        PM128A Xmm0;
                        PM128A Xmm1;
                        PM128A Xmm2;
                        PM128A Xmm3;
                        PM128A Xmm4;
                        PM128A Xmm5;
                        PM128A Xmm6;
                        PM128A Xmm7;
                        PM128A Xmm8;
                        PM128A Xmm9;
                        PM128A Xmm10;
                        PM128A Xmm11;
                        PM128A Xmm12;
                        PM128A Xmm13;
                        PM128A Xmm14;
                        PM128A Xmm15;
                    };
                };

                union
                {
                    PDWORD64 IntegerContext[16];
                    struct
                    {
                        PDWORD64 Rax;
                        PDWORD64 Rcx;
                        PDWORD64 Rdx;
                        PDWORD64 Rbx;
                        PDWORD64 Rsp;
                        PDWORD64 Rbp;
                        PDWORD64 Rsi;
                        PDWORD64 Rdi;
                        PDWORD64 R8;
                        PDWORD64 R9;
                        PDWORD64 R10;
                        PDWORD64 R11;
                        PDWORD64 R12;
                        PDWORD64 R13;
                        PDWORD64 R14;
                        PDWORD64 R15;
                    };
                };

            } KNONVOLATILE_CONTEXT_POINTERS, *PKNONVOLATILE_CONTEXT_POINTERS;

            typedef struct _SCOPE_TABLE_ARM
            {
                DWORD Count;
                struct
                {
                    DWORD BeginAddress;
                    DWORD EndAddress;
                    DWORD HandlerAddress;
                    DWORD JumpTarget;
                } ScopeRecord[1];
            } SCOPE_TABLE_ARM, *PSCOPE_TABLE_ARM;

            typedef struct _SCOPE_TABLE_ARM64
            {
                DWORD Count;
                struct
                {
                    DWORD BeginAddress;
                    DWORD EndAddress;
                    DWORD HandlerAddress;
                    DWORD JumpTarget;
                } ScopeRecord[1];
            } SCOPE_TABLE_ARM64, *PSCOPE_TABLE_ARM64;

            typedef struct _KNONVOLATILE_CONTEXT_POINTERS_ARM64
            {
                PDWORD64 X19;
                PDWORD64 X20;
                PDWORD64 X21;
                PDWORD64 X22;
                PDWORD64 X23;
                PDWORD64 X24;
                PDWORD64 X25;
                PDWORD64 X26;
                PDWORD64 X27;
                PDWORD64 X28;
                PDWORD64 Fp;
                PDWORD64 Lr;

                PDWORD64 D8;
                PDWORD64 D9;
                PDWORD64 D10;
                PDWORD64 D11;
                PDWORD64 D12;
                PDWORD64 D13;
                PDWORD64 D14;
                PDWORD64 D15;

            } KNONVOLATILE_CONTEXT_POINTERS_ARM64, *PKNONVOLATILE_CONTEXT_POINTERS_ARM64;

            extern "C"
            {
                void __int2c(void);

#pragma intrinsic(__int2c)
            }

            typedef struct _LDT_ENTRY
            {
                WORD LimitLow;
                WORD BaseLow;
                union
                {
                    struct
                    {
                        BYTE BaseMid;
                        BYTE Flags1;
                        BYTE Flags2;
                        BYTE BaseHi;
                    } Bytes;
                    struct
                    {
                        DWORD BaseMid : 8;
                        DWORD Type : 5;
                        DWORD Dpl : 2;
                        DWORD Pres : 1;
                        DWORD LimitHi : 4;
                        DWORD Sys : 1;
                        DWORD Reserved_0 : 1;
                        DWORD Default_Big : 1;
                        DWORD Granularity : 1;
                        DWORD BaseHi : 8;
                    } Bits;
                } HighWord;
            } LDT_ENTRY, *PLDT_ENTRY;

            extern "C"
            {
                __forceinline CHAR ReadAcquire8(CHAR const volatile* Source)

                {
                    CHAR Value;

                    Value = *Source;
                    return Value;
                }

                __forceinline CHAR ReadNoFence8(CHAR const volatile* Source)

                {
                    CHAR Value;

                    Value = *Source;
                    return Value;
                }

                __forceinline void WriteRelease8(CHAR volatile* Destination, CHAR Value)

                {
                    *Destination = Value;
                    return;
                }

                __forceinline void WriteNoFence8(CHAR volatile* Destination, CHAR Value)

                {
                    *Destination = Value;
                    return;
                }

                __forceinline SHORT ReadAcquire16(SHORT const volatile* Source)

                {
                    SHORT Value;

                    Value = *Source;
                    return Value;
                }

                __forceinline SHORT ReadNoFence16(SHORT const volatile* Source)

                {
                    SHORT Value;

                    Value = *Source;
                    return Value;
                }

                __forceinline void WriteRelease16(SHORT volatile* Destination, SHORT Value)

                {
                    *Destination = Value;
                    return;
                }

                __forceinline void WriteNoFence16(SHORT volatile* Destination, SHORT Value)

                {
                    *Destination = Value;
                    return;
                }

                __forceinline LONG ReadAcquire(LONG const volatile* Source)

                {
                    LONG Value;

                    Value = *Source;
                    return Value;
                }

                __forceinline LONG ReadNoFence(LONG const volatile* Source)

                {
                    LONG Value;

                    Value = *Source;
                    return Value;
                }

                __forceinline void WriteRelease(LONG volatile* Destination, LONG Value)

                {
                    *Destination = Value;
                    return;
                }

                __forceinline void WriteNoFence(LONG volatile* Destination, LONG Value)

                {
                    *Destination = Value;
                    return;
                }

                __forceinline LONG64 ReadAcquire64(LONG64 const volatile* Source)

                {
                    LONG64 Value;

                    Value = *Source;
                    return Value;
                }

                __forceinline LONG64 ReadNoFence64(LONG64 const volatile* Source)

                {
                    LONG64 Value;

                    Value = *Source;
                    return Value;
                }

                __forceinline void WriteRelease64(LONG64 volatile* Destination, LONG64 Value)

                {
                    *Destination = Value;
                    return;
                }

                __forceinline void WriteNoFence64(LONG64 volatile* Destination, LONG64 Value)

                {
                    *Destination = Value;
                    return;
                }
            }

            __forceinline CHAR ReadRaw8(CHAR const volatile* Source)

            {
                CHAR Value;

                Value = *(CHAR*)Source;
                return Value;
            }

            __forceinline void WriteRaw8(CHAR volatile* Destination, CHAR Value)

            {
                *(CHAR*)Destination = Value;
                return;
            }

            __forceinline SHORT ReadRaw16(SHORT const volatile* Source)

            {
                SHORT Value;

                Value = *(SHORT*)Source;
                return Value;
            }

            __forceinline void WriteRaw16(SHORT volatile* Destination, SHORT Value)

            {
                *(SHORT*)Destination = Value;
                return;
            }

            __forceinline LONG ReadRaw(LONG const volatile* Source)

            {
                LONG Value;

                Value = *(LONG*)Source;
                return Value;
            }

            __forceinline void WriteRaw(LONG volatile* Destination, LONG Value)

            {
                *(LONG*)Destination = Value;
                return;
            }

            __forceinline LONG64 ReadRaw64(LONG64 const volatile* Source)

            {
                LONG64 Value;

                Value = *(LONG64*)Source;
                return Value;
            }

            __forceinline void WriteRaw64(LONG64 volatile* Destination, LONG64 Value)

            {
                *(LONG64*)Destination = Value;
                return;
            }

            __forceinline BYTE ReadUCharAcquire(BYTE const volatile* Source)

            {
                return (BYTE)ReadAcquire8((PCHAR)Source);
            }

            __forceinline BYTE ReadUCharNoFence(BYTE const volatile* Source)

            {
                return (BYTE)ReadNoFence8((PCHAR)Source);
            }

            __forceinline BYTE ReadBooleanAcquire(BOOLEAN const volatile* Source)

            {
                return (BOOLEAN)ReadAcquire8((PCHAR)Source);
            }

            __forceinline BYTE ReadBooleanNoFence(BOOLEAN const volatile* Source)

            {
                return (BOOLEAN)ReadNoFence8((PCHAR)Source);
            }

            __forceinline BYTE ReadUCharRaw(BYTE const volatile* Source)

            {
                return (BYTE)ReadRaw8((PCHAR)Source);
            }

            __forceinline void WriteUCharRelease(BYTE volatile* Destination, BYTE Value)

            {
                WriteRelease8((PCHAR)Destination, (CHAR)Value);
                return;
            }

            __forceinline void WriteUCharNoFence(BYTE volatile* Destination, BYTE Value)

            {
                WriteNoFence8((PCHAR)Destination, (CHAR)Value);
                return;
            }

            __forceinline void WriteBooleanRelease(BOOLEAN volatile* Destination, BOOLEAN Value)

            {
                WriteRelease8((PCHAR)Destination, (CHAR)Value);
                return;
            }

            __forceinline void WriteBooleanNoFence(BOOLEAN volatile* Destination, BOOLEAN Value)

            {
                WriteNoFence8((PCHAR)Destination, (CHAR)Value);
                return;
            }

            __forceinline void WriteUCharRaw(BYTE volatile* Destination, BYTE Value)

            {
                WriteRaw8((PCHAR)Destination, (CHAR)Value);
                return;
            }

            __forceinline WORD ReadUShortAcquire(WORD const volatile* Source)

            {
                return (WORD)ReadAcquire16((PSHORT)Source);
            }

            __forceinline WORD ReadUShortNoFence(WORD const volatile* Source)

            {
                return (WORD)ReadNoFence16((PSHORT)Source);
            }

            __forceinline WORD ReadUShortRaw(WORD const volatile* Source)

            {
                return (WORD)ReadRaw16((PSHORT)Source);
            }

            __forceinline void WriteUShortRelease(WORD volatile* Destination, WORD Value)

            {
                WriteRelease16((PSHORT)Destination, (SHORT)Value);
                return;
            }

            __forceinline void WriteUShortNoFence(WORD volatile* Destination, WORD Value)

            {
                WriteNoFence16((PSHORT)Destination, (SHORT)Value);
                return;
            }

            __forceinline void WriteUShortRaw(WORD volatile* Destination, WORD Value)

            {
                WriteRaw16((PSHORT)Destination, (SHORT)Value);
                return;
            }

            __forceinline DWORD ReadULongAcquire(DWORD const volatile* Source)

            {
                return (DWORD)ReadAcquire((PLONG)Source);
            }

            __forceinline DWORD ReadULongNoFence(DWORD const volatile* Source)

            {
                return (DWORD)ReadNoFence((PLONG)Source);
            }

            __forceinline DWORD ReadULongRaw(DWORD const volatile* Source)

            {
                return (DWORD)ReadRaw((PLONG)Source);
            }

            __forceinline void WriteULongRelease(DWORD volatile* Destination, DWORD Value)

            {
                WriteRelease((PLONG)Destination, (LONG)Value);
                return;
            }

            __forceinline void WriteULongNoFence(DWORD volatile* Destination, DWORD Value)

            {
                WriteNoFence((PLONG)Destination, (LONG)Value);
                return;
            }

            __forceinline void WriteULongRaw(DWORD volatile* Destination, DWORD Value)

            {
                WriteRaw((PLONG)Destination, (LONG)Value);
                return;
            }

            __forceinline DWORD64 ReadULong64Acquire(DWORD64 const volatile* Source)

            {
                return (DWORD64)ReadAcquire64((PLONG64)Source);
            }

            __forceinline DWORD64 ReadULong64NoFence(DWORD64 const volatile* Source)

            {
                return (DWORD64)ReadNoFence64((PLONG64)Source);
            }

            __forceinline DWORD64 ReadULong64Raw(DWORD64 const volatile* Source)

            {
                return (DWORD64)ReadRaw64((PLONG64)Source);
            }

            __forceinline void WriteULong64Release(DWORD64 volatile* Destination, DWORD64 Value)

            {
                WriteRelease64((PLONG64)Destination, (LONG64)Value);
                return;
            }

            __forceinline void WriteULong64NoFence(DWORD64 volatile* Destination, DWORD64 Value)

            {
                WriteNoFence64((PLONG64)Destination, (LONG64)Value);
                return;
            }

            __forceinline void WriteULong64Raw(DWORD64 volatile* Destination, DWORD64 Value)

            {
                WriteRaw64((PLONG64)Destination, (LONG64)Value);
                return;
            }

            __forceinline PVOID ReadPointerAcquire(PVOID const volatile* Source)

            {
                return (PVOID)ReadAcquire64((PLONG64)Source);
            }

            __forceinline PVOID ReadPointerNoFence(PVOID const volatile* Source)

            {
                return (PVOID)ReadNoFence64((PLONG64)Source);
            }

            __forceinline PVOID ReadPointerRaw(PVOID const volatile* Source)

            {
                return (PVOID)ReadRaw64((PLONG64)Source);
            }

            __forceinline void WritePointerRelease(PVOID volatile* Destination, PVOID Value)

            {
                WriteRelease64((PLONG64)Destination, (LONG64)Value);
                return;
            }

            __forceinline void WritePointerNoFence(PVOID volatile* Destination, PVOID Value)

            {
                WriteNoFence64((PLONG64)Destination, (LONG64)Value);
                return;
            }

            __forceinline void WritePointerRaw(PVOID volatile* Destination, PVOID Value)

            {
                WriteRaw64((PLONG64)Destination, (LONG64)Value);
                return;
            }

            typedef struct _WOW64_FLOATING_SAVE_AREA
            {
                DWORD ControlWord;
                DWORD StatusWord;
                DWORD TagWord;
                DWORD ErrorOffset;
                DWORD ErrorSelector;
                DWORD DataOffset;
                DWORD DataSelector;
                BYTE RegisterArea[80];
                DWORD Cr0NpxState;
            } WOW64_FLOATING_SAVE_AREA;

            typedef WOW64_FLOATING_SAVE_AREA* PWOW64_FLOATING_SAVE_AREA;

#pragma warning(disable : 4103)

#pragma pack(push, 4)

            typedef struct _WOW64_CONTEXT
            {
                DWORD ContextFlags;

                DWORD Dr0;
                DWORD Dr1;
                DWORD Dr2;
                DWORD Dr3;
                DWORD Dr6;
                DWORD Dr7;

                WOW64_FLOATING_SAVE_AREA FloatSave;

                DWORD SegGs;
                DWORD SegFs;
                DWORD SegEs;
                DWORD SegDs;

                DWORD Edi;
                DWORD Esi;
                DWORD Ebx;
                DWORD Edx;
                DWORD Ecx;
                DWORD Eax;

                DWORD Ebp;
                DWORD Eip;
                DWORD SegCs;
                DWORD EFlags;
                DWORD Esp;
                DWORD SegSs;

                BYTE ExtendedRegisters[512];

            } WOW64_CONTEXT;

            typedef WOW64_CONTEXT* PWOW64_CONTEXT;

#pragma warning(disable : 4103)

#pragma pack(pop)

            typedef struct _WOW64_LDT_ENTRY
            {
                WORD LimitLow;
                WORD BaseLow;
                union
                {
                    struct
                    {
                        BYTE BaseMid;
                        BYTE Flags1;
                        BYTE Flags2;
                        BYTE BaseHi;
                    } Bytes;
                    struct
                    {
                        DWORD BaseMid : 8;
                        DWORD Type : 5;
                        DWORD Dpl : 2;
                        DWORD Pres : 1;
                        DWORD LimitHi : 4;
                        DWORD Sys : 1;
                        DWORD Reserved_0 : 1;
                        DWORD Default_Big : 1;
                        DWORD Granularity : 1;
                        DWORD BaseHi : 8;
                    } Bits;
                } HighWord;
            } WOW64_LDT_ENTRY, *PWOW64_LDT_ENTRY;

            typedef struct _WOW64_DESCRIPTOR_TABLE_ENTRY
            {
                DWORD Selector;
                WOW64_LDT_ENTRY Descriptor;
            } WOW64_DESCRIPTOR_TABLE_ENTRY, *PWOW64_DESCRIPTOR_TABLE_ENTRY;

            typedef struct _EXCEPTION_RECORD
            {
                DWORD ExceptionCode;
                DWORD ExceptionFlags;
                struct _EXCEPTION_RECORD* ExceptionRecord;
                PVOID ExceptionAddress;
                DWORD NumberParameters;
                ULONG_PTR ExceptionInformation[15];
            } EXCEPTION_RECORD;

            typedef EXCEPTION_RECORD* PEXCEPTION_RECORD;

            typedef struct _EXCEPTION_RECORD32
            {
                DWORD ExceptionCode;
                DWORD ExceptionFlags;
                DWORD ExceptionRecord;
                DWORD ExceptionAddress;
                DWORD NumberParameters;
                DWORD ExceptionInformation[15];
            } EXCEPTION_RECORD32, *PEXCEPTION_RECORD32;

            typedef struct _EXCEPTION_RECORD64
            {
                DWORD ExceptionCode;
                DWORD ExceptionFlags;
                DWORD64 ExceptionRecord;
                DWORD64 ExceptionAddress;
                DWORD NumberParameters;
                DWORD __unusedAlignment;
                DWORD64 ExceptionInformation[15];
            } EXCEPTION_RECORD64, *PEXCEPTION_RECORD64;

            typedef struct _EXCEPTION_POINTERS
            {
                PEXCEPTION_RECORD ExceptionRecord;
                PCONTEXT ContextRecord;
            } EXCEPTION_POINTERS, *PEXCEPTION_POINTERS;

            typedef PVOID PACCESS_TOKEN;
            typedef PVOID PSECURITY_DESCRIPTOR;
            typedef PVOID PSID;
            typedef PVOID PCLAIMS_BLOB;

            typedef DWORD ACCESS_MASK;
            typedef ACCESS_MASK* PACCESS_MASK;

            typedef struct _GENERIC_MAPPING
            {
                ACCESS_MASK GenericRead;
                ACCESS_MASK GenericWrite;
                ACCESS_MASK GenericExecute;
                ACCESS_MASK GenericAll;
            } GENERIC_MAPPING;
            typedef GENERIC_MAPPING* PGENERIC_MAPPING;

#pragma warning(disable : 4103)

#pragma pack(push, 4)

            typedef struct _LUID_AND_ATTRIBUTES
            {
                LUID Luid;
                DWORD Attributes;
            } LUID_AND_ATTRIBUTES, *PLUID_AND_ATTRIBUTES;
            typedef LUID_AND_ATTRIBUTES LUID_AND_ATTRIBUTES_ARRAY[1];
            typedef LUID_AND_ATTRIBUTES_ARRAY* PLUID_AND_ATTRIBUTES_ARRAY;

#pragma warning(disable : 4103)

#pragma pack(pop)

            typedef struct _SID_IDENTIFIER_AUTHORITY
            {
                BYTE Value[6];
            } SID_IDENTIFIER_AUTHORITY, *PSID_IDENTIFIER_AUTHORITY;

            typedef struct _SID
            {
                BYTE Revision;
                BYTE SubAuthorityCount;
                SID_IDENTIFIER_AUTHORITY IdentifierAuthority;

                DWORD SubAuthority[1];
            } SID, *PISID;

            typedef union _SE_SID
            {
                SID Sid;
                BYTE Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD)))];
            } SE_SID, *PSE_SID;

            typedef enum _SID_NAME_USE
            {
                SidTypeUser = 1,
                SidTypeGroup,
                SidTypeDomain,
                SidTypeAlias,
                SidTypeWellKnownGroup,
                SidTypeDeletedAccount,
                SidTypeInvalid,
                SidTypeUnknown,
                SidTypeComputer,
                SidTypeLabel,
                SidTypeLogonSession
            } SID_NAME_USE,
            *PSID_NAME_USE;

            typedef struct _SID_AND_ATTRIBUTES
            {
                PSID Sid;
                DWORD Attributes;
            } SID_AND_ATTRIBUTES, *PSID_AND_ATTRIBUTES;

            typedef SID_AND_ATTRIBUTES SID_AND_ATTRIBUTES_ARRAY[1];
            typedef SID_AND_ATTRIBUTES_ARRAY* PSID_AND_ATTRIBUTES_ARRAY;

            typedef ULONG_PTR SID_HASH_ENTRY, *PSID_HASH_ENTRY;

            typedef struct _SID_AND_ATTRIBUTES_HASH
            {
                DWORD SidCount;
                PSID_AND_ATTRIBUTES SidAttr;
                SID_HASH_ENTRY Hash[32];
            } SID_AND_ATTRIBUTES_HASH, *PSID_AND_ATTRIBUTES_HASH;

            typedef enum
            {

                WinNullSid = 0,
                WinWorldSid = 1,
                WinLocalSid = 2,
                WinCreatorOwnerSid = 3,
                WinCreatorGroupSid = 4,
                WinCreatorOwnerServerSid = 5,
                WinCreatorGroupServerSid = 6,
                WinNtAuthoritySid = 7,
                WinDialupSid = 8,
                WinNetworkSid = 9,
                WinBatchSid = 10,
                WinInteractiveSid = 11,
                WinServiceSid = 12,
                WinAnonymousSid = 13,
                WinProxySid = 14,
                WinEnterpriseControllersSid = 15,
                WinSelfSid = 16,
                WinAuthenticatedUserSid = 17,
                WinRestrictedCodeSid = 18,
                WinTerminalServerSid = 19,
                WinRemoteLogonIdSid = 20,
                WinLogonIdsSid = 21,
                WinLocalSystemSid = 22,
                WinLocalServiceSid = 23,
                WinNetworkServiceSid = 24,
                WinBuiltinDomainSid = 25,
                WinBuiltinAdministratorsSid = 26,
                WinBuiltinUsersSid = 27,
                WinBuiltinGuestsSid = 28,
                WinBuiltinPowerUsersSid = 29,
                WinBuiltinAccountOperatorsSid = 30,
                WinBuiltinSystemOperatorsSid = 31,
                WinBuiltinPrintOperatorsSid = 32,
                WinBuiltinBackupOperatorsSid = 33,
                WinBuiltinReplicatorSid = 34,
                WinBuiltinPreWindows2000CompatibleAccessSid = 35,
                WinBuiltinRemoteDesktopUsersSid = 36,
                WinBuiltinNetworkConfigurationOperatorsSid = 37,
                WinAccountAdministratorSid = 38,
                WinAccountGuestSid = 39,
                WinAccountKrbtgtSid = 40,
                WinAccountDomainAdminsSid = 41,
                WinAccountDomainUsersSid = 42,
                WinAccountDomainGuestsSid = 43,
                WinAccountComputersSid = 44,
                WinAccountControllersSid = 45,
                WinAccountCertAdminsSid = 46,
                WinAccountSchemaAdminsSid = 47,
                WinAccountEnterpriseAdminsSid = 48,
                WinAccountPolicyAdminsSid = 49,
                WinAccountRasAndIasServersSid = 50,
                WinNTLMAuthenticationSid = 51,
                WinDigestAuthenticationSid = 52,
                WinSChannelAuthenticationSid = 53,
                WinThisOrganizationSid = 54,
                WinOtherOrganizationSid = 55,
                WinBuiltinIncomingForestTrustBuildersSid = 56,
                WinBuiltinPerfMonitoringUsersSid = 57,
                WinBuiltinPerfLoggingUsersSid = 58,
                WinBuiltinAuthorizationAccessSid = 59,
                WinBuiltinTerminalServerLicenseServersSid = 60,
                WinBuiltinDCOMUsersSid = 61,
                WinBuiltinIUsersSid = 62,
                WinIUserSid = 63,
                WinBuiltinCryptoOperatorsSid = 64,
                WinUntrustedLabelSid = 65,
                WinLowLabelSid = 66,
                WinMediumLabelSid = 67,
                WinHighLabelSid = 68,
                WinSystemLabelSid = 69,
                WinWriteRestrictedCodeSid = 70,
                WinCreatorOwnerRightsSid = 71,
                WinCacheablePrincipalsGroupSid = 72,
                WinNonCacheablePrincipalsGroupSid = 73,
                WinEnterpriseReadonlyControllersSid = 74,
                WinAccountReadonlyControllersSid = 75,
                WinBuiltinEventLogReadersGroup = 76,
                WinNewEnterpriseReadonlyControllersSid = 77,
                WinBuiltinCertSvcDComAccessGroup = 78,
                WinMediumPlusLabelSid = 79,
                WinLocalLogonSid = 80,
                WinConsoleLogonSid = 81,
                WinThisOrganizationCertificateSid = 82,
                WinApplicationPackageAuthoritySid = 83,
                WinBuiltinAnyPackageSid = 84,
                WinCapabilityInternetClientSid = 85,
                WinCapabilityInternetClientServerSid = 86,
                WinCapabilityPrivateNetworkClientServerSid = 87,
                WinCapabilityPicturesLibrarySid = 88,
                WinCapabilityVideosLibrarySid = 89,
                WinCapabilityMusicLibrarySid = 90,
                WinCapabilityDocumentsLibrarySid = 91,
                WinCapabilitySharedUserCertificatesSid = 92,
                WinCapabilityEnterpriseAuthenticationSid = 93,
                WinCapabilityRemovableStorageSid = 94,
                WinBuiltinRDSRemoteAccessServersSid = 95,
                WinBuiltinRDSEndpointServersSid = 96,
                WinBuiltinRDSManagementServersSid = 97,
                WinUserModeDriversSid = 98,
                WinBuiltinHyperVAdminsSid = 99,
                WinAccountCloneableControllersSid = 100,
                WinBuiltinAccessControlAssistanceOperatorsSid = 101,
                WinBuiltinRemoteManagementUsersSid = 102,
                WinAuthenticationAuthorityAssertedSid = 103,
                WinAuthenticationServiceAssertedSid = 104,
                WinLocalAccountSid = 105,
                WinLocalAccountAndAdministratorSid = 106,
                WinAccountProtectedUsersSid = 107,
                WinCapabilityAppointmentsSid = 108,
                WinCapabilityContactsSid = 109,
                WinAccountDefaultSystemManagedSid = 110,
                WinBuiltinDefaultSystemManagedGroupSid = 111,
                WinBuiltinStorageReplicaAdminsSid = 112,
                WinAccountKeyAdminsSid = 113,
                WinAccountEnterpriseKeyAdminsSid = 114,
                WinAuthenticationKeyTrustSid = 115,
                WinAuthenticationKeyPropertyMFASid = 116,
                WinAuthenticationKeyPropertyAttestationSid = 117,
                WinAuthenticationFreshKeyAuthSid = 118,
                WinBuiltinDeviceOwnersSid = 119,
            } WELL_KNOWN_SID_TYPE;

            typedef struct _ACL
            {
                BYTE AclRevision;
                BYTE Sbz1;
                WORD AclSize;
                WORD AceCount;
                WORD Sbz2;
            } ACL;
            typedef ACL* PACL;

            typedef struct _ACE_HEADER
            {
                BYTE AceType;
                BYTE AceFlags;
                WORD AceSize;
            } ACE_HEADER;
            typedef ACE_HEADER* PACE_HEADER;

            typedef struct _ACCESS_ALLOWED_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;
            } ACCESS_ALLOWED_ACE;

            typedef ACCESS_ALLOWED_ACE* PACCESS_ALLOWED_ACE;

            typedef struct _ACCESS_DENIED_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;
            } ACCESS_DENIED_ACE;
            typedef ACCESS_DENIED_ACE* PACCESS_DENIED_ACE;

            typedef struct _SYSTEM_AUDIT_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;
            } SYSTEM_AUDIT_ACE;
            typedef SYSTEM_AUDIT_ACE* PSYSTEM_AUDIT_ACE;

            typedef struct _SYSTEM_ALARM_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;
            } SYSTEM_ALARM_ACE;
            typedef SYSTEM_ALARM_ACE* PSYSTEM_ALARM_ACE;

            typedef struct _SYSTEM_RESOURCE_ATTRIBUTE_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;

            } SYSTEM_RESOURCE_ATTRIBUTE_ACE, *PSYSTEM_RESOURCE_ATTRIBUTE_ACE;

            typedef struct _SYSTEM_SCOPED_POLICY_ID_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;
            } SYSTEM_SCOPED_POLICY_ID_ACE, *PSYSTEM_SCOPED_POLICY_ID_ACE;

            typedef struct _SYSTEM_MANDATORY_LABEL_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;
            } SYSTEM_MANDATORY_LABEL_ACE, *PSYSTEM_MANDATORY_LABEL_ACE;

            typedef struct _SYSTEM_PROCESS_TRUST_LABEL_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;
            } SYSTEM_PROCESS_TRUST_LABEL_ACE, *PSYSTEM_PROCESS_TRUST_LABEL_ACE;

            typedef struct _SYSTEM_ACCESS_FILTER_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;

            } SYSTEM_ACCESS_FILTER_ACE, *PSYSTEM_ACCESS_FILTER_ACE;

            typedef struct _ACCESS_ALLOWED_OBJECT_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD Flags;
                GUID ObjectType;
                GUID InheritedObjectType;
                DWORD SidStart;
            } ACCESS_ALLOWED_OBJECT_ACE, *PACCESS_ALLOWED_OBJECT_ACE;

            typedef struct _ACCESS_DENIED_OBJECT_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD Flags;
                GUID ObjectType;
                GUID InheritedObjectType;
                DWORD SidStart;
            } ACCESS_DENIED_OBJECT_ACE, *PACCESS_DENIED_OBJECT_ACE;

            typedef struct _SYSTEM_AUDIT_OBJECT_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD Flags;
                GUID ObjectType;
                GUID InheritedObjectType;
                DWORD SidStart;
            } SYSTEM_AUDIT_OBJECT_ACE, *PSYSTEM_AUDIT_OBJECT_ACE;

            typedef struct _SYSTEM_ALARM_OBJECT_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD Flags;
                GUID ObjectType;
                GUID InheritedObjectType;
                DWORD SidStart;
            } SYSTEM_ALARM_OBJECT_ACE, *PSYSTEM_ALARM_OBJECT_ACE;

            typedef struct _ACCESS_ALLOWED_CALLBACK_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;

            } ACCESS_ALLOWED_CALLBACK_ACE, *PACCESS_ALLOWED_CALLBACK_ACE;

            typedef struct _ACCESS_DENIED_CALLBACK_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;

            } ACCESS_DENIED_CALLBACK_ACE, *PACCESS_DENIED_CALLBACK_ACE;

            typedef struct _SYSTEM_AUDIT_CALLBACK_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;

            } SYSTEM_AUDIT_CALLBACK_ACE, *PSYSTEM_AUDIT_CALLBACK_ACE;

            typedef struct _SYSTEM_ALARM_CALLBACK_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD SidStart;

            } SYSTEM_ALARM_CALLBACK_ACE, *PSYSTEM_ALARM_CALLBACK_ACE;

            typedef struct _ACCESS_ALLOWED_CALLBACK_OBJECT_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD Flags;
                GUID ObjectType;
                GUID InheritedObjectType;
                DWORD SidStart;

            } ACCESS_ALLOWED_CALLBACK_OBJECT_ACE, *PACCESS_ALLOWED_CALLBACK_OBJECT_ACE;

            typedef struct _ACCESS_DENIED_CALLBACK_OBJECT_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD Flags;
                GUID ObjectType;
                GUID InheritedObjectType;
                DWORD SidStart;

            } ACCESS_DENIED_CALLBACK_OBJECT_ACE, *PACCESS_DENIED_CALLBACK_OBJECT_ACE;

            typedef struct _SYSTEM_AUDIT_CALLBACK_OBJECT_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD Flags;
                GUID ObjectType;
                GUID InheritedObjectType;
                DWORD SidStart;

            } SYSTEM_AUDIT_CALLBACK_OBJECT_ACE, *PSYSTEM_AUDIT_CALLBACK_OBJECT_ACE;

            typedef struct _SYSTEM_ALARM_CALLBACK_OBJECT_ACE
            {
                ACE_HEADER Header;
                ACCESS_MASK Mask;
                DWORD Flags;
                GUID ObjectType;
                GUID InheritedObjectType;
                DWORD SidStart;

            } SYSTEM_ALARM_CALLBACK_OBJECT_ACE, *PSYSTEM_ALARM_CALLBACK_OBJECT_ACE;

            typedef enum _ACL_INFORMATION_CLASS
            {
                AclRevisionInformation = 1,
                AclSizeInformation
            } ACL_INFORMATION_CLASS;

            typedef struct _ACL_REVISION_INFORMATION
            {
                DWORD AclRevision;
            } ACL_REVISION_INFORMATION;
            typedef ACL_REVISION_INFORMATION* PACL_REVISION_INFORMATION;

            typedef struct _ACL_SIZE_INFORMATION
            {
                DWORD AceCount;
                DWORD AclBytesInUse;
                DWORD AclBytesFree;
            } ACL_SIZE_INFORMATION;
            typedef ACL_SIZE_INFORMATION* PACL_SIZE_INFORMATION;

            typedef WORD SECURITY_DESCRIPTOR_CONTROL, *PSECURITY_DESCRIPTOR_CONTROL;

            typedef struct _SECURITY_DESCRIPTOR_RELATIVE
            {
                BYTE Revision;
                BYTE Sbz1;
                SECURITY_DESCRIPTOR_CONTROL Control;
                DWORD Owner;
                DWORD Group;
                DWORD Sacl;
                DWORD Dacl;
            } SECURITY_DESCRIPTOR_RELATIVE, *PISECURITY_DESCRIPTOR_RELATIVE;

            typedef struct _SECURITY_DESCRIPTOR
            {
                BYTE Revision;
                BYTE Sbz1;
                SECURITY_DESCRIPTOR_CONTROL Control;
                PSID Owner;
                PSID Group;
                PACL Sacl;
                PACL Dacl;

            } SECURITY_DESCRIPTOR, *PISECURITY_DESCRIPTOR;

            typedef struct _SECURITY_OBJECT_AI_PARAMS
            {
                DWORD Size;
                DWORD ConstraintMask;
            } SECURITY_OBJECT_AI_PARAMS, *PSECURITY_OBJECT_AI_PARAMS;

            typedef struct _OBJECT_TYPE_LIST
            {
                WORD Level;
                WORD Sbz;
                GUID* ObjectType;
            } OBJECT_TYPE_LIST, *POBJECT_TYPE_LIST;

            typedef enum _AUDIT_EVENT_TYPE
            {
                AuditEventObjectAccess,
                AuditEventDirectoryServiceAccess
            } AUDIT_EVENT_TYPE,
            *PAUDIT_EVENT_TYPE;

            typedef struct _PRIVILEGE_SET
            {
                DWORD PrivilegeCount;
                DWORD Control;
                LUID_AND_ATTRIBUTES Privilege[1];
            } PRIVILEGE_SET, *PPRIVILEGE_SET;

            typedef enum _ACCESS_REASON_TYPE
            {

                AccessReasonNone = 0x00000000,

                AccessReasonAllowedAce = 0x00010000,
                AccessReasonDeniedAce = 0x00020000,

                AccessReasonAllowedParentAce = 0x00030000,
                AccessReasonDeniedParentAce = 0x00040000,

                AccessReasonNotGrantedByCape = 0x00050000,
                AccessReasonNotGrantedByParentCape = 0x00060000,

                AccessReasonNotGrantedToAppContainer = 0x00070000,

                AccessReasonMissingPrivilege = 0x00100000,
                AccessReasonFromPrivilege = 0x00200000,

                AccessReasonIntegrityLevel = 0x00300000,

                AccessReasonOwnership = 0x00400000,

                AccessReasonNullDacl = 0x00500000,
                AccessReasonEmptyDacl = 0x00600000,

                AccessReasonNoSD = 0x00700000,
                AccessReasonNoGrant = 0x00800000,

                AccessReasonTrustLabel = 0x00900000,

                AccessReasonFilterAce = 0x00a00000
            } ACCESS_REASON_TYPE;

            typedef DWORD ACCESS_REASON;

            typedef struct _ACCESS_REASONS
            {
                ACCESS_REASON Data[32];
            } ACCESS_REASONS, *PACCESS_REASONS;

            typedef struct _SE_SECURITY_DESCRIPTOR
            {
                DWORD Size;
                DWORD Flags;
                PSECURITY_DESCRIPTOR SecurityDescriptor;
            } SE_SECURITY_DESCRIPTOR, *PSE_SECURITY_DESCRIPTOR;

            typedef struct _SE_ACCESS_REQUEST
            {
                DWORD Size;
                PSE_SECURITY_DESCRIPTOR SeSecurityDescriptor;
                ACCESS_MASK DesiredAccess;
                ACCESS_MASK PreviouslyGrantedAccess;
                PSID PrincipalSelfSid;
                PGENERIC_MAPPING GenericMapping;
                DWORD ObjectTypeListCount;
                POBJECT_TYPE_LIST ObjectTypeList;
            } SE_ACCESS_REQUEST, *PSE_ACCESS_REQUEST;

            typedef struct _SE_ACCESS_REPLY
            {
                DWORD Size;
                DWORD ResultListCount;
                PACCESS_MASK GrantedAccess;
                PDWORD AccessStatus;
                PACCESS_REASONS AccessReason;
                PPRIVILEGE_SET* Privileges;
            } SE_ACCESS_REPLY, *PSE_ACCESS_REPLY;

            typedef enum _SECURITY_IMPERSONATION_LEVEL
            {
                SecurityAnonymous,
                SecurityIdentification,
                SecurityImpersonation,
                SecurityDelegation
            } SECURITY_IMPERSONATION_LEVEL,
            *PSECURITY_IMPERSONATION_LEVEL;

            typedef enum _TOKEN_TYPE
            {
                TokenPrimary = 1,
                TokenImpersonation
            } TOKEN_TYPE;
            typedef TOKEN_TYPE* PTOKEN_TYPE;

            typedef enum _TOKEN_ELEVATION_TYPE
            {
                TokenElevationTypeDefault = 1,
                TokenElevationTypeFull,
                TokenElevationTypeLimited,
            } TOKEN_ELEVATION_TYPE,
            *PTOKEN_ELEVATION_TYPE;

            typedef enum _TOKEN_INFORMATION_CLASS
            {
                TokenUser = 1,
                TokenGroups,
                TokenPrivileges,
                TokenOwner,
                TokenPrimaryGroup,
                TokenDefaultDacl,
                TokenSource,
                TokenType,
                TokenImpersonationLevel,
                TokenStatistics,
                TokenRestrictedSids,
                TokenSessionId,
                TokenGroupsAndPrivileges,
                TokenSessionReference,
                TokenSandBoxInert,
                TokenAuditPolicy,
                TokenOrigin,
                TokenElevationType,
                TokenLinkedToken,
                TokenElevation,
                TokenHasRestrictions,
                TokenAccessInformation,
                TokenVirtualizationAllowed,
                TokenVirtualizationEnabled,
                TokenIntegrityLevel,
                TokenUIAccess,
                TokenMandatoryPolicy,
                TokenLogonSid,
                TokenIsAppContainer,
                TokenCapabilities,
                TokenAppContainerSid,
                TokenAppContainerNumber,
                TokenUserClaimAttributes,
                TokenDeviceClaimAttributes,
                TokenRestrictedUserClaimAttributes,
                TokenRestrictedDeviceClaimAttributes,
                TokenDeviceGroups,
                TokenRestrictedDeviceGroups,
                TokenSecurityAttributes,
                TokenIsRestricted,
                TokenProcessTrustLevel,
                TokenPrivateNameSpace,
                TokenSingletonAttributes,
                TokenBnoIsolation,
                TokenChildProcessFlags,
                TokenIsLessPrivilegedAppContainer,
                MaxTokenInfoClass
            } TOKEN_INFORMATION_CLASS,
            *PTOKEN_INFORMATION_CLASS;

            typedef struct _TOKEN_USER
            {
                SID_AND_ATTRIBUTES User;
            } TOKEN_USER, *PTOKEN_USER;

            typedef struct _SE_TOKEN_USER
            {
                union
                {
                    TOKEN_USER TokenUser;
                    SID_AND_ATTRIBUTES User;
                };

                union
                {
                    SID Sid;
                    BYTE Buffer[(sizeof(SID) - sizeof(DWORD) + ((15) * sizeof(DWORD)))];
                };

            } SE_TOKEN_USER, PSE_TOKEN_USER;

            typedef struct _TOKEN_GROUPS
            {
                DWORD GroupCount;

                SID_AND_ATTRIBUTES Groups[1];
            } TOKEN_GROUPS, *PTOKEN_GROUPS;

            typedef struct _TOKEN_PRIVILEGES
            {
                DWORD PrivilegeCount;
                LUID_AND_ATTRIBUTES Privileges[1];
            } TOKEN_PRIVILEGES, *PTOKEN_PRIVILEGES;

            typedef struct _TOKEN_OWNER
            {
                PSID Owner;
            } TOKEN_OWNER, *PTOKEN_OWNER;

            typedef struct _TOKEN_PRIMARY_GROUP
            {
                PSID PrimaryGroup;
            } TOKEN_PRIMARY_GROUP, *PTOKEN_PRIMARY_GROUP;

            typedef struct _TOKEN_DEFAULT_DACL
            {
                PACL DefaultDacl;
            } TOKEN_DEFAULT_DACL, *PTOKEN_DEFAULT_DACL;

            typedef struct _TOKEN_USER_CLAIMS
            {
                PCLAIMS_BLOB UserClaims;
            } TOKEN_USER_CLAIMS, *PTOKEN_USER_CLAIMS;

            typedef struct _TOKEN_DEVICE_CLAIMS
            {
                PCLAIMS_BLOB DeviceClaims;
            } TOKEN_DEVICE_CLAIMS, *PTOKEN_DEVICE_CLAIMS;

            typedef struct _TOKEN_GROUPS_AND_PRIVILEGES
            {
                DWORD SidCount;
                DWORD SidLength;
                PSID_AND_ATTRIBUTES Sids;
                DWORD RestrictedSidCount;
                DWORD RestrictedSidLength;
                PSID_AND_ATTRIBUTES RestrictedSids;
                DWORD PrivilegeCount;
                DWORD PrivilegeLength;
                PLUID_AND_ATTRIBUTES Privileges;
                LUID AuthenticationId;
            } TOKEN_GROUPS_AND_PRIVILEGES, *PTOKEN_GROUPS_AND_PRIVILEGES;

            typedef struct _TOKEN_LINKED_TOKEN
            {
                HANDLE LinkedToken;
            } TOKEN_LINKED_TOKEN, *PTOKEN_LINKED_TOKEN;

            typedef struct _TOKEN_ELEVATION
            {
                DWORD TokenIsElevated;
            } TOKEN_ELEVATION, *PTOKEN_ELEVATION;

            typedef struct _TOKEN_MANDATORY_LABEL
            {
                SID_AND_ATTRIBUTES Label;
            } TOKEN_MANDATORY_LABEL, *PTOKEN_MANDATORY_LABEL;

            typedef struct _TOKEN_MANDATORY_POLICY
            {
                DWORD Policy;
            } TOKEN_MANDATORY_POLICY, *PTOKEN_MANDATORY_POLICY;

            typedef PVOID PSECURITY_ATTRIBUTES_OPAQUE;

            typedef struct _TOKEN_ACCESS_INFORMATION
            {
                PSID_AND_ATTRIBUTES_HASH SidHash;
                PSID_AND_ATTRIBUTES_HASH RestrictedSidHash;
                PTOKEN_PRIVILEGES Privileges;
                LUID AuthenticationId;
                TOKEN_TYPE TokenType;
                SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
                TOKEN_MANDATORY_POLICY MandatoryPolicy;
                DWORD Flags;
                DWORD AppContainerNumber;
                PSID PackageSid;
                PSID_AND_ATTRIBUTES_HASH CapabilitiesHash;
                PSID TrustLevelSid;
                PSECURITY_ATTRIBUTES_OPAQUE SecurityAttributes;
            } TOKEN_ACCESS_INFORMATION, *PTOKEN_ACCESS_INFORMATION;

            typedef struct _TOKEN_AUDIT_POLICY
            {
                BYTE PerUserPolicy[(((59)) >> 1) + 1];
            } TOKEN_AUDIT_POLICY, *PTOKEN_AUDIT_POLICY;

            typedef struct _TOKEN_SOURCE
            {
                CHAR SourceName[8];
                LUID SourceIdentifier;
            } TOKEN_SOURCE, *PTOKEN_SOURCE;

            typedef struct _TOKEN_STATISTICS
            {
                LUID TokenId;
                LUID AuthenticationId;
                LARGE_INTEGER ExpirationTime;
                TOKEN_TYPE TokenType;
                SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
                DWORD DynamicCharged;
                DWORD DynamicAvailable;
                DWORD GroupCount;
                DWORD PrivilegeCount;
                LUID ModifiedId;
            } TOKEN_STATISTICS, *PTOKEN_STATISTICS;

            typedef struct _TOKEN_CONTROL
            {
                LUID TokenId;
                LUID AuthenticationId;
                LUID ModifiedId;
                TOKEN_SOURCE TokenSource;
            } TOKEN_CONTROL, *PTOKEN_CONTROL;

            typedef struct _TOKEN_ORIGIN
            {
                LUID OriginatingLogonSession;
            } TOKEN_ORIGIN, *PTOKEN_ORIGIN;

            typedef enum _MANDATORY_LEVEL
            {
                MandatoryLevelUntrusted = 0,
                MandatoryLevelLow,
                MandatoryLevelMedium,
                MandatoryLevelHigh,
                MandatoryLevelSystem,
                MandatoryLevelSecureProcess,
                MandatoryLevelCount
            } MANDATORY_LEVEL,
            *PMANDATORY_LEVEL;

            typedef struct _TOKEN_APPCONTAINER_INFORMATION
            {
                PSID TokenAppContainer;
            } TOKEN_APPCONTAINER_INFORMATION, *PTOKEN_APPCONTAINER_INFORMATION;

            typedef struct _TOKEN_SID_INFORMATION
            {
                PSID Sid;
            } TOKEN_SID_INFORMATION, *PTOKEN_SID_INFORMATION;

            typedef struct _TOKEN_BNO_ISOLATION_INFORMATION
            {
                PWSTR IsolationPrefix;
                BOOLEAN IsolationEnabled;
            } TOKEN_BNO_ISOLATION_INFORMATION, *PTOKEN_BNO_ISOLATION_INFORMATION;

            typedef struct _CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE
            {
                DWORD64 Version;
                PWSTR Name;
            } CLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE, *PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE;

            typedef struct _CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE
            {
                PVOID pValue;
                DWORD ValueLength;
            } CLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE, *PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE;

            typedef struct _CLAIM_SECURITY_ATTRIBUTE_V1
            {
                PWSTR Name;

                WORD ValueType;

                WORD Reserved;

                DWORD Flags;

                DWORD ValueCount;

                union
                {
                    PLONG64 pInt64;
                    PDWORD64 pUint64;
                    PWSTR* ppString;
                    PCLAIM_SECURITY_ATTRIBUTE_FQBN_VALUE pFqbn;
                    PCLAIM_SECURITY_ATTRIBUTE_OCTET_STRING_VALUE pOctetString;
                } Values;
            } CLAIM_SECURITY_ATTRIBUTE_V1, *PCLAIM_SECURITY_ATTRIBUTE_V1;

            typedef struct _CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1
            {
                DWORD Name;

                WORD ValueType;

                WORD Reserved;

                DWORD Flags;

                DWORD ValueCount;

                union
                {
                    DWORD pInt64[1];
                    DWORD pUint64[1];
                    DWORD ppString[1];
                    DWORD pFqbn[1];
                    DWORD pOctetString[1];
                } Values;
            } CLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1, *PCLAIM_SECURITY_ATTRIBUTE_RELATIVE_V1;

            typedef struct _CLAIM_SECURITY_ATTRIBUTES_INFORMATION
            {
                WORD Version;

                WORD Reserved;

                DWORD AttributeCount;
                union
                {
                    PCLAIM_SECURITY_ATTRIBUTE_V1 pAttributeV1;
                } Attribute;
            } CLAIM_SECURITY_ATTRIBUTES_INFORMATION, *PCLAIM_SECURITY_ATTRIBUTES_INFORMATION;

            typedef BOOLEAN SECURITY_CONTEXT_TRACKING_MODE, *PSECURITY_CONTEXT_TRACKING_MODE;

            typedef struct _SECURITY_QUALITY_OF_SERVICE
            {
                DWORD Length;
                SECURITY_IMPERSONATION_LEVEL ImpersonationLevel;
                SECURITY_CONTEXT_TRACKING_MODE ContextTrackingMode;
                BOOLEAN EffectiveOnly;
            } SECURITY_QUALITY_OF_SERVICE, *PSECURITY_QUALITY_OF_SERVICE;

            typedef struct _SE_IMPERSONATION_STATE
            {
                PACCESS_TOKEN Token;
                BOOLEAN CopyOnOpen;
                BOOLEAN EffectiveOnly;
                SECURITY_IMPERSONATION_LEVEL Level;
            } SE_IMPERSONATION_STATE, *PSE_IMPERSONATION_STATE;

            typedef DWORD SECURITY_INFORMATION, *PSECURITY_INFORMATION;

            typedef BYTE SE_SIGNING_LEVEL, *PSE_SIGNING_LEVEL;

            typedef enum _SE_IMAGE_SIGNATURE_TYPE
            {
                SeImageSignatureNone = 0,
                SeImageSignatureEmbedded,
                SeImageSignatureCache,
                SeImageSignatureCatalogCached,
                SeImageSignatureCatalogNotCached,
                SeImageSignatureCatalogHint,
                SeImageSignaturePackageCatalog,
            } SE_IMAGE_SIGNATURE_TYPE,
            *PSE_IMAGE_SIGNATURE_TYPE;

            typedef enum _SE_LEARNING_MODE_DATA_TYPE
            {
                SeLearningModeInvalidType = 0,
                SeLearningModeSettings,
                SeLearningModeMax
            } SE_LEARNING_MODE_DATA_TYPE;

            typedef struct _SECURITY_CAPABILITIES
            {
                PSID AppContainerSid;
                PSID_AND_ATTRIBUTES Capabilities;
                DWORD CapabilityCount;
                DWORD Reserved;
            } SECURITY_CAPABILITIES, *PSECURITY_CAPABILITIES, *LPSECURITY_CAPABILITIES;

            typedef struct _JOB_SET_ARRAY
            {
                HANDLE JobHandle;
                DWORD MemberLevel;
                DWORD Flags;
            } JOB_SET_ARRAY, *PJOB_SET_ARRAY;

            typedef struct _EXCEPTION_REGISTRATION_RECORD
            {
                struct _EXCEPTION_REGISTRATION_RECORD* Next;
                PEXCEPTION_ROUTINE Handler;
            } EXCEPTION_REGISTRATION_RECORD;

            typedef EXCEPTION_REGISTRATION_RECORD* PEXCEPTION_REGISTRATION_RECORD;

            typedef struct _NT_TIB
            {
                struct _EXCEPTION_REGISTRATION_RECORD* ExceptionList;
                PVOID StackBase;
                PVOID StackLimit;
                PVOID SubSystemTib;

                union
                {
                    PVOID FiberData;
                    DWORD Version;
                };

                PVOID ArbitraryUserPointer;
                struct _NT_TIB* Self;
            } NT_TIB;
            typedef NT_TIB* PNT_TIB;

            typedef struct _NT_TIB32
            {
                DWORD ExceptionList;
                DWORD StackBase;
                DWORD StackLimit;
                DWORD SubSystemTib;

                union
                {
                    DWORD FiberData;
                    DWORD Version;
                };

                DWORD ArbitraryUserPointer;
                DWORD Self;
            } NT_TIB32, *PNT_TIB32;

            typedef struct _NT_TIB64
            {
                DWORD64 ExceptionList;
                DWORD64 StackBase;
                DWORD64 StackLimit;
                DWORD64 SubSystemTib;

                union
                {
                    DWORD64 FiberData;
                    DWORD Version;
                };

                DWORD64 ArbitraryUserPointer;
                DWORD64 Self;
            } NT_TIB64, *PNT_TIB64;

            typedef struct _UMS_CREATE_THREAD_ATTRIBUTES
            {
                DWORD UmsVersion;
                PVOID UmsContext;
                PVOID UmsCompletionList;
            } UMS_CREATE_THREAD_ATTRIBUTES, *PUMS_CREATE_THREAD_ATTRIBUTES;

            typedef struct _WOW64_ARCHITECTURE_INFORMATION
            {
                DWORD Machine : 16;
                DWORD KernelMode : 1;
                DWORD UserMode : 1;
                DWORD Native : 1;
                DWORD Process : 1;
                DWORD ReservedZero0 : 12;
            } WOW64_ARCHITECTURE_INFORMATION;

            typedef struct _QUOTA_LIMITS
            {
                SIZE_T PagedPoolLimit;
                SIZE_T NonPagedPoolLimit;
                SIZE_T MinimumWorkingSetSize;
                SIZE_T MaximumWorkingSetSize;
                SIZE_T PagefileLimit;
                LARGE_INTEGER TimeLimit;
            } QUOTA_LIMITS, *PQUOTA_LIMITS;

            typedef union _RATE_QUOTA_LIMIT
            {
                DWORD RateData;
                struct
                {
                    DWORD RatePercent : 7;
                    DWORD Reserved0 : 25;
                };
            } RATE_QUOTA_LIMIT, *PRATE_QUOTA_LIMIT;

            typedef struct _QUOTA_LIMITS_EX
            {
                SIZE_T PagedPoolLimit;
                SIZE_T NonPagedPoolLimit;
                SIZE_T MinimumWorkingSetSize;
                SIZE_T MaximumWorkingSetSize;
                SIZE_T PagefileLimit;
                LARGE_INTEGER TimeLimit;
                SIZE_T WorkingSetLimit;
                SIZE_T Reserved2;
                SIZE_T Reserved3;
                SIZE_T Reserved4;
                DWORD Flags;
                RATE_QUOTA_LIMIT CpuRateLimit;
            } QUOTA_LIMITS_EX, *PQUOTA_LIMITS_EX;

            typedef struct _IO_COUNTERS
            {
                ULONGLONG ReadOperationCount;
                ULONGLONG WriteOperationCount;
                ULONGLONG OtherOperationCount;
                ULONGLONG ReadTransferCount;
                ULONGLONG WriteTransferCount;
                ULONGLONG OtherTransferCount;
            } IO_COUNTERS;
            typedef IO_COUNTERS* PIO_COUNTERS;

            typedef enum _HARDWARE_COUNTER_TYPE
            {
                PMCCounter,
                MaxHardwareCounterType
            } HARDWARE_COUNTER_TYPE,
            *PHARDWARE_COUNTER_TYPE;
            typedef enum _PROCESS_MITIGATION_POLICY
            {
                ProcessDEPPolicy,
                ProcessASLRPolicy,
                ProcessDynamicCodePolicy,
                ProcessStrictHandleCheckPolicy,
                ProcessSystemCallDisablePolicy,
                ProcessMitigationOptionsMask,
                ProcessExtensionPointDisablePolicy,
                ProcessControlFlowGuardPolicy,
                ProcessSignaturePolicy,
                ProcessFontDisablePolicy,
                ProcessImageLoadPolicy,
                ProcessSystemCallFilterPolicy,
                ProcessPayloadRestrictionPolicy,
                ProcessChildProcessPolicy,
                ProcessSideChannelIsolationPolicy,
                MaxProcessMitigationPolicy
            } PROCESS_MITIGATION_POLICY,
            *PPROCESS_MITIGATION_POLICY;

            typedef struct _PROCESS_MITIGATION_ASLR_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD EnableBottomUpRandomization : 1;
                        DWORD EnableForceRelocateImages : 1;
                        DWORD EnableHighEntropy : 1;
                        DWORD DisallowStrippedImages : 1;
                        DWORD ReservedFlags : 28;
                    };
                };
            } PROCESS_MITIGATION_ASLR_POLICY, *PPROCESS_MITIGATION_ASLR_POLICY;

            typedef struct _PROCESS_MITIGATION_DEP_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD Enable : 1;
                        DWORD DisableAtlThunkEmulation : 1;
                        DWORD ReservedFlags : 30;
                    };
                };
                BOOLEAN Permanent;
            } PROCESS_MITIGATION_DEP_POLICY, *PPROCESS_MITIGATION_DEP_POLICY;

            typedef struct _PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD RaiseExceptionOnInvalidHandleReference : 1;
                        DWORD HandleExceptionsPermanentlyEnabled : 1;
                        DWORD ReservedFlags : 30;
                    };
                };
            } PROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY, *PPROCESS_MITIGATION_STRICT_HANDLE_CHECK_POLICY;

            typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD DisallowWin32kSystemCalls : 1;
                        DWORD AuditDisallowWin32kSystemCalls : 1;
                        DWORD ReservedFlags : 30;
                    };
                };
            } PROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_DISABLE_POLICY;

            typedef struct _PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD DisableExtensionPoints : 1;
                        DWORD ReservedFlags : 31;
                    };
                };
            } PROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY, *PPROCESS_MITIGATION_EXTENSION_POINT_DISABLE_POLICY;

            typedef struct _PROCESS_MITIGATION_DYNAMIC_CODE_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD ProhibitDynamicCode : 1;
                        DWORD AllowThreadOptOut : 1;
                        DWORD AllowRemoteDowngrade : 1;
                        DWORD AuditProhibitDynamicCode : 1;
                        DWORD ReservedFlags : 28;
                    };
                };
            } PROCESS_MITIGATION_DYNAMIC_CODE_POLICY, *PPROCESS_MITIGATION_DYNAMIC_CODE_POLICY;

            typedef struct _PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD EnableControlFlowGuard : 1;
                        DWORD EnableExportSuppression : 1;
                        DWORD StrictMode : 1;
                        DWORD ReservedFlags : 29;
                    };
                };
            } PROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY, *PPROCESS_MITIGATION_CONTROL_FLOW_GUARD_POLICY;

            typedef struct _PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD MicrosoftSignedOnly : 1;
                        DWORD StoreSignedOnly : 1;
                        DWORD MitigationOptIn : 1;
                        DWORD AuditMicrosoftSignedOnly : 1;
                        DWORD AuditStoreSignedOnly : 1;
                        DWORD ReservedFlags : 27;
                    };
                };
            } PROCESS_MITIGATION_BINARY_SIGNATURE_POLICY, *PPROCESS_MITIGATION_BINARY_SIGNATURE_POLICY;

            typedef struct _PROCESS_MITIGATION_FONT_DISABLE_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD DisableNonSystemFonts : 1;
                        DWORD AuditNonSystemFontLoading : 1;
                        DWORD ReservedFlags : 30;
                    };
                };
            } PROCESS_MITIGATION_FONT_DISABLE_POLICY, *PPROCESS_MITIGATION_FONT_DISABLE_POLICY;

            typedef struct _PROCESS_MITIGATION_IMAGE_LOAD_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD NoRemoteImages : 1;
                        DWORD NoLowMandatoryLabelImages : 1;
                        DWORD PreferSystem32Images : 1;
                        DWORD AuditNoRemoteImages : 1;
                        DWORD AuditNoLowMandatoryLabelImages : 1;
                        DWORD ReservedFlags : 27;
                    };
                };
            } PROCESS_MITIGATION_IMAGE_LOAD_POLICY, *PPROCESS_MITIGATION_IMAGE_LOAD_POLICY;

            typedef struct _PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD FilterId : 4;
                        DWORD ReservedFlags : 28;
                    };
                };
            } PROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY, *PPROCESS_MITIGATION_SYSTEM_CALL_FILTER_POLICY;

            typedef struct _PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD EnableExportAddressFilter : 1;
                        DWORD AuditExportAddressFilter : 1;

                        DWORD EnableExportAddressFilterPlus : 1;
                        DWORD AuditExportAddressFilterPlus : 1;

                        DWORD EnableImportAddressFilter : 1;
                        DWORD AuditImportAddressFilter : 1;

                        DWORD EnableRopStackPivot : 1;
                        DWORD AuditRopStackPivot : 1;

                        DWORD EnableRopCallerCheck : 1;
                        DWORD AuditRopCallerCheck : 1;

                        DWORD EnableRopSimExec : 1;
                        DWORD AuditRopSimExec : 1;

                        DWORD ReservedFlags : 20;
                    };
                };
            } PROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY, *PPROCESS_MITIGATION_PAYLOAD_RESTRICTION_POLICY;

            typedef struct _PROCESS_MITIGATION_CHILD_PROCESS_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD NoChildProcessCreation : 1;
                        DWORD AuditNoChildProcessCreation : 1;
                        DWORD AllowSecureProcessCreation : 1;
                        DWORD ReservedFlags : 29;
                    };
                };
            } PROCESS_MITIGATION_CHILD_PROCESS_POLICY, *PPROCESS_MITIGATION_CHILD_PROCESS_POLICY;

            typedef struct _PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY
            {
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD SmtBranchTargetIsolation : 1;

                        DWORD IsolateSecurityDomain : 1;

                        DWORD DisablePageCombine : 1;

                        DWORD SpeculativeStoreBypassDisable : 1;

                        DWORD ReservedFlags : 28;
                    };
                };
            } PROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY, *PPROCESS_MITIGATION_SIDE_CHANNEL_ISOLATION_POLICY;

            typedef struct _JOBOBJECT_BASIC_ACCOUNTING_INFORMATION
            {
                LARGE_INTEGER TotalUserTime;
                LARGE_INTEGER TotalKernelTime;
                LARGE_INTEGER ThisPeriodTotalUserTime;
                LARGE_INTEGER ThisPeriodTotalKernelTime;
                DWORD TotalPageFaultCount;
                DWORD TotalProcesses;
                DWORD ActiveProcesses;
                DWORD TotalTerminatedProcesses;
            } JOBOBJECT_BASIC_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_ACCOUNTING_INFORMATION;

            typedef struct _JOBOBJECT_BASIC_LIMIT_INFORMATION
            {
                LARGE_INTEGER PerProcessUserTimeLimit;
                LARGE_INTEGER PerJobUserTimeLimit;
                DWORD LimitFlags;
                SIZE_T MinimumWorkingSetSize;
                SIZE_T MaximumWorkingSetSize;
                DWORD ActiveProcessLimit;
                ULONG_PTR Affinity;
                DWORD PriorityClass;
                DWORD SchedulingClass;
            } JOBOBJECT_BASIC_LIMIT_INFORMATION, *PJOBOBJECT_BASIC_LIMIT_INFORMATION;

            typedef struct _JOBOBJECT_EXTENDED_LIMIT_INFORMATION
            {
                JOBOBJECT_BASIC_LIMIT_INFORMATION BasicLimitInformation;
                IO_COUNTERS IoInfo;
                SIZE_T ProcessMemoryLimit;
                SIZE_T JobMemoryLimit;
                SIZE_T PeakProcessMemoryUsed;
                SIZE_T PeakJobMemoryUsed;
            } JOBOBJECT_EXTENDED_LIMIT_INFORMATION, *PJOBOBJECT_EXTENDED_LIMIT_INFORMATION;

            typedef struct _JOBOBJECT_BASIC_PROCESS_ID_LIST
            {
                DWORD NumberOfAssignedProcesses;
                DWORD NumberOfProcessIdsInList;
                ULONG_PTR ProcessIdList[1];
            } JOBOBJECT_BASIC_PROCESS_ID_LIST, *PJOBOBJECT_BASIC_PROCESS_ID_LIST;

            typedef struct _JOBOBJECT_BASIC_UI_RESTRICTIONS
            {
                DWORD UIRestrictionsClass;
            } JOBOBJECT_BASIC_UI_RESTRICTIONS, *PJOBOBJECT_BASIC_UI_RESTRICTIONS;

            typedef struct _JOBOBJECT_SECURITY_LIMIT_INFORMATION
            {
                DWORD SecurityLimitFlags;
                HANDLE JobToken;
                PTOKEN_GROUPS SidsToDisable;
                PTOKEN_PRIVILEGES PrivilegesToDelete;
                PTOKEN_GROUPS RestrictedSids;
            } JOBOBJECT_SECURITY_LIMIT_INFORMATION, *PJOBOBJECT_SECURITY_LIMIT_INFORMATION;

            typedef struct _JOBOBJECT_END_OF_JOB_TIME_INFORMATION
            {
                DWORD EndOfJobTimeAction;
            } JOBOBJECT_END_OF_JOB_TIME_INFORMATION, *PJOBOBJECT_END_OF_JOB_TIME_INFORMATION;

            typedef struct _JOBOBJECT_ASSOCIATE_COMPLETION_PORT
            {
                PVOID CompletionKey;
                HANDLE CompletionPort;
            } JOBOBJECT_ASSOCIATE_COMPLETION_PORT, *PJOBOBJECT_ASSOCIATE_COMPLETION_PORT;

            typedef struct _JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION
            {
                JOBOBJECT_BASIC_ACCOUNTING_INFORMATION BasicInfo;
                IO_COUNTERS IoInfo;
            } JOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION, *PJOBOBJECT_BASIC_AND_IO_ACCOUNTING_INFORMATION;

            typedef struct _JOBOBJECT_JOBSET_INFORMATION
            {
                DWORD MemberLevel;
            } JOBOBJECT_JOBSET_INFORMATION, *PJOBOBJECT_JOBSET_INFORMATION;

            typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE
            {
                ToleranceLow = 1,
                ToleranceMedium,
                ToleranceHigh
            } JOBOBJECT_RATE_CONTROL_TOLERANCE,
            *PJOBOBJECT_RATE_CONTROL_TOLERANCE;

            typedef enum _JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
            {
                ToleranceIntervalShort = 1,
                ToleranceIntervalMedium,
                ToleranceIntervalLong
            } JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL,
            *PJOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL;

            typedef struct _JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION
            {
                DWORD64 IoReadBytesLimit;
                DWORD64 IoWriteBytesLimit;
                LARGE_INTEGER PerJobUserTimeLimit;
                DWORD64 JobMemoryLimit;
                JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
                JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
                DWORD LimitFlags;
            } JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION, *PJOBOBJECT_NOTIFICATION_LIMIT_INFORMATION;

            typedef struct JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2
            {
                DWORD64 IoReadBytesLimit;
                DWORD64 IoWriteBytesLimit;
                LARGE_INTEGER PerJobUserTimeLimit;
                union
                {
                    DWORD64 JobHighMemoryLimit;
                    DWORD64 JobMemoryLimit;
                };

                union
                {
                    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
                    JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
                };

                union
                {
                    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL RateControlToleranceInterval;
                    JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL
                    CpuRateControlToleranceInterval;
                };

                DWORD LimitFlags;
                JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
                DWORD64 JobLowMemoryLimit;
                JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL IoRateControlToleranceInterval;
                JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
                JOBOBJECT_RATE_CONTROL_TOLERANCE_INTERVAL NetRateControlToleranceInterval;
            } JOBOBJECT_NOTIFICATION_LIMIT_INFORMATION_2;

            typedef struct _JOBOBJECT_LIMIT_VIOLATION_INFORMATION
            {
                DWORD LimitFlags;
                DWORD ViolationLimitFlags;
                DWORD64 IoReadBytes;
                DWORD64 IoReadBytesLimit;
                DWORD64 IoWriteBytes;
                DWORD64 IoWriteBytesLimit;
                LARGE_INTEGER PerJobUserTime;
                LARGE_INTEGER PerJobUserTimeLimit;
                DWORD64 JobMemory;
                DWORD64 JobMemoryLimit;
                JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
                JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
            } JOBOBJECT_LIMIT_VIOLATION_INFORMATION, *PJOBOBJECT_LIMIT_VIOLATION_INFORMATION;

            typedef struct JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2
            {
                DWORD LimitFlags;
                DWORD ViolationLimitFlags;
                DWORD64 IoReadBytes;
                DWORD64 IoReadBytesLimit;
                DWORD64 IoWriteBytes;
                DWORD64 IoWriteBytesLimit;
                LARGE_INTEGER PerJobUserTime;
                LARGE_INTEGER PerJobUserTimeLimit;
                DWORD64 JobMemory;
                union
                {
                    DWORD64 JobHighMemoryLimit;
                    DWORD64 JobMemoryLimit;
                };

                union
                {
                    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlTolerance;
                    JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlTolerance;
                };

                union
                {
                    JOBOBJECT_RATE_CONTROL_TOLERANCE RateControlToleranceLimit;
                    JOBOBJECT_RATE_CONTROL_TOLERANCE CpuRateControlToleranceLimit;
                };

                DWORD64 JobLowMemoryLimit;
                JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlTolerance;
                JOBOBJECT_RATE_CONTROL_TOLERANCE IoRateControlToleranceLimit;
                JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlTolerance;
                JOBOBJECT_RATE_CONTROL_TOLERANCE NetRateControlToleranceLimit;
            } JOBOBJECT_LIMIT_VIOLATION_INFORMATION_2;

            typedef struct _JOBOBJECT_CPU_RATE_CONTROL_INFORMATION
            {
                DWORD ControlFlags;
                union
                {
                    DWORD CpuRate;
                    DWORD Weight;
                    struct
                    {
                        WORD MinRate;
                        WORD MaxRate;
                    };
                };
            } JOBOBJECT_CPU_RATE_CONTROL_INFORMATION, *PJOBOBJECT_CPU_RATE_CONTROL_INFORMATION;

            typedef enum JOB_OBJECT_NET_RATE_CONTROL_FLAGS
            {
                JOB_OBJECT_NET_RATE_CONTROL_ENABLE = 0x1,
                JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH = 0x2,
                JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG = 0x4,
                JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS = 0x7
            } JOB_OBJECT_NET_RATE_CONTROL_FLAGS;

            extern "C++"
            {
                inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS
                operator|(JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw()
                {
                    return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(
                    ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a)
                    | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b));
                }
                inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS&
                operator|=(JOB_OBJECT_NET_RATE_CONTROL_FLAGS& a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw()
                {
                    return (
                    JOB_OBJECT_NET_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type&)a)
                                                        |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b));
                }
                inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS
                operator&(JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw()
                {
                    return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(
                    ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a)
                    & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b));
                }
                inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS&
                operator&=(JOB_OBJECT_NET_RATE_CONTROL_FLAGS& a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw()
                {
                    return (
                    JOB_OBJECT_NET_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type&)a)
                                                        &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b));
                }
                inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS operator~(JOB_OBJECT_NET_RATE_CONTROL_FLAGS a) throw()
                {
                    return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(
                    ~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a));
                }
                inline constexpr JOB_OBJECT_NET_RATE_CONTROL_FLAGS
                operator^(JOB_OBJECT_NET_RATE_CONTROL_FLAGS a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw()
                {
                    return JOB_OBJECT_NET_RATE_CONTROL_FLAGS(
                    ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)a)
                    ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b));
                }
                inline JOB_OBJECT_NET_RATE_CONTROL_FLAGS&
                operator^=(JOB_OBJECT_NET_RATE_CONTROL_FLAGS& a, JOB_OBJECT_NET_RATE_CONTROL_FLAGS b) throw()
                {
                    return (
                    JOB_OBJECT_NET_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type&)a)
                                                        ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_NET_RATE_CONTROL_FLAGS>::type)b));
                }
            }
            typedef char __C_ASSERT__[(JOB_OBJECT_NET_RATE_CONTROL_VALID_FLAGS == (JOB_OBJECT_NET_RATE_CONTROL_ENABLE + JOB_OBJECT_NET_RATE_CONTROL_MAX_BANDWIDTH + JOB_OBJECT_NET_RATE_CONTROL_DSCP_TAG)) ?
                                      1 :
                                      -1];

            typedef struct JOBOBJECT_NET_RATE_CONTROL_INFORMATION
            {
                DWORD64 MaxBandwidth;
                JOB_OBJECT_NET_RATE_CONTROL_FLAGS ControlFlags;
                BYTE DscpTag;
            } JOBOBJECT_NET_RATE_CONTROL_INFORMATION;

            typedef enum JOB_OBJECT_IO_RATE_CONTROL_FLAGS
            {
                JOB_OBJECT_IO_RATE_CONTROL_ENABLE = 0x1,
                JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME = 0x2,
                JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL = 0x4,
                JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP = 0x8,
                JOB_OBJECT_IO_RATE_CONTROL_VALID_FLAGS = JOB_OBJECT_IO_RATE_CONTROL_ENABLE | JOB_OBJECT_IO_RATE_CONTROL_STANDALONE_VOLUME
                                                         | JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ALL | JOB_OBJECT_IO_RATE_CONTROL_FORCE_UNIT_ACCESS_ON_SOFT_CAP
            } JOB_OBJECT_IO_RATE_CONTROL_FLAGS;

            extern "C++"
            {
                inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS
                operator|(JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw()
                {
                    return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(
                    ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a)
                    | ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b));
                }
                inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS&
                operator|=(JOB_OBJECT_IO_RATE_CONTROL_FLAGS& a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw()
                {
                    return (
                    JOB_OBJECT_IO_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type&)a)
                                                       |= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b));
                }
                inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS
                operator&(JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw()
                {
                    return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(
                    ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a)
                    & ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b));
                }
                inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS&
                operator&=(JOB_OBJECT_IO_RATE_CONTROL_FLAGS& a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw()
                {
                    return (
                    JOB_OBJECT_IO_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type&)a)
                                                       &= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b));
                }
                inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS operator~(JOB_OBJECT_IO_RATE_CONTROL_FLAGS a) throw()
                {
                    return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(~((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a));
                }
                inline constexpr JOB_OBJECT_IO_RATE_CONTROL_FLAGS
                operator^(JOB_OBJECT_IO_RATE_CONTROL_FLAGS a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw()
                {
                    return JOB_OBJECT_IO_RATE_CONTROL_FLAGS(
                    ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)a)
                    ^ ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b));
                }
                inline JOB_OBJECT_IO_RATE_CONTROL_FLAGS&
                operator^=(JOB_OBJECT_IO_RATE_CONTROL_FLAGS& a, JOB_OBJECT_IO_RATE_CONTROL_FLAGS b) throw()
                {
                    return (
                    JOB_OBJECT_IO_RATE_CONTROL_FLAGS&)(((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type&)a)
                                                       ^= ((_ENUM_FLAG_SIZED_INTEGER<JOB_OBJECT_IO_RATE_CONTROL_FLAGS>::type)b));
                }
            }

            typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE
            {
                LONG64 MaxIops;
                LONG64 MaxBandwidth;
                LONG64 ReservationIops;
                PWSTR VolumeName;
                DWORD BaseIoSize;
                JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
                WORD VolumeNameLength;
            } JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE;

            typedef JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V1;

            typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2
            {
                LONG64 MaxIops;
                LONG64 MaxBandwidth;
                LONG64 ReservationIops;
                PWSTR VolumeName;
                DWORD BaseIoSize;
                JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
                WORD VolumeNameLength;
                LONG64 CriticalReservationIops;
                LONG64 ReservationBandwidth;
                LONG64 CriticalReservationBandwidth;
                LONG64 MaxTimePercent;
                LONG64 ReservationTimePercent;
                LONG64 CriticalReservationTimePercent;
            } JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V2;

            typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3
            {
                LONG64 MaxIops;
                LONG64 MaxBandwidth;
                LONG64 ReservationIops;
                PWSTR VolumeName;
                DWORD BaseIoSize;
                JOB_OBJECT_IO_RATE_CONTROL_FLAGS ControlFlags;
                WORD VolumeNameLength;
                LONG64 CriticalReservationIops;
                LONG64 ReservationBandwidth;
                LONG64 CriticalReservationBandwidth;
                LONG64 MaxTimePercent;
                LONG64 ReservationTimePercent;
                LONG64 CriticalReservationTimePercent;
                LONG64 SoftMaxIops;
                LONG64 SoftMaxBandwidth;
                LONG64 SoftMaxTimePercent;
                LONG64 LimitExcessNotifyIops;
                LONG64 LimitExcessNotifyBandwidth;
                LONG64 LimitExcessNotifyTimePercent;
            } JOBOBJECT_IO_RATE_CONTROL_INFORMATION_NATIVE_V3;

            typedef enum JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS
            {
                JOBOBJECT_IO_ATTRIBUTION_CONTROL_ENABLE = 0x1,
                JOBOBJECT_IO_ATTRIBUTION_CONTROL_DISABLE = 0x2,
                JOBOBJECT_IO_ATTRIBUTION_CONTROL_VALID_FLAGS = 0x3
            } JOBOBJECT_IO_ATTRIBUTION_CONTROL_FLAGS;

            typedef struct _JOBOBJECT_IO_ATTRIBUTION_STATS
            {
                ULONG_PTR IoCount;
                ULONGLONG TotalNonOverlappedQueueTime;
                ULONGLONG TotalNonOverlappedServiceTime;
                ULONGLONG TotalSize;

            } JOBOBJECT_IO_ATTRIBUTION_STATS, *PJOBOBJECT_IO_ATTRIBUTION_STATS;

            typedef struct _JOBOBJECT_IO_ATTRIBUTION_INFORMATION
            {
                DWORD ControlFlags;

                JOBOBJECT_IO_ATTRIBUTION_STATS ReadStats;
                JOBOBJECT_IO_ATTRIBUTION_STATS WriteStats;

            } JOBOBJECT_IO_ATTRIBUTION_INFORMATION, *PJOBOBJECT_IO_ATTRIBUTION_INFORMATION;

            typedef enum _JOBOBJECTINFOCLASS
            {
                JobObjectBasicAccountingInformation = 1,
                JobObjectBasicLimitInformation,
                JobObjectBasicProcessIdList,
                JobObjectBasicUIRestrictions,
                JobObjectSecurityLimitInformation,
                JobObjectEndOfJobTimeInformation,
                JobObjectAssociateCompletionPortInformation,
                JobObjectBasicAndIoAccountingInformation,
                JobObjectExtendedLimitInformation,
                JobObjectJobSetInformation,
                JobObjectGroupInformation,
                JobObjectNotificationLimitInformation,
                JobObjectLimitViolationInformation,
                JobObjectGroupInformationEx,
                JobObjectCpuRateControlInformation,
                JobObjectCompletionFilter,
                JobObjectCompletionCounter,
                JobObjectReserved1Information = 18,
                JobObjectReserved2Information,
                JobObjectReserved3Information,
                JobObjectReserved4Information,
                JobObjectReserved5Information,
                JobObjectReserved6Information,
                JobObjectReserved7Information,
                JobObjectReserved8Information,
                JobObjectReserved9Information,
                JobObjectReserved10Information,
                JobObjectReserved11Information,
                JobObjectReserved12Information,
                JobObjectReserved13Information,
                JobObjectReserved14Information = 31,
                JobObjectNetRateControlInformation,
                JobObjectNotificationLimitInformation2,
                JobObjectLimitViolationInformation2,
                JobObjectCreateSilo,
                JobObjectSiloBasicInformation,
                JobObjectReserved15Information = 37,
                JobObjectReserved16Information = 38,
                JobObjectReserved17Information = 39,
                JobObjectReserved18Information = 40,
                JobObjectReserved19Information = 41,
                JobObjectReserved20Information = 42,
                JobObjectReserved21Information = 43,
                JobObjectReserved22Information = 44,
                JobObjectReserved23Information = 45,
                JobObjectReserved24Information = 46,
                JobObjectReserved25Information = 47,
                MaxJobObjectInfoClass
            } JOBOBJECTINFOCLASS;

            typedef struct _SILOOBJECT_BASIC_INFORMATION
            {
                DWORD SiloId;
                DWORD SiloParentId;
                DWORD NumberOfProcesses;
                BOOLEAN IsInServerSilo;
                BYTE Reserved[3];
            } SILOOBJECT_BASIC_INFORMATION, *PSILOOBJECT_BASIC_INFORMATION;

            typedef enum _SERVERSILO_STATE
            {
                SERVERSILO_INITING = 0,
                SERVERSILO_STARTED,
                SERVERSILO_SHUTTING_DOWN,
                SERVERSILO_TERMINATING,
                SERVERSILO_TERMINATED,
            } SERVERSILO_STATE,
            *PSERVERSILO_STATE;

            typedef struct _SERVERSILO_BASIC_INFORMATION
            {
                DWORD ServiceSessionId;
                SERVERSILO_STATE State;
                DWORD ExitStatus;
            } SERVERSILO_BASIC_INFORMATION, *PSERVERSILO_BASIC_INFORMATION;

            typedef enum _FIRMWARE_TYPE
            {
                FirmwareTypeUnknown,
                FirmwareTypeBios,
                FirmwareTypeUefi,
                FirmwareTypeMax
            } FIRMWARE_TYPE,
            *PFIRMWARE_TYPE;

            typedef enum _LOGICAL_PROCESSOR_RELATIONSHIP
            {
                RelationProcessorCore,
                RelationNumaNode,
                RelationCache,
                RelationProcessorPackage,
                RelationGroup,
                RelationAll = 0xffff
            } LOGICAL_PROCESSOR_RELATIONSHIP;

            typedef enum _PROCESSOR_CACHE_TYPE
            {
                CacheUnified,
                CacheInstruction,
                CacheData,
                CacheTrace
            } PROCESSOR_CACHE_TYPE;

            typedef struct _CACHE_DESCRIPTOR
            {
                BYTE Level;
                BYTE Associativity;
                WORD LineSize;
                DWORD Size;
                PROCESSOR_CACHE_TYPE Type;
            } CACHE_DESCRIPTOR, *PCACHE_DESCRIPTOR;

            typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION
            {
                ULONG_PTR ProcessorMask;
                LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
                union
                {
                    struct
                    {
                        BYTE Flags;
                    } ProcessorCore;
                    struct
                    {
                        DWORD NodeNumber;
                    } NumaNode;
                    CACHE_DESCRIPTOR Cache;
                    ULONGLONG Reserved[2];
                };
            } SYSTEM_LOGICAL_PROCESSOR_INFORMATION, *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION;

            typedef struct _PROCESSOR_RELATIONSHIP
            {
                BYTE Flags;
                BYTE EfficiencyClass;
                BYTE Reserved[20];
                WORD GroupCount;
                GROUP_AFFINITY GroupMask[1];
            } PROCESSOR_RELATIONSHIP, *PPROCESSOR_RELATIONSHIP;

            typedef struct _NUMA_NODE_RELATIONSHIP
            {
                DWORD NodeNumber;
                BYTE Reserved[20];
                GROUP_AFFINITY GroupMask;
            } NUMA_NODE_RELATIONSHIP, *PNUMA_NODE_RELATIONSHIP;

            typedef struct _CACHE_RELATIONSHIP
            {
                BYTE Level;
                BYTE Associativity;
                WORD LineSize;
                DWORD CacheSize;
                PROCESSOR_CACHE_TYPE Type;
                BYTE Reserved[20];
                GROUP_AFFINITY GroupMask;
            } CACHE_RELATIONSHIP, *PCACHE_RELATIONSHIP;

            typedef struct _PROCESSOR_GROUP_INFO
            {
                BYTE MaximumProcessorCount;
                BYTE ActiveProcessorCount;
                BYTE Reserved[38];
                KAFFINITY ActiveProcessorMask;
            } PROCESSOR_GROUP_INFO, *PPROCESSOR_GROUP_INFO;

            typedef struct _GROUP_RELATIONSHIP
            {
                WORD MaximumGroupCount;
                WORD ActiveGroupCount;
                BYTE Reserved[20];
                PROCESSOR_GROUP_INFO GroupInfo[1];
            } GROUP_RELATIONSHIP, *PGROUP_RELATIONSHIP;

            struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX
            {
                LOGICAL_PROCESSOR_RELATIONSHIP Relationship;
                DWORD Size;
                union
                {
                    PROCESSOR_RELATIONSHIP Processor;
                    NUMA_NODE_RELATIONSHIP NumaNode;
                    CACHE_RELATIONSHIP Cache;
                    GROUP_RELATIONSHIP Group;
                };
            };

            typedef struct _SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX SYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX,
            *PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX;

            typedef enum _CPU_SET_INFORMATION_TYPE
            {
                CpuSetInformation
            } CPU_SET_INFORMATION_TYPE,
            *PCPU_SET_INFORMATION_TYPE;

            struct _SYSTEM_CPU_SET_INFORMATION
            {
                DWORD Size;
                CPU_SET_INFORMATION_TYPE Type;
                union
                {
                    struct
                    {
                        DWORD Id;
                        WORD Group;
                        BYTE LogicalProcessorIndex;
                        BYTE CoreIndex;
                        BYTE LastLevelCacheIndex;
                        BYTE NumaNodeIndex;
                        BYTE EfficiencyClass;
                        union
                        {
                            BYTE AllFlags;
                            struct
                            {
                                BYTE Parked : 1;
                                BYTE Allocated : 1;
                                BYTE AllocatedToTargetProcess : 1;
                                BYTE RealTime : 1;
                                BYTE ReservedFlags : 4;
                            };
                        };

                        union
                        {
                            DWORD Reserved;
                            BYTE SchedulingClass;
                        };

                        DWORD64 AllocationTag;
                    } CpuSet;
                };
            };

            typedef struct _SYSTEM_CPU_SET_INFORMATION SYSTEM_CPU_SET_INFORMATION, *PSYSTEM_CPU_SET_INFORMATION;

            typedef struct _SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION
            {
                DWORD64 CycleTime;
            } SYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION, *PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION;

            typedef struct _XSTATE_FEATURE
            {
                DWORD Offset;
                DWORD Size;
            } XSTATE_FEATURE, *PXSTATE_FEATURE;

            typedef struct _XSTATE_CONFIGURATION
            {
                DWORD64 EnabledFeatures;

                DWORD64 EnabledVolatileFeatures;

                DWORD Size;

                union
                {
                    DWORD ControlFlags;
                    struct
                    {
                        DWORD OptimizedSave : 1;
                        DWORD CompactionEnabled : 1;
                    };
                };

                XSTATE_FEATURE Features[(64)];

                DWORD64 EnabledSupervisorFeatures;

                DWORD64 AlignedFeatures;

                DWORD AllFeatureSize;

                DWORD AllFeatures[(64)];

                DWORD64 EnabledUserVisibleSupervisorFeatures;

            } XSTATE_CONFIGURATION, *PXSTATE_CONFIGURATION;

            typedef struct _MEMORY_BASIC_INFORMATION
            {
                PVOID BaseAddress;
                PVOID AllocationBase;
                DWORD AllocationProtect;
                SIZE_T RegionSize;
                DWORD State;
                DWORD Protect;
                DWORD Type;
            } MEMORY_BASIC_INFORMATION, *PMEMORY_BASIC_INFORMATION;

            typedef struct _MEMORY_BASIC_INFORMATION32
            {
                DWORD BaseAddress;
                DWORD AllocationBase;
                DWORD AllocationProtect;
                DWORD RegionSize;
                DWORD State;
                DWORD Protect;
                DWORD Type;
            } MEMORY_BASIC_INFORMATION32, *PMEMORY_BASIC_INFORMATION32;

            typedef struct __declspec(align(16)) _MEMORY_BASIC_INFORMATION64
            {
                ULONGLONG BaseAddress;
                ULONGLONG AllocationBase;
                DWORD AllocationProtect;
                DWORD __alignment1;
                ULONGLONG RegionSize;
                DWORD State;
                DWORD Protect;
                DWORD Type;
                DWORD __alignment2;
            } MEMORY_BASIC_INFORMATION64, *PMEMORY_BASIC_INFORMATION64;

            typedef struct _CFG_CALL_TARGET_INFO
            {
                ULONG_PTR Offset;
                ULONG_PTR Flags;
            } CFG_CALL_TARGET_INFO, *PCFG_CALL_TARGET_INFO;

            typedef struct _MEM_ADDRESS_REQUIREMENTS
            {
                PVOID LowestStartingAddress;
                PVOID HighestEndingAddress;
                SIZE_T Alignment;
            } MEM_ADDRESS_REQUIREMENTS, *PMEM_ADDRESS_REQUIREMENTS;

            typedef enum MEM_EXTENDED_PARAMETER_TYPE
            {
                MemExtendedParameterInvalidType = 0,
                MemExtendedParameterAddressRequirements,
                MemExtendedParameterNumaNode,
                MemExtendedParameterPartitionHandle,
                MemExtendedParameterUserPhysicalHandle,
                MemExtendedParameterAttributeFlags,
                MemExtendedParameterMax
            } MEM_EXTENDED_PARAMETER_TYPE,
            *PMEM_EXTENDED_PARAMETER_TYPE;

            typedef struct __declspec(align(8)) MEM_EXTENDED_PARAMETER
            {
                struct
                {
                    DWORD64 Type : 8;
                    DWORD64 Reserved : 64 - 8;
                };

                union
                {
                    DWORD64 ULong64;
                    PVOID Pointer;
                    SIZE_T Size;
                    HANDLE Handle;
                    DWORD ULong;
                };

            } MEM_EXTENDED_PARAMETER, *PMEM_EXTENDED_PARAMETER;

            typedef enum MEM_SECTION_EXTENDED_PARAMETER_TYPE
            {
                MemSectionExtendedParameterInvalidType = 0,
                MemSectionExtendedParameterUserPhysicalFlags,
                MemSectionExtendedParameterNumaNode,
                MemSectionExtendedParameterMax
            } MEM_SECTION_EXTENDED_PARAMETER_TYPE,
            *PMEM_SECTION_EXTENDED_PARAMETER_TYPE;

            typedef struct _ENCLAVE_CREATE_INFO_SGX
            {
                BYTE Secs[4096];
            } ENCLAVE_CREATE_INFO_SGX, *PENCLAVE_CREATE_INFO_SGX;

            typedef struct _ENCLAVE_INIT_INFO_SGX
            {
                BYTE SigStruct[1808];
                BYTE Reserved1[240];
                BYTE EInitToken[304];
                BYTE Reserved2[1744];
            } ENCLAVE_INIT_INFO_SGX, *PENCLAVE_INIT_INFO_SGX;

            typedef struct _ENCLAVE_CREATE_INFO_VBS
            {
                DWORD Flags;
                BYTE OwnerID[32];
            } ENCLAVE_CREATE_INFO_VBS, *PENCLAVE_CREATE_INFO_VBS;

            typedef struct _ENCLAVE_INIT_INFO_VBS
            {
                DWORD Length;
                DWORD ThreadCount;
            } ENCLAVE_INIT_INFO_VBS, *PENCLAVE_INIT_INFO_VBS;

            typedef PVOID(ENCLAVE_TARGET_FUNCTION)(PVOID);
            typedef ENCLAVE_TARGET_FUNCTION(*PENCLAVE_TARGET_FUNCTION);
            typedef PENCLAVE_TARGET_FUNCTION LPENCLAVE_TARGET_FUNCTION;

            typedef struct _FILE_ID_128
            {
                BYTE Identifier[16];
            } FILE_ID_128, *PFILE_ID_128;

            typedef struct _FILE_NOTIFY_INFORMATION
            {
                DWORD NextEntryOffset;
                DWORD Action;
                DWORD FileNameLength;
                WCHAR FileName[1];
            } FILE_NOTIFY_INFORMATION, *PFILE_NOTIFY_INFORMATION;

            typedef struct _FILE_NOTIFY_EXTENDED_INFORMATION
            {
                DWORD NextEntryOffset;
                DWORD Action;
                LARGE_INTEGER CreationTime;
                LARGE_INTEGER LastModificationTime;
                LARGE_INTEGER LastChangeTime;
                LARGE_INTEGER LastAccessTime;
                LARGE_INTEGER AllocatedLength;
                LARGE_INTEGER FileSize;
                DWORD FileAttributes;
                DWORD ReparsePointTag;
                LARGE_INTEGER FileId;
                LARGE_INTEGER ParentFileId;
                DWORD FileNameLength;
                WCHAR FileName[1];
            } FILE_NOTIFY_EXTENDED_INFORMATION, *PFILE_NOTIFY_EXTENDED_INFORMATION;

            typedef union _FILE_SEGMENT_ELEMENT
            {
                PVOID64 Buffer;
                ULONGLONG Alignment;
            } FILE_SEGMENT_ELEMENT, *PFILE_SEGMENT_ELEMENT;

            typedef struct _REPARSE_GUID_DATA_BUFFER
            {
                DWORD ReparseTag;
                WORD ReparseDataLength;
                WORD Reserved;
                GUID ReparseGuid;
                struct
                {
                    BYTE DataBuffer[1];
                } GenericReparseBuffer;
            } REPARSE_GUID_DATA_BUFFER, *PREPARSE_GUID_DATA_BUFFER;

            typedef struct _SCRUB_DATA_INPUT
            {
                DWORD Size;

                DWORD Flags;

                DWORD MaximumIos;

                DWORD ObjectId[4];

                DWORD Reserved[25];

                BYTE ResumeContext[816];

            } SCRUB_DATA_INPUT, *PSCRUB_DATA_INPUT;

            typedef struct _SCRUB_PARITY_EXTENT
            {
                LONGLONG Offset;

                ULONGLONG Length;

            } SCRUB_PARITY_EXTENT, *PSCRUB_PARITY_EXTENT;

            typedef struct _SCRUB_PARITY_EXTENT_DATA
            {
                WORD Size;

                WORD Flags;

                WORD NumberOfParityExtents;

                WORD MaximumNumberOfParityExtents;

                SCRUB_PARITY_EXTENT ParityExtents[1];

            } SCRUB_PARITY_EXTENT_DATA, *PSCRUB_PARITY_EXTENT_DATA;

            typedef struct _SCRUB_DATA_OUTPUT
            {
                DWORD Size;

                DWORD Flags;

                DWORD Status;

                ULONGLONG ErrorFileOffset;

                ULONGLONG ErrorLength;

                ULONGLONG NumberOfBytesRepaired;

                ULONGLONG NumberOfBytesFailed;

                ULONGLONG InternalFileReference;

                WORD ResumeContextLength;

                WORD ParityExtentDataOffset;

                DWORD Reserved[9];

                ULONGLONG NumberOfMetadataBytesProcessed;

                ULONGLONG NumberOfDataBytesProcessed;

                ULONGLONG TotalNumberOfMetadataBytesInUse;

                ULONGLONG TotalNumberOfDataBytesInUse;

                BYTE ResumeContext[816];

            } SCRUB_DATA_OUTPUT, *PSCRUB_DATA_OUTPUT;

            typedef enum _SharedVirtualDiskSupportType
            {

                SharedVirtualDisksUnsupported = 0,

                SharedVirtualDisksSupported = 1,

                SharedVirtualDiskSnapshotsSupported = 3,

                SharedVirtualDiskCDPSnapshotsSupported = 7
            } SharedVirtualDiskSupportType;

            typedef enum _SharedVirtualDiskHandleState
            {

                SharedVirtualDiskHandleStateNone = 0,

                SharedVirtualDiskHandleStateFileShared = 1,

                SharedVirtualDiskHandleStateHandleShared = 3
            } SharedVirtualDiskHandleState;

            typedef struct _SHARED_VIRTUAL_DISK_SUPPORT
            {
                SharedVirtualDiskSupportType SharedVirtualDiskSupport;

                SharedVirtualDiskHandleState HandleState;
            } SHARED_VIRTUAL_DISK_SUPPORT, *PSHARED_VIRTUAL_DISK_SUPPORT;

            typedef struct _REARRANGE_FILE_DATA
            {
                ULONGLONG SourceStartingOffset;

                ULONGLONG TargetOffset;

                HANDLE SourceFileHandle;

                DWORD Length;

                DWORD Flags;

            } REARRANGE_FILE_DATA, *PREARRANGE_FILE_DATA;

            typedef struct _REARRANGE_FILE_DATA32
            {
                ULONGLONG SourceStartingOffset;
                ULONGLONG TargetOffset;
                UINT32 SourceFileHandle;
                DWORD Length;
                DWORD Flags;

            } REARRANGE_FILE_DATA32, *PREARRANGE_FILE_DATA32;

            typedef struct _SHUFFLE_FILE_DATA
            {
                LONGLONG StartingOffset;
                LONGLONG Length;
                DWORD Flags;

            } SHUFFLE_FILE_DATA, *PSHUFFLE_FILE_DATA;

            typedef struct _NETWORK_APP_INSTANCE_EA
            {
                GUID AppInstanceID;

                DWORD CsvFlags;

            } NETWORK_APP_INSTANCE_EA, *PNETWORK_APP_INSTANCE_EA;

            extern "C" const GUID GUID_MAX_POWER_SAVINGS;

            extern "C" const GUID GUID_MIN_POWER_SAVINGS;

            extern "C" const GUID GUID_TYPICAL_POWER_SAVINGS;

            extern "C" const GUID NO_SUBGROUP_GUID;

            extern "C" const GUID ALL_POWERSCHEMES_GUID;

            extern "C" const GUID GUID_POWERSCHEME_PERSONALITY;

            extern "C" const GUID GUID_ACTIVE_POWERSCHEME;

            extern "C" const GUID GUID_IDLE_RESILIENCY_SUBGROUP;

            extern "C" const GUID GUID_IDLE_RESILIENCY_PERIOD;

            extern "C" const GUID GUID_DEEP_SLEEP_ENABLED;

            extern "C" const GUID GUID_DEEP_SLEEP_PLATFORM_STATE;

            extern "C" const GUID GUID_DISK_COALESCING_POWERDOWN_TIMEOUT;

            extern "C" const GUID GUID_EXECUTION_REQUIRED_REQUEST_TIMEOUT;

            extern "C" const GUID GUID_VIDEO_SUBGROUP;

            extern "C" const GUID GUID_VIDEO_POWERDOWN_TIMEOUT;

            extern "C" const GUID GUID_VIDEO_ANNOYANCE_TIMEOUT;

            extern "C" const GUID GUID_VIDEO_ADAPTIVE_PERCENT_INCREASE;

            extern "C" const GUID GUID_VIDEO_DIM_TIMEOUT;

            extern "C" const GUID GUID_VIDEO_ADAPTIVE_POWERDOWN;

            extern "C" const GUID GUID_MONITOR_POWER_ON;

            extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_BRIGHTNESS;

            extern "C" const GUID GUID_DEVICE_POWER_POLICY_VIDEO_DIM_BRIGHTNESS;

            extern "C" const GUID GUID_VIDEO_CURRENT_MONITOR_BRIGHTNESS;

            extern "C" const GUID GUID_VIDEO_ADAPTIVE_DISPLAY_BRIGHTNESS;

            extern "C" const GUID GUID_CONSOLE_DISPLAY_STATE;

            extern "C" const GUID GUID_ALLOW_DISPLAY_REQUIRED;

            extern "C" const GUID GUID_VIDEO_CONSOLE_LOCK_TIMEOUT;

            extern "C" const GUID GUID_ADVANCED_COLOR_QUALITY_BIAS;

            extern "C" const GUID GUID_ADAPTIVE_POWER_BEHAVIOR_SUBGROUP;

            extern "C" const GUID GUID_NON_ADAPTIVE_INPUT_TIMEOUT;

            extern "C" const GUID GUID_ADAPTIVE_INPUT_CONTROLLER_STATE;

            extern "C" const GUID GUID_DISK_SUBGROUP;

            extern "C" const GUID GUID_DISK_MAX_POWER;

            extern "C" const GUID GUID_DISK_POWERDOWN_TIMEOUT;

            extern "C" const GUID GUID_DISK_IDLE_TIMEOUT;

            extern "C" const GUID GUID_DISK_BURST_IGNORE_THRESHOLD;

            extern "C" const GUID GUID_DISK_ADAPTIVE_POWERDOWN;

            extern "C" const GUID GUID_SLEEP_SUBGROUP;

            extern "C" const GUID GUID_SLEEP_IDLE_THRESHOLD;

            extern "C" const GUID GUID_STANDBY_TIMEOUT;

            extern "C" const GUID GUID_UNATTEND_SLEEP_TIMEOUT;

            extern "C" const GUID GUID_HIBERNATE_TIMEOUT;

            extern "C" const GUID GUID_HIBERNATE_FASTS4_POLICY;

            extern "C" const GUID GUID_CRITICAL_POWER_TRANSITION;

            extern "C" const GUID GUID_SYSTEM_AWAYMODE;

            extern "C" const GUID GUID_ALLOW_AWAYMODE;

            extern "C" const GUID GUID_USER_PRESENCE_PREDICTION;

            extern "C" const GUID GUID_STANDBY_BUDGET_GRACE_PERIOD;

            extern "C" const GUID GUID_STANDBY_BUDGET_PERCENT;

            extern "C" const GUID GUID_STANDBY_RESERVE_GRACE_PERIOD;

            extern "C" const GUID GUID_STANDBY_RESERVE_TIME;

            extern "C" const GUID GUID_STANDBY_RESET_PERCENT;

            extern "C" const GUID GUID_ALLOW_STANDBY_STATES;

            extern "C" const GUID GUID_ALLOW_RTC_WAKE;

            extern "C" const GUID GUID_LEGACY_RTC_MITIGATION;

            extern "C" const GUID GUID_ALLOW_SYSTEM_REQUIRED;

            extern "C" const GUID GUID_POWER_SAVING_STATUS;

            extern "C" const GUID GUID_ENERGY_SAVER_SUBGROUP;

            extern "C" const GUID GUID_ENERGY_SAVER_BATTERY_THRESHOLD;

            extern "C" const GUID GUID_ENERGY_SAVER_BRIGHTNESS;

            extern "C" const GUID GUID_ENERGY_SAVER_POLICY;

            extern "C" const GUID GUID_SYSTEM_BUTTON_SUBGROUP;

            extern "C" const GUID GUID_POWERBUTTON_ACTION;

            extern "C" const GUID GUID_SLEEPBUTTON_ACTION;

            extern "C" const GUID GUID_USERINTERFACEBUTTON_ACTION;

            extern "C" const GUID GUID_LIDCLOSE_ACTION;
            extern "C" const GUID GUID_LIDOPEN_POWERSTATE;

            extern "C" const GUID GUID_BATTERY_SUBGROUP;

            extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_0;
            extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_0;
            extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_0;

            extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_1;
            extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_1;
            extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_1;

            extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_2;
            extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_2;
            extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_2;

            extern "C" const GUID GUID_BATTERY_DISCHARGE_ACTION_3;
            extern "C" const GUID GUID_BATTERY_DISCHARGE_LEVEL_3;
            extern "C" const GUID GUID_BATTERY_DISCHARGE_FLAGS_3;

            extern "C" const GUID GUID_PROCESSOR_SETTINGS_SUBGROUP;

            extern "C" const GUID GUID_PROCESSOR_THROTTLE_POLICY;

            extern "C" const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM;

            extern "C" const GUID GUID_PROCESSOR_THROTTLE_MAXIMUM_1;

            extern "C" const GUID GUID_PROCESSOR_THROTTLE_MINIMUM;

            extern "C" const GUID GUID_PROCESSOR_THROTTLE_MINIMUM_1;

            extern "C" const GUID GUID_PROCESSOR_FREQUENCY_LIMIT;

            extern "C" const GUID GUID_PROCESSOR_FREQUENCY_LIMIT_1;

            extern "C" const GUID GUID_PROCESSOR_ALLOW_THROTTLING;

            extern "C" const GUID GUID_PROCESSOR_IDLESTATE_POLICY;

            extern "C" const GUID GUID_PROCESSOR_PERFSTATE_POLICY;

            extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_THRESHOLD_1;

            extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_THRESHOLD_1;

            extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY;

            extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_POLICY_1;

            extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY;

            extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_POLICY_1;

            extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_TIME;

            extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_TIME_1;

            extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_TIME;

            extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_TIME_1;

            extern "C" const GUID GUID_PROCESSOR_PERF_TIME_CHECK;

            extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_POLICY;

            extern "C" const GUID GUID_PROCESSOR_PERF_BOOST_MODE;

            extern "C" const GUID GUID_PROCESSOR_PERF_AUTONOMOUS_MODE;

            extern "C" const GUID GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE;

            extern "C" const GUID GUID_PROCESSOR_PERF_ENERGY_PERFORMANCE_PREFERENCE_1;

            extern "C" const GUID GUID_PROCESSOR_PERF_AUTONOMOUS_ACTIVITY_WINDOW;

            extern "C" const GUID GUID_PROCESSOR_DUTY_CYCLING;

            extern "C" const GUID GUID_PROCESSOR_IDLE_ALLOW_SCALING;

            extern "C" const GUID GUID_PROCESSOR_IDLE_DISABLE;

            extern "C" const GUID GUID_PROCESSOR_IDLE_STATE_MAXIMUM;

            extern "C" const GUID GUID_PROCESSOR_IDLE_TIME_CHECK;

            extern "C" const GUID GUID_PROCESSOR_IDLE_DEMOTE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_IDLE_PROMOTE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_POLICY;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_POLICY;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MAX_CORES_1;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_MIN_CORES_1;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_INCREASE_TIME;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_DECREASE_TIME;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_DECREASE_FACTOR;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_HISTORY_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_AFFINITY_WEIGHTING;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_DECREASE_FACTOR;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_HISTORY_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_WEIGHTING;

            extern "C" const GUID GUID_PROCESSOR_CORE_PARKING_OVER_UTILIZATION_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_PARKING_CORE_OVERRIDE;

            extern "C" const GUID GUID_PROCESSOR_PARKING_PERF_STATE;

            extern "C" const GUID GUID_PROCESSOR_PARKING_PERF_STATE_1;

            extern "C" const GUID GUID_PROCESSOR_PARKING_CONCURRENCY_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_PARKING_HEADROOM_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_PARKING_DISTRIBUTION_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_PERF_HISTORY;

            extern "C" const GUID GUID_PROCESSOR_PERF_HISTORY_1;

            extern "C" const GUID GUID_PROCESSOR_PERF_INCREASE_HISTORY;

            extern "C" const GUID GUID_PROCESSOR_PERF_DECREASE_HISTORY;

            extern "C" const GUID GUID_PROCESSOR_PERF_CORE_PARKING_HISTORY;

            extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT;

            extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF;

            extern "C" const GUID GUID_PROCESSOR_PERF_LATENCY_HINT_PERF_1;

            extern "C" const GUID GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK;

            extern "C" const GUID GUID_PROCESSOR_LATENCY_HINT_MIN_UNPARK_1;

            extern "C" const GUID GUID_PROCESSOR_DISTRIBUTE_UTILITY;

            extern "C" const GUID GUID_PROCESSOR_HETEROGENEOUS_POLICY;

            extern "C" const GUID GUID_PROCESSOR_HETERO_DECREASE_TIME;

            extern "C" const GUID GUID_PROCESSOR_HETERO_INCREASE_TIME;

            extern "C" const GUID GUID_PROCESSOR_HETERO_DECREASE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_HETERO_INCREASE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_CLASS0_FLOOR_PERF;

            extern "C" const GUID GUID_PROCESSOR_CLASS1_INITIAL_PERF;

            extern "C" const GUID GUID_PROCESSOR_THREAD_SCHEDULING_POLICY;

            extern "C" const GUID GUID_PROCESSOR_SHORT_THREAD_SCHEDULING_POLICY;

            extern "C" const GUID GUID_SYSTEM_COOLING_POLICY;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_THRESHOLD_1;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_THRESHOLD_1;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_DISABLE_TIME_1;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_ENABLE_TIME_1;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_EPP_CEILING_1;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR;

            extern "C" const GUID GUID_PROCESSOR_RESPONSIVENESS_PERF_FLOOR_1;

            extern "C" const GUID GUID_LOCK_CONSOLE_ON_WAKE;

            extern "C" const GUID GUID_DEVICE_IDLE_POLICY;

            extern "C" const GUID GUID_CONNECTIVITY_IN_STANDBY;

            extern "C" const GUID GUID_DISCONNECTED_STANDBY_MODE;

            extern "C" const GUID GUID_ACDC_POWER_SOURCE;

            extern "C" const GUID GUID_LIDSWITCH_STATE_CHANGE;

            extern "C" const GUID GUID_BATTERY_PERCENTAGE_REMAINING;

            extern "C" const GUID GUID_BATTERY_COUNT;

            extern "C" const GUID GUID_GLOBAL_USER_PRESENCE;

            extern "C" const GUID GUID_SESSION_DISPLAY_STATUS;

            extern "C" const GUID GUID_SESSION_USER_PRESENCE;

            extern "C" const GUID GUID_IDLE_BACKGROUND_TASK;

            extern "C" const GUID GUID_BACKGROUND_TASK_NOTIFICATION;

            extern "C" const GUID GUID_APPLAUNCH_BUTTON;

            extern "C" const GUID GUID_PCIEXPRESS_SETTINGS_SUBGROUP;

            extern "C" const GUID GUID_PCIEXPRESS_ASPM_POLICY;

            extern "C" const GUID GUID_ENABLE_SWITCH_FORCED_SHUTDOWN;

            extern "C" const GUID GUID_INTSTEER_SUBGROUP;

            extern "C" const GUID GUID_INTSTEER_MODE;

            extern "C" const GUID GUID_INTSTEER_LOAD_PER_PROC_TRIGGER;

            extern "C" const GUID GUID_INTSTEER_TIME_UNPARK_TRIGGER;

            extern "C" const GUID GUID_GRAPHICS_SUBGROUP;

            extern "C" const GUID GUID_GPU_PREFERENCE_POLICY;

            extern "C" const GUID GUID_MIXED_REALITY_MODE;

            extern "C" const GUID GUID_SPR_ACTIVE_SESSION_CHANGE;

            typedef enum _SYSTEM_POWER_STATE
            {
                PowerSystemUnspecified = 0,
                PowerSystemWorking = 1,
                PowerSystemSleeping1 = 2,
                PowerSystemSleeping2 = 3,
                PowerSystemSleeping3 = 4,
                PowerSystemHibernate = 5,
                PowerSystemShutdown = 6,
                PowerSystemMaximum = 7
            } SYSTEM_POWER_STATE,
            *PSYSTEM_POWER_STATE;

            typedef enum
            {
                PowerActionNone = 0,
                PowerActionReserved,
                PowerActionSleep,
                PowerActionHibernate,
                PowerActionShutdown,
                PowerActionShutdownReset,
                PowerActionShutdownOff,
                PowerActionWarmEject,
                PowerActionDisplayOff
            } POWER_ACTION,
            *PPOWER_ACTION;

            typedef enum _DEVICE_POWER_STATE
            {
                PowerDeviceUnspecified = 0,
                PowerDeviceD0,
                PowerDeviceD1,
                PowerDeviceD2,
                PowerDeviceD3,
                PowerDeviceMaximum
            } DEVICE_POWER_STATE,
            *PDEVICE_POWER_STATE;

            typedef enum _MONITOR_DISPLAY_STATE
            {
                PowerMonitorOff = 0,
                PowerMonitorOn,
                PowerMonitorDim
            } MONITOR_DISPLAY_STATE,
            *PMONITOR_DISPLAY_STATE;

            typedef enum _USER_ACTIVITY_PRESENCE
            {
                PowerUserPresent = 0,
                PowerUserNotPresent,
                PowerUserInactive,
                PowerUserMaximum,
                PowerUserInvalid = PowerUserMaximum
            } USER_ACTIVITY_PRESENCE,
            *PUSER_ACTIVITY_PRESENCE;

            typedef DWORD EXECUTION_STATE, *PEXECUTION_STATE;

            typedef enum
            {
                LT_DONT_CARE,
                LT_LOWEST_LATENCY
            } LATENCY_TIME;

            typedef enum _POWER_REQUEST_TYPE
            {
                PowerRequestDisplayRequired,
                PowerRequestSystemRequired,
                PowerRequestAwayModeRequired,
                PowerRequestExecutionRequired
            } POWER_REQUEST_TYPE,
            *PPOWER_REQUEST_TYPE;

            typedef struct CM_Power_Data_s
            {
                DWORD PD_Size;
                DEVICE_POWER_STATE PD_MostRecentPowerState;
                DWORD PD_Capabilities;
                DWORD PD_D1Latency;
                DWORD PD_D2Latency;
                DWORD PD_D3Latency;
                DEVICE_POWER_STATE PD_PowerStateMapping[7];
                SYSTEM_POWER_STATE PD_DeepestSystemWake;
            } CM_POWER_DATA, *PCM_POWER_DATA;

            typedef enum
            {
                SystemPowerPolicyAc,
                SystemPowerPolicyDc,
                VerifySystemPolicyAc,
                VerifySystemPolicyDc,
                SystemPowerCapabilities,
                SystemBatteryState,
                SystemPowerStateHandler,
                ProcessorStateHandler,
                SystemPowerPolicyCurrent,
                AdministratorPowerPolicy,
                SystemReserveHiberFile,
                ProcessorInformation,
                SystemPowerInformation,
                ProcessorStateHandler2,
                LastWakeTime,
                LastSleepTime,
                SystemExecutionState,
                SystemPowerStateNotifyHandler,
                ProcessorPowerPolicyAc,
                ProcessorPowerPolicyDc,
                VerifyProcessorPowerPolicyAc,
                VerifyProcessorPowerPolicyDc,
                ProcessorPowerPolicyCurrent,
                SystemPowerStateLogging,
                SystemPowerLoggingEntry,
                SetPowerSettingValue,
                NotifyUserPowerSetting,
                PowerInformationLevelUnused0,
                SystemMonitorHiberBootPowerOff,
                SystemVideoState,
                TraceApplicationPowerMessage,
                TraceApplicationPowerMessageEnd,
                ProcessorPerfStates,
                ProcessorIdleStates,
                ProcessorCap,
                SystemWakeSource,
                SystemHiberFileInformation,
                TraceServicePowerMessage,
                ProcessorLoad,
                PowerShutdownNotification,
                MonitorCapabilities,
                SessionPowerInit,
                SessionDisplayState,
                PowerRequestCreate,
                PowerRequestAction,
                GetPowerRequestList,
                ProcessorInformationEx,
                NotifyUserModeLegacyPowerEvent,
                GroupPark,
                ProcessorIdleDomains,
                WakeTimerList,
                SystemHiberFileSize,
                ProcessorIdleStatesHv,
                ProcessorPerfStatesHv,
                ProcessorPerfCapHv,
                ProcessorSetIdle,
                LogicalProcessorIdling,
                UserPresence,
                PowerSettingNotificationName,
                GetPowerSettingValue,
                IdleResiliency,
                SessionRITState,
                SessionConnectNotification,
                SessionPowerCleanup,
                SessionLockState,
                SystemHiberbootState,
                PlatformInformation,
                PdcInvocation,
                MonitorInvocation,
                FirmwareTableInformationRegistered,
                SetShutdownSelectedTime,
                SuspendResumeInvocation,
                PlmPowerRequestCreate,
                ScreenOff,
                CsDeviceNotification,
                PlatformRole,
                LastResumePerformance,
                DisplayBurst,
                ExitLatencySamplingPercentage,
                RegisterSpmPowerSettings,
                PlatformIdleStates,
                ProcessorIdleVeto,
                PlatformIdleVeto,
                SystemBatteryStatePrecise,
                ThermalEvent,
                PowerRequestActionInternal,
                BatteryDeviceState,
                PowerInformationInternal,
                ThermalStandby,
                SystemHiberFileType,
                PhysicalPowerButtonPress,
                QueryPotentialDripsConstraint,
                EnergyTrackerCreate,
                EnergyTrackerQuery,
                UpdateBlackBoxRecorder,
                PowerInformationLevelMaximum
            } POWER_INFORMATION_LEVEL;

            typedef enum
            {
                UserNotPresent = 0,
                UserPresent = 1,
                UserUnknown = 0xff
            } POWER_USER_PRESENCE_TYPE,
            *PPOWER_USER_PRESENCE_TYPE;

            typedef struct _POWER_USER_PRESENCE
            {
                POWER_USER_PRESENCE_TYPE UserPresence;
            } POWER_USER_PRESENCE, *PPOWER_USER_PRESENCE;

            typedef struct _POWER_SESSION_CONNECT
            {
                BOOLEAN Connected;
                BOOLEAN Console;
            } POWER_SESSION_CONNECT, *PPOWER_SESSION_CONNECT;

            typedef struct _POWER_SESSION_TIMEOUTS
            {
                DWORD InputTimeout;
                DWORD DisplayTimeout;
            } POWER_SESSION_TIMEOUTS, *PPOWER_SESSION_TIMEOUTS;

            typedef struct _POWER_SESSION_RIT_STATE
            {
                BOOLEAN Active;
                DWORD LastInputTime;
            } POWER_SESSION_RIT_STATE, *PPOWER_SESSION_RIT_STATE;

            typedef struct _POWER_SESSION_WINLOGON
            {
                DWORD SessionId;
                BOOLEAN Console;
                BOOLEAN Locked;
            } POWER_SESSION_WINLOGON, *PPOWER_SESSION_WINLOGON;

            typedef struct _POWER_IDLE_RESILIENCY
            {
                DWORD CoalescingTimeout;
                DWORD IdleResiliencyPeriod;
            } POWER_IDLE_RESILIENCY, *PPOWER_IDLE_RESILIENCY;

            typedef enum
            {
                MonitorRequestReasonUnknown,
                MonitorRequestReasonPowerButton,
                MonitorRequestReasonRemoteConnection,
                MonitorRequestReasonScMonitorpower,
                MonitorRequestReasonUserInput,
                MonitorRequestReasonAcDcDisplayBurst,
                MonitorRequestReasonUserDisplayBurst,
                MonitorRequestReasonPoSetSystemState,
                MonitorRequestReasonSetThreadExecutionState,
                MonitorRequestReasonFullWake,
                MonitorRequestReasonSessionUnlock,
                MonitorRequestReasonScreenOffRequest,
                MonitorRequestReasonIdleTimeout,
                MonitorRequestReasonPolicyChange,
                MonitorRequestReasonSleepButton,
                MonitorRequestReasonLid,
                MonitorRequestReasonBatteryCountChange,
                MonitorRequestReasonGracePeriod,
                MonitorRequestReasonPnP,
                MonitorRequestReasonDP,
                MonitorRequestReasonSxTransition,
                MonitorRequestReasonSystemIdle,
                MonitorRequestReasonNearProximity,
                MonitorRequestReasonThermalStandby,
                MonitorRequestReasonResumePdc,
                MonitorRequestReasonResumeS4,
                MonitorRequestReasonTerminal,
                MonitorRequestReasonPdcSignal,
                MonitorRequestReasonAcDcDisplayBurstSuppressed,
                MonitorRequestReasonSystemStateEntered,

                MonitorRequestReasonWinrt,
                MonitorRequestReasonUserInputKeyboard,
                MonitorRequestReasonUserInputMouse,
                MonitorRequestReasonUserInputTouch,
                MonitorRequestReasonUserInputPen,
                MonitorRequestReasonUserInputAccelerometer,
                MonitorRequestReasonUserInputHid,
                MonitorRequestReasonUserInputPoUserPresent,
                MonitorRequestReasonUserInputSessionSwitch,
                MonitorRequestReasonUserInputInitialization,
                MonitorRequestReasonPdcSignalWindowsMobilePwrNotif,
                MonitorRequestReasonPdcSignalWindowsMobileShell,
                MonitorRequestReasonPdcSignalHeyCortana,
                MonitorRequestReasonPdcSignalHolographicShell,
                MonitorRequestReasonPdcSignalFingerprint,
                MonitorRequestReasonDirectedDrips,
                MonitorRequestReasonMax
            } POWER_MONITOR_REQUEST_REASON;

            typedef enum _POWER_MONITOR_REQUEST_TYPE
            {
                MonitorRequestTypeOff,
                MonitorRequestTypeOnAndPresent,
                MonitorRequestTypeToggleOn
            } POWER_MONITOR_REQUEST_TYPE;

            typedef struct _POWER_MONITOR_INVOCATION
            {
                BOOLEAN Console;
                POWER_MONITOR_REQUEST_REASON RequestReason;
            } POWER_MONITOR_INVOCATION, *PPOWER_MONITOR_INVOCATION;

            typedef struct _RESUME_PERFORMANCE
            {
                DWORD PostTimeMs;
                ULONGLONG TotalResumeTimeMs;
                ULONGLONG ResumeCompleteTimestamp;
            } RESUME_PERFORMANCE, *PRESUME_PERFORMANCE;

            typedef enum
            {
                PoAc,
                PoDc,
                PoHot,
                PoConditionMaximum
            } SYSTEM_POWER_CONDITION;

            typedef struct
            {
                DWORD Version;

                GUID Guid;

                SYSTEM_POWER_CONDITION PowerCondition;

                DWORD DataLength;

                BYTE Data[1];
            } SET_POWER_SETTING_VALUE, *PSET_POWER_SETTING_VALUE;

            typedef struct
            {
                GUID Guid;
            } NOTIFY_USER_POWER_SETTING, *PNOTIFY_USER_POWER_SETTING;

            typedef struct _APPLICATIONLAUNCH_SETTING_VALUE
            {
                LARGE_INTEGER ActivationTime;

                DWORD Flags;

                DWORD ButtonInstanceID;

            } APPLICATIONLAUNCH_SETTING_VALUE, *PAPPLICATIONLAUNCH_SETTING_VALUE;

            typedef enum _POWER_PLATFORM_ROLE
            {
                PlatformRoleUnspecified = 0,
                PlatformRoleDesktop,
                PlatformRoleMobile,
                PlatformRoleWorkstation,
                PlatformRoleEnterpriseServer,
                PlatformRoleSOHOServer,
                PlatformRoleAppliancePC,
                PlatformRolePerformanceServer,
                PlatformRoleSlate,
                PlatformRoleMaximum
            } POWER_PLATFORM_ROLE,
            *PPOWER_PLATFORM_ROLE;

            typedef struct _POWER_PLATFORM_INFORMATION
            {
                BOOLEAN AoAc;
            } POWER_PLATFORM_INFORMATION, *PPOWER_PLATFORM_INFORMATION;

            typedef struct
            {
                DWORD Granularity;
                DWORD Capacity;
            } BATTERY_REPORTING_SCALE, *PBATTERY_REPORTING_SCALE;

            typedef struct
            {
                DWORD Frequency;
                DWORD Flags;
                DWORD PercentFrequency;
            } PPM_WMI_LEGACY_PERFSTATE, *PPPM_WMI_LEGACY_PERFSTATE;

            typedef struct
            {
                DWORD Latency;
                DWORD Power;
                DWORD TimeCheck;
                BYTE PromotePercent;
                BYTE DemotePercent;
                BYTE StateType;
                BYTE Reserved;
                DWORD StateFlags;
                DWORD Context;
                DWORD IdleHandler;
                DWORD Reserved1;
            } PPM_WMI_IDLE_STATE, *PPPM_WMI_IDLE_STATE;

            typedef struct
            {
                DWORD Type;
                DWORD Count;
                DWORD TargetState;
                DWORD OldState;
                DWORD64 TargetProcessors;
                PPM_WMI_IDLE_STATE State[1];
            } PPM_WMI_IDLE_STATES, *PPPM_WMI_IDLE_STATES;

            typedef struct
            {
                DWORD Type;
                DWORD Count;
                DWORD TargetState;
                DWORD OldState;
                PVOID TargetProcessors;
                PPM_WMI_IDLE_STATE State[1];
            } PPM_WMI_IDLE_STATES_EX, *PPPM_WMI_IDLE_STATES_EX;

            typedef struct
            {
                DWORD Frequency;
                DWORD Power;
                BYTE PercentFrequency;
                BYTE IncreaseLevel;
                BYTE DecreaseLevel;
                BYTE Type;
                DWORD IncreaseTime;
                DWORD DecreaseTime;
                DWORD64 Control;
                DWORD64 Status;
                DWORD HitCount;
                DWORD Reserved1;
                DWORD64 Reserved2;
                DWORD64 Reserved3;
            } PPM_WMI_PERF_STATE, *PPPM_WMI_PERF_STATE;

            typedef struct
            {
                DWORD Count;
                DWORD MaxFrequency;
                DWORD CurrentState;
                DWORD MaxPerfState;
                DWORD MinPerfState;
                DWORD LowestPerfState;
                DWORD ThermalConstraint;
                BYTE BusyAdjThreshold;
                BYTE PolicyType;
                BYTE Type;
                BYTE Reserved;
                DWORD TimerInterval;
                DWORD64 TargetProcessors;
                DWORD PStateHandler;
                DWORD PStateContext;
                DWORD TStateHandler;
                DWORD TStateContext;
                DWORD FeedbackHandler;
                DWORD Reserved1;
                DWORD64 Reserved2;
                PPM_WMI_PERF_STATE State[1];
            } PPM_WMI_PERF_STATES, *PPPM_WMI_PERF_STATES;

            typedef struct
            {
                DWORD Count;
                DWORD MaxFrequency;
                DWORD CurrentState;
                DWORD MaxPerfState;
                DWORD MinPerfState;
                DWORD LowestPerfState;
                DWORD ThermalConstraint;
                BYTE BusyAdjThreshold;
                BYTE PolicyType;
                BYTE Type;
                BYTE Reserved;
                DWORD TimerInterval;
                PVOID TargetProcessors;
                DWORD PStateHandler;
                DWORD PStateContext;
                DWORD TStateHandler;
                DWORD TStateContext;
                DWORD FeedbackHandler;
                DWORD Reserved1;
                DWORD64 Reserved2;
                PPM_WMI_PERF_STATE State[1];
            } PPM_WMI_PERF_STATES_EX, *PPPM_WMI_PERF_STATES_EX;

            typedef struct
            {
                DWORD IdleTransitions;
                DWORD FailedTransitions;
                DWORD InvalidBucketIndex;
                DWORD64 TotalTime;
                DWORD IdleTimeBuckets[6];
            } PPM_IDLE_STATE_ACCOUNTING, *PPPM_IDLE_STATE_ACCOUNTING;

            typedef struct
            {
                DWORD StateCount;
                DWORD TotalTransitions;
                DWORD ResetCount;
                DWORD64 StartTime;
                PPM_IDLE_STATE_ACCOUNTING State[1];
            } PPM_IDLE_ACCOUNTING, *PPPM_IDLE_ACCOUNTING;

            typedef struct
            {
                DWORD64 TotalTimeUs;
                DWORD MinTimeUs;
                DWORD MaxTimeUs;
                DWORD Count;
            } PPM_IDLE_STATE_BUCKET_EX, *PPPM_IDLE_STATE_BUCKET_EX;

            typedef struct
            {
                DWORD64 TotalTime;
                DWORD IdleTransitions;
                DWORD FailedTransitions;
                DWORD InvalidBucketIndex;
                DWORD MinTimeUs;
                DWORD MaxTimeUs;
                DWORD CancelledTransitions;
                PPM_IDLE_STATE_BUCKET_EX IdleTimeBuckets[16];
            } PPM_IDLE_STATE_ACCOUNTING_EX, *PPPM_IDLE_STATE_ACCOUNTING_EX;

            typedef struct
            {
                DWORD StateCount;
                DWORD TotalTransitions;
                DWORD ResetCount;
                DWORD AbortCount;
                DWORD64 StartTime;
                PPM_IDLE_STATE_ACCOUNTING_EX State[1];
            } PPM_IDLE_ACCOUNTING_EX, *PPPM_IDLE_ACCOUNTING_EX;

            extern "C" const GUID PPM_PERFSTATE_CHANGE_GUID;

            extern "C" const GUID PPM_PERFSTATE_DOMAIN_CHANGE_GUID;

            extern "C" const GUID PPM_IDLESTATE_CHANGE_GUID;

            extern "C" const GUID PPM_PERFSTATES_DATA_GUID;

            extern "C" const GUID PPM_IDLESTATES_DATA_GUID;

            extern "C" const GUID PPM_IDLE_ACCOUNTING_GUID;

            extern "C" const GUID PPM_IDLE_ACCOUNTING_EX_GUID;

            extern "C" const GUID PPM_THERMALCONSTRAINT_GUID;

            extern "C" const GUID PPM_PERFMON_PERFSTATE_GUID;

            extern "C" const GUID PPM_THERMAL_POLICY_CHANGE_GUID;

            typedef struct
            {
                DWORD State;
                DWORD Status;
                DWORD Latency;
                DWORD Speed;
                DWORD Processor;
            } PPM_PERFSTATE_EVENT, *PPPM_PERFSTATE_EVENT;

            typedef struct
            {
                DWORD State;
                DWORD Latency;
                DWORD Speed;
                DWORD64 Processors;
            } PPM_PERFSTATE_DOMAIN_EVENT, *PPPM_PERFSTATE_DOMAIN_EVENT;

            typedef struct
            {
                DWORD NewState;
                DWORD OldState;
                DWORD64 Processors;
            } PPM_IDLESTATE_EVENT, *PPPM_IDLESTATE_EVENT;

            typedef struct
            {
                DWORD ThermalConstraint;
                DWORD64 Processors;
            } PPM_THERMALCHANGE_EVENT, *PPPM_THERMALCHANGE_EVENT;

#pragma warning(push)
#pragma warning(disable : 4121)

            typedef struct
            {
                BYTE Mode;
                DWORD64 Processors;
            } PPM_THERMAL_POLICY_EVENT, *PPPM_THERMAL_POLICY_EVENT;

#pragma warning(pop)

            typedef struct
            {
                POWER_ACTION Action;
                DWORD Flags;
                DWORD EventCode;
            } POWER_ACTION_POLICY, *PPOWER_ACTION_POLICY;

            typedef struct
            {
                BOOLEAN Enable;
                BYTE Spare[3];
                DWORD BatteryLevel;
                POWER_ACTION_POLICY PowerPolicy;
                SYSTEM_POWER_STATE MinSystemState;
            } SYSTEM_POWER_LEVEL, *PSYSTEM_POWER_LEVEL;

            typedef struct _SYSTEM_POWER_POLICY
            {
                DWORD Revision;

                POWER_ACTION_POLICY PowerButton;
                POWER_ACTION_POLICY SleepButton;
                POWER_ACTION_POLICY LidClose;
                SYSTEM_POWER_STATE LidOpenWake;
                DWORD Reserved;

                POWER_ACTION_POLICY Idle;
                DWORD IdleTimeout;
                BYTE IdleSensitivity;

                BYTE DynamicThrottle;
                BYTE Spare2[2];

                SYSTEM_POWER_STATE MinSleep;
                SYSTEM_POWER_STATE MaxSleep;
                SYSTEM_POWER_STATE ReducedLatencySleep;
                DWORD WinLogonFlags;

                DWORD Spare3;

                DWORD DozeS4Timeout;

                DWORD BroadcastCapacityResolution;
                SYSTEM_POWER_LEVEL DischargePolicy[4];

                DWORD VideoTimeout;
                BOOLEAN VideoDimDisplay;
                DWORD VideoReserved[3];

                DWORD SpindownTimeout;

                BOOLEAN OptimizeForPower;
                BYTE FanThrottleTolerance;
                BYTE ForcedThrottle;
                BYTE MinThrottle;
                POWER_ACTION_POLICY OverThrottled;

            } SYSTEM_POWER_POLICY, *PSYSTEM_POWER_POLICY;

            typedef struct
            {
                DWORD TimeCheck;
                BYTE DemotePercent;
                BYTE PromotePercent;
                BYTE Spare[2];
            } PROCESSOR_IDLESTATE_INFO, *PPROCESSOR_IDLESTATE_INFO;

            typedef struct
            {
                WORD Revision;
                union
                {
                    WORD AsWORD;
                    struct
                    {
                        WORD AllowScaling : 1;
                        WORD Disabled : 1;
                        WORD Reserved : 14;
                    };
                } Flags;

                DWORD PolicyCount;
                PROCESSOR_IDLESTATE_INFO Policy[0x3];
            } PROCESSOR_IDLESTATE_POLICY, *PPROCESSOR_IDLESTATE_POLICY;

            typedef struct _PROCESSOR_POWER_POLICY_INFO
            {
                DWORD TimeCheck;
                DWORD DemoteLimit;
                DWORD PromoteLimit;

                BYTE DemotePercent;
                BYTE PromotePercent;
                BYTE Spare[2];

                DWORD AllowDemotion : 1;
                DWORD AllowPromotion : 1;
                DWORD Reserved : 30;

            } PROCESSOR_POWER_POLICY_INFO, *PPROCESSOR_POWER_POLICY_INFO;

            typedef struct _PROCESSOR_POWER_POLICY
            {
                DWORD Revision;

                BYTE DynamicThrottle;
                BYTE Spare[3];

                DWORD DisableCStates : 1;
                DWORD Reserved : 31;

                DWORD PolicyCount;
                PROCESSOR_POWER_POLICY_INFO Policy[3];

            } PROCESSOR_POWER_POLICY, *PPROCESSOR_POWER_POLICY;

            typedef struct
            {
                DWORD Revision;
                BYTE MaxThrottle;
                BYTE MinThrottle;
                BYTE BusyAdjThreshold;
                union
                {
                    BYTE Spare;
                    union
                    {
                        BYTE AsBYTE;
                        struct
                        {
                            BYTE NoDomainAccounting : 1;
                            BYTE IncreasePolicy : 2;
                            BYTE DecreasePolicy : 2;
                            BYTE Reserved : 3;
                        };
                    } Flags;
                };

                DWORD TimeCheck;
                DWORD IncreaseTime;
                DWORD DecreaseTime;
                DWORD IncreasePercent;
                DWORD DecreasePercent;
            } PROCESSOR_PERFSTATE_POLICY, *PPROCESSOR_PERFSTATE_POLICY;

            typedef struct _ADMINISTRATOR_POWER_POLICY
            {
                SYSTEM_POWER_STATE MinSleep;
                SYSTEM_POWER_STATE MaxSleep;

                DWORD MinVideoTimeout;
                DWORD MaxVideoTimeout;

                DWORD MinSpindownTimeout;
                DWORD MaxSpindownTimeout;
            } ADMINISTRATOR_POWER_POLICY, *PADMINISTRATOR_POWER_POLICY;

            typedef enum _HIBERFILE_BUCKET_SIZE
            {
                HiberFileBucket1GB = 0,
                HiberFileBucket2GB,
                HiberFileBucket4GB,
                HiberFileBucket8GB,
                HiberFileBucket16GB,
                HiberFileBucket32GB,
                HiberFileBucketUnlimited,
                HiberFileBucketMax
            } HIBERFILE_BUCKET_SIZE,
            *PHIBERFILE_BUCKET_SIZE;

            typedef struct _HIBERFILE_BUCKET
            {
                DWORD64 MaxPhysicalMemory;
                DWORD PhysicalMemoryPercent[0x03];
            } HIBERFILE_BUCKET, *PHIBERFILE_BUCKET;

            typedef struct
            {
                BOOLEAN PowerButtonPresent;
                BOOLEAN SleepButtonPresent;
                BOOLEAN LidPresent;
                BOOLEAN SystemS1;
                BOOLEAN SystemS2;
                BOOLEAN SystemS3;
                BOOLEAN SystemS4;
                BOOLEAN SystemS5;
                BOOLEAN HiberFilePresent;
                BOOLEAN FullWake;
                BOOLEAN VideoDimPresent;
                BOOLEAN ApmPresent;
                BOOLEAN UpsPresent;

                BOOLEAN ThermalControl;
                BOOLEAN ProcessorThrottle;
                BYTE ProcessorMinThrottle;

                BYTE ProcessorMaxThrottle;
                BOOLEAN FastSystemS4;
                BOOLEAN Hiberboot;
                BOOLEAN WakeAlarmPresent;
                BOOLEAN AoAc;

                BOOLEAN DiskSpinDown;

                BYTE HiberFileType;
                BOOLEAN AoAcConnectivitySupported;
                BYTE spare3[6];

                BOOLEAN SystemBatteriesPresent;
                BOOLEAN BatteriesAreShortTerm;
                BATTERY_REPORTING_SCALE BatteryScale[3];

                SYSTEM_POWER_STATE AcOnLineWake;
                SYSTEM_POWER_STATE SoftLidWake;
                SYSTEM_POWER_STATE RtcWake;
                SYSTEM_POWER_STATE MinDeviceWakeState;
                SYSTEM_POWER_STATE DefaultLowLatencyWake;
            } SYSTEM_POWER_CAPABILITIES, *PSYSTEM_POWER_CAPABILITIES;

            typedef struct
            {
                BOOLEAN AcOnLine;
                BOOLEAN BatteryPresent;
                BOOLEAN Charging;
                BOOLEAN Discharging;
                BOOLEAN Spare1[3];

                BYTE Tag;

                DWORD MaxCapacity;
                DWORD RemainingCapacity;
                DWORD Rate;
                DWORD EstimatedTime;

                DWORD DefaultAlert1;
                DWORD DefaultAlert2;
            } SYSTEM_BATTERY_STATE, *PSYSTEM_BATTERY_STATE;

#pragma warning(disable : 4103)

#pragma pack(push, 4)

#pragma warning(disable : 4103)

#pragma pack(push, 2)

            typedef struct _IMAGE_DOS_HEADER
            {
                WORD e_magic;
                WORD e_cblp;
                WORD e_cp;
                WORD e_crlc;
                WORD e_cparhdr;
                WORD e_minalloc;
                WORD e_maxalloc;
                WORD e_ss;
                WORD e_sp;
                WORD e_csum;
                WORD e_ip;
                WORD e_cs;
                WORD e_lfarlc;
                WORD e_ovno;
                WORD e_res[4];
                WORD e_oemid;
                WORD e_oeminfo;
                WORD e_res2[10];
                LONG e_lfanew;
            } IMAGE_DOS_HEADER, *PIMAGE_DOS_HEADER;

            typedef struct _IMAGE_OS2_HEADER
            {
                WORD ne_magic;
                CHAR ne_ver;
                CHAR ne_rev;
                WORD ne_enttab;
                WORD ne_cbenttab;
                LONG ne_crc;
                WORD ne_flags;
                WORD ne_autodata;
                WORD ne_heap;
                WORD ne_stack;
                LONG ne_csip;
                LONG ne_sssp;
                WORD ne_cseg;
                WORD ne_cmod;
                WORD ne_cbnrestab;
                WORD ne_segtab;
                WORD ne_rsrctab;
                WORD ne_restab;
                WORD ne_modtab;
                WORD ne_imptab;
                LONG ne_nrestab;
                WORD ne_cmovent;
                WORD ne_align;
                WORD ne_cres;
                BYTE ne_exetyp;
                BYTE ne_flagsothers;
                WORD ne_pretthunks;
                WORD ne_psegrefbytes;
                WORD ne_swaparea;
                WORD ne_expver;
            } IMAGE_OS2_HEADER, *PIMAGE_OS2_HEADER;

            typedef struct _IMAGE_VXD_HEADER
            {
                WORD e32_magic;
                BYTE e32_border;
                BYTE e32_worder;
                DWORD e32_level;
                WORD e32_cpu;
                WORD e32_os;
                DWORD e32_ver;
                DWORD e32_mflags;
                DWORD e32_mpages;
                DWORD e32_startobj;
                DWORD e32_eip;
                DWORD e32_stackobj;
                DWORD e32_esp;
                DWORD e32_pagesize;
                DWORD e32_lastpagesize;
                DWORD e32_fixupsize;
                DWORD e32_fixupsum;
                DWORD e32_ldrsize;
                DWORD e32_ldrsum;
                DWORD e32_objtab;
                DWORD e32_objcnt;
                DWORD e32_objmap;
                DWORD e32_itermap;
                DWORD e32_rsrctab;
                DWORD e32_rsrccnt;
                DWORD e32_restab;
                DWORD e32_enttab;
                DWORD e32_dirtab;
                DWORD e32_dircnt;
                DWORD e32_fpagetab;
                DWORD e32_frectab;
                DWORD e32_impmod;
                DWORD e32_impmodcnt;
                DWORD e32_impproc;
                DWORD e32_pagesum;
                DWORD e32_datapage;
                DWORD e32_preload;
                DWORD e32_nrestab;
                DWORD e32_cbnrestab;
                DWORD e32_nressum;
                DWORD e32_autodata;
                DWORD e32_debuginfo;
                DWORD e32_debuglen;
                DWORD e32_instpreload;
                DWORD e32_instdemand;
                DWORD e32_heapsize;
                BYTE e32_res3[12];
                DWORD e32_winresoff;
                DWORD e32_winreslen;
                WORD e32_devid;
                WORD e32_ddkver;
            } IMAGE_VXD_HEADER, *PIMAGE_VXD_HEADER;

#pragma warning(disable : 4103)

#pragma pack(pop)

            typedef struct _IMAGE_FILE_HEADER
            {
                WORD Machine;
                WORD NumberOfSections;
                DWORD TimeDateStamp;
                DWORD PointerToSymbolTable;
                DWORD NumberOfSymbols;
                WORD SizeOfOptionalHeader;
                WORD Characteristics;
            } IMAGE_FILE_HEADER, *PIMAGE_FILE_HEADER;

            typedef struct _IMAGE_DATA_DIRECTORY
            {
                DWORD VirtualAddress;
                DWORD Size;
            } IMAGE_DATA_DIRECTORY, *PIMAGE_DATA_DIRECTORY;

            typedef struct _IMAGE_OPTIONAL_HEADER
            {
                WORD Magic;
                BYTE MajorLinkerVersion;
                BYTE MinorLinkerVersion;
                DWORD SizeOfCode;
                DWORD SizeOfInitializedData;
                DWORD SizeOfUninitializedData;
                DWORD AddressOfEntryPoint;
                DWORD BaseOfCode;
                DWORD BaseOfData;

                DWORD ImageBase;
                DWORD SectionAlignment;
                DWORD FileAlignment;
                WORD MajorOperatingSystemVersion;
                WORD MinorOperatingSystemVersion;
                WORD MajorImageVersion;
                WORD MinorImageVersion;
                WORD MajorSubsystemVersion;
                WORD MinorSubsystemVersion;
                DWORD Win32VersionValue;
                DWORD SizeOfImage;
                DWORD SizeOfHeaders;
                DWORD CheckSum;
                WORD Subsystem;
                WORD DllCharacteristics;
                DWORD SizeOfStackReserve;
                DWORD SizeOfStackCommit;
                DWORD SizeOfHeapReserve;
                DWORD SizeOfHeapCommit;
                DWORD LoaderFlags;
                DWORD NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            } IMAGE_OPTIONAL_HEADER32, *PIMAGE_OPTIONAL_HEADER32;

            typedef struct _IMAGE_ROM_OPTIONAL_HEADER
            {
                WORD Magic;
                BYTE MajorLinkerVersion;
                BYTE MinorLinkerVersion;
                DWORD SizeOfCode;
                DWORD SizeOfInitializedData;
                DWORD SizeOfUninitializedData;
                DWORD AddressOfEntryPoint;
                DWORD BaseOfCode;
                DWORD BaseOfData;
                DWORD BaseOfBss;
                DWORD GprMask;
                DWORD CprMask[4];
                DWORD GpValue;
            } IMAGE_ROM_OPTIONAL_HEADER, *PIMAGE_ROM_OPTIONAL_HEADER;

            typedef struct _IMAGE_OPTIONAL_HEADER64
            {
                WORD Magic;
                BYTE MajorLinkerVersion;
                BYTE MinorLinkerVersion;
                DWORD SizeOfCode;
                DWORD SizeOfInitializedData;
                DWORD SizeOfUninitializedData;
                DWORD AddressOfEntryPoint;
                DWORD BaseOfCode;
                ULONGLONG ImageBase;
                DWORD SectionAlignment;
                DWORD FileAlignment;
                WORD MajorOperatingSystemVersion;
                WORD MinorOperatingSystemVersion;
                WORD MajorImageVersion;
                WORD MinorImageVersion;
                WORD MajorSubsystemVersion;
                WORD MinorSubsystemVersion;
                DWORD Win32VersionValue;
                DWORD SizeOfImage;
                DWORD SizeOfHeaders;
                DWORD CheckSum;
                WORD Subsystem;
                WORD DllCharacteristics;
                ULONGLONG SizeOfStackReserve;
                ULONGLONG SizeOfStackCommit;
                ULONGLONG SizeOfHeapReserve;
                ULONGLONG SizeOfHeapCommit;
                DWORD LoaderFlags;
                DWORD NumberOfRvaAndSizes;
                IMAGE_DATA_DIRECTORY DataDirectory[16];
            } IMAGE_OPTIONAL_HEADER64, *PIMAGE_OPTIONAL_HEADER64;

            typedef IMAGE_OPTIONAL_HEADER64 IMAGE_OPTIONAL_HEADER;
            typedef PIMAGE_OPTIONAL_HEADER64 PIMAGE_OPTIONAL_HEADER;

            typedef struct _IMAGE_NT_HEADERS64
            {
                DWORD Signature;
                IMAGE_FILE_HEADER FileHeader;
                IMAGE_OPTIONAL_HEADER64 OptionalHeader;
            } IMAGE_NT_HEADERS64, *PIMAGE_NT_HEADERS64;

            typedef struct _IMAGE_NT_HEADERS
            {
                DWORD Signature;
                IMAGE_FILE_HEADER FileHeader;
                IMAGE_OPTIONAL_HEADER32 OptionalHeader;
            } IMAGE_NT_HEADERS32, *PIMAGE_NT_HEADERS32;

            typedef struct _IMAGE_ROM_HEADERS
            {
                IMAGE_FILE_HEADER FileHeader;
                IMAGE_ROM_OPTIONAL_HEADER OptionalHeader;
            } IMAGE_ROM_HEADERS, *PIMAGE_ROM_HEADERS;

            typedef IMAGE_NT_HEADERS64 IMAGE_NT_HEADERS;
            typedef PIMAGE_NT_HEADERS64 PIMAGE_NT_HEADERS;

            typedef struct ANON_OBJECT_HEADER
            {
                WORD Sig1;
                WORD Sig2;
                WORD Version;
                WORD Machine;
                DWORD TimeDateStamp;
                CLSID ClassID;
                DWORD SizeOfData;
            } ANON_OBJECT_HEADER;

            typedef struct ANON_OBJECT_HEADER_V2
            {
                WORD Sig1;
                WORD Sig2;
                WORD Version;
                WORD Machine;
                DWORD TimeDateStamp;
                CLSID ClassID;
                DWORD SizeOfData;
                DWORD Flags;
                DWORD MetaDataSize;
                DWORD MetaDataOffset;
            } ANON_OBJECT_HEADER_V2;

            typedef struct ANON_OBJECT_HEADER_BIGOBJ
            {
                WORD Sig1;
                WORD Sig2;
                WORD Version;
                WORD Machine;
                DWORD TimeDateStamp;
                CLSID ClassID;
                DWORD SizeOfData;
                DWORD Flags;
                DWORD MetaDataSize;
                DWORD MetaDataOffset;

                DWORD NumberOfSections;
                DWORD PointerToSymbolTable;
                DWORD NumberOfSymbols;
            } ANON_OBJECT_HEADER_BIGOBJ;

            typedef struct _IMAGE_SECTION_HEADER
            {
                BYTE Name[8];
                union
                {
                    DWORD PhysicalAddress;
                    DWORD VirtualSize;
                } Misc;
                DWORD VirtualAddress;
                DWORD SizeOfRawData;
                DWORD PointerToRawData;
                DWORD PointerToRelocations;
                DWORD PointerToLinenumbers;
                WORD NumberOfRelocations;
                WORD NumberOfLinenumbers;
                DWORD Characteristics;
            } IMAGE_SECTION_HEADER, *PIMAGE_SECTION_HEADER;

#pragma warning(disable : 4103)

#pragma pack(push, 2)

            typedef struct _IMAGE_SYMBOL
            {
                union
                {
                    BYTE ShortName[8];
                    struct
                    {
                        DWORD Short;
                        DWORD Long;
                    } Name;
                    DWORD LongName[2];
                } N;
                DWORD Value;
                SHORT SectionNumber;
                WORD Type;
                BYTE StorageClass;
                BYTE NumberOfAuxSymbols;
            } IMAGE_SYMBOL;
            typedef IMAGE_SYMBOL __unaligned* PIMAGE_SYMBOL;

            typedef struct _IMAGE_SYMBOL_EX
            {
                union
                {
                    BYTE ShortName[8];
                    struct
                    {
                        DWORD Short;
                        DWORD Long;
                    } Name;
                    DWORD LongName[2];
                } N;
                DWORD Value;
                LONG SectionNumber;
                WORD Type;
                BYTE StorageClass;
                BYTE NumberOfAuxSymbols;
            } IMAGE_SYMBOL_EX;
            typedef IMAGE_SYMBOL_EX __unaligned* PIMAGE_SYMBOL_EX;

#pragma warning(disable : 4103)

#pragma pack(push, 2)

            typedef struct IMAGE_AUX_SYMBOL_TOKEN_DEF
            {
                BYTE bAuxType;
                BYTE bReserved;
                DWORD SymbolTableIndex;
                BYTE rgbReserved[12];
            } IMAGE_AUX_SYMBOL_TOKEN_DEF;

            typedef IMAGE_AUX_SYMBOL_TOKEN_DEF __unaligned* PIMAGE_AUX_SYMBOL_TOKEN_DEF;

#pragma warning(disable : 4103)

#pragma pack(pop)

            typedef union _IMAGE_AUX_SYMBOL
            {
                struct
                {
                    DWORD TagIndex;
                    union
                    {
                        struct
                        {
                            WORD Linenumber;
                            WORD Size;
                        } LnSz;
                        DWORD TotalSize;
                    } Misc;
                    union
                    {
                        struct
                        {
                            DWORD PointerToLinenumber;
                            DWORD PointerToNextFunction;
                        } Function;
                        struct
                        {
                            WORD Dimension[4];
                        } Array;
                    } FcnAry;
                    WORD TvIndex;
                } Sym;
                struct
                {
                    BYTE Name[18];
                } File;
                struct
                {
                    DWORD Length;
                    WORD NumberOfRelocations;
                    WORD NumberOfLinenumbers;
                    DWORD CheckSum;
                    SHORT Number;
                    BYTE Selection;
                    BYTE bReserved;
                    SHORT HighNumber;
                } Section;
                IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
                struct
                {
                    DWORD crc;
                    BYTE rgbReserved[14];
                } CRC;
            } IMAGE_AUX_SYMBOL;
            typedef IMAGE_AUX_SYMBOL __unaligned* PIMAGE_AUX_SYMBOL;

            typedef union _IMAGE_AUX_SYMBOL_EX
            {
                struct
                {
                    DWORD WeakDefaultSymIndex;
                    DWORD WeakSearchType;
                    BYTE rgbReserved[12];
                } Sym;
                struct
                {
                    BYTE Name[sizeof(IMAGE_SYMBOL_EX)];
                } File;
                struct
                {
                    DWORD Length;
                    WORD NumberOfRelocations;
                    WORD NumberOfLinenumbers;
                    DWORD CheckSum;
                    SHORT Number;
                    BYTE Selection;
                    BYTE bReserved;
                    SHORT HighNumber;
                    BYTE rgbReserved[2];
                } Section;
                struct
                {
                    IMAGE_AUX_SYMBOL_TOKEN_DEF TokenDef;
                    BYTE rgbReserved[2];
                };
                struct
                {
                    DWORD crc;
                    BYTE rgbReserved[16];
                } CRC;
            } IMAGE_AUX_SYMBOL_EX;
            typedef IMAGE_AUX_SYMBOL_EX __unaligned* PIMAGE_AUX_SYMBOL_EX;

            typedef enum IMAGE_AUX_SYMBOL_TYPE
            {
                IMAGE_AUX_SYMBOL_TYPE_TOKEN_DEF = 1,
            } IMAGE_AUX_SYMBOL_TYPE;

            typedef struct _IMAGE_RELOCATION
            {
                union
                {
                    DWORD VirtualAddress;
                    DWORD RelocCount;
                };
                DWORD SymbolTableIndex;
                WORD Type;
            } IMAGE_RELOCATION;
            typedef IMAGE_RELOCATION __unaligned* PIMAGE_RELOCATION;

            typedef struct _IMAGE_LINENUMBER
            {
                union
                {
                    DWORD SymbolTableIndex;
                    DWORD VirtualAddress;
                } Type;
                WORD Linenumber;
            } IMAGE_LINENUMBER;
            typedef IMAGE_LINENUMBER __unaligned* PIMAGE_LINENUMBER;

#pragma warning(disable : 4103)

#pragma pack(pop)

            typedef struct _IMAGE_BASE_RELOCATION
            {
                DWORD VirtualAddress;
                DWORD SizeOfBlock;

            } IMAGE_BASE_RELOCATION;
            typedef IMAGE_BASE_RELOCATION __unaligned* PIMAGE_BASE_RELOCATION;

            typedef struct _IMAGE_ARCHIVE_MEMBER_HEADER
            {
                BYTE Name[16];
                BYTE Date[12];
                BYTE UserID[6];
                BYTE GroupID[6];
                BYTE Mode[8];
                BYTE Size[10];
                BYTE EndHeader[2];
            } IMAGE_ARCHIVE_MEMBER_HEADER, *PIMAGE_ARCHIVE_MEMBER_HEADER;

            typedef struct _IMAGE_EXPORT_DIRECTORY
            {
                DWORD Characteristics;
                DWORD TimeDateStamp;
                WORD MajorVersion;
                WORD MinorVersion;
                DWORD Name;
                DWORD Base;
                DWORD NumberOfFunctions;
                DWORD NumberOfNames;
                DWORD AddressOfFunctions;
                DWORD AddressOfNames;
                DWORD AddressOfNameOrdinals;
            } IMAGE_EXPORT_DIRECTORY, *PIMAGE_EXPORT_DIRECTORY;

            typedef struct _IMAGE_IMPORT_BY_NAME
            {
                WORD Hint;
                CHAR Name[1];
            } IMAGE_IMPORT_BY_NAME, *PIMAGE_IMPORT_BY_NAME;

#pragma warning(disable : 4103)

#pragma pack(push, 8)

            typedef struct _IMAGE_THUNK_DATA64
            {
                union
                {
                    ULONGLONG ForwarderString;
                    ULONGLONG Function;
                    ULONGLONG Ordinal;
                    ULONGLONG AddressOfData;
                } u1;
            } IMAGE_THUNK_DATA64;
            typedef IMAGE_THUNK_DATA64* PIMAGE_THUNK_DATA64;

#pragma warning(disable : 4103)

#pragma pack(pop)

            typedef struct _IMAGE_THUNK_DATA32
            {
                union
                {
                    DWORD ForwarderString;
                    DWORD Function;
                    DWORD Ordinal;
                    DWORD AddressOfData;
                } u1;
            } IMAGE_THUNK_DATA32;
            typedef IMAGE_THUNK_DATA32* PIMAGE_THUNK_DATA32;

            typedef void(__stdcall* PIMAGE_TLS_CALLBACK)(PVOID DllHandle, DWORD Reason, PVOID Reserved);

            typedef struct _IMAGE_TLS_DIRECTORY64
            {
                ULONGLONG StartAddressOfRawData;
                ULONGLONG EndAddressOfRawData;
                ULONGLONG AddressOfIndex;
                ULONGLONG AddressOfCallBacks;
                DWORD SizeOfZeroFill;
                union
                {
                    DWORD Characteristics;
                    struct
                    {
                        DWORD Reserved0 : 20;
                        DWORD Alignment : 4;
                        DWORD Reserved1 : 8;
                    };
                };

            } IMAGE_TLS_DIRECTORY64;

            typedef IMAGE_TLS_DIRECTORY64* PIMAGE_TLS_DIRECTORY64;

            typedef struct _IMAGE_TLS_DIRECTORY32
            {
                DWORD StartAddressOfRawData;
                DWORD EndAddressOfRawData;
                DWORD AddressOfIndex;
                DWORD AddressOfCallBacks;
                DWORD SizeOfZeroFill;
                union
                {
                    DWORD Characteristics;
                    struct
                    {
                        DWORD Reserved0 : 20;
                        DWORD Alignment : 4;
                        DWORD Reserved1 : 8;
                    };
                };

            } IMAGE_TLS_DIRECTORY32;
            typedef IMAGE_TLS_DIRECTORY32* PIMAGE_TLS_DIRECTORY32;

            typedef IMAGE_THUNK_DATA64 IMAGE_THUNK_DATA;
            typedef PIMAGE_THUNK_DATA64 PIMAGE_THUNK_DATA;

            typedef IMAGE_TLS_DIRECTORY64 IMAGE_TLS_DIRECTORY;
            typedef PIMAGE_TLS_DIRECTORY64 PIMAGE_TLS_DIRECTORY;

            typedef struct _IMAGE_IMPORT_DESCRIPTOR
            {
                union
                {
                    DWORD Characteristics;
                    DWORD OriginalFirstThunk;
                };
                DWORD TimeDateStamp;

                DWORD ForwarderChain;
                DWORD Name;
                DWORD FirstThunk;
            } IMAGE_IMPORT_DESCRIPTOR;
            typedef IMAGE_IMPORT_DESCRIPTOR __unaligned* PIMAGE_IMPORT_DESCRIPTOR;

            typedef struct _IMAGE_BOUND_IMPORT_DESCRIPTOR
            {
                DWORD TimeDateStamp;
                WORD OffsetModuleName;
                WORD NumberOfModuleForwarderRefs;

            } IMAGE_BOUND_IMPORT_DESCRIPTOR, *PIMAGE_BOUND_IMPORT_DESCRIPTOR;

            typedef struct _IMAGE_BOUND_FORWARDER_REF
            {
                DWORD TimeDateStamp;
                WORD OffsetModuleName;
                WORD Reserved;
            } IMAGE_BOUND_FORWARDER_REF, *PIMAGE_BOUND_FORWARDER_REF;

            typedef struct _IMAGE_DELAYLOAD_DESCRIPTOR
            {
                union
                {
                    DWORD AllAttributes;
                    struct
                    {
                        DWORD RvaBased : 1;
                        DWORD ReservedAttributes : 31;
                    };
                } Attributes;

                DWORD DllNameRVA;
                DWORD ModuleHandleRVA;
                DWORD ImportAddressTableRVA;
                DWORD ImportNameTableRVA;
                DWORD BoundImportAddressTableRVA;
                DWORD UnloadInformationTableRVA;
                DWORD TimeDateStamp;

            } IMAGE_DELAYLOAD_DESCRIPTOR, *PIMAGE_DELAYLOAD_DESCRIPTOR;

            typedef const IMAGE_DELAYLOAD_DESCRIPTOR* PCIMAGE_DELAYLOAD_DESCRIPTOR;

            typedef struct _IMAGE_RESOURCE_DIRECTORY
            {
                DWORD Characteristics;
                DWORD TimeDateStamp;
                WORD MajorVersion;
                WORD MinorVersion;
                WORD NumberOfNamedEntries;
                WORD NumberOfIdEntries;

            } IMAGE_RESOURCE_DIRECTORY, *PIMAGE_RESOURCE_DIRECTORY;

            typedef struct _IMAGE_RESOURCE_DIRECTORY_ENTRY
            {
                union
                {
                    struct
                    {
                        DWORD NameOffset : 31;
                        DWORD NameIsString : 1;
                    };
                    DWORD Name;
                    WORD Id;
                };
                union
                {
                    DWORD OffsetToData;
                    struct
                    {
                        DWORD OffsetToDirectory : 31;
                        DWORD DataIsDirectory : 1;
                    };
                };
            } IMAGE_RESOURCE_DIRECTORY_ENTRY, *PIMAGE_RESOURCE_DIRECTORY_ENTRY;

            typedef struct _IMAGE_RESOURCE_DIRECTORY_STRING
            {
                WORD Length;
                CHAR NameString[1];
            } IMAGE_RESOURCE_DIRECTORY_STRING, *PIMAGE_RESOURCE_DIRECTORY_STRING;

            typedef struct _IMAGE_RESOURCE_DIR_STRING_U
            {
                WORD Length;
                WCHAR NameString[1];
            } IMAGE_RESOURCE_DIR_STRING_U, *PIMAGE_RESOURCE_DIR_STRING_U;

            typedef struct _IMAGE_RESOURCE_DATA_ENTRY
            {
                DWORD OffsetToData;
                DWORD Size;
                DWORD CodePage;
                DWORD Reserved;
            } IMAGE_RESOURCE_DATA_ENTRY, *PIMAGE_RESOURCE_DATA_ENTRY;

            typedef struct _IMAGE_LOAD_CONFIG_CODE_INTEGRITY
            {
                WORD Flags;
                WORD Catalog;
                DWORD CatalogOffset;
                DWORD Reserved;
            } IMAGE_LOAD_CONFIG_CODE_INTEGRITY, *PIMAGE_LOAD_CONFIG_CODE_INTEGRITY;

            typedef struct _IMAGE_DYNAMIC_RELOCATION_TABLE
            {
                DWORD Version;
                DWORD Size;

            } IMAGE_DYNAMIC_RELOCATION_TABLE, *PIMAGE_DYNAMIC_RELOCATION_TABLE;

#pragma warning(disable : 4103)

#pragma pack(push, 1)

            typedef struct _IMAGE_DYNAMIC_RELOCATION32
            {
                DWORD Symbol;
                DWORD BaseRelocSize;

            } IMAGE_DYNAMIC_RELOCATION32, *PIMAGE_DYNAMIC_RELOCATION32;

            typedef struct _IMAGE_DYNAMIC_RELOCATION64
            {
                ULONGLONG Symbol;
                DWORD BaseRelocSize;

            } IMAGE_DYNAMIC_RELOCATION64, *PIMAGE_DYNAMIC_RELOCATION64;

            typedef struct _IMAGE_DYNAMIC_RELOCATION32_V2
            {
                DWORD HeaderSize;
                DWORD FixupInfoSize;
                DWORD Symbol;
                DWORD SymbolGroup;
                DWORD Flags;

            } IMAGE_DYNAMIC_RELOCATION32_V2, *PIMAGE_DYNAMIC_RELOCATION32_V2;

            typedef struct _IMAGE_DYNAMIC_RELOCATION64_V2
            {
                DWORD HeaderSize;
                DWORD FixupInfoSize;
                ULONGLONG Symbol;
                DWORD SymbolGroup;
                DWORD Flags;

            } IMAGE_DYNAMIC_RELOCATION64_V2, *PIMAGE_DYNAMIC_RELOCATION64_V2;

#pragma warning(disable : 4103)

#pragma pack(pop)

            typedef IMAGE_DYNAMIC_RELOCATION64 IMAGE_DYNAMIC_RELOCATION;
            typedef PIMAGE_DYNAMIC_RELOCATION64 PIMAGE_DYNAMIC_RELOCATION;
            typedef IMAGE_DYNAMIC_RELOCATION64_V2 IMAGE_DYNAMIC_RELOCATION_V2;
            typedef PIMAGE_DYNAMIC_RELOCATION64_V2 PIMAGE_DYNAMIC_RELOCATION_V2;

#pragma warning(disable : 4103)

#pragma pack(push, 1)

            typedef struct _IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER
            {
                BYTE PrologueByteCount;

            } IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;
            typedef IMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER __unaligned* PIMAGE_PROLOGUE_DYNAMIC_RELOCATION_HEADER;

            typedef struct _IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER
            {
                DWORD EpilogueCount;
                BYTE EpilogueByteCount;
                BYTE BranchDescriptorElementSize;
                WORD BranchDescriptorCount;

            } IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;
            typedef IMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER __unaligned* PIMAGE_EPILOGUE_DYNAMIC_RELOCATION_HEADER;

            typedef struct _IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION
            {
                DWORD PageRelativeOffset : 12;
                DWORD IndirectCall : 1;
                DWORD IATIndex : 19;
            } IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
            typedef IMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION __unaligned* PIMAGE_IMPORT_CONTROL_TRANSFER_DYNAMIC_RELOCATION;

            typedef struct _IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION
            {
                WORD PageRelativeOffset : 12;
                WORD IndirectCall : 1;
                WORD RexWPrefix : 1;
                WORD CfgCheck : 1;
                WORD Reserved : 1;
            } IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;
            typedef IMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION __unaligned* PIMAGE_INDIR_CONTROL_TRANSFER_DYNAMIC_RELOCATION;

            typedef struct _IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION
            {
                WORD PageRelativeOffset : 12;
                WORD RegisterNumber : 4;
            } IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;
            typedef IMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION __unaligned* PIMAGE_SWITCHTABLE_BRANCH_DYNAMIC_RELOCATION;

#pragma warning(disable : 4103)

#pragma pack(pop)

            typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY32
            {
                DWORD Size;
                DWORD TimeDateStamp;
                WORD MajorVersion;
                WORD MinorVersion;
                DWORD GlobalFlagsClear;
                DWORD GlobalFlagsSet;
                DWORD CriticalSectionDefaultTimeout;
                DWORD DeCommitFreeBlockThreshold;
                DWORD DeCommitTotalFreeThreshold;
                DWORD LockPrefixTable;
                DWORD MaximumAllocationSize;
                DWORD VirtualMemoryThreshold;
                DWORD ProcessHeapFlags;
                DWORD ProcessAffinityMask;
                WORD CSDVersion;
                WORD DependentLoadFlags;
                DWORD EditList;
                DWORD SecurityCookie;
                DWORD SEHandlerTable;
                DWORD SEHandlerCount;
                DWORD GuardCFCheckFunctionPointer;
                DWORD GuardCFDispatchFunctionPointer;
                DWORD GuardCFFunctionTable;
                DWORD GuardCFFunctionCount;
                DWORD GuardFlags;
                IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
                DWORD GuardAddressTakenIatEntryTable;
                DWORD GuardAddressTakenIatEntryCount;
                DWORD GuardLongJumpTargetTable;
                DWORD GuardLongJumpTargetCount;
                DWORD DynamicValueRelocTable;
                DWORD CHPEMetadataPointer;
                DWORD GuardRFFailureRoutine;
                DWORD GuardRFFailureRoutineFunctionPointer;
                DWORD DynamicValueRelocTableOffset;
                WORD DynamicValueRelocTableSection;
                WORD Reserved2;
                DWORD GuardRFVerifyStackPointerFunctionPointer;
                DWORD HotPatchTableOffset;
                DWORD Reserved3;
                DWORD EnclaveConfigurationPointer;
                DWORD VolatileMetadataPointer;
            } IMAGE_LOAD_CONFIG_DIRECTORY32, *PIMAGE_LOAD_CONFIG_DIRECTORY32;

            typedef struct _IMAGE_LOAD_CONFIG_DIRECTORY64
            {
                DWORD Size;
                DWORD TimeDateStamp;
                WORD MajorVersion;
                WORD MinorVersion;
                DWORD GlobalFlagsClear;
                DWORD GlobalFlagsSet;
                DWORD CriticalSectionDefaultTimeout;
                ULONGLONG DeCommitFreeBlockThreshold;
                ULONGLONG DeCommitTotalFreeThreshold;
                ULONGLONG LockPrefixTable;
                ULONGLONG MaximumAllocationSize;
                ULONGLONG VirtualMemoryThreshold;
                ULONGLONG ProcessAffinityMask;
                DWORD ProcessHeapFlags;
                WORD CSDVersion;
                WORD DependentLoadFlags;
                ULONGLONG EditList;
                ULONGLONG SecurityCookie;
                ULONGLONG SEHandlerTable;
                ULONGLONG SEHandlerCount;
                ULONGLONG GuardCFCheckFunctionPointer;
                ULONGLONG GuardCFDispatchFunctionPointer;
                ULONGLONG GuardCFFunctionTable;
                ULONGLONG GuardCFFunctionCount;
                DWORD GuardFlags;
                IMAGE_LOAD_CONFIG_CODE_INTEGRITY CodeIntegrity;
                ULONGLONG GuardAddressTakenIatEntryTable;
                ULONGLONG GuardAddressTakenIatEntryCount;
                ULONGLONG GuardLongJumpTargetTable;
                ULONGLONG GuardLongJumpTargetCount;
                ULONGLONG DynamicValueRelocTable;
                ULONGLONG CHPEMetadataPointer;
                ULONGLONG GuardRFFailureRoutine;
                ULONGLONG GuardRFFailureRoutineFunctionPointer;
                DWORD DynamicValueRelocTableOffset;
                WORD DynamicValueRelocTableSection;
                WORD Reserved2;
                ULONGLONG GuardRFVerifyStackPointerFunctionPointer;
                DWORD HotPatchTableOffset;
                DWORD Reserved3;
                ULONGLONG EnclaveConfigurationPointer;
                ULONGLONG VolatileMetadataPointer;
            } IMAGE_LOAD_CONFIG_DIRECTORY64, *PIMAGE_LOAD_CONFIG_DIRECTORY64;

            typedef IMAGE_LOAD_CONFIG_DIRECTORY64 IMAGE_LOAD_CONFIG_DIRECTORY;
            typedef PIMAGE_LOAD_CONFIG_DIRECTORY64 PIMAGE_LOAD_CONFIG_DIRECTORY;

            typedef struct _IMAGE_HOT_PATCH_INFO
            {
                DWORD Version;
                DWORD Size;
                DWORD SequenceNumber;
                DWORD BaseImageList;
                DWORD BaseImageCount;
                DWORD BufferOffset;
                DWORD ExtraPatchSize;
            } IMAGE_HOT_PATCH_INFO, *PIMAGE_HOT_PATCH_INFO;

            typedef struct _IMAGE_HOT_PATCH_BASE
            {
                DWORD SequenceNumber;
                DWORD Flags;
                DWORD OriginalTimeDateStamp;
                DWORD OriginalCheckSum;
                DWORD CodeIntegrityInfo;
                DWORD CodeIntegritySize;
                DWORD PatchTable;
                DWORD BufferOffset;
            } IMAGE_HOT_PATCH_BASE, *PIMAGE_HOT_PATCH_BASE;

            typedef struct _IMAGE_HOT_PATCH_HASHES
            {
                BYTE SHA256[32];
                BYTE SHA1[20];
            } IMAGE_HOT_PATCH_HASHES, *PIMAGE_HOT_PATCH_HASHES;

            typedef struct _IMAGE_CE_RUNTIME_FUNCTION_ENTRY
            {
                DWORD FuncStart;
                DWORD PrologLen : 8;
                DWORD FuncLen : 22;
                DWORD ThirtyTwoBit : 1;
                DWORD ExceptionFlag : 1;
            } IMAGE_CE_RUNTIME_FUNCTION_ENTRY, *PIMAGE_CE_RUNTIME_FUNCTION_ENTRY;

            typedef struct _IMAGE_ARM_RUNTIME_FUNCTION_ENTRY
            {
                DWORD BeginAddress;
                union
                {
                    DWORD UnwindData;
                    struct
                    {
                        DWORD Flag : 2;
                        DWORD FunctionLength : 11;
                        DWORD Ret : 2;
                        DWORD H : 1;
                        DWORD Reg : 3;
                        DWORD R : 1;
                        DWORD L : 1;
                        DWORD C : 1;
                        DWORD StackAdjust : 10;
                    };
                };
            } IMAGE_ARM_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ARM_RUNTIME_FUNCTION_ENTRY;

            typedef struct _IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY
            {
                DWORD BeginAddress;
                union
                {
                    DWORD UnwindData;
                    struct
                    {
                        DWORD Flag : 2;
                        DWORD FunctionLength : 11;
                        DWORD RegF : 3;
                        DWORD RegI : 4;
                        DWORD H : 1;
                        DWORD CR : 2;
                        DWORD FrameSize : 9;
                    };
                };
            } IMAGE_ARM64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ARM64_RUNTIME_FUNCTION_ENTRY;

            typedef struct _IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY
            {
                ULONGLONG BeginAddress;
                ULONGLONG EndAddress;
                ULONGLONG ExceptionHandler;
                ULONGLONG HandlerData;
                ULONGLONG PrologEndAddress;
            } IMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA64_RUNTIME_FUNCTION_ENTRY;

            typedef struct _IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY
            {
                DWORD BeginAddress;
                DWORD EndAddress;
                DWORD ExceptionHandler;
                DWORD HandlerData;
                DWORD PrologEndAddress;
            } IMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY, *PIMAGE_ALPHA_RUNTIME_FUNCTION_ENTRY;

            typedef struct _IMAGE_RUNTIME_FUNCTION_ENTRY
            {
                DWORD BeginAddress;
                DWORD EndAddress;
                union
                {
                    DWORD UnwindInfoAddress;
                    DWORD UnwindData;
                };
            } _IMAGE_RUNTIME_FUNCTION_ENTRY, *_PIMAGE_RUNTIME_FUNCTION_ENTRY;

            typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_IA64_RUNTIME_FUNCTION_ENTRY;
            typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_IA64_RUNTIME_FUNCTION_ENTRY;

            typedef _IMAGE_RUNTIME_FUNCTION_ENTRY IMAGE_RUNTIME_FUNCTION_ENTRY;
            typedef _PIMAGE_RUNTIME_FUNCTION_ENTRY PIMAGE_RUNTIME_FUNCTION_ENTRY;

            typedef struct _IMAGE_ENCLAVE_CONFIG32
            {
                DWORD Size;
                DWORD MinimumRequiredConfigSize;
                DWORD PolicyFlags;
                DWORD NumberOfImports;
                DWORD ImportList;
                DWORD ImportEntrySize;
                BYTE FamilyID[16];
                BYTE ImageID[16];
                DWORD ImageVersion;
                DWORD SecurityVersion;
                DWORD EnclaveSize;
                DWORD NumberOfThreads;
                DWORD EnclaveFlags;
            } IMAGE_ENCLAVE_CONFIG32, *PIMAGE_ENCLAVE_CONFIG32;

            typedef struct _IMAGE_ENCLAVE_CONFIG64
            {
                DWORD Size;
                DWORD MinimumRequiredConfigSize;
                DWORD PolicyFlags;
                DWORD NumberOfImports;
                DWORD ImportList;
                DWORD ImportEntrySize;
                BYTE FamilyID[16];
                BYTE ImageID[16];
                DWORD ImageVersion;
                DWORD SecurityVersion;
                ULONGLONG EnclaveSize;
                DWORD NumberOfThreads;
                DWORD EnclaveFlags;
            } IMAGE_ENCLAVE_CONFIG64, *PIMAGE_ENCLAVE_CONFIG64;

            typedef IMAGE_ENCLAVE_CONFIG64 IMAGE_ENCLAVE_CONFIG;
            typedef PIMAGE_ENCLAVE_CONFIG64 PIMAGE_ENCLAVE_CONFIG;

            typedef struct _IMAGE_ENCLAVE_IMPORT
            {
                DWORD MatchType;
                DWORD MinimumSecurityVersion;
                BYTE UniqueOrAuthorID[32];
                BYTE FamilyID[16];
                BYTE ImageID[16];
                DWORD ImportName;
                DWORD Reserved;
            } IMAGE_ENCLAVE_IMPORT, *PIMAGE_ENCLAVE_IMPORT;

            typedef struct _IMAGE_DEBUG_DIRECTORY
            {
                DWORD Characteristics;
                DWORD TimeDateStamp;
                WORD MajorVersion;
                WORD MinorVersion;
                DWORD Type;
                DWORD SizeOfData;
                DWORD AddressOfRawData;
                DWORD PointerToRawData;
            } IMAGE_DEBUG_DIRECTORY, *PIMAGE_DEBUG_DIRECTORY;

            typedef struct _IMAGE_COFF_SYMBOLS_HEADER
            {
                DWORD NumberOfSymbols;
                DWORD LvaToFirstSymbol;
                DWORD NumberOfLinenumbers;
                DWORD LvaToFirstLinenumber;
                DWORD RvaToFirstByteOfCode;
                DWORD RvaToLastByteOfCode;
                DWORD RvaToFirstByteOfData;
                DWORD RvaToLastByteOfData;
            } IMAGE_COFF_SYMBOLS_HEADER, *PIMAGE_COFF_SYMBOLS_HEADER;

            typedef struct _FPO_DATA
            {
                DWORD ulOffStart;
                DWORD cbProcSize;
                DWORD cdwLocals;
                WORD cdwParams;
                WORD cbProlog : 8;
                WORD cbRegs : 3;
                WORD fHasSEH : 1;
                WORD fUseBP : 1;
                WORD reserved : 1;
                WORD cbFrame : 2;
            } FPO_DATA, *PFPO_DATA;

            typedef struct _IMAGE_DEBUG_MISC
            {
                DWORD DataType;
                DWORD Length;

                BOOLEAN Unicode;
                BYTE Reserved[3];
                BYTE Data[1];
            } IMAGE_DEBUG_MISC, *PIMAGE_DEBUG_MISC;

            typedef struct _IMAGE_FUNCTION_ENTRY
            {
                DWORD StartingAddress;
                DWORD EndingAddress;
                DWORD EndOfPrologue;
            } IMAGE_FUNCTION_ENTRY, *PIMAGE_FUNCTION_ENTRY;

            typedef struct _IMAGE_FUNCTION_ENTRY64
            {
                ULONGLONG StartingAddress;
                ULONGLONG EndingAddress;
                union
                {
                    ULONGLONG EndOfPrologue;
                    ULONGLONG UnwindInfoAddress;
                };
            } IMAGE_FUNCTION_ENTRY64, *PIMAGE_FUNCTION_ENTRY64;

            typedef struct _IMAGE_SEPARATE_DEBUG_HEADER
            {
                WORD Signature;
                WORD Flags;
                WORD Machine;
                WORD Characteristics;
                DWORD TimeDateStamp;
                DWORD CheckSum;
                DWORD ImageBase;
                DWORD SizeOfImage;
                DWORD NumberOfSections;
                DWORD ExportedNamesSize;
                DWORD DebugDirectorySize;
                DWORD SectionAlignment;
                DWORD Reserved[2];
            } IMAGE_SEPARATE_DEBUG_HEADER, *PIMAGE_SEPARATE_DEBUG_HEADER;

            typedef struct _NON_PAGED_DEBUG_INFO
            {
                WORD Signature;
                WORD Flags;
                DWORD Size;
                WORD Machine;
                WORD Characteristics;
                DWORD TimeDateStamp;
                DWORD CheckSum;
                DWORD SizeOfImage;
                ULONGLONG ImageBase;

            } NON_PAGED_DEBUG_INFO, *PNON_PAGED_DEBUG_INFO;

            typedef struct _ImageArchitectureHeader
            {
                unsigned int AmaskValue : 1;

                int : 7;
                unsigned int AmaskShift : 8;
                int : 16;
                DWORD FirstEntryRVA;
            } IMAGE_ARCHITECTURE_HEADER, *PIMAGE_ARCHITECTURE_HEADER;

            typedef struct _ImageArchitectureEntry
            {
                DWORD FixupInstRVA;
                DWORD NewInst;
            } IMAGE_ARCHITECTURE_ENTRY, *PIMAGE_ARCHITECTURE_ENTRY;

#pragma warning(disable : 4103)

#pragma pack(pop)

            typedef struct IMPORT_OBJECT_HEADER
            {
                WORD Sig1;
                WORD Sig2;
                WORD Version;
                WORD Machine;
                DWORD TimeDateStamp;
                DWORD SizeOfData;

                union
                {
                    WORD Ordinal;
                    WORD Hint;
                };

                WORD Type : 2;
                WORD NameType : 3;
                WORD Reserved : 11;
            } IMPORT_OBJECT_HEADER;

            typedef enum IMPORT_OBJECT_TYPE
            {
                IMPORT_OBJECT_CODE = 0,
                IMPORT_OBJECT_DATA = 1,
                IMPORT_OBJECT_CONST = 2,
            } IMPORT_OBJECT_TYPE;

            typedef enum IMPORT_OBJECT_NAME_TYPE
            {
                IMPORT_OBJECT_ORDINAL = 0,
                IMPORT_OBJECT_NAME = 1,
                IMPORT_OBJECT_NAME_NO_PREFIX = 2,
                IMPORT_OBJECT_NAME_UNDECORATE = 3,

                IMPORT_OBJECT_NAME_EXPORTAS = 4,
            } IMPORT_OBJECT_NAME_TYPE;

            typedef enum ReplacesCorHdrNumericDefines
            {

                COMIMAGE_FLAGS_ILONLY = 0x00000001,
                COMIMAGE_FLAGS_32BITREQUIRED = 0x00000002,
                COMIMAGE_FLAGS_IL_LIBRARY = 0x00000004,
                COMIMAGE_FLAGS_STRONGNAMESIGNED = 0x00000008,
                COMIMAGE_FLAGS_NATIVE_ENTRYPOINT = 0x00000010,
                COMIMAGE_FLAGS_TRACKDEBUGDATA = 0x00010000,
                COMIMAGE_FLAGS_32BITPREFERRED = 0x00020000,

                COR_VERSION_MAJOR_V2 = 2,
                COR_VERSION_MAJOR = COR_VERSION_MAJOR_V2,
                COR_VERSION_MINOR = 5,
                COR_DELETED_NAME_LENGTH = 8,
                COR_VTABLEGAP_NAME_LENGTH = 8,

                NATIVE_TYPE_MAX_CB = 1,
                COR_ILMETHOD_SECT_SMALL_MAX_DATASIZE = 0xFF,

                IMAGE_COR_MIH_METHODRVA = 0x01,
                IMAGE_COR_MIH_EHRVA = 0x02,
                IMAGE_COR_MIH_BASICBLOCK = 0x08,

                COR_VTABLE_32BIT = 0x01,
                COR_VTABLE_64BIT = 0x02,
                COR_VTABLE_FROM_UNMANAGED = 0x04,
                COR_VTABLE_FROM_UNMANAGED_RETAIN_APPDOMAIN = 0x08,
                COR_VTABLE_CALL_MOST_DERIVED = 0x10,

                IMAGE_COR_EATJ_THUNK_SIZE = 32,

                MAX_CLASS_NAME = 1024,
                MAX_PACKAGE_NAME = 1024,
            } ReplacesCorHdrNumericDefines;

            typedef struct IMAGE_COR20_HEADER
            {
                DWORD cb;
                WORD MajorRuntimeVersion;
                WORD MinorRuntimeVersion;

                IMAGE_DATA_DIRECTORY MetaData;
                DWORD Flags;

                union
                {
                    DWORD EntryPointToken;
                    DWORD EntryPointRVA;
                };

                IMAGE_DATA_DIRECTORY Resources;
                IMAGE_DATA_DIRECTORY StrongNameSignature;

                IMAGE_DATA_DIRECTORY CodeManagerTable;
                IMAGE_DATA_DIRECTORY VTableFixups;
                IMAGE_DATA_DIRECTORY ExportAddressTableJumps;

                IMAGE_DATA_DIRECTORY ManagedNativeHeader;

            } IMAGE_COR20_HEADER, *PIMAGE_COR20_HEADER;

#pragma region Application or OneCore Family

            __declspec(dllimport)

            WORD __stdcall RtlCaptureStackBackTrace(DWORD FramesToSkip, DWORD FramesToCapture, PVOID* BackTrace, PDWORD BackTraceHash);

#pragma endregion

#pragma region Desktop Family or OneCore Family

            __declspec(dllimport) void __stdcall RtlCaptureContext(PCONTEXT ContextRecord);

#pragma endregion

#pragma region Application or OneCore Family

            __declspec(dllimport) void __stdcall RtlUnwind(PVOID TargetFrame, PVOID TargetIp, PEXCEPTION_RECORD ExceptionRecord, PVOID ReturnValue);

#pragma endregion

#pragma region Desktop Family or OneCore Family

            __declspec(dllimport) BOOLEAN
            __cdecl RtlAddFunctionTable(PRUNTIME_FUNCTION FunctionTable, DWORD EntryCount, DWORD64 BaseAddress);

            __declspec(dllimport) BOOLEAN __cdecl RtlDeleteFunctionTable(PRUNTIME_FUNCTION FunctionTable);

            __declspec(dllimport) BOOLEAN __cdecl RtlInstallFunctionTableCallback(DWORD64 TableIdentifier,
                                                                                  DWORD64 BaseAddress,
                                                                                  DWORD Length,
                                                                                  PGET_RUNTIME_FUNCTION_CALLBACK Callback,
                                                                                  PVOID Context,
                                                                                  PCWSTR OutOfProcessCallbackDll);

            __declspec(dllimport) DWORD __stdcall RtlAddGrowableFunctionTable(PVOID* DynamicTable,
                                                                              PRUNTIME_FUNCTION FunctionTable,
                                                                              DWORD EntryCount,
                                                                              DWORD MaximumEntryCount,
                                                                              ULONG_PTR RangeBase,
                                                                              ULONG_PTR RangeEnd);

            __declspec(dllimport) void __stdcall RtlGrowFunctionTable(PVOID DynamicTable, DWORD NewEntryCount);

            __declspec(dllimport) void __stdcall RtlDeleteGrowableFunctionTable(PVOID DynamicTable);

#pragma endregion

#pragma region Application or OneCore Family

            __declspec(dllimport) PRUNTIME_FUNCTION
            __stdcall RtlLookupFunctionEntry(DWORD64 ControlPc, PDWORD64 ImageBase, PUNWIND_HISTORY_TABLE HistoryTable);

#pragma endregion

#pragma region Desktop Family or OneCore Family

            __declspec(dllimport) void __cdecl RtlRestoreContext(PCONTEXT ContextRecord, struct _EXCEPTION_RECORD* ExceptionRecord);

#pragma endregion

#pragma region Application or OneCore Family

            __declspec(dllimport) void __stdcall RtlUnwindEx(PVOID TargetFrame,
                                                             PVOID TargetIp,
                                                             PEXCEPTION_RECORD ExceptionRecord,
                                                             PVOID ReturnValue,
                                                             PCONTEXT ContextRecord,
                                                             PUNWIND_HISTORY_TABLE HistoryTable);

            __declspec(dllimport) PEXCEPTION_ROUTINE __stdcall RtlVirtualUnwind(DWORD HandlerType,
                                                                                DWORD64 ImageBase,
                                                                                DWORD64 ControlPc,
                                                                                PRUNTIME_FUNCTION FunctionEntry,
                                                                                PCONTEXT ContextRecord,
                                                                                PVOID* HandlerData,
                                                                                PDWORD64 EstablisherFrame,
                                                                                PKNONVOLATILE_CONTEXT_POINTERS ContextPointers);

#pragma endregion

#pragma region Application or OneCore Family

            __declspec(dllimport) PVOID __stdcall RtlPcToFileHeader(PVOID PcValue, PVOID* BaseOfImage);

#pragma endregion

#pragma region Desktop Family or OneCore Family

            __declspec(dllimport) SIZE_T __stdcall RtlCompareMemory(const void* Source1, const void* Source2, SIZE_T Length);

#pragma endregion

#pragma warning(push)
#pragma warning(disable : 4324)

            typedef struct __declspec(align(16)) _SLIST_ENTRY
            {
                struct _SLIST_ENTRY* Next;
            } SLIST_ENTRY, *PSLIST_ENTRY;

#pragma warning(pop)

            typedef union __declspec(align(16)) _SLIST_HEADER
            {
                struct
                {
                    ULONGLONG Alignment;
                    ULONGLONG Region;
                };
                struct
                {
                    ULONGLONG Depth : 16;
                    ULONGLONG Sequence : 48;
                    ULONGLONG Reserved : 4;
                    ULONGLONG NextEntry : 60;
                } HeaderX64;
            } SLIST_HEADER, *PSLIST_HEADER;

#pragma region Desktop Family or OneCore Family

            __declspec(dllimport) void __stdcall RtlInitializeSListHead(PSLIST_HEADER ListHead);

            __declspec(dllimport) PSLIST_ENTRY __stdcall RtlFirstEntrySList(const SLIST_HEADER* ListHead);

            __declspec(dllimport) PSLIST_ENTRY __stdcall RtlInterlockedPopEntrySList(PSLIST_HEADER ListHead);

            __declspec(dllimport) PSLIST_ENTRY
            __stdcall RtlInterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);

            __declspec(dllimport) PSLIST_ENTRY
            __stdcall RtlInterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, DWORD Count);

            __declspec(dllimport) PSLIST_ENTRY __stdcall RtlInterlockedFlushSList(PSLIST_HEADER ListHead);

            __declspec(dllimport) WORD __stdcall RtlQueryDepthSList(PSLIST_HEADER ListHead);

#pragma endregion

            typedef union _RTL_RUN_ONCE
            {
                PVOID Ptr;
            } RTL_RUN_ONCE, *PRTL_RUN_ONCE;

            typedef struct _RTL_BARRIER
            {
                DWORD Reserved1;
                DWORD Reserved2;
                ULONG_PTR Reserved3[2];
                DWORD Reserved4;
                DWORD Reserved5;
            } RTL_BARRIER, *PRTL_BARRIER;

            __declspec(noreturn) void __fastfail(unsigned int Code);

#pragma intrinsic(__fastfail)

#pragma region Desktop Family

            __forceinline DWORD HEAP_MAKE_TAG_FLAGS(DWORD TagBase, DWORD Tag)

            {
                return ((DWORD)((TagBase) + ((Tag) << 18)));
            }
#pragma endregion

            __forceinline PVOID RtlSecureZeroMemory(PVOID ptr, SIZE_T cnt)
            {
                volatile char* vptr = (volatile char*)ptr;

                __stosb((PBYTE)((DWORD64)vptr), 0, cnt);

                return ptr;
            }

            typedef struct _MESSAGE_RESOURCE_ENTRY
            {
                WORD Length;
                WORD Flags;
                BYTE Text[1];
            } MESSAGE_RESOURCE_ENTRY, *PMESSAGE_RESOURCE_ENTRY;

            typedef struct _MESSAGE_RESOURCE_BLOCK
            {
                DWORD LowId;
                DWORD HighId;
                DWORD OffsetToEntries;
            } MESSAGE_RESOURCE_BLOCK, *PMESSAGE_RESOURCE_BLOCK;

            typedef struct _MESSAGE_RESOURCE_DATA
            {
                DWORD NumberOfBlocks;
                MESSAGE_RESOURCE_BLOCK Blocks[1];
            } MESSAGE_RESOURCE_DATA, *PMESSAGE_RESOURCE_DATA;

            typedef struct _OSVERSIONINFOA
            {
                DWORD dwOSVersionInfoSize;
                DWORD dwMajorVersion;
                DWORD dwMinorVersion;
                DWORD dwBuildNumber;
                DWORD dwPlatformId;
                CHAR szCSDVersion[128];
            } OSVERSIONINFOA, *POSVERSIONINFOA, *LPOSVERSIONINFOA;

            typedef struct _OSVERSIONINFOW
            {
                DWORD dwOSVersionInfoSize;
                DWORD dwMajorVersion;
                DWORD dwMinorVersion;
                DWORD dwBuildNumber;
                DWORD dwPlatformId;
                WCHAR szCSDVersion[128];
            } OSVERSIONINFOW, *POSVERSIONINFOW, *LPOSVERSIONINFOW, RTL_OSVERSIONINFOW, *PRTL_OSVERSIONINFOW;

            typedef OSVERSIONINFOA OSVERSIONINFO;
            typedef POSVERSIONINFOA POSVERSIONINFO;
            typedef LPOSVERSIONINFOA LPOSVERSIONINFO;

            typedef struct _OSVERSIONINFOEXA
            {
                DWORD dwOSVersionInfoSize;
                DWORD dwMajorVersion;
                DWORD dwMinorVersion;
                DWORD dwBuildNumber;
                DWORD dwPlatformId;
                CHAR szCSDVersion[128];
                WORD wServicePackMajor;
                WORD wServicePackMinor;
                WORD wSuiteMask;
                BYTE wProductType;
                BYTE wReserved;
            } OSVERSIONINFOEXA, *POSVERSIONINFOEXA, *LPOSVERSIONINFOEXA;
            typedef struct _OSVERSIONINFOEXW
            {
                DWORD dwOSVersionInfoSize;
                DWORD dwMajorVersion;
                DWORD dwMinorVersion;
                DWORD dwBuildNumber;
                DWORD dwPlatformId;
                WCHAR szCSDVersion[128];
                WORD wServicePackMajor;
                WORD wServicePackMinor;
                WORD wSuiteMask;
                BYTE wProductType;
                BYTE wReserved;
            } OSVERSIONINFOEXW, *POSVERSIONINFOEXW, *LPOSVERSIONINFOEXW, RTL_OSVERSIONINFOEXW, *PRTL_OSVERSIONINFOEXW;

            typedef OSVERSIONINFOEXA OSVERSIONINFOEX;
            typedef POSVERSIONINFOEXA POSVERSIONINFOEX;
            typedef LPOSVERSIONINFOEXA LPOSVERSIONINFOEX;

#pragma region Desktop Family or OneCore Family

            __declspec(dllimport) ULONGLONG __stdcall VerSetConditionMask(ULONGLONG ConditionMask, DWORD TypeMask, BYTE Condition);

#pragma endregion

#pragma region Desktop Family or OneCore Family

            __declspec(dllimport) BOOLEAN
            __stdcall RtlGetProductInfo(DWORD OSMajorVersion, DWORD OSMinorVersion, DWORD SpMajorVersion, DWORD SpMinorVersion, PDWORD ReturnedProductType);

#pragma endregion

            typedef enum _RTL_UMS_THREAD_INFO_CLASS
            {
                UmsThreadInvalidInfoClass = 0,
                UmsThreadUserContext,
                UmsThreadPriority,
                UmsThreadAffinity,
                UmsThreadTeb,
                UmsThreadIsSuspended,
                UmsThreadIsTerminated,
                UmsThreadMaxInfoClass
            } RTL_UMS_THREAD_INFO_CLASS,
            *PRTL_UMS_THREAD_INFO_CLASS;

            typedef enum _RTL_UMS_SCHEDULER_REASON
            {
                UmsSchedulerStartup = 0,
                UmsSchedulerThreadBlocked,
                UmsSchedulerThreadYield,
            } RTL_UMS_SCHEDULER_REASON,
            *PRTL_UMS_SCHEDULER_REASON;

            typedef

            void __stdcall RTL_UMS_SCHEDULER_ENTRY_POINT(RTL_UMS_SCHEDULER_REASON Reason, ULONG_PTR ActivationPayload, PVOID SchedulerParam);

            typedef RTL_UMS_SCHEDULER_ENTRY_POINT* PRTL_UMS_SCHEDULER_ENTRY_POINT;

#pragma region Desktop Family or OneCore Family

            __declspec(dllimport) DWORD __stdcall RtlCrc32(const void* Buffer, size_t Size, DWORD InitialCrc);

            __declspec(dllimport) ULONGLONG __stdcall RtlCrc64(const void* Buffer, size_t Size, ULONGLONG InitialCrc);

#pragma endregion

            typedef enum _OS_DEPLOYEMENT_STATE_VALUES
            {
                OS_DEPLOYMENT_STANDARD = 1,
                OS_DEPLOYMENT_COMPACT
            } OS_DEPLOYEMENT_STATE_VALUES;

            __declspec(dllimport) OS_DEPLOYEMENT_STATE_VALUES __stdcall RtlOsDeploymentState(DWORD Flags);

            typedef struct _NV_MEMORY_RANGE
            {
                void* BaseAddress;
                SIZE_T Length;
            } NV_MEMORY_RANGE, *PNV_MEMORY_RANGE;

            __declspec(dllimport) DWORD __stdcall RtlGetNonVolatileToken(PVOID NvBuffer, SIZE_T Size, PVOID* NvToken);

            __declspec(dllimport) DWORD __stdcall RtlFreeNonVolatileToken(PVOID NvToken);

            __declspec(dllimport) DWORD
            __stdcall RtlFlushNonVolatileMemory(PVOID NvToken, PVOID NvBuffer, SIZE_T Size, DWORD Flags);

            __declspec(dllimport) DWORD __stdcall RtlDrainNonVolatileFlush(PVOID NvToken);

            __declspec(dllimport) DWORD __stdcall RtlWriteNonVolatileMemory(
            PVOID NvToken, void __unaligned* NvDestination, const void __unaligned* Source, SIZE_T Size, DWORD Flags);

            __declspec(dllimport) DWORD
            __stdcall RtlFlushNonVolatileMemoryRanges(PVOID NvToken, PNV_MEMORY_RANGE NvRanges, SIZE_T NumRanges, DWORD Flags);

            typedef struct CORRELATION_VECTOR
            {
                CHAR Version;
                CHAR Vector[129];
            } CORRELATION_VECTOR;

            typedef CORRELATION_VECTOR* PCORRELATION_VECTOR;

            __declspec(dllimport) DWORD
            __stdcall RtlInitializeCorrelationVector(PCORRELATION_VECTOR CorrelationVector, int Version, const GUID* Guid);

            __declspec(dllimport) DWORD __stdcall RtlIncrementCorrelationVector(PCORRELATION_VECTOR CorrelationVector);

            __declspec(dllimport) DWORD __stdcall RtlExtendCorrelationVector(PCORRELATION_VECTOR CorrelationVector);

            __declspec(dllimport) DWORD __stdcall RtlValidateCorrelationVector(PCORRELATION_VECTOR Vector);

            typedef struct _CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG
            {
                DWORD Size;

                PCWSTR TriggerId;

            } CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG, *PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG;

            __forceinline void CUSTOM_SYSTEM_EVENT_TRIGGER_INIT(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG Config, PCWSTR TriggerId)
            {
                memset((Config), 0, (sizeof(CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG)));

                Config->Size = sizeof(CUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG);
                Config->TriggerId = TriggerId;
            }

            DWORD
            __stdcall RtlRaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG TriggerConfig);

            typedef enum _IMAGE_POLICY_ENTRY_TYPE
            {
                ImagePolicyEntryTypeNone = 0,
                ImagePolicyEntryTypeBool,
                ImagePolicyEntryTypeInt8,
                ImagePolicyEntryTypeUInt8,
                ImagePolicyEntryTypeInt16,
                ImagePolicyEntryTypeUInt16,
                ImagePolicyEntryTypeInt32,
                ImagePolicyEntryTypeUInt32,
                ImagePolicyEntryTypeInt64,
                ImagePolicyEntryTypeUInt64,
                ImagePolicyEntryTypeAnsiString,
                ImagePolicyEntryTypeUnicodeString,
                ImagePolicyEntryTypeOverride,
                ImagePolicyEntryTypeMaximum
            } IMAGE_POLICY_ENTRY_TYPE;

            typedef enum _IMAGE_POLICY_ID
            {
                ImagePolicyIdNone = 0,
                ImagePolicyIdEtw,
                ImagePolicyIdDebug,
                ImagePolicyIdCrashDump,
                ImagePolicyIdCrashDumpKey,
                ImagePolicyIdCrashDumpKeyGuid,
                ImagePolicyIdParentSd,
                ImagePolicyIdParentSdRev,
                ImagePolicyIdSvn,
                ImagePolicyIdDeviceId,
                ImagePolicyIdCapability,
                ImagePolicyIdScenarioId,
                ImagePolicyIdMaximum
            } IMAGE_POLICY_ID;

            typedef struct _IMAGE_POLICY_ENTRY
            {
                IMAGE_POLICY_ENTRY_TYPE Type;
                IMAGE_POLICY_ID PolicyId;
                union
                {
                    const void* None;
                    BOOLEAN BoolValue;
                    INT8 Int8Value;
                    UINT8 UInt8Value;
                    INT16 Int16Value;
                    UINT16 UInt16Value;
                    INT32 Int32Value;
                    UINT32 UInt32Value;
                    INT64 Int64Value;
                    UINT64 UInt64Value;
                    PCSTR AnsiStringValue;
                    PCWSTR UnicodeStringValue;
                } u;
            } IMAGE_POLICY_ENTRY;
            typedef const IMAGE_POLICY_ENTRY* PCIMAGE_POLICY_ENTRY;

#pragma warning(push)
#pragma warning(disable : 4200)
            typedef struct _IMAGE_POLICY_METADATA
            {
                BYTE Version;
                BYTE Reserved0[7];
                ULONGLONG ApplicationId;
                IMAGE_POLICY_ENTRY Policies[];
            } IMAGE_POLICY_METADATA;
            typedef const IMAGE_POLICY_METADATA* PCIMAGE_POLICY_METADATA;
#pragma warning(pop)

            typedef struct _RTL_CRITICAL_SECTION_DEBUG
            {
                WORD Type;
                WORD CreatorBackTraceIndex;
                struct _RTL_CRITICAL_SECTION* CriticalSection;
                LIST_ENTRY ProcessLocksList;
                DWORD EntryCount;
                DWORD ContentionCount;
                DWORD Flags;
                WORD CreatorBackTraceIndexHigh;
                WORD SpareWORD;
            } RTL_CRITICAL_SECTION_DEBUG, *PRTL_CRITICAL_SECTION_DEBUG, RTL_RESOURCE_DEBUG, *PRTL_RESOURCE_DEBUG;

#pragma pack(push, 8)

            typedef struct _RTL_CRITICAL_SECTION
            {
                PRTL_CRITICAL_SECTION_DEBUG DebugInfo;

                LONG LockCount;
                LONG RecursionCount;
                HANDLE OwningThread;
                HANDLE LockSemaphore;
                ULONG_PTR SpinCount;
            } RTL_CRITICAL_SECTION, *PRTL_CRITICAL_SECTION;

#pragma pack(pop)

            typedef struct _RTL_SRWLOCK
            {
                PVOID Ptr;
            } RTL_SRWLOCK, *PRTL_SRWLOCK;

            typedef struct _RTL_CONDITION_VARIABLE
            {
                PVOID Ptr;
            } RTL_CONDITION_VARIABLE, *PRTL_CONDITION_VARIABLE;

            typedef void(__stdcall* PAPCFUNC)(ULONG_PTR Parameter);
            typedef LONG(__stdcall* PVECTORED_EXCEPTION_HANDLER)(struct _EXCEPTION_POINTERS* ExceptionInfo);

            typedef enum _HEAP_INFORMATION_CLASS
            {

                HeapCompatibilityInformation = 0,
                HeapEnableTerminationOnCorruption = 1

                ,

                HeapOptimizeResources = 3

            } HEAP_INFORMATION_CLASS;

            typedef struct _HEAP_OPTIMIZE_RESOURCES_INFORMATION
            {
                DWORD Version;
                DWORD Flags;
            } HEAP_OPTIMIZE_RESOURCES_INFORMATION, *PHEAP_OPTIMIZE_RESOURCES_INFORMATION;

            typedef void(__stdcall* WAITORTIMERCALLBACKFUNC)(PVOID, BOOLEAN);
            typedef void(__stdcall* WORKERCALLBACKFUNC)(PVOID);
            typedef void(__stdcall* APC_CALLBACK_FUNCTION)(DWORD, PVOID, PVOID);
            typedef WAITORTIMERCALLBACKFUNC WAITORTIMERCALLBACK;
            typedef void(__stdcall* PFLS_CALLBACK_FUNCTION)(PVOID lpFlsData);

            typedef BOOLEAN(__stdcall* PSECURE_MEMORY_CACHE_CALLBACK)(PVOID Addr, SIZE_T Range);

            typedef enum _ACTIVATION_CONTEXT_INFO_CLASS
            {
                ActivationContextBasicInformation = 1,
                ActivationContextDetailedInformation = 2,
                AssemblyDetailedInformationInActivationContext = 3,
                FileInformationInAssemblyOfAssemblyInActivationContext = 4,
                RunlevelInformationInActivationContext = 5,
                CompatibilityInformationInActivationContext = 6,
                ActivationContextManifestResourceName = 7,
                MaxActivationContextInfoClass,

                AssemblyDetailedInformationInActivationContxt = 3,
                FileInformationInAssemblyOfAssemblyInActivationContxt = 4
            } ACTIVATION_CONTEXT_INFO_CLASS;

            typedef struct _ACTIVATION_CONTEXT_QUERY_INDEX
            {
                DWORD ulAssemblyIndex;
                DWORD ulFileIndexInAssembly;
            } ACTIVATION_CONTEXT_QUERY_INDEX, *PACTIVATION_CONTEXT_QUERY_INDEX;

            typedef const struct _ACTIVATION_CONTEXT_QUERY_INDEX* PCACTIVATION_CONTEXT_QUERY_INDEX;

            typedef struct _ASSEMBLY_FILE_DETAILED_INFORMATION
            {
                DWORD ulFlags;
                DWORD ulFilenameLength;
                DWORD ulPathLength;

                PCWSTR lpFileName;
                PCWSTR lpFilePath;
            } ASSEMBLY_FILE_DETAILED_INFORMATION, *PASSEMBLY_FILE_DETAILED_INFORMATION;
            typedef const ASSEMBLY_FILE_DETAILED_INFORMATION* PCASSEMBLY_FILE_DETAILED_INFORMATION;

            typedef struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION
            {
                DWORD ulFlags;
                DWORD ulEncodedAssemblyIdentityLength;
                DWORD ulManifestPathType;
                DWORD ulManifestPathLength;
                LARGE_INTEGER liManifestLastWriteTime;
                DWORD ulPolicyPathType;
                DWORD ulPolicyPathLength;
                LARGE_INTEGER liPolicyLastWriteTime;
                DWORD ulMetadataSatelliteRosterIndex;

                DWORD ulManifestVersionMajor;
                DWORD ulManifestVersionMinor;
                DWORD ulPolicyVersionMajor;
                DWORD ulPolicyVersionMinor;
                DWORD ulAssemblyDirectoryNameLength;

                PCWSTR lpAssemblyEncodedAssemblyIdentity;
                PCWSTR lpAssemblyManifestPath;
                PCWSTR lpAssemblyPolicyPath;
                PCWSTR lpAssemblyDirectoryName;

                DWORD ulFileCount;
            } ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

            typedef const struct _ACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION* PCACTIVATION_CONTEXT_ASSEMBLY_DETAILED_INFORMATION;

            typedef enum
            {
                ACTCTX_RUN_LEVEL_UNSPECIFIED = 0,
                ACTCTX_RUN_LEVEL_AS_INVOKER,
                ACTCTX_RUN_LEVEL_HIGHEST_AVAILABLE,
                ACTCTX_RUN_LEVEL_REQUIRE_ADMIN,
                ACTCTX_RUN_LEVEL_NUMBERS
            } ACTCTX_REQUESTED_RUN_LEVEL;

            typedef struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION
            {
                DWORD ulFlags;
                ACTCTX_REQUESTED_RUN_LEVEL RunLevel;
                DWORD UiAccess;
            } ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION, *PACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

            typedef const struct _ACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION* PCACTIVATION_CONTEXT_RUN_LEVEL_INFORMATION;

            typedef enum
            {
                ACTCTX_COMPATIBILITY_ELEMENT_TYPE_UNKNOWN = 0,
                ACTCTX_COMPATIBILITY_ELEMENT_TYPE_OS,
                ACTCTX_COMPATIBILITY_ELEMENT_TYPE_MITIGATION
            } ACTCTX_COMPATIBILITY_ELEMENT_TYPE;

            typedef struct _COMPATIBILITY_CONTEXT_ELEMENT
            {
                GUID Id;
                ACTCTX_COMPATIBILITY_ELEMENT_TYPE Type;
            } COMPATIBILITY_CONTEXT_ELEMENT, *PCOMPATIBILITY_CONTEXT_ELEMENT;

            typedef const struct _COMPATIBILITY_CONTEXT_ELEMENT* PCCOMPATIBILITY_CONTEXT_ELEMENT;

#pragma warning(push)
#pragma warning(disable : 4200)

            typedef struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION
            {
                DWORD ElementCount;
                COMPATIBILITY_CONTEXT_ELEMENT Elements[];
            } ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION, *PACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

#pragma warning(pop)

            typedef const struct _ACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION* PCACTIVATION_CONTEXT_COMPATIBILITY_INFORMATION;

            typedef struct _SUPPORTED_OS_INFO
            {
                WORD MajorVersion;
                WORD MinorVersion;
            } SUPPORTED_OS_INFO, *PSUPPORTED_OS_INFO;

            typedef struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION
            {
                DWORD dwFlags;
                DWORD ulFormatVersion;
                DWORD ulAssemblyCount;
                DWORD ulRootManifestPathType;
                DWORD ulRootManifestPathChars;
                DWORD ulRootConfigurationPathType;
                DWORD ulRootConfigurationPathChars;
                DWORD ulAppDirPathType;
                DWORD ulAppDirPathChars;
                PCWSTR lpRootManifestPath;
                PCWSTR lpRootConfigurationPath;
                PCWSTR lpAppDirPath;
            } ACTIVATION_CONTEXT_DETAILED_INFORMATION, *PACTIVATION_CONTEXT_DETAILED_INFORMATION;

            typedef const struct _ACTIVATION_CONTEXT_DETAILED_INFORMATION* PCACTIVATION_CONTEXT_DETAILED_INFORMATION;

            typedef struct _HARDWARE_COUNTER_DATA
            {
                HARDWARE_COUNTER_TYPE Type;
                DWORD Reserved;
                DWORD64 Value;
            } HARDWARE_COUNTER_DATA, *PHARDWARE_COUNTER_DATA;

            typedef struct _PERFORMANCE_DATA
            {
                WORD Size;
                BYTE Version;
                BYTE HwCountersCount;
                DWORD ContextSwitchCount;
                DWORD64 WaitReasonBitMap;
                DWORD64 CycleTime;
                DWORD RetryCount;
                DWORD Reserved;
                HARDWARE_COUNTER_DATA HwCounters[16];
            } PERFORMANCE_DATA, *PPERFORMANCE_DATA;

#pragma region Desktop Family

            void __stdcall RtlGetDeviceFamilyInfoEnum(ULONGLONG* pullUAPInfo, DWORD* pulDeviceFamily, DWORD* pulDeviceForm);

            DWORD
            __stdcall RtlConvertDeviceFamilyInfoToString(PDWORD pulDeviceFamilyBufferSize, PDWORD pulDeviceFormBufferSize, PWSTR DeviceFamily, PWSTR DeviceForm

            );

            DWORD
            __stdcall RtlSwitchedVVI(PRTL_OSVERSIONINFOEXW VersionInfo, DWORD TypeMask, ULONGLONG ConditionMask);

#pragma endregion

            typedef struct _EVENTLOGRECORD
            {
                DWORD Length;
                DWORD Reserved;
                DWORD RecordNumber;
                DWORD TimeGenerated;
                DWORD TimeWritten;
                DWORD EventID;
                WORD EventType;
                WORD NumStrings;
                WORD EventCategory;
                WORD ReservedFlags;
                DWORD ClosingRecordNumber;
                DWORD StringOffset;
                DWORD UserSidLength;
                DWORD UserSidOffset;
                DWORD DataLength;
                DWORD DataOffset;

            } EVENTLOGRECORD, *PEVENTLOGRECORD;

#pragma warning(push)
#pragma warning(disable : 4200)

            struct _EVENTSFORLOGFILE;
            typedef struct _EVENTSFORLOGFILE EVENTSFORLOGFILE, *PEVENTSFORLOGFILE;

            struct _PACKEDEVENTINFO;
            typedef struct _PACKEDEVENTINFO PACKEDEVENTINFO, *PPACKEDEVENTINFO;

            struct _EVENTSFORLOGFILE
            {
                DWORD ulSize;
                WCHAR szLogicalLogFile[256];
                DWORD ulNumRecords;
                EVENTLOGRECORD pEventLogRecords[];
            };

            struct _PACKEDEVENTINFO
            {
                DWORD ulSize;
                DWORD ulNumEventsForLogFile;
                DWORD ulOffsets[];
            };

#pragma warning(pop)

            typedef enum _CM_SERVICE_NODE_TYPE
            {
                DriverType = 0x00000001,
                FileSystemType = 0x00000002,
                Win32ServiceOwnProcess = 0x00000010,
                Win32ServiceShareProcess = 0x00000020,
                AdapterType = 0x00000004,
                RecognizerType = 0x00000008
            } SERVICE_NODE_TYPE;

            typedef enum _CM_SERVICE_LOAD_TYPE
            {
                BootLoad = 0x00000000,
                SystemLoad = 0x00000001,
                AutoLoad = 0x00000002,
                DemandLoad = 0x00000003,
                DisableLoad = 0x00000004
            } SERVICE_LOAD_TYPE;

            typedef enum _CM_ERROR_CONTROL_TYPE
            {
                IgnoreError = 0x00000000,
                NormalError = 0x00000001,
                SevereError = 0x00000002,
                CriticalError = 0x00000003
            } SERVICE_ERROR_TYPE;

            typedef struct _TAPE_ERASE
            {
                DWORD Type;
                BOOLEAN Immediate;
            } TAPE_ERASE, *PTAPE_ERASE;

            typedef struct _TAPE_PREPARE
            {
                DWORD Operation;
                BOOLEAN Immediate;
            } TAPE_PREPARE, *PTAPE_PREPARE;

            typedef struct _TAPE_WRITE_MARKS
            {
                DWORD Type;
                DWORD Count;
                BOOLEAN Immediate;
            } TAPE_WRITE_MARKS, *PTAPE_WRITE_MARKS;

            typedef struct _TAPE_GET_POSITION
            {
                DWORD Type;
                DWORD Partition;
                LARGE_INTEGER Offset;
            } TAPE_GET_POSITION, *PTAPE_GET_POSITION;

            typedef struct _TAPE_SET_POSITION
            {
                DWORD Method;
                DWORD Partition;
                LARGE_INTEGER Offset;
                BOOLEAN Immediate;
            } TAPE_SET_POSITION, *PTAPE_SET_POSITION;

            typedef struct _TAPE_GET_DRIVE_PARAMETERS
            {
                BOOLEAN ECC;
                BOOLEAN Compression;
                BOOLEAN DataPadding;
                BOOLEAN ReportSetmarks;
                DWORD DefaultBlockSize;
                DWORD MaximumBlockSize;
                DWORD MinimumBlockSize;
                DWORD MaximumPartitionCount;
                DWORD FeaturesLow;
                DWORD FeaturesHigh;
                DWORD EOTWarningZoneSize;
            } TAPE_GET_DRIVE_PARAMETERS, *PTAPE_GET_DRIVE_PARAMETERS;

            typedef struct _TAPE_SET_DRIVE_PARAMETERS
            {
                BOOLEAN ECC;
                BOOLEAN Compression;
                BOOLEAN DataPadding;
                BOOLEAN ReportSetmarks;
                DWORD EOTWarningZoneSize;
            } TAPE_SET_DRIVE_PARAMETERS, *PTAPE_SET_DRIVE_PARAMETERS;

            typedef struct _TAPE_GET_MEDIA_PARAMETERS
            {
                LARGE_INTEGER Capacity;
                LARGE_INTEGER Remaining;
                DWORD BlockSize;
                DWORD PartitionCount;
                BOOLEAN WriteProtected;
            } TAPE_GET_MEDIA_PARAMETERS, *PTAPE_GET_MEDIA_PARAMETERS;

            typedef struct _TAPE_SET_MEDIA_PARAMETERS
            {
                DWORD BlockSize;
            } TAPE_SET_MEDIA_PARAMETERS, *PTAPE_SET_MEDIA_PARAMETERS;

            typedef struct _TAPE_CREATE_PARTITION
            {
                DWORD Method;
                DWORD Count;
                DWORD Size;
            } TAPE_CREATE_PARTITION, *PTAPE_CREATE_PARTITION;

            typedef struct _TAPE_WMI_OPERATIONS
            {
                DWORD Method;
                DWORD DataBufferSize;
                PVOID DataBuffer;
            } TAPE_WMI_OPERATIONS, *PTAPE_WMI_OPERATIONS;

            typedef enum _TAPE_DRIVE_PROBLEM_TYPE
            {
                TapeDriveProblemNone,
                TapeDriveReadWriteWarning,
                TapeDriveReadWriteError,
                TapeDriveReadWarning,
                TapeDriveWriteWarning,
                TapeDriveReadError,
                TapeDriveWriteError,
                TapeDriveHardwareError,
                TapeDriveUnsupportedMedia,
                TapeDriveScsiConnectionError,
                TapeDriveTimetoClean,
                TapeDriveCleanDriveNow,
                TapeDriveMediaLifeExpired,
                TapeDriveSnappedTape
            } TAPE_DRIVE_PROBLEM_TYPE;

            extern "C"
            {
                extern "C"
                {
#pragma warning(push)
#pragma warning(disable : 4820)

                    typedef GUID UOW, *PUOW;
                    typedef GUID CRM_PROTOCOL_ID, *PCRM_PROTOCOL_ID;

                    typedef ULONG NOTIFICATION_MASK;

                    typedef struct _TRANSACTION_NOTIFICATION
                    {
                        PVOID TransactionKey;
                        ULONG TransactionNotification;
                        LARGE_INTEGER TmVirtualClock;
                        ULONG ArgumentLength;
                    } TRANSACTION_NOTIFICATION, *PTRANSACTION_NOTIFICATION;

                    typedef struct _TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT
                    {
                        GUID EnlistmentId;
                        UOW UOW;
                    } TRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT, *PTRANSACTION_NOTIFICATION_RECOVERY_ARGUMENT;

                    typedef struct _TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT
                    {
                        GUID TmIdentity;
                        ULONG Flags;
                    } TRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT, *PTRANSACTION_NOTIFICATION_TM_ONLINE_ARGUMENT;

                    typedef ULONG SAVEPOINT_ID, *PSAVEPOINT_ID;

                    typedef struct _TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT
                    {
                        SAVEPOINT_ID SavepointId;
                    } TRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT, *PTRANSACTION_NOTIFICATION_SAVEPOINT_ARGUMENT;

                    typedef struct _TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT
                    {
                        ULONG PropagationCookie;
                        GUID UOW;
                        GUID TmIdentity;
                        ULONG BufferLength;

                    } TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT, *PTRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT;

                    typedef struct _TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT
                    {
                        ULONG MarshalCookie;
                        GUID UOW;
                    } TRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT, *PTRANSACTION_NOTIFICATION_MARSHAL_ARGUMENT;

                    typedef TRANSACTION_NOTIFICATION_PROPAGATE_ARGUMENT TRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT,
                    *PTRANSACTION_NOTIFICATION_PROMOTE_ARGUMENT;

                    typedef struct _KCRM_MARSHAL_HEADER
                    {
                        ULONG VersionMajor;
                        ULONG VersionMinor;
                        ULONG NumProtocols;
                        ULONG Unused;
                    } KCRM_MARSHAL_HEADER, *PKCRM_MARSHAL_HEADER, *PRKCRM_MARSHAL_HEADER;

                    typedef struct _KCRM_TRANSACTION_BLOB
                    {
                        UOW UOW;
                        GUID TmIdentity;
                        ULONG IsolationLevel;
                        ULONG IsolationFlags;
                        ULONG Timeout;
                        WCHAR Description[64];
                    } KCRM_TRANSACTION_BLOB, *PKCRM_TRANSACTION_BLOB, *PRKCRM_TRANSACTION_BLOB;

                    typedef struct _KCRM_PROTOCOL_BLOB
                    {
                        CRM_PROTOCOL_ID ProtocolId;
                        ULONG StaticInfoLength;
                        ULONG TransactionIdInfoLength;
                        ULONG Unused1;
                        ULONG Unused2;
                    } KCRM_PROTOCOL_BLOB, *PKCRM_PROTOCOL_BLOB, *PRKCRM_PROTOCOL_BLOB;

#pragma warning(pop)
                }

#pragma warning(push)
#pragma warning(disable : 4820)

                typedef enum _TRANSACTION_OUTCOME
                {
                    TransactionOutcomeUndetermined = 1,
                    TransactionOutcomeCommitted,
                    TransactionOutcomeAborted,
                } TRANSACTION_OUTCOME;

                typedef enum _TRANSACTION_STATE
                {
                    TransactionStateNormal = 1,
                    TransactionStateIndoubt,
                    TransactionStateCommittedNotify,
                } TRANSACTION_STATE;

                typedef struct _TRANSACTION_BASIC_INFORMATION
                {
                    GUID TransactionId;
                    DWORD State;
                    DWORD Outcome;
                } TRANSACTION_BASIC_INFORMATION, *PTRANSACTION_BASIC_INFORMATION;

                typedef struct _TRANSACTIONMANAGER_BASIC_INFORMATION
                {
                    GUID TmIdentity;
                    LARGE_INTEGER VirtualClock;
                } TRANSACTIONMANAGER_BASIC_INFORMATION, *PTRANSACTIONMANAGER_BASIC_INFORMATION;

                typedef struct _TRANSACTIONMANAGER_LOG_INFORMATION
                {
                    GUID LogIdentity;
                } TRANSACTIONMANAGER_LOG_INFORMATION, *PTRANSACTIONMANAGER_LOG_INFORMATION;

                typedef struct _TRANSACTIONMANAGER_LOGPATH_INFORMATION
                {
                    DWORD LogPathLength;
                    WCHAR LogPath[1];

                } TRANSACTIONMANAGER_LOGPATH_INFORMATION, *PTRANSACTIONMANAGER_LOGPATH_INFORMATION;

                typedef struct _TRANSACTIONMANAGER_RECOVERY_INFORMATION
                {
                    ULONGLONG LastRecoveredLsn;
                } TRANSACTIONMANAGER_RECOVERY_INFORMATION, *PTRANSACTIONMANAGER_RECOVERY_INFORMATION;

                typedef struct _TRANSACTIONMANAGER_OLDEST_INFORMATION
                {
                    GUID OldestTransactionGuid;
                } TRANSACTIONMANAGER_OLDEST_INFORMATION, *PTRANSACTIONMANAGER_OLDEST_INFORMATION;

                typedef struct _TRANSACTION_PROPERTIES_INFORMATION
                {
                    DWORD IsolationLevel;
                    DWORD IsolationFlags;
                    LARGE_INTEGER Timeout;
                    DWORD Outcome;
                    DWORD DescriptionLength;
                    WCHAR Description[1];

                } TRANSACTION_PROPERTIES_INFORMATION, *PTRANSACTION_PROPERTIES_INFORMATION;

                typedef struct _TRANSACTION_BIND_INFORMATION
                {
                    HANDLE TmHandle;
                } TRANSACTION_BIND_INFORMATION, *PTRANSACTION_BIND_INFORMATION;

                typedef struct _TRANSACTION_ENLISTMENT_PAIR
                {
                    GUID EnlistmentId;
                    GUID ResourceManagerId;
                } TRANSACTION_ENLISTMENT_PAIR, *PTRANSACTION_ENLISTMENT_PAIR;

                typedef struct _TRANSACTION_ENLISTMENTS_INFORMATION
                {
                    DWORD NumberOfEnlistments;
                    TRANSACTION_ENLISTMENT_PAIR EnlistmentPair[1];
                } TRANSACTION_ENLISTMENTS_INFORMATION, *PTRANSACTION_ENLISTMENTS_INFORMATION;

                typedef struct _TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION
                {
                    TRANSACTION_ENLISTMENT_PAIR SuperiorEnlistmentPair;
                } TRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION, *PTRANSACTION_SUPERIOR_ENLISTMENT_INFORMATION;

                typedef struct _RESOURCEMANAGER_BASIC_INFORMATION
                {
                    GUID ResourceManagerId;
                    DWORD DescriptionLength;
                    WCHAR Description[1];
                } RESOURCEMANAGER_BASIC_INFORMATION, *PRESOURCEMANAGER_BASIC_INFORMATION;

                typedef struct _RESOURCEMANAGER_COMPLETION_INFORMATION
                {
                    HANDLE IoCompletionPortHandle;
                    ULONG_PTR CompletionKey;
                } RESOURCEMANAGER_COMPLETION_INFORMATION, *PRESOURCEMANAGER_COMPLETION_INFORMATION;

                typedef enum _TRANSACTION_INFORMATION_CLASS
                {
                    TransactionBasicInformation,
                    TransactionPropertiesInformation,
                    TransactionEnlistmentInformation,
                    TransactionSuperiorEnlistmentInformation

                    ,

                    TransactionBindInformation,
                    TransactionDTCPrivateInformation,

                } TRANSACTION_INFORMATION_CLASS;

                typedef enum _TRANSACTIONMANAGER_INFORMATION_CLASS
                {
                    TransactionManagerBasicInformation,
                    TransactionManagerLogInformation,
                    TransactionManagerLogPathInformation,
                    TransactionManagerRecoveryInformation = 4

                    ,

                    TransactionManagerOnlineProbeInformation = 3,
                    TransactionManagerOldestTransactionInformation = 5

                } TRANSACTIONMANAGER_INFORMATION_CLASS;

                typedef enum _RESOURCEMANAGER_INFORMATION_CLASS
                {
                    ResourceManagerBasicInformation,
                    ResourceManagerCompletionInformation,
                } RESOURCEMANAGER_INFORMATION_CLASS;

                typedef struct _ENLISTMENT_BASIC_INFORMATION
                {
                    GUID EnlistmentId;
                    GUID TransactionId;
                    GUID ResourceManagerId;
                } ENLISTMENT_BASIC_INFORMATION, *PENLISTMENT_BASIC_INFORMATION;

                typedef struct _ENLISTMENT_CRM_INFORMATION
                {
                    GUID CrmTransactionManagerId;
                    GUID CrmResourceManagerId;
                    GUID CrmEnlistmentId;
                } ENLISTMENT_CRM_INFORMATION, *PENLISTMENT_CRM_INFORMATION;

                typedef enum _ENLISTMENT_INFORMATION_CLASS
                {
                    EnlistmentBasicInformation,
                    EnlistmentRecoveryInformation,
                    EnlistmentCrmInformation
                } ENLISTMENT_INFORMATION_CLASS;

                typedef struct _TRANSACTION_LIST_ENTRY
                {
                    UOW UOW;
                } TRANSACTION_LIST_ENTRY, *PTRANSACTION_LIST_ENTRY;

                typedef struct _TRANSACTION_LIST_INFORMATION
                {
                    DWORD NumberOfTransactions;
                    TRANSACTION_LIST_ENTRY TransactionInformation[1];
                } TRANSACTION_LIST_INFORMATION, *PTRANSACTION_LIST_INFORMATION;

                typedef enum _KTMOBJECT_TYPE
                {

                    KTMOBJECT_TRANSACTION,
                    KTMOBJECT_TRANSACTION_MANAGER,
                    KTMOBJECT_RESOURCE_MANAGER,
                    KTMOBJECT_ENLISTMENT,
                    KTMOBJECT_INVALID

                } KTMOBJECT_TYPE,
                *PKTMOBJECT_TYPE;

                typedef struct _KTMOBJECT_CURSOR
                {
                    GUID LastQuery;

                    DWORD ObjectIdCount;

                    GUID ObjectIds[1];

                } KTMOBJECT_CURSOR, *PKTMOBJECT_CURSOR;

#pragma warning(pop)
            }

            typedef DWORD TP_VERSION, *PTP_VERSION;

            typedef struct _TP_CALLBACK_INSTANCE TP_CALLBACK_INSTANCE, *PTP_CALLBACK_INSTANCE;

            typedef void(__stdcall* PTP_SIMPLE_CALLBACK)(PTP_CALLBACK_INSTANCE Instance, PVOID Context);

            typedef struct _TP_POOL TP_POOL, *PTP_POOL;

            typedef enum _TP_CALLBACK_PRIORITY
            {
                TP_CALLBACK_PRIORITY_HIGH,
                TP_CALLBACK_PRIORITY_NORMAL,
                TP_CALLBACK_PRIORITY_LOW,
                TP_CALLBACK_PRIORITY_INVALID,
                TP_CALLBACK_PRIORITY_COUNT = TP_CALLBACK_PRIORITY_INVALID
            } TP_CALLBACK_PRIORITY;

            typedef struct _TP_POOL_STACK_INFORMATION
            {
                SIZE_T StackReserve;
                SIZE_T StackCommit;
            } TP_POOL_STACK_INFORMATION, *PTP_POOL_STACK_INFORMATION;

            typedef struct _TP_CLEANUP_GROUP TP_CLEANUP_GROUP, *PTP_CLEANUP_GROUP;

            typedef void(__stdcall* PTP_CLEANUP_GROUP_CANCEL_CALLBACK)(PVOID ObjectContext, PVOID CleanupContext);

            typedef struct _TP_CALLBACK_ENVIRON_V3
            {
                TP_VERSION Version;
                PTP_POOL Pool;
                PTP_CLEANUP_GROUP CleanupGroup;
                PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback;
                PVOID RaceDll;
                struct _ACTIVATION_CONTEXT* ActivationContext;
                PTP_SIMPLE_CALLBACK FinalizationCallback;
                union
                {
                    DWORD Flags;
                    struct
                    {
                        DWORD LongFunction : 1;
                        DWORD Persistent : 1;
                        DWORD Private : 30;
                    } s;
                } u;
                TP_CALLBACK_PRIORITY CallbackPriority;
                DWORD Size;
            } TP_CALLBACK_ENVIRON_V3;

            typedef TP_CALLBACK_ENVIRON_V3 TP_CALLBACK_ENVIRON, *PTP_CALLBACK_ENVIRON;

            __forceinline void TpInitializeCallbackEnviron(PTP_CALLBACK_ENVIRON CallbackEnviron)
            {
                CallbackEnviron->Version = 3;

                CallbackEnviron->Pool = 0;
                CallbackEnviron->CleanupGroup = 0;
                CallbackEnviron->CleanupGroupCancelCallback = 0;
                CallbackEnviron->RaceDll = 0;
                CallbackEnviron->ActivationContext = 0;
                CallbackEnviron->FinalizationCallback = 0;
                CallbackEnviron->u.Flags = 0;

                CallbackEnviron->CallbackPriority = TP_CALLBACK_PRIORITY_NORMAL;
                CallbackEnviron->Size = sizeof(TP_CALLBACK_ENVIRON);
            }

            __forceinline void TpSetCallbackThreadpool(PTP_CALLBACK_ENVIRON CallbackEnviron, PTP_POOL Pool)
            {
                CallbackEnviron->Pool = Pool;
            }

            __forceinline void TpSetCallbackCleanupGroup(PTP_CALLBACK_ENVIRON CallbackEnviron,
                                                         PTP_CLEANUP_GROUP CleanupGroup,
                                                         PTP_CLEANUP_GROUP_CANCEL_CALLBACK CleanupGroupCancelCallback)
            {
                CallbackEnviron->CleanupGroup = CleanupGroup;
                CallbackEnviron->CleanupGroupCancelCallback = CleanupGroupCancelCallback;
            }

            __forceinline void TpSetCallbackActivationContext(PTP_CALLBACK_ENVIRON CallbackEnviron,
                                                              struct _ACTIVATION_CONTEXT* ActivationContext)
            {
                CallbackEnviron->ActivationContext = ActivationContext;
            }

            __forceinline void TpSetCallbackNoActivationContext(PTP_CALLBACK_ENVIRON CallbackEnviron)
            {
                CallbackEnviron->ActivationContext = (struct _ACTIVATION_CONTEXT*)(LONG_PTR)-1;
            }

            __forceinline void TpSetCallbackLongFunction(PTP_CALLBACK_ENVIRON CallbackEnviron)
            {
                CallbackEnviron->u.s.LongFunction = 1;
            }

            __forceinline void TpSetCallbackRaceWithDll(PTP_CALLBACK_ENVIRON CallbackEnviron, PVOID DllHandle)
            {
                CallbackEnviron->RaceDll = DllHandle;
            }

            __forceinline void TpSetCallbackFinalizationCallback(PTP_CALLBACK_ENVIRON CallbackEnviron, PTP_SIMPLE_CALLBACK FinalizationCallback)
            {
                CallbackEnviron->FinalizationCallback = FinalizationCallback;
            }

            __forceinline void TpSetCallbackPriority(PTP_CALLBACK_ENVIRON CallbackEnviron, TP_CALLBACK_PRIORITY Priority)
            {
                CallbackEnviron->CallbackPriority = Priority;
            }

            __forceinline void TpSetCallbackPersistent(PTP_CALLBACK_ENVIRON CallbackEnviron)
            {
                CallbackEnviron->u.s.Persistent = 1;
            }

            __forceinline void TpDestroyCallbackEnviron(PTP_CALLBACK_ENVIRON CallbackEnviron)
            {
                (CallbackEnviron);
            }

            typedef struct _TP_WORK TP_WORK, *PTP_WORK;

            typedef void(__stdcall* PTP_WORK_CALLBACK)(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WORK Work);

            typedef struct _TP_TIMER TP_TIMER, *PTP_TIMER;

            typedef void(__stdcall* PTP_TIMER_CALLBACK)(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_TIMER Timer);

            typedef DWORD TP_WAIT_RESULT;

            typedef struct _TP_WAIT TP_WAIT, *PTP_WAIT;

            typedef void(__stdcall* PTP_WAIT_CALLBACK)(PTP_CALLBACK_INSTANCE Instance, PVOID Context, PTP_WAIT Wait, TP_WAIT_RESULT WaitResult);

            typedef struct _TP_IO TP_IO, *PTP_IO;

            __forceinline struct _TEB* NtCurrentTeb(void)

            {
                return (struct _TEB*)__readgsqword(((LONG)(LONG_PTR) & (((NT_TIB*)0)->Self)));
            }

            __forceinline PVOID GetCurrentFiber(void)

            {
                return (PVOID)__readgsqword(((LONG)(LONG_PTR) & (((NT_TIB*)0)->FiberData)));
            }

            __forceinline PVOID GetFiberData(void)

            {
                return *(PVOID*)GetCurrentFiber();
            }
        }

#pragma warning(pop)

        typedef UINT_PTR WPARAM;
        typedef LONG_PTR LPARAM;
        typedef LONG_PTR LRESULT;

        typedef HANDLE* SPHANDLE;
        typedef HANDLE* LPHANDLE;
        typedef HANDLE HGLOBAL;
        typedef HANDLE HLOCAL;
        typedef HANDLE GLOBALHANDLE;
        typedef HANDLE LOCALHANDLE;

        typedef INT_PTR(__stdcall* FARPROC)(void);
        typedef INT_PTR(__stdcall* NEARPROC)(void);
        typedef INT_PTR(__stdcall* PROC)(void);

        typedef WORD ATOM;

        struct HKEY__
        {
            int unused;
        };
        typedef struct HKEY__* HKEY;
        typedef HKEY* PHKEY;
        struct HMETAFILE__
        {
            int unused;
        };
        typedef struct HMETAFILE__* HMETAFILE;
        struct HINSTANCE__
        {
            int unused;
        };
        typedef struct HINSTANCE__* HINSTANCE;
        typedef HINSTANCE HMODULE;
        struct HRGN__
        {
            int unused;
        };
        typedef struct HRGN__* HRGN;
        struct HRSRC__
        {
            int unused;
        };
        typedef struct HRSRC__* HRSRC;
        struct HSPRITE__
        {
            int unused;
        };
        typedef struct HSPRITE__* HSPRITE;
        struct HLSURF__
        {
            int unused;
        };
        typedef struct HLSURF__* HLSURF;
        struct HSTR__
        {
            int unused;
        };
        typedef struct HSTR__* HSTR;
        struct HTASK__
        {
            int unused;
        };
        typedef struct HTASK__* HTASK;
        struct HWINSTA__
        {
            int unused;
        };
        typedef struct HWINSTA__* HWINSTA;
        struct HKL__
        {
            int unused;
        };
        typedef struct HKL__* HKL;

        typedef int HFILE;

        typedef struct _FILETIME
        {
            DWORD dwLowDateTime;
            DWORD dwHighDateTime;
        } FILETIME, *PFILETIME, *LPFILETIME;
    }

#pragma endregion

#pragma region Application Family or OneCore Family

    struct HWND__
    {
        int unused;
    };
    typedef struct HWND__* HWND;
    struct HHOOK__
    {
        int unused;
    };
    typedef struct HHOOK__* HHOOK;

#pragma endregion

#pragma region Application Family

    typedef void* HGDIOBJ;

    struct HACCEL__
    {
        int unused;
    };
    typedef struct HACCEL__* HACCEL;

    struct HBITMAP__
    {
        int unused;
    };
    typedef struct HBITMAP__* HBITMAP;
    struct HBRUSH__
    {
        int unused;
    };
    typedef struct HBRUSH__* HBRUSH;

    struct HCOLORSPACE__
    {
        int unused;
    };
    typedef struct HCOLORSPACE__* HCOLORSPACE;

    struct HDC__
    {
        int unused;
    };
    typedef struct HDC__* HDC;
    struct HGLRC__
    {
        int unused;
    };
    typedef struct HGLRC__* HGLRC;
    struct HDESK__
    {
        int unused;
    };
    typedef struct HDESK__* HDESK;
    struct HENHMETAFILE__
    {
        int unused;
    };
    typedef struct HENHMETAFILE__* HENHMETAFILE;

    struct HFONT__
    {
        int unused;
    };
    typedef struct HFONT__* HFONT;
    struct HICON__
    {
        int unused;
    };
    typedef struct HICON__* HICON;

    struct HMENU__
    {
        int unused;
    };
    typedef struct HMENU__* HMENU;

    struct HPALETTE__
    {
        int unused;
    };
    typedef struct HPALETTE__* HPALETTE;
    struct HPEN__
    {
        int unused;
    };
    typedef struct HPEN__* HPEN;

    struct HWINEVENTHOOK__
    {
        int unused;
    };
    typedef struct HWINEVENTHOOK__* HWINEVENTHOOK;

#pragma endregion

#pragma region Application Family

    struct HMONITOR__
    {
        int unused;
    };
    typedef struct HMONITOR__* HMONITOR;

#pragma endregion

#pragma region Desktop Family

    struct HUMPD__
    {
        int unused;
    };
    typedef struct HUMPD__* HUMPD;

#pragma endregion

#pragma region Application Family

    typedef HICON HCURSOR;

    typedef DWORD COLORREF;

#pragma endregion

#pragma region Desktop Family

    typedef DWORD* LPCOLORREF;

#pragma endregion

#pragma region Application Family

    typedef struct tagRECT
    {
        LONG left;
        LONG top;
        LONG right;
        LONG bottom;
    } RECT, *PRECT, *NPRECT, *LPRECT;

    typedef const RECT* LPCRECT;

    typedef struct _RECTL
    {
        LONG left;
        LONG top;
        LONG right;
        LONG bottom;
    } RECTL, *PRECTL, *LPRECTL;

    typedef const RECTL* LPCRECTL;

    typedef struct tagPOINT
    {
        LONG x;
        LONG y;
    } POINT, *PPOINT, *NPPOINT, *LPPOINT;

    typedef struct _POINTL
    {
        LONG x;
        LONG y;
    } POINTL, *PPOINTL;

    typedef struct tagSIZE
    {
        LONG cx;
        LONG cy;
    } SIZE, *PSIZE, *LPSIZE;

    typedef SIZE SIZEL;
    typedef SIZE *PSIZEL, *LPSIZEL;

    typedef struct tagPOINTS
    {
        SHORT x;
        SHORT y;

    } POINTS, *PPOINTS, *LPPOINTS;

#pragma endregion
}

#pragma region Desktop Family

struct DPI_AWARENESS_CONTEXT__
{
    int unused;
};
typedef struct DPI_AWARENESS_CONTEXT__* DPI_AWARENESS_CONTEXT;

typedef enum DPI_AWARENESS
{
    DPI_AWARENESS_INVALID = -1,
    DPI_AWARENESS_UNAWARE = 0,
    DPI_AWARENESS_SYSTEM_AWARE = 1,
    DPI_AWARENESS_PER_MONITOR_AWARE = 2
} DPI_AWARENESS;

typedef enum DPI_HOSTING_BEHAVIOR
{
    DPI_HOSTING_BEHAVIOR_INVALID = -1,
    DPI_HOSTING_BEHAVIOR_DEFAULT = 0,
    DPI_HOSTING_BEHAVIOR_MIXED = 1
} DPI_HOSTING_BEHAVIOR;

#pragma once

#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4668)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)

#pragma once

#pragma warning(disable : 4514)

#pragma warning(disable : 4103)

#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)

extern "C"
{
    typedef struct _SECURITY_ATTRIBUTES
    {
        DWORD nLength;
        LPVOID lpSecurityDescriptor;
        BOOL bInheritHandle;
    } SECURITY_ATTRIBUTES, *PSECURITY_ATTRIBUTES, *LPSECURITY_ATTRIBUTES;

    typedef struct _OVERLAPPED
    {
        ULONG_PTR Internal;
        ULONG_PTR InternalHigh;
        union
        {
            struct
            {
                DWORD Offset;
                DWORD OffsetHigh;
            };
            PVOID Pointer;
        };

        HANDLE hEvent;
    } OVERLAPPED, *LPOVERLAPPED;

    typedef struct _OVERLAPPED_ENTRY
    {
        ULONG_PTR lpCompletionKey;
        LPOVERLAPPED lpOverlapped;
        ULONG_PTR Internal;
        DWORD dwNumberOfBytesTransferred;
    } OVERLAPPED_ENTRY, *LPOVERLAPPED_ENTRY;

    typedef struct _SYSTEMTIME
    {
        WORD wYear;
        WORD wMonth;
        WORD wDayOfWeek;
        WORD wDay;
        WORD wHour;
        WORD wMinute;
        WORD wSecond;
        WORD wMilliseconds;
    } SYSTEMTIME, *PSYSTEMTIME, *LPSYSTEMTIME;

    typedef struct _WIN32_FIND_DATAA
    {
        DWORD dwFileAttributes;
        FILETIME ftCreationTime;
        FILETIME ftLastAccessTime;
        FILETIME ftLastWriteTime;
        DWORD nFileSizeHigh;
        DWORD nFileSizeLow;
        DWORD dwReserved0;
        DWORD dwReserved1;
        CHAR cFileName[260];
        CHAR cAlternateFileName[14];

    } WIN32_FIND_DATAA, *PWIN32_FIND_DATAA, *LPWIN32_FIND_DATAA;
    typedef struct _WIN32_FIND_DATAW
    {
        DWORD dwFileAttributes;
        FILETIME ftCreationTime;
        FILETIME ftLastAccessTime;
        FILETIME ftLastWriteTime;
        DWORD nFileSizeHigh;
        DWORD nFileSizeLow;
        DWORD dwReserved0;
        DWORD dwReserved1;
        WCHAR cFileName[260];
        WCHAR cAlternateFileName[14];

    } WIN32_FIND_DATAW, *PWIN32_FIND_DATAW, *LPWIN32_FIND_DATAW;

    typedef WIN32_FIND_DATAA WIN32_FIND_DATA;
    typedef PWIN32_FIND_DATAA PWIN32_FIND_DATA;
    typedef LPWIN32_FIND_DATAA LPWIN32_FIND_DATA;

    typedef enum _FINDEX_INFO_LEVELS
    {
        FindExInfoStandard,
        FindExInfoBasic,
        FindExInfoMaxInfoLevel
    } FINDEX_INFO_LEVELS;

    typedef enum _FINDEX_SEARCH_OPS
    {
        FindExSearchNameMatch,
        FindExSearchLimitToDirectories,
        FindExSearchLimitToDevices,
        FindExSearchMaxSearchOp
    } FINDEX_SEARCH_OPS;

    typedef enum _READ_DIRECTORY_NOTIFY_INFORMATION_CLASS
    {
        ReadDirectoryNotifyInformation = 1,
        ReadDirectoryNotifyExtendedInformation
    } READ_DIRECTORY_NOTIFY_INFORMATION_CLASS,
    *PREAD_DIRECTORY_NOTIFY_INFORMATION_CLASS;

    typedef enum _GET_FILEEX_INFO_LEVELS
    {
        GetFileExInfoStandard,
        GetFileExMaxInfoLevel
    } GET_FILEEX_INFO_LEVELS;

    typedef enum _FILE_INFO_BY_HANDLE_CLASS
    {
        FileBasicInfo,
        FileStandardInfo,
        FileNameInfo,
        FileRenameInfo,
        FileDispositionInfo,
        FileAllocationInfo,
        FileEndOfFileInfo,
        FileStreamInfo,
        FileCompressionInfo,
        FileAttributeTagInfo,
        FileIdBothDirectoryInfo,
        FileIdBothDirectoryRestartInfo,
        FileIoPriorityHintInfo,
        FileRemoteProtocolInfo,
        FileFullDirectoryInfo,
        FileFullDirectoryRestartInfo,

        FileStorageInfo,
        FileAlignmentInfo,
        FileIdInfo,
        FileIdExtdDirectoryInfo,
        FileIdExtdDirectoryRestartInfo,

        FileDispositionInfoEx,
        FileRenameInfoEx,
        MaximumFileInfoByHandleClass
    } FILE_INFO_BY_HANDLE_CLASS,
    *PFILE_INFO_BY_HANDLE_CLASS;

    typedef RTL_CRITICAL_SECTION CRITICAL_SECTION;
    typedef PRTL_CRITICAL_SECTION PCRITICAL_SECTION;
    typedef PRTL_CRITICAL_SECTION LPCRITICAL_SECTION;

    typedef RTL_CRITICAL_SECTION_DEBUG CRITICAL_SECTION_DEBUG;
    typedef PRTL_CRITICAL_SECTION_DEBUG PCRITICAL_SECTION_DEBUG;
    typedef PRTL_CRITICAL_SECTION_DEBUG LPCRITICAL_SECTION_DEBUG;

    typedef void(__stdcall* LPOVERLAPPED_COMPLETION_ROUTINE)(DWORD dwErrorCode, DWORD dwNumberOfBytesTransfered, LPOVERLAPPED lpOverlapped);

    typedef struct _PROCESS_HEAP_ENTRY
    {
        PVOID lpData;
        DWORD cbData;
        BYTE cbOverhead;
        BYTE iRegionIndex;
        WORD wFlags;
        union
        {
            struct
            {
                HANDLE hMem;
                DWORD dwReserved[3];
            } Block;
            struct
            {
                DWORD dwCommittedSize;
                DWORD dwUnCommittedSize;
                LPVOID lpFirstBlock;
                LPVOID lpLastBlock;
            } Region;
        };
    } PROCESS_HEAP_ENTRY, *LPPROCESS_HEAP_ENTRY, *PPROCESS_HEAP_ENTRY;

    typedef struct _REASON_CONTEXT
    {
        ULONG Version;
        DWORD Flags;
        union
        {
            struct
            {
                HMODULE LocalizedReasonModule;
                ULONG LocalizedReasonId;
                ULONG ReasonStringCount;
                LPWSTR* ReasonStrings;

            } Detailed;

            LPWSTR SimpleReasonString;
        } Reason;
    } REASON_CONTEXT, *PREASON_CONTEXT;

    typedef DWORD(__stdcall* PTHREAD_START_ROUTINE)(LPVOID lpThreadParameter);
    typedef PTHREAD_START_ROUTINE LPTHREAD_START_ROUTINE;

    typedef LPVOID(__stdcall* PENCLAVE_ROUTINE)(LPVOID lpThreadParameter);
    typedef PENCLAVE_ROUTINE LPENCLAVE_ROUTINE;

    typedef struct _EXCEPTION_DEBUG_INFO
    {
        EXCEPTION_RECORD ExceptionRecord;
        DWORD dwFirstChance;
    } EXCEPTION_DEBUG_INFO, *LPEXCEPTION_DEBUG_INFO;

    typedef struct _CREATE_THREAD_DEBUG_INFO
    {
        HANDLE hThread;
        LPVOID lpThreadLocalBase;
        LPTHREAD_START_ROUTINE lpStartAddress;
    } CREATE_THREAD_DEBUG_INFO, *LPCREATE_THREAD_DEBUG_INFO;

    typedef struct _CREATE_PROCESS_DEBUG_INFO
    {
        HANDLE hFile;
        HANDLE hProcess;
        HANDLE hThread;
        LPVOID lpBaseOfImage;
        DWORD dwDebugInfoFileOffset;
        DWORD nDebugInfoSize;
        LPVOID lpThreadLocalBase;
        LPTHREAD_START_ROUTINE lpStartAddress;
        LPVOID lpImageName;
        WORD fUnicode;
    } CREATE_PROCESS_DEBUG_INFO, *LPCREATE_PROCESS_DEBUG_INFO;

    typedef struct _EXIT_THREAD_DEBUG_INFO
    {
        DWORD dwExitCode;
    } EXIT_THREAD_DEBUG_INFO, *LPEXIT_THREAD_DEBUG_INFO;

    typedef struct _EXIT_PROCESS_DEBUG_INFO
    {
        DWORD dwExitCode;
    } EXIT_PROCESS_DEBUG_INFO, *LPEXIT_PROCESS_DEBUG_INFO;

    typedef struct _LOAD_DLL_DEBUG_INFO
    {
        HANDLE hFile;
        LPVOID lpBaseOfDll;
        DWORD dwDebugInfoFileOffset;
        DWORD nDebugInfoSize;
        LPVOID lpImageName;
        WORD fUnicode;
    } LOAD_DLL_DEBUG_INFO, *LPLOAD_DLL_DEBUG_INFO;

    typedef struct _UNLOAD_DLL_DEBUG_INFO
    {
        LPVOID lpBaseOfDll;
    } UNLOAD_DLL_DEBUG_INFO, *LPUNLOAD_DLL_DEBUG_INFO;

    typedef struct _OUTPUT_DEBUG_STRING_INFO
    {
        LPSTR lpDebugStringData;
        WORD fUnicode;
        WORD nDebugStringLength;
    } OUTPUT_DEBUG_STRING_INFO, *LPOUTPUT_DEBUG_STRING_INFO;

    typedef struct _RIP_INFO
    {
        DWORD dwError;
        DWORD dwType;
    } RIP_INFO, *LPRIP_INFO;

    typedef struct _DEBUG_EVENT
    {
        DWORD dwDebugEventCode;
        DWORD dwProcessId;
        DWORD dwThreadId;
        union
        {
            EXCEPTION_DEBUG_INFO Exception;
            CREATE_THREAD_DEBUG_INFO CreateThread;
            CREATE_PROCESS_DEBUG_INFO CreateProcessInfo;
            EXIT_THREAD_DEBUG_INFO ExitThread;
            EXIT_PROCESS_DEBUG_INFO ExitProcess;
            LOAD_DLL_DEBUG_INFO LoadDll;
            UNLOAD_DLL_DEBUG_INFO UnloadDll;
            OUTPUT_DEBUG_STRING_INFO DebugString;
            RIP_INFO RipInfo;
        } u;
    } DEBUG_EVENT, *LPDEBUG_EVENT;

    typedef PCONTEXT LPCONTEXT;
}

#pragma warning(pop)

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    BOOL __stdcall IsApiSetImplemented(PCSTR Contract);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetEnvironmentStringsW(LPWCH NewEnvironment);

#pragma endregion

#pragma region PC Family or OneCore Family

    __declspec(dllimport) HANDLE __stdcall GetStdHandle(DWORD nStdHandle);

    __declspec(dllimport) BOOL __stdcall SetStdHandle(DWORD nStdHandle, HANDLE hHandle);

    __declspec(dllimport) BOOL __stdcall SetStdHandleEx(DWORD nStdHandle, HANDLE hHandle, PHANDLE phPrevValue);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) LPSTR __stdcall GetCommandLineA(void);

    __declspec(dllimport) LPWSTR __stdcall GetCommandLineW(void);

    __declspec(dllimport)

    LPCH __stdcall GetEnvironmentStrings(void);

    __declspec(dllimport)

    LPWCH __stdcall GetEnvironmentStringsW(void);

    __declspec(dllimport) BOOL __stdcall FreeEnvironmentStringsA(LPCH penv);

    __declspec(dllimport) BOOL __stdcall FreeEnvironmentStringsW(LPWCH penv);

    __declspec(dllimport)

    DWORD __stdcall GetEnvironmentVariableA(LPCSTR lpName, LPSTR lpBuffer, DWORD nSize);

    __declspec(dllimport)

    DWORD __stdcall GetEnvironmentVariableW(LPCWSTR lpName, LPWSTR lpBuffer, DWORD nSize);

    __declspec(dllimport) BOOL __stdcall SetEnvironmentVariableA(LPCSTR lpName, LPCSTR lpValue);

    __declspec(dllimport) BOOL __stdcall SetEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpValue);

    __declspec(dllimport)

    DWORD __stdcall ExpandEnvironmentStringsA(LPCSTR lpSrc, LPSTR lpDst, DWORD nSize);

    __declspec(dllimport)

    DWORD __stdcall ExpandEnvironmentStringsW(LPCWSTR lpSrc, LPWSTR lpDst, DWORD nSize);

    __declspec(dllimport) BOOL __stdcall SetCurrentDirectoryA(LPCSTR lpPathName);

    __declspec(dllimport) BOOL __stdcall SetCurrentDirectoryW(LPCWSTR lpPathName);

    __declspec(dllimport)

    DWORD __stdcall GetCurrentDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);

    __declspec(dllimport)

    DWORD __stdcall GetCurrentDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD
    __stdcall SearchPathW(LPCWSTR lpPath, LPCWSTR lpFileName, LPCWSTR lpExtension, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR* lpFilePart);

    __declspec(dllimport) DWORD
    __stdcall SearchPathA(LPCSTR lpPath, LPCSTR lpFileName, LPCSTR lpExtension, DWORD nBufferLength, LPSTR lpBuffer, LPSTR* lpFilePart);

    __declspec(dllimport) BOOL __stdcall NeedCurrentDirectoryForExePathA(LPCSTR ExeName);

    __declspec(dllimport) BOOL __stdcall NeedCurrentDirectoryForExePathW(LPCWSTR ExeName);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) LONG __stdcall CompareFileTime(const FILETIME* lpFileTime1, const FILETIME* lpFileTime2);

    __declspec(dllimport) BOOL __stdcall CreateDirectoryA(LPCSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);

    __declspec(dllimport) BOOL __stdcall CreateDirectoryW(LPCWSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) HANDLE __stdcall CreateFileA(LPCSTR lpFileName,
                                                       DWORD dwDesiredAccess,
                                                       DWORD dwShareMode,
                                                       LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                       DWORD dwCreationDisposition,
                                                       DWORD dwFlagsAndAttributes,
                                                       HANDLE hTemplateFile);

    __declspec(dllimport) HANDLE __stdcall CreateFileW(LPCWSTR lpFileName,
                                                       DWORD dwDesiredAccess,
                                                       DWORD dwShareMode,
                                                       LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                       DWORD dwCreationDisposition,
                                                       DWORD dwFlagsAndAttributes,
                                                       HANDLE hTemplateFile);

    __declspec(dllimport) BOOL __stdcall DefineDosDeviceW(DWORD dwFlags, LPCWSTR lpDeviceName, LPCWSTR lpTargetPath);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall DeleteFileA(LPCSTR lpFileName);

    __declspec(dllimport) BOOL __stdcall DeleteFileW(LPCWSTR lpFileName);

    __declspec(dllimport) BOOL __stdcall DeleteVolumeMountPointW(LPCWSTR lpszVolumeMountPoint);

    __declspec(dllimport) BOOL __stdcall FileTimeToLocalFileTime(const FILETIME* lpFileTime, LPFILETIME lpLocalFileTime);

    __declspec(dllimport) BOOL __stdcall FindClose(HANDLE hFindFile);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall FindCloseChangeNotification(HANDLE hChangeHandle);

    __declspec(dllimport) HANDLE __stdcall FindFirstChangeNotificationA(LPCSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);

    __declspec(dllimport) HANDLE
    __stdcall FindFirstChangeNotificationW(LPCWSTR lpPathName, BOOL bWatchSubtree, DWORD dwNotifyFilter);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) HANDLE __stdcall FindFirstFileA(LPCSTR lpFileName, LPWIN32_FIND_DATAA lpFindFileData);

    __declspec(dllimport) HANDLE __stdcall FindFirstFileW(LPCWSTR lpFileName, LPWIN32_FIND_DATAW lpFindFileData);

    __declspec(dllimport) HANDLE __stdcall FindFirstFileExA(LPCSTR lpFileName,
                                                            FINDEX_INFO_LEVELS fInfoLevelId,
                                                            LPVOID lpFindFileData,
                                                            FINDEX_SEARCH_OPS fSearchOp,
                                                            LPVOID lpSearchFilter,
                                                            DWORD dwAdditionalFlags);

    __declspec(dllimport) HANDLE __stdcall FindFirstFileExW(LPCWSTR lpFileName,
                                                            FINDEX_INFO_LEVELS fInfoLevelId,
                                                            LPVOID lpFindFileData,
                                                            FINDEX_SEARCH_OPS fSearchOp,
                                                            LPVOID lpSearchFilter,
                                                            DWORD dwAdditionalFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) HANDLE __stdcall FindFirstVolumeW(LPWSTR lpszVolumeName, DWORD cchBufferLength);

    __declspec(dllimport) BOOL __stdcall FindNextChangeNotification(HANDLE hChangeHandle);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall FindNextFileA(HANDLE hFindFile, LPWIN32_FIND_DATAA lpFindFileData);

    __declspec(dllimport) BOOL __stdcall FindNextFileW(HANDLE hFindFile, LPWIN32_FIND_DATAW lpFindFileData);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall FindNextVolumeW(HANDLE hFindVolume, LPWSTR lpszVolumeName, DWORD cchBufferLength);

    __declspec(dllimport) BOOL __stdcall FindVolumeClose(HANDLE hFindVolume);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall FlushFileBuffers(HANDLE hFile);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetDiskFreeSpaceA(LPCSTR lpRootPathName,
                                                           LPDWORD lpSectorsPerCluster,
                                                           LPDWORD lpBytesPerSector,
                                                           LPDWORD lpNumberOfFreeClusters,
                                                           LPDWORD lpTotalNumberOfClusters);

    __declspec(dllimport) BOOL __stdcall GetDiskFreeSpaceW(LPCWSTR lpRootPathName,
                                                           LPDWORD lpSectorsPerCluster,
                                                           LPDWORD lpBytesPerSector,
                                                           LPDWORD lpNumberOfFreeClusters,
                                                           LPDWORD lpTotalNumberOfClusters);

    __declspec(dllimport) BOOL __stdcall GetDiskFreeSpaceExA(LPCSTR lpDirectoryName,
                                                             PULARGE_INTEGER lpFreeBytesAvailableToCaller,
                                                             PULARGE_INTEGER lpTotalNumberOfBytes,
                                                             PULARGE_INTEGER lpTotalNumberOfFreeBytes);

    __declspec(dllimport) BOOL __stdcall GetDiskFreeSpaceExW(LPCWSTR lpDirectoryName,
                                                             PULARGE_INTEGER lpFreeBytesAvailableToCaller,
                                                             PULARGE_INTEGER lpTotalNumberOfBytes,
                                                             PULARGE_INTEGER lpTotalNumberOfFreeBytes);

    typedef struct DISK_SPACE_INFORMATION
    {
        ULONGLONG ActualTotalAllocationUnits;
        ULONGLONG ActualAvailableAllocationUnits;
        ULONGLONG ActualPoolUnavailableAllocationUnits;

        ULONGLONG CallerTotalAllocationUnits;
        ULONGLONG CallerAvailableAllocationUnits;
        ULONGLONG CallerPoolUnavailableAllocationUnits;

        ULONGLONG UsedAllocationUnits;

        ULONGLONG TotalReservedAllocationUnits;

        ULONGLONG VolumeStorageReserveAllocationUnits;

        ULONGLONG AvailableCommittedAllocationUnits;

        ULONGLONG PoolAvailableAllocationUnits;

        DWORD SectorsPerAllocationUnit;
        DWORD BytesPerSector;

    } DISK_SPACE_INFORMATION;

    __declspec(dllimport) HRESULT __stdcall GetDiskSpaceInformationA(LPCSTR rootPath, DISK_SPACE_INFORMATION* diskSpaceInfo);

    __declspec(dllimport) HRESULT __stdcall GetDiskSpaceInformationW(LPCWSTR rootPath, DISK_SPACE_INFORMATION* diskSpaceInfo);

    __declspec(dllimport) UINT __stdcall GetDriveTypeA(LPCSTR lpRootPathName);

    __declspec(dllimport) UINT __stdcall GetDriveTypeW(LPCWSTR lpRootPathName);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct _WIN32_FILE_ATTRIBUTE_DATA
    {
        DWORD dwFileAttributes;
        FILETIME ftCreationTime;
        FILETIME ftLastAccessTime;
        FILETIME ftLastWriteTime;
        DWORD nFileSizeHigh;
        DWORD nFileSizeLow;
    } WIN32_FILE_ATTRIBUTE_DATA, *LPWIN32_FILE_ATTRIBUTE_DATA;

    __declspec(dllimport) DWORD __stdcall GetFileAttributesA(LPCSTR lpFileName);

    __declspec(dllimport) DWORD __stdcall GetFileAttributesW(LPCWSTR lpFileName);

    __declspec(dllimport) BOOL
    __stdcall GetFileAttributesExA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);

    __declspec(dllimport) BOOL
    __stdcall GetFileAttributesExW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef struct _BY_HANDLE_FILE_INFORMATION
    {
        DWORD dwFileAttributes;
        FILETIME ftCreationTime;
        FILETIME ftLastAccessTime;
        FILETIME ftLastWriteTime;
        DWORD dwVolumeSerialNumber;
        DWORD nFileSizeHigh;
        DWORD nFileSizeLow;
        DWORD nNumberOfLinks;
        DWORD nFileIndexHigh;
        DWORD nFileIndexLow;
    } BY_HANDLE_FILE_INFORMATION, *PBY_HANDLE_FILE_INFORMATION, *LPBY_HANDLE_FILE_INFORMATION;

    __declspec(dllimport) BOOL __stdcall GetFileInformationByHandle(HANDLE hFile, LPBY_HANDLE_FILE_INFORMATION lpFileInformation);

    __declspec(dllimport) DWORD __stdcall GetFileSize(HANDLE hFile, LPDWORD lpFileSizeHigh);

#pragma endregion

#pragma region Application Family

    __declspec(dllimport) BOOL __stdcall GetFileSizeEx(HANDLE hFile, PLARGE_INTEGER lpFileSize);

    __declspec(dllimport) DWORD __stdcall GetFileType(HANDLE hFile);

    __declspec(dllimport) DWORD
    __stdcall GetFinalPathNameByHandleA(HANDLE hFile, LPSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);

    __declspec(dllimport) DWORD
    __stdcall GetFinalPathNameByHandleW(HANDLE hFile, LPWSTR lpszFilePath, DWORD cchFilePath, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall GetFileTime(HANDLE hFile, LPFILETIME lpCreationTime, LPFILETIME lpLastAccessTime, LPFILETIME lpLastWriteTime);

    __declspec(dllimport)

    DWORD __stdcall GetFullPathNameW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR* lpFilePart);

    __declspec(dllimport)

    DWORD __stdcall GetFullPathNameA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR* lpFilePart);

    __declspec(dllimport) DWORD __stdcall GetLogicalDrives(void);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetLogicalDriveStringsW(DWORD nBufferLength, LPWSTR lpBuffer);

    __declspec(dllimport)

    DWORD __stdcall GetLongPathNameA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    DWORD __stdcall GetLongPathNameW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    DWORD __stdcall GetShortPathNameW(LPCWSTR lpszLongPath, LPWSTR lpszShortPath, DWORD cchBuffer);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) UINT
    __stdcall GetTempFileNameW(LPCWSTR lpPathName, LPCWSTR lpPrefixString, UINT uUnique, LPWSTR lpTempFileName);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetVolumeInformationByHandleW(HANDLE hFile,
                                                                       LPWSTR lpVolumeNameBuffer,
                                                                       DWORD nVolumeNameSize,
                                                                       LPDWORD lpVolumeSerialNumber,
                                                                       LPDWORD lpMaximumComponentLength,
                                                                       LPDWORD lpFileSystemFlags,
                                                                       LPWSTR lpFileSystemNameBuffer,
                                                                       DWORD nFileSystemNameSize);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetVolumeInformationW(LPCWSTR lpRootPathName,
                                                               LPWSTR lpVolumeNameBuffer,
                                                               DWORD nVolumeNameSize,
                                                               LPDWORD lpVolumeSerialNumber,
                                                               LPDWORD lpMaximumComponentLength,
                                                               LPDWORD lpFileSystemFlags,
                                                               LPWSTR lpFileSystemNameBuffer,
                                                               DWORD nFileSystemNameSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetVolumePathNameW(LPCWSTR lpszFileName, LPWSTR lpszVolumePathName, DWORD cchBufferLength);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall LocalFileTimeToFileTime(const FILETIME* lpLocalFileTime, LPFILETIME lpFileTime);

    __declspec(dllimport) BOOL
    __stdcall LockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh);

    __declspec(dllimport) BOOL
    __stdcall LockFileEx(HANDLE hFile, DWORD dwFlags, DWORD dwReserved, DWORD nNumberOfBytesToLockLow, DWORD nNumberOfBytesToLockHigh, LPOVERLAPPED lpOverlapped);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall QueryDosDeviceW(LPCWSTR lpDeviceName, LPWSTR lpTargetPath, DWORD ucchMax);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall ReadFile(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPDWORD lpNumberOfBytesRead, LPOVERLAPPED lpOverlapped);

    __declspec(dllimport)

    BOOL __stdcall ReadFileEx(HANDLE hFile, LPVOID lpBuffer, DWORD nNumberOfBytesToRead, LPOVERLAPPED lpOverlapped, LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL
    __stdcall ReadFileScatter(HANDLE hFile, FILE_SEGMENT_ELEMENT aSegmentArray[], DWORD nNumberOfBytesToRead, LPDWORD lpReserved, LPOVERLAPPED lpOverlapped);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall RemoveDirectoryA(LPCSTR lpPathName);

    __declspec(dllimport) BOOL __stdcall RemoveDirectoryW(LPCWSTR lpPathName);

    __declspec(dllimport) BOOL __stdcall SetEndOfFile(HANDLE hFile);

    __declspec(dllimport) BOOL __stdcall SetFileAttributesA(LPCSTR lpFileName, DWORD dwFileAttributes);

    __declspec(dllimport) BOOL __stdcall SetFileAttributesW(LPCWSTR lpFileName, DWORD dwFileAttributes);

    __declspec(dllimport) BOOL __stdcall SetFileInformationByHandle(HANDLE hFile,
                                                                    FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
                                                                    LPVOID lpFileInformation,
                                                                    DWORD dwBufferSize);

    __declspec(dllimport) DWORD
    __stdcall SetFilePointer(HANDLE hFile, LONG lDistanceToMove, PLONG lpDistanceToMoveHigh, DWORD dwMoveMethod);

    __declspec(dllimport) BOOL
    __stdcall SetFilePointerEx(HANDLE hFile, LARGE_INTEGER liDistanceToMove, PLARGE_INTEGER lpNewFilePointer, DWORD dwMoveMethod);

    __declspec(dllimport) BOOL
    __stdcall SetFileTime(HANDLE hFile, const FILETIME* lpCreationTime, const FILETIME* lpLastAccessTime, const FILETIME* lpLastWriteTime);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetFileValidData(HANDLE hFile, LONGLONG ValidDataLength);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall UnlockFile(HANDLE hFile, DWORD dwFileOffsetLow, DWORD dwFileOffsetHigh, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh);

    __declspec(dllimport) BOOL
    __stdcall UnlockFileEx(HANDLE hFile, DWORD dwReserved, DWORD nNumberOfBytesToUnlockLow, DWORD nNumberOfBytesToUnlockHigh, LPOVERLAPPED lpOverlapped);

    __declspec(dllimport) BOOL
    __stdcall WriteFile(HANDLE hFile, LPCVOID lpBuffer, DWORD nNumberOfBytesToWrite, LPDWORD lpNumberOfBytesWritten, LPOVERLAPPED lpOverlapped);

    __declspec(dllimport) BOOL __stdcall WriteFileEx(HANDLE hFile,
                                                     LPCVOID lpBuffer,
                                                     DWORD nNumberOfBytesToWrite,
                                                     LPOVERLAPPED lpOverlapped,
                                                     LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall WriteFileGather(HANDLE hFile,
                                                         FILE_SEGMENT_ELEMENT aSegmentArray[],
                                                         DWORD nNumberOfBytesToWrite,
                                                         LPDWORD lpReserved,
                                                         LPOVERLAPPED lpOverlapped);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetTempPathW(DWORD nBufferLength, LPWSTR lpBuffer);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetVolumeNameForVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPWSTR lpszVolumeName, DWORD cchBufferLength);

    __declspec(dllimport) BOOL
    __stdcall GetVolumePathNamesForVolumeNameW(LPCWSTR lpszVolumeName, LPWCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct _CREATEFILE2_EXTENDED_PARAMETERS
    {
        DWORD dwSize;
        DWORD dwFileAttributes;
        DWORD dwFileFlags;
        DWORD dwSecurityQosFlags;
        LPSECURITY_ATTRIBUTES lpSecurityAttributes;
        HANDLE hTemplateFile;
    } CREATEFILE2_EXTENDED_PARAMETERS, *PCREATEFILE2_EXTENDED_PARAMETERS, *LPCREATEFILE2_EXTENDED_PARAMETERS;

    __declspec(dllimport) HANDLE __stdcall CreateFile2(LPCWSTR lpFileName,
                                                       DWORD dwDesiredAccess,
                                                       DWORD dwShareMode,
                                                       DWORD dwCreationDisposition,
                                                       LPCREATEFILE2_EXTENDED_PARAMETERS pCreateExParams);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetFileIoOverlappedRange(HANDLE FileHandle, PUCHAR OverlappedRangeStart, ULONG Length);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetCompressedFileSizeA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh);

    __declspec(dllimport) DWORD __stdcall GetCompressedFileSizeW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef enum _STREAM_INFO_LEVELS
    {

        FindStreamInfoStandard,
        FindStreamInfoMaxInfoLevel

    } STREAM_INFO_LEVELS;

    typedef struct _WIN32_FIND_STREAM_DATA
    {
        LARGE_INTEGER StreamSize;
        WCHAR cStreamName[260 + 36];

    } WIN32_FIND_STREAM_DATA, *PWIN32_FIND_STREAM_DATA;

    __declspec(dllimport) HANDLE
    __stdcall FindFirstStreamW(LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall FindNextStreamW(HANDLE hFindStream, LPVOID lpFindStreamData);

    __declspec(dllimport) BOOL __stdcall AreFileApisANSI(void);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetTempPathA(DWORD nBufferLength, LPSTR lpBuffer);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) HANDLE
    __stdcall FindFirstFileNameW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName);

    __declspec(dllimport) BOOL __stdcall FindNextFileNameW(HANDLE hFindStream, LPDWORD StringLength, PWSTR LinkName);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetVolumeInformationA(LPCSTR lpRootPathName,
                                                               LPSTR lpVolumeNameBuffer,
                                                               DWORD nVolumeNameSize,
                                                               LPDWORD lpVolumeSerialNumber,
                                                               LPDWORD lpMaximumComponentLength,
                                                               LPDWORD lpFileSystemFlags,
                                                               LPSTR lpFileSystemNameBuffer,
                                                               DWORD nFileSystemNameSize);

    __declspec(dllimport) UINT
    __stdcall GetTempFileNameA(LPCSTR lpPathName, LPCSTR lpPrefixString, UINT uUnique, LPSTR lpTempFileName);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) void __stdcall SetFileApisToOEM(void);

    __declspec(dllimport) void __stdcall SetFileApisToANSI(void);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsDebuggerPresent(void);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) void __stdcall DebugBreak(void);

    __declspec(dllimport) void __stdcall OutputDebugStringA(LPCSTR lpOutputString);

    __declspec(dllimport) void __stdcall OutputDebugStringW(LPCWSTR lpOutputString);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall ContinueDebugEvent(DWORD dwProcessId, DWORD dwThreadId, DWORD dwContinueStatus);

    __declspec(dllimport) BOOL __stdcall WaitForDebugEvent(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds);

    __declspec(dllimport) BOOL __stdcall DebugActiveProcess(DWORD dwProcessId);

    __declspec(dllimport) BOOL __stdcall DebugActiveProcessStop(DWORD dwProcessId);

    __declspec(dllimport) BOOL __stdcall CheckRemoteDebuggerPresent(HANDLE hProcess, PBOOL pbDebuggerPresent);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall WaitForDebugEventEx(LPDEBUG_EVENT lpDebugEvent, DWORD dwMilliseconds);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    PVOID __stdcall EncodePointer(PVOID Ptr);

    __declspec(dllimport)

    PVOID __stdcall DecodePointer(PVOID Ptr);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    PVOID __stdcall EncodeSystemPointer(PVOID Ptr);

    __declspec(dllimport)

    PVOID __stdcall DecodeSystemPointer(PVOID Ptr);

    __declspec(dllimport) HRESULT __stdcall EncodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID* EncodedPtr);

    __declspec(dllimport) HRESULT __stdcall DecodeRemotePointer(HANDLE ProcessHandle, PVOID Ptr, PVOID* DecodedPtr);

#pragma endregion

#pragma region PC Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall Beep(DWORD dwFreq, DWORD dwDuration);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CloseHandle(HANDLE hObject);

    __declspec(dllimport) BOOL __stdcall DuplicateHandle(HANDLE hSourceProcessHandle,
                                                         HANDLE hSourceHandle,
                                                         HANDLE hTargetProcessHandle,
                                                         LPHANDLE lpTargetHandle,
                                                         DWORD dwDesiredAccess,
                                                         BOOL bInheritHandle,
                                                         DWORD dwOptions);

    __declspec(dllimport) BOOL __stdcall CompareObjectHandles(HANDLE hFirstObjectHandle, HANDLE hSecondObjectHandle);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetHandleInformation(HANDLE hObject, LPDWORD lpdwFlags);

    __declspec(dllimport) BOOL __stdcall SetHandleInformation(HANDLE hObject, DWORD dwMask, DWORD dwFlags);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    typedef LONG(__stdcall* PTOP_LEVEL_EXCEPTION_FILTER)(struct _EXCEPTION_POINTERS* ExceptionInfo);

    typedef PTOP_LEVEL_EXCEPTION_FILTER LPTOP_LEVEL_EXCEPTION_FILTER;

    __declspec(dllimport)

    void __stdcall RaiseException(DWORD dwExceptionCode, DWORD dwExceptionFlags, DWORD nNumberOfArguments, const ULONG_PTR* lpArguments);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) LONG __stdcall UnhandledExceptionFilter(struct _EXCEPTION_POINTERS* ExceptionInfo);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) LPTOP_LEVEL_EXCEPTION_FILTER
    __stdcall SetUnhandledExceptionFilter(LPTOP_LEVEL_EXCEPTION_FILTER lpTopLevelExceptionFilter);

    __declspec(dllimport)

    DWORD __stdcall GetLastError(void);

    __declspec(dllimport) void __stdcall SetLastError(DWORD dwErrCode);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) UINT __stdcall GetErrorMode(void);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) UINT __stdcall SetErrorMode(UINT uMode);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    PVOID __stdcall AddVectoredExceptionHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler);

    __declspec(dllimport) ULONG __stdcall RemoveVectoredExceptionHandler(PVOID Handle);

    __declspec(dllimport)

    PVOID __stdcall AddVectoredContinueHandler(ULONG First, PVECTORED_EXCEPTION_HANDLER Handler);

    __declspec(dllimport) ULONG __stdcall RemoveVectoredContinueHandler(PVOID Handle);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) void __stdcall RaiseFailFastException(PEXCEPTION_RECORD pExceptionRecord, PCONTEXT pContextRecord, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) void __stdcall FatalAppExitA(UINT uAction, LPCSTR lpMessageText);

    __declspec(dllimport) void __stdcall FatalAppExitW(UINT uAction, LPCWSTR lpMessageText);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetThreadErrorMode(void);

    __declspec(dllimport) BOOL __stdcall SetThreadErrorMode(DWORD dwNewMode, LPDWORD lpOldMode);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) void __stdcall TerminateProcessOnMemoryExhaustion(SIZE_T FailedAllocationSize);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall FlsAlloc(PFLS_CALLBACK_FUNCTION lpCallback);

    __declspec(dllimport) PVOID __stdcall FlsGetValue(DWORD dwFlsIndex);

    __declspec(dllimport) BOOL __stdcall FlsSetValue(DWORD dwFlsIndex, PVOID lpFlsData);

    __declspec(dllimport) BOOL __stdcall FlsFree(DWORD dwFlsIndex);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsThreadAFiber(void);

#pragma endregion
}

#pragma once

extern "C"
{
    __declspec(dllimport) BOOL
    __stdcall CreatePipe(PHANDLE hReadPipe, PHANDLE hWritePipe, LPSECURITY_ATTRIBUTES lpPipeAttributes, DWORD nSize);

    __declspec(dllimport) BOOL __stdcall ConnectNamedPipe(HANDLE hNamedPipe, LPOVERLAPPED lpOverlapped);

    __declspec(dllimport) BOOL __stdcall DisconnectNamedPipe(HANDLE hNamedPipe);

    __declspec(dllimport) BOOL
    __stdcall SetNamedPipeHandleState(HANDLE hNamedPipe, LPDWORD lpMode, LPDWORD lpMaxCollectionCount, LPDWORD lpCollectDataTimeout);

    __declspec(dllimport) BOOL
    __stdcall PeekNamedPipe(HANDLE hNamedPipe, LPVOID lpBuffer, DWORD nBufferSize, LPDWORD lpBytesRead, LPDWORD lpTotalBytesAvail, LPDWORD lpBytesLeftThisMessage);

    __declspec(dllimport) BOOL __stdcall TransactNamedPipe(HANDLE hNamedPipe,
                                                           LPVOID lpInBuffer,
                                                           DWORD nInBufferSize,
                                                           LPVOID lpOutBuffer,
                                                           DWORD nOutBufferSize,
                                                           LPDWORD lpBytesRead,
                                                           LPOVERLAPPED lpOverlapped);

    __declspec(dllimport) HANDLE __stdcall CreateNamedPipeW(LPCWSTR lpName,
                                                            DWORD dwOpenMode,
                                                            DWORD dwPipeMode,
                                                            DWORD nMaxInstances,
                                                            DWORD nOutBufferSize,
                                                            DWORD nInBufferSize,
                                                            DWORD nDefaultTimeOut,
                                                            LPSECURITY_ATTRIBUTES lpSecurityAttributes);

    __declspec(dllimport) BOOL __stdcall WaitNamedPipeW(LPCWSTR lpNamedPipeName, DWORD nTimeOut);

    __declspec(dllimport) BOOL
    __stdcall GetNamedPipeClientComputerNameW(HANDLE Pipe, LPWSTR ClientComputerName, ULONG ClientComputerNameLength);

    __declspec(dllimport)

    BOOL __stdcall ImpersonateNamedPipeClient(HANDLE hNamedPipe);

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetNamedPipeInfo(HANDLE hNamedPipe, LPDWORD lpFlags, LPDWORD lpOutBufferSize, LPDWORD lpInBufferSize, LPDWORD lpMaxInstances);

    __declspec(dllimport) BOOL __stdcall GetNamedPipeHandleStateW(HANDLE hNamedPipe,
                                                                  LPDWORD lpState,
                                                                  LPDWORD lpCurInstances,
                                                                  LPDWORD lpMaxCollectionCount,
                                                                  LPDWORD lpCollectDataTimeout,
                                                                  LPWSTR lpUserName,
                                                                  DWORD nMaxUserNameSize);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CallNamedPipeW(LPCWSTR lpNamedPipeName,
                                                        LPVOID lpInBuffer,
                                                        DWORD nInBufferSize,
                                                        LPVOID lpOutBuffer,
                                                        DWORD nOutBufferSize,
                                                        LPDWORD lpBytesRead,
                                                        DWORD nTimeOut);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall QueryPerformanceCounter(LARGE_INTEGER* lpPerformanceCount);

    __declspec(dllimport) BOOL __stdcall QueryPerformanceFrequency(LARGE_INTEGER* lpFrequency);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

#pragma region Desktop Family or OneCore Family

    typedef struct _HEAP_SUMMARY
    {
        DWORD cb;
        SIZE_T cbAllocated;
        SIZE_T cbCommitted;
        SIZE_T cbReserved;
        SIZE_T cbMaxReserve;
    } HEAP_SUMMARY, *PHEAP_SUMMARY;
    typedef PHEAP_SUMMARY LPHEAP_SUMMARY;

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    HANDLE __stdcall HeapCreate(DWORD flOptions, SIZE_T dwInitialSize, SIZE_T dwMaximumSize);

    __declspec(dllimport) BOOL __stdcall HeapDestroy(HANDLE hHeap);

    __declspec(dllimport)

    __declspec(allocator) LPVOID __stdcall HeapAlloc(HANDLE hHeap, DWORD dwFlags, SIZE_T dwBytes);

    __declspec(dllimport)

    __declspec(allocator) LPVOID __stdcall HeapReAlloc(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem, SIZE_T dwBytes);

    __declspec(dllimport)

    BOOL __stdcall HeapFree(HANDLE hHeap, DWORD dwFlags, LPVOID lpMem);

    __declspec(dllimport) SIZE_T __stdcall HeapSize(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);

    __declspec(dllimport) HANDLE __stdcall GetProcessHeap(void);

    __declspec(dllimport) SIZE_T __stdcall HeapCompact(HANDLE hHeap, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall HeapSetInformation(HANDLE HeapHandle, HEAP_INFORMATION_CLASS HeapInformationClass, PVOID HeapInformation, SIZE_T HeapInformationLength);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall HeapValidate(HANDLE hHeap, DWORD dwFlags, LPCVOID lpMem);

#pragma endregion

#pragma region Desktop Family

    BOOL __stdcall HeapSummary(HANDLE hHeap, DWORD dwFlags, LPHEAP_SUMMARY lpSummary);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetProcessHeaps(DWORD NumberOfHeaps, PHANDLE ProcessHeaps);

    __declspec(dllimport) BOOL __stdcall HeapLock(HANDLE hHeap);

    __declspec(dllimport) BOOL __stdcall HeapUnlock(HANDLE hHeap);

    __declspec(dllimport) BOOL __stdcall HeapWalk(HANDLE hHeap, LPPROCESS_HEAP_ENTRY lpEntry);

    __declspec(dllimport) BOOL __stdcall HeapQueryInformation(HANDLE HeapHandle,
                                                              HEAP_INFORMATION_CLASS HeapInformationClass,
                                                              PVOID HeapInformation,
                                                              SIZE_T HeapInformationLength,
                                                              PSIZE_T ReturnLength);

#pragma endregion

#pragma warning(pop)
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    HANDLE
    __stdcall CreateIoCompletionPort(HANDLE FileHandle, HANDLE ExistingCompletionPort, ULONG_PTR CompletionKey, DWORD NumberOfConcurrentThreads);

    __declspec(dllimport) BOOL __stdcall GetQueuedCompletionStatus(HANDLE CompletionPort,
                                                                   LPDWORD lpNumberOfBytesTransferred,
                                                                   PULONG_PTR lpCompletionKey,
                                                                   LPOVERLAPPED* lpOverlapped,
                                                                   DWORD dwMilliseconds);

    __declspec(dllimport) BOOL __stdcall GetQueuedCompletionStatusEx(HANDLE CompletionPort,
                                                                     LPOVERLAPPED_ENTRY lpCompletionPortEntries,
                                                                     ULONG ulCount,
                                                                     PULONG ulNumEntriesRemoved,
                                                                     DWORD dwMilliseconds,
                                                                     BOOL fAlertable);

    __declspec(dllimport) BOOL __stdcall PostQueuedCompletionStatus(HANDLE CompletionPort,
                                                                    DWORD dwNumberOfBytesTransferred,
                                                                    ULONG_PTR dwCompletionKey,
                                                                    LPOVERLAPPED lpOverlapped);

#pragma endregion

#pragma region Desktop Family or OneCore Family or Application Family

    __declspec(dllimport) BOOL __stdcall DeviceIoControl(HANDLE hDevice,
                                                         DWORD dwIoControlCode,
                                                         LPVOID lpInBuffer,
                                                         DWORD nInBufferSize,
                                                         LPVOID lpOutBuffer,
                                                         DWORD nOutBufferSize,
                                                         LPDWORD lpBytesReturned,
                                                         LPOVERLAPPED lpOverlapped);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetOverlappedResult(HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, BOOL bWait);

    __declspec(dllimport) BOOL __stdcall CancelIoEx(HANDLE hFile, LPOVERLAPPED lpOverlapped);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CancelIo(HANDLE hFile);

    __declspec(dllimport) BOOL __stdcall GetOverlappedResultEx(
    HANDLE hFile, LPOVERLAPPED lpOverlapped, LPDWORD lpNumberOfBytesTransferred, DWORD dwMilliseconds, BOOL bAlertable);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CancelSynchronousIo(HANDLE hThread);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application or OneCore Family

    typedef RTL_SRWLOCK SRWLOCK, *PSRWLOCK;

#pragma endregion

#pragma region Application or OneCore Family

    __declspec(dllimport) void __stdcall InitializeSRWLock(PSRWLOCK SRWLock);

    __declspec(dllimport)

    void __stdcall ReleaseSRWLockExclusive(PSRWLOCK SRWLock);

    __declspec(dllimport)

    void __stdcall ReleaseSRWLockShared(PSRWLOCK SRWLock);

    __declspec(dllimport)

    void __stdcall AcquireSRWLockExclusive(PSRWLOCK SRWLock);

    __declspec(dllimport)

    void __stdcall AcquireSRWLockShared(PSRWLOCK SRWLock);

    __declspec(dllimport)

    BOOLEAN __stdcall TryAcquireSRWLockExclusive(PSRWLOCK SRWLock);

    __declspec(dllimport)

    BOOLEAN __stdcall TryAcquireSRWLockShared(PSRWLOCK SRWLock);

    __declspec(dllimport) void __stdcall InitializeCriticalSection(LPCRITICAL_SECTION lpCriticalSection);

    __declspec(dllimport) void __stdcall EnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);

    __declspec(dllimport) void __stdcall LeaveCriticalSection(LPCRITICAL_SECTION lpCriticalSection);

    __declspec(dllimport)

    BOOL __stdcall InitializeCriticalSectionAndSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);

    __declspec(dllimport) BOOL
    __stdcall InitializeCriticalSectionEx(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount, DWORD Flags);

    __declspec(dllimport) DWORD __stdcall SetCriticalSectionSpinCount(LPCRITICAL_SECTION lpCriticalSection, DWORD dwSpinCount);

    __declspec(dllimport) BOOL __stdcall TryEnterCriticalSection(LPCRITICAL_SECTION lpCriticalSection);

    __declspec(dllimport) void __stdcall DeleteCriticalSection(LPCRITICAL_SECTION lpCriticalSection);

    typedef RTL_RUN_ONCE INIT_ONCE;
    typedef PRTL_RUN_ONCE PINIT_ONCE;
    typedef PRTL_RUN_ONCE LPINIT_ONCE;

    typedef BOOL(__stdcall* PINIT_ONCE_FN)(PINIT_ONCE InitOnce, PVOID Parameter, PVOID* Context);

    __declspec(dllimport) void __stdcall InitOnceInitialize(PINIT_ONCE InitOnce);

    __declspec(dllimport) BOOL
    __stdcall InitOnceExecuteOnce(PINIT_ONCE InitOnce, PINIT_ONCE_FN InitFn, PVOID Parameter, LPVOID* Context);

    __declspec(dllimport) BOOL
    __stdcall InitOnceBeginInitialize(LPINIT_ONCE lpInitOnce, DWORD dwFlags, PBOOL fPending, LPVOID* lpContext);

    __declspec(dllimport) BOOL __stdcall InitOnceComplete(LPINIT_ONCE lpInitOnce, DWORD dwFlags, LPVOID lpContext);

    typedef RTL_CONDITION_VARIABLE CONDITION_VARIABLE, *PCONDITION_VARIABLE;

    __declspec(dllimport) void __stdcall InitializeConditionVariable(PCONDITION_VARIABLE ConditionVariable);

    __declspec(dllimport) void __stdcall WakeConditionVariable(PCONDITION_VARIABLE ConditionVariable);

    __declspec(dllimport) void __stdcall WakeAllConditionVariable(PCONDITION_VARIABLE ConditionVariable);

    __declspec(dllimport) BOOL
    __stdcall SleepConditionVariableCS(PCONDITION_VARIABLE ConditionVariable, PCRITICAL_SECTION CriticalSection, DWORD dwMilliseconds);

    __declspec(dllimport) BOOL
    __stdcall SleepConditionVariableSRW(PCONDITION_VARIABLE ConditionVariable, PSRWLOCK SRWLock, DWORD dwMilliseconds, ULONG Flags);

    __declspec(dllimport) BOOL __stdcall SetEvent(HANDLE hEvent);

    __declspec(dllimport) BOOL __stdcall ResetEvent(HANDLE hEvent);

    __declspec(dllimport) BOOL __stdcall ReleaseSemaphore(HANDLE hSemaphore, LONG lReleaseCount, LPLONG lpPreviousCount);

    __declspec(dllimport) BOOL __stdcall ReleaseMutex(HANDLE hMutex);

    __declspec(dllimport) DWORD __stdcall WaitForSingleObject(HANDLE hHandle, DWORD dwMilliseconds);

    __declspec(dllimport) DWORD __stdcall SleepEx(DWORD dwMilliseconds, BOOL bAlertable);

    __declspec(dllimport) DWORD __stdcall WaitForSingleObjectEx(HANDLE hHandle, DWORD dwMilliseconds, BOOL bAlertable);

    __declspec(dllimport) DWORD
    __stdcall WaitForMultipleObjectsEx(DWORD nCount, const HANDLE* lpHandles, BOOL bWaitAll, DWORD dwMilliseconds, BOOL bAlertable);

    __declspec(dllimport)

    HANDLE __stdcall CreateMutexA(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall CreateMutexW(LPSECURITY_ATTRIBUTES lpMutexAttributes, BOOL bInitialOwner, LPCWSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall OpenMutexW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall CreateEventA(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall CreateEventW(LPSECURITY_ATTRIBUTES lpEventAttributes, BOOL bManualReset, BOOL bInitialState, LPCWSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall OpenEventA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall OpenEventW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall OpenSemaphoreW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);

    typedef void(__stdcall* PTIMERAPCROUTINE)(LPVOID lpArgToCompletionRoutine, DWORD dwTimerLowValue, DWORD dwTimerHighValue);

    __declspec(dllimport)

    HANDLE __stdcall OpenWaitableTimerW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpTimerName);

    BOOL __stdcall SetWaitableTimerEx(HANDLE hTimer,
                                      const LARGE_INTEGER* lpDueTime,
                                      LONG lPeriod,
                                      PTIMERAPCROUTINE pfnCompletionRoutine,
                                      LPVOID lpArgToCompletionRoutine,
                                      PREASON_CONTEXT WakeContext,
                                      ULONG TolerableDelay);

    __declspec(dllimport) BOOL __stdcall SetWaitableTimer(HANDLE hTimer,
                                                          const LARGE_INTEGER* lpDueTime,
                                                          LONG lPeriod,
                                                          PTIMERAPCROUTINE pfnCompletionRoutine,
                                                          LPVOID lpArgToCompletionRoutine,
                                                          BOOL fResume);

    __declspec(dllimport) BOOL __stdcall CancelWaitableTimer(HANDLE hTimer);

    __declspec(dllimport)

    HANDLE __stdcall CreateMutexExA(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);

    __declspec(dllimport)

    HANDLE __stdcall CreateMutexExW(LPSECURITY_ATTRIBUTES lpMutexAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);

    __declspec(dllimport)

    HANDLE __stdcall CreateEventExA(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);

    __declspec(dllimport)

    HANDLE __stdcall CreateEventExW(LPSECURITY_ATTRIBUTES lpEventAttributes, LPCWSTR lpName, DWORD dwFlags, DWORD dwDesiredAccess);

    __declspec(dllimport)

    HANDLE __stdcall CreateSemaphoreExW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
                                        LONG lInitialCount,
                                        LONG lMaximumCount,
                                        LPCWSTR lpName,
                                        DWORD dwFlags,
                                        DWORD dwDesiredAccess);

    __declspec(dllimport)

    HANDLE
    __stdcall CreateWaitableTimerExW(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCWSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess);

#pragma endregion

#pragma region Desktop or OneCore Family

    typedef RTL_BARRIER SYNCHRONIZATION_BARRIER;
    typedef PRTL_BARRIER PSYNCHRONIZATION_BARRIER;
    typedef PRTL_BARRIER LPSYNCHRONIZATION_BARRIER;

    BOOL __stdcall EnterSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, DWORD dwFlags);

    BOOL __stdcall InitializeSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier, LONG lTotalThreads, LONG lSpinCount);

    BOOL __stdcall DeleteSynchronizationBarrier(LPSYNCHRONIZATION_BARRIER lpBarrier);

#pragma endregion

#pragma region Application or OneCore Family

    __declspec(dllimport) void __stdcall Sleep(DWORD dwMilliseconds);

    BOOL __stdcall WaitOnAddress(volatile void* Address, PVOID CompareAddress, SIZE_T AddressSize, DWORD dwMilliseconds);

    void __stdcall WakeByAddressSingle(PVOID Address);

    void __stdcall WakeByAddressAll(PVOID Address);

#pragma endregion

#pragma region Desktop or OneCore Family

    __declspec(dllimport) DWORD
    __stdcall SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);

#pragma endregion

#pragma region Application or OneCore Family

    __declspec(dllimport) DWORD
    __stdcall WaitForMultipleObjects(DWORD nCount, const HANDLE* lpHandles, BOOL bWaitAll, DWORD dwMilliseconds);

    __declspec(dllimport) HANDLE
    __stdcall CreateSemaphoreW(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCWSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall CreateWaitableTimerW(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCWSTR lpTimerName);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    __declspec(dllimport) void __stdcall InitializeSListHead(PSLIST_HEADER ListHead);

    __declspec(dllimport) PSLIST_ENTRY __stdcall InterlockedPopEntrySList(PSLIST_HEADER ListHead);

    __declspec(dllimport) PSLIST_ENTRY __stdcall InterlockedPushEntrySList(PSLIST_HEADER ListHead, PSLIST_ENTRY ListEntry);

    __declspec(dllimport) PSLIST_ENTRY
    __stdcall InterlockedPushListSListEx(PSLIST_HEADER ListHead, PSLIST_ENTRY List, PSLIST_ENTRY ListEnd, ULONG Count);

    __declspec(dllimport) PSLIST_ENTRY __stdcall InterlockedFlushSList(PSLIST_HEADER ListHead);

    __declspec(dllimport) USHORT __stdcall QueryDepthSList(PSLIST_HEADER ListHead);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    typedef struct _PROCESS_INFORMATION
    {
        HANDLE hProcess;
        HANDLE hThread;
        DWORD dwProcessId;
        DWORD dwThreadId;
    } PROCESS_INFORMATION, *PPROCESS_INFORMATION, *LPPROCESS_INFORMATION;

    typedef struct _STARTUPINFOA
    {
        DWORD cb;
        LPSTR lpReserved;
        LPSTR lpDesktop;
        LPSTR lpTitle;
        DWORD dwX;
        DWORD dwY;
        DWORD dwXSize;
        DWORD dwYSize;
        DWORD dwXCountChars;
        DWORD dwYCountChars;
        DWORD dwFillAttribute;
        DWORD dwFlags;
        WORD wShowWindow;
        WORD cbReserved2;
        LPBYTE lpReserved2;
        HANDLE hStdInput;
        HANDLE hStdOutput;
        HANDLE hStdError;
    } STARTUPINFOA, *LPSTARTUPINFOA;
    typedef struct _STARTUPINFOW
    {
        DWORD cb;
        LPWSTR lpReserved;
        LPWSTR lpDesktop;
        LPWSTR lpTitle;
        DWORD dwX;
        DWORD dwY;
        DWORD dwXSize;
        DWORD dwYSize;
        DWORD dwXCountChars;
        DWORD dwYCountChars;
        DWORD dwFillAttribute;
        DWORD dwFlags;
        WORD wShowWindow;
        WORD cbReserved2;
        LPBYTE lpReserved2;
        HANDLE hStdInput;
        HANDLE hStdOutput;
        HANDLE hStdError;
    } STARTUPINFOW, *LPSTARTUPINFOW;

    typedef STARTUPINFOA STARTUPINFO;
    typedef LPSTARTUPINFOA LPSTARTUPINFO;

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall QueueUserAPC(PAPCFUNC pfnAPC, HANDLE hThread, ULONG_PTR dwData);

    __declspec(dllimport) BOOL
    __stdcall GetProcessTimes(HANDLE hProcess, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);

    __declspec(dllimport) HANDLE __stdcall GetCurrentProcess(void);

    __declspec(dllimport) DWORD __stdcall GetCurrentProcessId(void);

    __declspec(dllimport) __declspec(noreturn) void __stdcall ExitProcess(UINT uExitCode);

    __declspec(dllimport) BOOL __stdcall TerminateProcess(HANDLE hProcess, UINT uExitCode);

    __declspec(dllimport) BOOL __stdcall GetExitCodeProcess(HANDLE hProcess, LPDWORD lpExitCode);

    __declspec(dllimport) BOOL __stdcall SwitchToThread(void);

    __declspec(dllimport)

    HANDLE __stdcall CreateThread(LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                  SIZE_T dwStackSize,
                                  LPTHREAD_START_ROUTINE lpStartAddress,
                                  LPVOID lpParameter,
                                  DWORD dwCreationFlags,
                                  LPDWORD lpThreadId);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    HANDLE __stdcall CreateRemoteThread(HANDLE hProcess,
                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                        SIZE_T dwStackSize,
                                        LPTHREAD_START_ROUTINE lpStartAddress,
                                        LPVOID lpParameter,
                                        DWORD dwCreationFlags,
                                        LPDWORD lpThreadId);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) HANDLE __stdcall GetCurrentThread(void);

    __declspec(dllimport) DWORD __stdcall GetCurrentThreadId(void);

    __declspec(dllimport)

    HANDLE __stdcall OpenThread(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwThreadId);

    __declspec(dllimport) BOOL __stdcall SetThreadPriority(HANDLE hThread, int nPriority);

    __declspec(dllimport) BOOL __stdcall SetThreadPriorityBoost(HANDLE hThread, BOOL bDisablePriorityBoost);

    __declspec(dllimport) BOOL __stdcall GetThreadPriorityBoost(HANDLE hThread, PBOOL pDisablePriorityBoost);

    __declspec(dllimport) int __stdcall GetThreadPriority(HANDLE hThread);

    __declspec(dllimport) __declspec(noreturn) void __stdcall ExitThread(DWORD dwExitCode);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall TerminateThread(HANDLE hThread, DWORD dwExitCode);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall GetExitCodeThread(HANDLE hThread, LPDWORD lpExitCode);

    __declspec(dllimport) DWORD __stdcall SuspendThread(HANDLE hThread);

    __declspec(dllimport) DWORD __stdcall ResumeThread(HANDLE hThread);

    __declspec(dllimport) DWORD __stdcall TlsAlloc(void);

    __declspec(dllimport) LPVOID __stdcall TlsGetValue(DWORD dwTlsIndex);

    __declspec(dllimport) BOOL __stdcall TlsSetValue(DWORD dwTlsIndex, LPVOID lpTlsValue);

    __declspec(dllimport) BOOL __stdcall TlsFree(DWORD dwTlsIndex);

    __declspec(dllimport) BOOL __stdcall CreateProcessA(LPCSTR lpApplicationName,
                                                        LPSTR lpCommandLine,
                                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                                        BOOL bInheritHandles,
                                                        DWORD dwCreationFlags,
                                                        LPVOID lpEnvironment,
                                                        LPCSTR lpCurrentDirectory,
                                                        LPSTARTUPINFOA lpStartupInfo,
                                                        LPPROCESS_INFORMATION lpProcessInformation);

    __declspec(dllimport) BOOL __stdcall CreateProcessW(LPCWSTR lpApplicationName,
                                                        LPWSTR lpCommandLine,
                                                        LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                                        LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                                        BOOL bInheritHandles,
                                                        DWORD dwCreationFlags,
                                                        LPVOID lpEnvironment,
                                                        LPCWSTR lpCurrentDirectory,
                                                        LPSTARTUPINFOW lpStartupInfo,
                                                        LPPROCESS_INFORMATION lpProcessInformation);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetProcessShutdownParameters(DWORD dwLevel, DWORD dwFlags);

    __declspec(dllimport) DWORD __stdcall GetProcessVersion(DWORD ProcessId);

    __declspec(dllimport) void __stdcall GetStartupInfoW(LPSTARTUPINFOW lpStartupInfo);

    __declspec(dllimport) BOOL __stdcall CreateProcessAsUserW(HANDLE hToken,
                                                              LPCWSTR lpApplicationName,
                                                              LPWSTR lpCommandLine,
                                                              LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                                              LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                                              BOOL bInheritHandles,
                                                              DWORD dwCreationFlags,
                                                              LPVOID lpEnvironment,
                                                              LPCWSTR lpCurrentDirectory,
                                                              LPSTARTUPINFOW lpStartupInfo,
                                                              LPPROCESS_INFORMATION lpProcessInformation);

    __forceinline HANDLE GetCurrentProcessToken(void)
    {
        return (HANDLE)(LONG_PTR)-4;
    }

    __forceinline HANDLE GetCurrentThreadToken(void)
    {
        return (HANDLE)(LONG_PTR)-5;
    }

    __forceinline HANDLE GetCurrentThreadEffectiveToken(void)
    {
        return (HANDLE)(LONG_PTR)-6;
    }

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall SetThreadToken(PHANDLE Thread, HANDLE Token);

    __declspec(dllimport) BOOL __stdcall OpenProcessToken(HANDLE ProcessHandle, DWORD DesiredAccess, PHANDLE TokenHandle);

    __declspec(dllimport) BOOL
    __stdcall OpenThreadToken(HANDLE ThreadHandle, DWORD DesiredAccess, BOOL OpenAsSelf, PHANDLE TokenHandle);

    __declspec(dllimport) BOOL __stdcall SetPriorityClass(HANDLE hProcess, DWORD dwPriorityClass);

    __declspec(dllimport) DWORD __stdcall GetPriorityClass(HANDLE hProcess);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetThreadStackGuarantee(PULONG StackSizeInBytes);

    __declspec(dllimport) BOOL __stdcall ProcessIdToSessionId(DWORD dwProcessId, DWORD* pSessionId);

    typedef struct _PROC_THREAD_ATTRIBUTE_LIST *PPROC_THREAD_ATTRIBUTE_LIST, *LPPROC_THREAD_ATTRIBUTE_LIST;

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetProcessId(HANDLE Process);

    __declspec(dllimport) DWORD __stdcall GetThreadId(HANDLE Thread);

    __declspec(dllimport) void __stdcall FlushProcessWriteBuffers(void);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetProcessIdOfThread(HANDLE Thread);

    __declspec(dllimport)

    BOOL __stdcall InitializeProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
                                                     DWORD dwAttributeCount,
                                                     DWORD dwFlags,
                                                     PSIZE_T lpSize);

    __declspec(dllimport) void __stdcall DeleteProcThreadAttributeList(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList);

    __declspec(dllimport) BOOL __stdcall SetProcessAffinityUpdateMode(HANDLE hProcess, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall QueryProcessAffinityUpdateMode(HANDLE hProcess, LPDWORD lpdwFlags);

    __declspec(dllimport) BOOL __stdcall UpdateProcThreadAttribute(LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
                                                                   DWORD dwFlags,
                                                                   DWORD_PTR Attribute,
                                                                   PVOID lpValue,
                                                                   SIZE_T cbSize,
                                                                   PVOID lpPreviousValue,
                                                                   PSIZE_T lpReturnSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    HANDLE __stdcall CreateRemoteThreadEx(HANDLE hProcess,
                                          LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                          SIZE_T dwStackSize,
                                          LPTHREAD_START_ROUTINE lpStartAddress,
                                          LPVOID lpParameter,
                                          DWORD dwCreationFlags,
                                          LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList,
                                          LPDWORD lpThreadId);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) void __stdcall GetCurrentThreadStackLimits(PULONG_PTR LowLimit, PULONG_PTR HighLimit);

    __declspec(dllimport) BOOL __stdcall GetThreadContext(HANDLE hThread, LPCONTEXT lpContext);

    __declspec(dllimport) BOOL
    __stdcall GetProcessMitigationPolicy(HANDLE hProcess, PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetThreadContext(HANDLE hThread, const CONTEXT* lpContext);

    __declspec(dllimport) BOOL
    __stdcall SetProcessMitigationPolicy(PROCESS_MITIGATION_POLICY MitigationPolicy, PVOID lpBuffer, SIZE_T dwLength);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall FlushInstructionCache(HANDLE hProcess, LPCVOID lpBaseAddress, SIZE_T dwSize);

    __declspec(dllimport) BOOL
    __stdcall GetThreadTimes(HANDLE hThread, LPFILETIME lpCreationTime, LPFILETIME lpExitTime, LPFILETIME lpKernelTime, LPFILETIME lpUserTime);

    __declspec(dllimport) HANDLE __stdcall OpenProcess(DWORD dwDesiredAccess, BOOL bInheritHandle, DWORD dwProcessId);

    __declspec(dllimport) BOOL __stdcall IsProcessorFeaturePresent(DWORD ProcessorFeature);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetProcessHandleCount(HANDLE hProcess, PDWORD pdwHandleCount);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetCurrentProcessorNumber(void);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall SetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor, PPROCESSOR_NUMBER lpPreviousIdealProcessor);

    __declspec(dllimport) BOOL __stdcall GetThreadIdealProcessorEx(HANDLE hThread, PPROCESSOR_NUMBER lpIdealProcessor);

    __declspec(dllimport) void __stdcall GetCurrentProcessorNumberEx(PPROCESSOR_NUMBER ProcNumber);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetProcessPriorityBoost(HANDLE hProcess, PBOOL pDisablePriorityBoost);

    __declspec(dllimport) BOOL __stdcall SetProcessPriorityBoost(HANDLE hProcess, BOOL bDisablePriorityBoost);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetThreadIOPendingFlag(HANDLE hThread, PBOOL lpIOIsPending);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetSystemTimes(PFILETIME lpIdleTime, PFILETIME lpKernelTime, PFILETIME lpUserTime);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef enum _THREAD_INFORMATION_CLASS
    {
        ThreadMemoryPriority,
        ThreadAbsoluteCpuPriority,
        ThreadDynamicCodePolicy,
        ThreadPowerThrottling,
        ThreadInformationClassMax
    } THREAD_INFORMATION_CLASS;

    typedef struct _MEMORY_PRIORITY_INFORMATION
    {
        ULONG MemoryPriority;
    } MEMORY_PRIORITY_INFORMATION, *PMEMORY_PRIORITY_INFORMATION;

    __declspec(dllimport) BOOL __stdcall GetThreadInformation(HANDLE hThread,
                                                              THREAD_INFORMATION_CLASS ThreadInformationClass,
                                                              LPVOID ThreadInformation,
                                                              DWORD ThreadInformationSize);

    __declspec(dllimport) BOOL __stdcall SetThreadInformation(HANDLE hThread,
                                                              THREAD_INFORMATION_CLASS ThreadInformationClass,
                                                              LPVOID ThreadInformation,
                                                              DWORD ThreadInformationSize);

    typedef struct _THREAD_POWER_THROTTLING_STATE
    {
        ULONG Version;
        ULONG ControlMask;
        ULONG StateMask;
    } THREAD_POWER_THROTTLING_STATE;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsProcessCritical(HANDLE hProcess, PBOOL Critical);

    __declspec(dllimport) BOOL __stdcall SetProtectedPolicy(LPCGUID PolicyGuid, ULONG_PTR PolicyValue, PULONG_PTR OldPolicyValue);

    __declspec(dllimport) BOOL __stdcall QueryProtectedPolicy(LPCGUID PolicyGuid, PULONG_PTR PolicyValue);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall SetThreadIdealProcessor(HANDLE hThread, DWORD dwIdealProcessor);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef enum _PROCESS_INFORMATION_CLASS
    {
        ProcessMemoryPriority,
        ProcessMemoryExhaustionInfo,
        ProcessAppMemoryInfo,
        ProcessInPrivateInfo,
        ProcessPowerThrottling,
        ProcessReservedValue1,
        ProcessTelemetryCoverageInfo,
        ProcessProtectionLevelInfo,
        ProcessLeapSecondInfo,
        ProcessInformationClassMax
    } PROCESS_INFORMATION_CLASS;

    typedef struct _APP_MEMORY_INFORMATION
    {
        ULONG64 AvailableCommit;
        ULONG64 PrivateCommitUsage;
        ULONG64 PeakPrivateCommitUsage;
        ULONG64 TotalCommitUsage;
    } APP_MEMORY_INFORMATION, *PAPP_MEMORY_INFORMATION;

    typedef enum _PROCESS_MEMORY_EXHAUSTION_TYPE
    {
        PMETypeFailFastOnCommitFailure,
        PMETypeMax
    } PROCESS_MEMORY_EXHAUSTION_TYPE,
    *PPROCESS_MEMORY_EXHAUSTION_TYPE;

    typedef struct _PROCESS_MEMORY_EXHAUSTION_INFO
    {
        USHORT Version;
        USHORT Reserved;
        PROCESS_MEMORY_EXHAUSTION_TYPE Type;
        ULONG_PTR Value;
    } PROCESS_MEMORY_EXHAUSTION_INFO, *PPROCESS_MEMORY_EXHAUSTION_INFO;

    typedef struct _PROCESS_POWER_THROTTLING_STATE
    {
        ULONG Version;
        ULONG ControlMask;
        ULONG StateMask;
    } PROCESS_POWER_THROTTLING_STATE, *PPROCESS_POWER_THROTTLING_STATE;

    typedef struct PROCESS_PROTECTION_LEVEL_INFORMATION
    {
        DWORD ProtectionLevel;
    } PROCESS_PROTECTION_LEVEL_INFORMATION;

    typedef struct _PROCESS_LEAP_SECOND_INFO
    {
        ULONG Flags;
        ULONG Reserved;
    } PROCESS_LEAP_SECOND_INFO, *PPROCESS_LEAP_SECOND_INFO;

    __declspec(dllimport) BOOL __stdcall SetProcessInformation(HANDLE hProcess,
                                                               PROCESS_INFORMATION_CLASS ProcessInformationClass,
                                                               LPVOID ProcessInformation,
                                                               DWORD ProcessInformationSize);

    __declspec(dllimport) BOOL __stdcall GetProcessInformation(HANDLE hProcess,
                                                               PROCESS_INFORMATION_CLASS ProcessInformationClass,
                                                               LPVOID ProcessInformation,
                                                               DWORD ProcessInformationSize);

    BOOL __stdcall GetSystemCpuSetInformation(
    PSYSTEM_CPU_SET_INFORMATION Information, ULONG BufferLength, PULONG ReturnedLength, HANDLE Process, ULONG Flags);

    BOOL __stdcall GetProcessDefaultCpuSets(HANDLE Process, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount);

    BOOL __stdcall SetProcessDefaultCpuSets(HANDLE Process, const ULONG* CpuSetIds, ULONG CpuSetIdCount);

    BOOL __stdcall GetThreadSelectedCpuSets(HANDLE Thread, PULONG CpuSetIds, ULONG CpuSetIdCount, PULONG RequiredIdCount);

    BOOL __stdcall SetThreadSelectedCpuSets(HANDLE Thread, const ULONG* CpuSetIds, ULONG CpuSetIdCount);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CreateProcessAsUserA(HANDLE hToken,
                                                              LPCSTR lpApplicationName,
                                                              LPSTR lpCommandLine,
                                                              LPSECURITY_ATTRIBUTES lpProcessAttributes,
                                                              LPSECURITY_ATTRIBUTES lpThreadAttributes,
                                                              BOOL bInheritHandles,
                                                              DWORD dwCreationFlags,
                                                              LPVOID lpEnvironment,
                                                              LPCSTR lpCurrentDirectory,
                                                              LPSTARTUPINFOA lpStartupInfo,
                                                              LPPROCESS_INFORMATION lpProcessInformation);

    __declspec(dllimport) BOOL __stdcall GetProcessShutdownParameters(LPDWORD lpdwLevel, LPDWORD lpdwFlags);

#pragma endregion

    __declspec(dllimport) HRESULT __stdcall SetThreadDescription(HANDLE hThread, PCWSTR lpThreadDescription);

    __declspec(dllimport) HRESULT __stdcall GetThreadDescription(HANDLE hThread, PWSTR* ppszThreadDescription);
}

#pragma once

#pragma warning(disable : 4514)

#pragma warning(disable : 4103)

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)

extern "C"
{
#pragma region Application Family or OneCore Family

    typedef struct _SYSTEM_INFO
    {
        union
        {
            DWORD dwOemId;
            struct
            {
                WORD wProcessorArchitecture;
                WORD wReserved;
            };
        };
        DWORD dwPageSize;
        LPVOID lpMinimumApplicationAddress;
        LPVOID lpMaximumApplicationAddress;
        DWORD_PTR dwActiveProcessorMask;
        DWORD dwNumberOfProcessors;
        DWORD dwProcessorType;
        DWORD dwAllocationGranularity;
        WORD wProcessorLevel;
        WORD wProcessorRevision;
    } SYSTEM_INFO, *LPSYSTEM_INFO;

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct _MEMORYSTATUSEX
    {
        DWORD dwLength;
        DWORD dwMemoryLoad;
        DWORDLONG ullTotalPhys;
        DWORDLONG ullAvailPhys;
        DWORDLONG ullTotalPageFile;
        DWORDLONG ullAvailPageFile;
        DWORDLONG ullTotalVirtual;
        DWORDLONG ullAvailVirtual;
        DWORDLONG ullAvailExtendedVirtual;
    } MEMORYSTATUSEX, *LPMEMORYSTATUSEX;

    __declspec(dllimport) BOOL __stdcall GlobalMemoryStatusEx(LPMEMORYSTATUSEX lpBuffer);

    __declspec(dllimport) void __stdcall GetSystemInfo(LPSYSTEM_INFO lpSystemInfo);

    __declspec(dllimport) void __stdcall GetSystemTime(LPSYSTEMTIME lpSystemTime);

    __declspec(dllimport) void __stdcall GetSystemTimeAsFileTime(LPFILETIME lpSystemTimeAsFileTime);

    __declspec(dllimport) void __stdcall GetLocalTime(LPSYSTEMTIME lpSystemTime);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(deprecated) __declspec(dllimport)

    DWORD __stdcall GetVersion(void);

    __declspec(dllimport) BOOL __stdcall SetLocalTime(const SYSTEMTIME* lpSystemTime);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetTickCount(void);

    __declspec(dllimport) ULONGLONG __stdcall GetTickCount64(void);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall GetSystemTimeAdjustment(PDWORD lpTimeAdjustment, PDWORD lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled);

    __declspec(dllimport)

    BOOL __stdcall GetSystemTimeAdjustmentPrecise(PDWORD64 lpTimeAdjustment, PDWORD64 lpTimeIncrement, PBOOL lpTimeAdjustmentDisabled);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    UINT __stdcall GetSystemDirectoryA(LPSTR lpBuffer, UINT uSize);

    __declspec(dllimport)

    UINT __stdcall GetSystemDirectoryW(LPWSTR lpBuffer, UINT uSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    UINT __stdcall GetWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);

    __declspec(dllimport)

    UINT __stdcall GetWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);

    __declspec(dllimport)

    UINT __stdcall GetSystemWindowsDirectoryA(LPSTR lpBuffer, UINT uSize);

    __declspec(dllimport)

    UINT __stdcall GetSystemWindowsDirectoryW(LPWSTR lpBuffer, UINT uSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef enum _COMPUTER_NAME_FORMAT
    {
        ComputerNameNetBIOS,
        ComputerNameDnsHostname,
        ComputerNameDnsDomain,
        ComputerNameDnsFullyQualified,
        ComputerNamePhysicalNetBIOS,
        ComputerNamePhysicalDnsHostname,
        ComputerNamePhysicalDnsDomain,
        ComputerNamePhysicalDnsFullyQualified,
        ComputerNameMax
    } COMPUTER_NAME_FORMAT;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall GetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPSTR lpBuffer, LPDWORD nSize);

    __declspec(dllimport)

    BOOL __stdcall GetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPWSTR lpBuffer, LPDWORD nSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetComputerNameExW(COMPUTER_NAME_FORMAT NameType, LPCWSTR lpBuffer);

    __declspec(dllimport) BOOL __stdcall SetSystemTime(const SYSTEMTIME* lpSystemTime);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(deprecated) __declspec(dllimport)

    BOOL __stdcall GetVersionExA(LPOSVERSIONINFOA lpVersionInformation);

    __declspec(deprecated) __declspec(dllimport)

    BOOL __stdcall GetVersionExW(LPOSVERSIONINFOW lpVersionInformation);

    __declspec(dllimport) BOOL
    __stdcall GetLogicalProcessorInformation(PSYSTEM_LOGICAL_PROCESSOR_INFORMATION Buffer, PDWORD ReturnedLength);

    __declspec(dllimport) BOOL __stdcall GetLogicalProcessorInformationEx(LOGICAL_PROCESSOR_RELATIONSHIP RelationshipType,
                                                                          PSYSTEM_LOGICAL_PROCESSOR_INFORMATION_EX Buffer,
                                                                          PDWORD ReturnedLength);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) void __stdcall GetNativeSystemInfo(LPSYSTEM_INFO lpSystemInfo);

    __declspec(dllimport) void __stdcall GetSystemTimePreciseAsFileTime(LPFILETIME lpSystemTimeAsFileTime);

    __declspec(dllimport) BOOL
    __stdcall GetProductInfo(DWORD dwOSMajorVersion, DWORD dwOSMinorVersion, DWORD dwSpMajorVersion, DWORD dwSpMinorVersion, PDWORD pdwReturnedProductType);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) ULONGLONG __stdcall VerSetConditionMask(ULONGLONG ConditionMask, ULONG TypeMask, UCHAR Condition);

    __declspec(dllimport) BOOL __stdcall GetOsSafeBootMode(PDWORD Flags);

#pragma endregion

#pragma region OneCore Family or App Family

    __declspec(dllimport) UINT
    __stdcall EnumSystemFirmwareTables(DWORD FirmwareTableProviderSignature, PVOID pFirmwareTableEnumBuffer, DWORD BufferSize);

    __declspec(dllimport) UINT
    __stdcall GetSystemFirmwareTable(DWORD FirmwareTableProviderSignature, DWORD FirmwareTableID, PVOID pFirmwareTableBuffer, DWORD BufferSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall DnsHostnameToComputerNameExW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize);

    __declspec(dllimport)

    BOOL __stdcall GetPhysicallyInstalledSystemMemory(PULONGLONG TotalMemoryInKilobytes);

    __declspec(dllimport) BOOL __stdcall SetComputerNameEx2W(COMPUTER_NAME_FORMAT NameType, DWORD Flags, LPCWSTR lpBuffer);

    __declspec(dllimport)

    BOOL __stdcall SetSystemTimeAdjustment(DWORD dwTimeAdjustment, BOOL bTimeAdjustmentDisabled);

    __declspec(dllimport)

    BOOL __stdcall SetSystemTimeAdjustmentPrecise(DWORD64 dwTimeAdjustment, BOOL bTimeAdjustmentDisabled);

    __declspec(dllimport) BOOL __stdcall InstallELAMCertificateInfo(HANDLE ELAMFile);

#pragma endregion

    __declspec(dllimport) BOOL
    __stdcall GetProcessorSystemCycleTime(USHORT Group, PSYSTEM_PROCESSOR_CYCLE_TIME_INFORMATION Buffer, PDWORD ReturnedLength);

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetOsManufacturingMode(PBOOL pbEnabled);

#pragma endregion

#pragma region App Family or OneCore Family

    __declspec(dllimport) HRESULT __stdcall GetIntegratedDisplaySize(double* sizeInInches);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetComputerNameA(LPCSTR lpComputerName);

    __declspec(dllimport) BOOL __stdcall SetComputerNameW(LPCWSTR lpComputerName);

    __declspec(dllimport) BOOL __stdcall SetComputerNameExA(COMPUTER_NAME_FORMAT NameType, LPCSTR lpBuffer);

#pragma endregion
}

#pragma warning(pop)

#pragma once

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4668)

#pragma region Application Family or OneCore Family

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    LPVOID __stdcall VirtualAlloc(LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

    __declspec(dllimport)

    BOOL __stdcall VirtualProtect(LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall VirtualFree(LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);

    __declspec(dllimport) SIZE_T __stdcall VirtualQuery(LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    LPVOID __stdcall VirtualAllocEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect);

    __declspec(dllimport)

    BOOL __stdcall VirtualProtectEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flNewProtect, PDWORD lpflOldProtect);

    __declspec(dllimport) SIZE_T
    __stdcall VirtualQueryEx(HANDLE hProcess, LPCVOID lpAddress, PMEMORY_BASIC_INFORMATION lpBuffer, SIZE_T dwLength);

    __declspec(dllimport)

    BOOL __stdcall ReadProcessMemory(HANDLE hProcess, LPCVOID lpBaseAddress, LPVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesRead);

    __declspec(dllimport)

    BOOL __stdcall WriteProcessMemory(HANDLE hProcess, LPVOID lpBaseAddress, LPCVOID lpBuffer, SIZE_T nSize, SIZE_T* lpNumberOfBytesWritten);

    __declspec(dllimport)

    HANDLE __stdcall CreateFileMappingW(HANDLE hFile,
                                        LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
                                        DWORD flProtect,
                                        DWORD dwMaximumSizeHigh,
                                        DWORD dwMaximumSizeLow,
                                        LPCWSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall OpenFileMappingW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);

    __declspec(dllimport)

    LPVOID
    __stdcall MapViewOfFile(HANDLE hFileMappingObject, DWORD dwDesiredAccess, DWORD dwFileOffsetHigh, DWORD dwFileOffsetLow, SIZE_T dwNumberOfBytesToMap);

    __declspec(dllimport)

    LPVOID __stdcall MapViewOfFileEx(HANDLE hFileMappingObject,
                                     DWORD dwDesiredAccess,
                                     DWORD dwFileOffsetHigh,
                                     DWORD dwFileOffsetLow,
                                     SIZE_T dwNumberOfBytesToMap,
                                     LPVOID lpBaseAddress);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall VirtualFreeEx(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD dwFreeType);

    __declspec(dllimport) BOOL __stdcall FlushViewOfFile(LPCVOID lpBaseAddress, SIZE_T dwNumberOfBytesToFlush);

    __declspec(dllimport) BOOL __stdcall UnmapViewOfFile(LPCVOID lpBaseAddress);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) SIZE_T __stdcall GetLargePageMinimum(void);

    __declspec(dllimport)

    BOOL
    __stdcall GetProcessWorkingSetSizeEx(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize, PDWORD Flags);

    __declspec(dllimport) BOOL
    __stdcall SetProcessWorkingSetSizeEx(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize, DWORD Flags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall VirtualLock(LPVOID lpAddress, SIZE_T dwSize);

    __declspec(dllimport) BOOL __stdcall VirtualUnlock(LPVOID lpAddress, SIZE_T dwSize);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    UINT
    __stdcall GetWriteWatch(DWORD dwFlags, PVOID lpBaseAddress, SIZE_T dwRegionSize, PVOID* lpAddresses, ULONG_PTR* lpdwCount, LPDWORD lpdwGranularity);

    __declspec(dllimport) UINT __stdcall ResetWriteWatch(LPVOID lpBaseAddress, SIZE_T dwRegionSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef enum _MEMORY_RESOURCE_NOTIFICATION_TYPE
    {
        LowMemoryResourceNotification,
        HighMemoryResourceNotification
    } MEMORY_RESOURCE_NOTIFICATION_TYPE;

    __declspec(dllimport)

    HANDLE __stdcall CreateMemoryResourceNotification(MEMORY_RESOURCE_NOTIFICATION_TYPE NotificationType);

    __declspec(dllimport)

    BOOL __stdcall QueryMemoryResourceNotification(HANDLE ResourceNotificationHandle, PBOOL ResourceState);

    __declspec(dllimport)

    BOOL __stdcall GetSystemFileCacheSize(PSIZE_T lpMinimumFileCacheSize, PSIZE_T lpMaximumFileCacheSize, PDWORD lpFlags);

    __declspec(dllimport) BOOL
    __stdcall SetSystemFileCacheSize(SIZE_T MinimumFileCacheSize, SIZE_T MaximumFileCacheSize, DWORD Flags);

    __declspec(dllimport)

    HANDLE __stdcall CreateFileMappingNumaW(HANDLE hFile,
                                            LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
                                            DWORD flProtect,
                                            DWORD dwMaximumSizeHigh,
                                            DWORD dwMaximumSizeLow,
                                            LPCWSTR lpName,
                                            DWORD nndPreferred);

    typedef struct _WIN32_MEMORY_RANGE_ENTRY
    {
        PVOID VirtualAddress;
        SIZE_T NumberOfBytes;
    } WIN32_MEMORY_RANGE_ENTRY, *PWIN32_MEMORY_RANGE_ENTRY;

    __declspec(dllimport) BOOL
    __stdcall PrefetchVirtualMemory(HANDLE hProcess, ULONG_PTR NumberOfEntries, PWIN32_MEMORY_RANGE_ENTRY VirtualAddresses, ULONG Flags);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    HANDLE __stdcall CreateFileMappingFromApp(
    HANDLE hFile, PSECURITY_ATTRIBUTES SecurityAttributes, ULONG PageProtection, ULONG64 MaximumSize, PCWSTR Name);

    __declspec(dllimport)

    PVOID __stdcall MapViewOfFileFromApp(HANDLE hFileMappingObject, ULONG DesiredAccess, ULONG64 FileOffset, SIZE_T NumberOfBytesToMap);

    __declspec(dllimport) BOOL __stdcall UnmapViewOfFileEx(PVOID BaseAddress, ULONG UnmapFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall AllocateUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray);

    __declspec(dllimport)

    BOOL __stdcall FreeUserPhysicalPages(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray);

    __declspec(dllimport)

    BOOL __stdcall MapUserPhysicalPages(PVOID VirtualAddress, ULONG_PTR NumberOfPages, PULONG_PTR PageArray);

    __declspec(dllimport)

    BOOL __stdcall AllocateUserPhysicalPagesNuma(HANDLE hProcess, PULONG_PTR NumberOfPages, PULONG_PTR PageArray, DWORD nndPreferred);

    __declspec(dllimport)

    LPVOID
    __stdcall VirtualAllocExNuma(HANDLE hProcess, LPVOID lpAddress, SIZE_T dwSize, DWORD flAllocationType, DWORD flProtect, DWORD nndPreferred);

    __declspec(dllimport)

    BOOL __stdcall GetMemoryErrorHandlingCapabilities(PULONG Capabilities);

    typedef void __stdcall BAD_MEMORY_CALLBACK_ROUTINE(void);

    typedef BAD_MEMORY_CALLBACK_ROUTINE* PBAD_MEMORY_CALLBACK_ROUTINE;

    __declspec(dllimport)

    PVOID __stdcall RegisterBadMemoryNotification(PBAD_MEMORY_CALLBACK_ROUTINE Callback);

    __declspec(dllimport)

    BOOL __stdcall UnregisterBadMemoryNotification(PVOID RegistrationHandle);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef enum OFFER_PRIORITY
    {
        VmOfferPriorityVeryLow = 1,
        VmOfferPriorityLow,
        VmOfferPriorityBelowNormal,
        VmOfferPriorityNormal
    } OFFER_PRIORITY;

    DWORD
    __stdcall OfferVirtualMemory(PVOID VirtualAddress, SIZE_T Size, OFFER_PRIORITY Priority);

    DWORD
    __stdcall ReclaimVirtualMemory(void const* VirtualAddress, SIZE_T Size);

    DWORD
    __stdcall DiscardVirtualMemory(PVOID VirtualAddress, SIZE_T Size);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetProcessValidCallTargets(
    HANDLE hProcess, PVOID VirtualAddress, SIZE_T RegionSize, ULONG NumberOfOffsets, PCFG_CALL_TARGET_INFO OffsetInformation);

    __declspec(dllimport) BOOL __stdcall SetProcessValidCallTargetsForMappedView(HANDLE Process,
                                                                                 PVOID VirtualAddress,
                                                                                 SIZE_T RegionSize,
                                                                                 ULONG NumberOfOffsets,
                                                                                 PCFG_CALL_TARGET_INFO OffsetInformation,
                                                                                 HANDLE Section,
                                                                                 ULONG64 ExpectedFileOffset);

    __declspec(dllimport)

    PVOID __stdcall VirtualAllocFromApp(PVOID BaseAddress, SIZE_T Size, ULONG AllocationType, ULONG Protection);

    __declspec(dllimport)

    BOOL __stdcall VirtualProtectFromApp(PVOID Address, SIZE_T Size, ULONG NewProtection, PULONG OldProtection);

    __declspec(dllimport)

    HANDLE __stdcall OpenFileMappingFromApp(ULONG DesiredAccess, BOOL InheritHandle, PCWSTR Name);

#pragma endregion

#pragma region Application Family

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef enum WIN32_MEMORY_INFORMATION_CLASS
    {
        MemoryRegionInfo
    } WIN32_MEMORY_INFORMATION_CLASS;

#pragma warning(push)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)

    typedef struct WIN32_MEMORY_REGION_INFORMATION
    {
        PVOID AllocationBase;
        ULONG AllocationProtect;

        union
        {
            ULONG Flags;

            struct
            {
                ULONG Private : 1;
                ULONG MappedDataFile : 1;
                ULONG MappedImage : 1;
                ULONG MappedPageFile : 1;
                ULONG MappedPhysical : 1;
                ULONG DirectMapped : 1;
                ULONG Reserved : 26;
            };
        };

        SIZE_T RegionSize;
        SIZE_T CommitSize;
    } WIN32_MEMORY_REGION_INFORMATION;

#pragma warning(pop)

    __declspec(dllimport)

    BOOL __stdcall QueryVirtualMemoryInformation(HANDLE Process,
                                                 const void* VirtualAddress,
                                                 WIN32_MEMORY_INFORMATION_CLASS MemoryInformationClass,
                                                 PVOID MemoryInformation,
                                                 SIZE_T MemoryInformationSize,
                                                 PSIZE_T ReturnSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    PVOID __stdcall MapViewOfFileNuma2(HANDLE FileMappingHandle,
                                       HANDLE ProcessHandle,
                                       ULONG64 Offset,
                                       PVOID BaseAddress,
                                       SIZE_T ViewSize,
                                       ULONG AllocationType,
                                       ULONG PageProtection,
                                       ULONG PreferredNode);

    __forceinline

    PVOID
    MapViewOfFile2(HANDLE FileMappingHandle, HANDLE ProcessHandle, ULONG64 Offset, PVOID BaseAddress, SIZE_T ViewSize, ULONG AllocationType, ULONG PageProtection)
    {
        return MapViewOfFileNuma2(FileMappingHandle, ProcessHandle, Offset, BaseAddress, ViewSize, AllocationType,
                                  PageProtection, ((DWORD)-1));
    }

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall UnmapViewOfFile2(HANDLE Process, PVOID BaseAddress, ULONG UnmapFlags);

    __declspec(dllimport) BOOL __stdcall VirtualUnlockEx(HANDLE Process, LPVOID Address, SIZE_T Size);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    PVOID __stdcall VirtualAlloc2(HANDLE Process,
                                  PVOID BaseAddress,
                                  SIZE_T Size,
                                  ULONG AllocationType,
                                  ULONG PageProtection,
                                  MEM_EXTENDED_PARAMETER* ExtendedParameters,
                                  ULONG ParameterCount);

    __declspec(dllimport)

    PVOID __stdcall MapViewOfFile3(HANDLE FileMapping,
                                   HANDLE Process,
                                   PVOID BaseAddress,
                                   ULONG64 Offset,
                                   SIZE_T ViewSize,
                                   ULONG AllocationType,
                                   ULONG PageProtection,
                                   MEM_EXTENDED_PARAMETER* ExtendedParameters,
                                   ULONG ParameterCount);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    PVOID __stdcall VirtualAlloc2FromApp(HANDLE Process,
                                         PVOID BaseAddress,
                                         SIZE_T Size,
                                         ULONG AllocationType,
                                         ULONG PageProtection,
                                         MEM_EXTENDED_PARAMETER* ExtendedParameters,
                                         ULONG ParameterCount);

    __declspec(dllimport)

    PVOID __stdcall MapViewOfFile3FromApp(HANDLE FileMapping,
                                          HANDLE Process,
                                          PVOID BaseAddress,
                                          ULONG64 Offset,
                                          SIZE_T ViewSize,
                                          ULONG AllocationType,
                                          ULONG PageProtection,
                                          MEM_EXTENDED_PARAMETER* ExtendedParameters,
                                          ULONG ParameterCount);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    HANDLE __stdcall CreateFileMapping2(HANDLE File,
                                        SECURITY_ATTRIBUTES* SecurityAttributes,
                                        ULONG DesiredAccess,
                                        ULONG PageProtection,
                                        ULONG AllocationAttributes,
                                        ULONG64 MaximumSize,
                                        PCWSTR Name,
                                        MEM_EXTENDED_PARAMETER* ExtendedParameters,
                                        ULONG ParameterCount);

#pragma endregion

#pragma warning(pop)
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Or App Family

    __declspec(dllimport)

    BOOL __stdcall IsEnclaveTypeSupported(DWORD flEnclaveType);

    __declspec(dllimport)

    LPVOID __stdcall CreateEnclave(HANDLE hProcess,
                                   LPVOID lpAddress,
                                   SIZE_T dwSize,
                                   SIZE_T dwInitialCommitment,
                                   DWORD flEnclaveType,
                                   LPCVOID lpEnclaveInformation,
                                   DWORD dwInfoLength,
                                   LPDWORD lpEnclaveError);

    __declspec(dllimport)

    BOOL __stdcall LoadEnclaveData(HANDLE hProcess,
                                   LPVOID lpAddress,
                                   LPCVOID lpBuffer,
                                   SIZE_T nSize,
                                   DWORD flProtect,
                                   LPCVOID lpPageInformation,
                                   DWORD dwInfoLength,
                                   PSIZE_T lpNumberOfBytesWritten,
                                   LPDWORD lpEnclaveError);

    __declspec(dllimport)

    BOOL __stdcall InitializeEnclave(HANDLE hProcess, LPVOID lpAddress, LPCVOID lpEnclaveInformation, DWORD dwInfoLength, LPDWORD lpEnclaveError);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall LoadEnclaveImageA(LPVOID lpEnclaveAddress, LPCSTR lpImageName);

    __declspec(dllimport)

    BOOL __stdcall LoadEnclaveImageW(LPVOID lpEnclaveAddress, LPCWSTR lpImageName);

    __declspec(dllimport)

    BOOL __stdcall CallEnclave(LPENCLAVE_ROUTINE lpRoutine, LPVOID lpParameter, BOOL fWaitForThread, LPVOID* lpReturnValue);

    __declspec(dllimport)

    BOOL __stdcall TerminateEnclave(LPVOID lpAddress, BOOL fWait);

    __declspec(dllimport)

    BOOL __stdcall DeleteEnclave(LPVOID lpAddress);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall QueueUserWorkItem(LPTHREAD_START_ROUTINE Function, PVOID Context, ULONG Flags);

    __declspec(dllimport)

    BOOL __stdcall UnregisterWaitEx(HANDLE WaitHandle, HANDLE CompletionEvent);

    __declspec(dllimport)

    HANDLE __stdcall CreateTimerQueue(void);

    __declspec(dllimport) BOOL __stdcall CreateTimerQueueTimer(
    PHANDLE phNewTimer, HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, ULONG Flags);

    __declspec(dllimport)

    BOOL __stdcall ChangeTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, ULONG DueTime, ULONG Period);

    __declspec(dllimport)

    BOOL __stdcall DeleteTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer, HANDLE CompletionEvent);

    __declspec(dllimport)

    BOOL __stdcall DeleteTimerQueueEx(HANDLE TimerQueue, HANDLE CompletionEvent);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    typedef void(__stdcall* PTP_WIN32_IO_CALLBACK)(
    PTP_CALLBACK_INSTANCE Instance, PVOID Context, PVOID Overlapped, ULONG IoResult, ULONG_PTR NumberOfBytesTransferred, PTP_IO Io);

    __declspec(dllimport)

    PTP_POOL __stdcall CreateThreadpool(PVOID reserved);

    __declspec(dllimport) void __stdcall SetThreadpoolThreadMaximum(PTP_POOL ptpp, DWORD cthrdMost);

    __declspec(dllimport) BOOL __stdcall SetThreadpoolThreadMinimum(PTP_POOL ptpp, DWORD cthrdMic);

    __declspec(dllimport) BOOL __stdcall SetThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);

    __declspec(dllimport) BOOL __stdcall QueryThreadpoolStackInformation(PTP_POOL ptpp, PTP_POOL_STACK_INFORMATION ptpsi);

    __declspec(dllimport) void __stdcall CloseThreadpool(PTP_POOL ptpp);

    __declspec(dllimport)

    PTP_CLEANUP_GROUP __stdcall CreateThreadpoolCleanupGroup(void);

    __declspec(dllimport) void __stdcall CloseThreadpoolCleanupGroupMembers(PTP_CLEANUP_GROUP ptpcg,
                                                                            BOOL fCancelPendingCallbacks,
                                                                            PVOID pvCleanupContext);

    __declspec(dllimport) void __stdcall CloseThreadpoolCleanupGroup(PTP_CLEANUP_GROUP ptpcg);

    __declspec(dllimport) void __stdcall SetEventWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE evt);

    __declspec(dllimport) void __stdcall ReleaseSemaphoreWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE sem, DWORD crel);

    __declspec(dllimport) void __stdcall ReleaseMutexWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HANDLE mut);

    __declspec(dllimport) void __stdcall LeaveCriticalSectionWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, PCRITICAL_SECTION pcs);

    __declspec(dllimport) void __stdcall FreeLibraryWhenCallbackReturns(PTP_CALLBACK_INSTANCE pci, HMODULE mod);

    __declspec(dllimport) BOOL __stdcall CallbackMayRunLong(PTP_CALLBACK_INSTANCE pci);

    __declspec(dllimport) void __stdcall DisassociateCurrentThreadFromCallback(PTP_CALLBACK_INSTANCE pci);

    __declspec(dllimport)

    BOOL __stdcall TrySubmitThreadpoolCallback(PTP_SIMPLE_CALLBACK pfns, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);

    __declspec(dllimport)

    PTP_WORK __stdcall CreateThreadpoolWork(PTP_WORK_CALLBACK pfnwk, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);

    __declspec(dllimport) void __stdcall SubmitThreadpoolWork(PTP_WORK pwk);

    __declspec(dllimport) void __stdcall WaitForThreadpoolWorkCallbacks(PTP_WORK pwk, BOOL fCancelPendingCallbacks);

    __declspec(dllimport) void __stdcall CloseThreadpoolWork(PTP_WORK pwk);

    __declspec(dllimport)

    PTP_TIMER __stdcall CreateThreadpoolTimer(PTP_TIMER_CALLBACK pfnti, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);

    __declspec(dllimport) void __stdcall SetThreadpoolTimer(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength);

    __declspec(dllimport) BOOL __stdcall IsThreadpoolTimerSet(PTP_TIMER pti);

    __declspec(dllimport) void __stdcall WaitForThreadpoolTimerCallbacks(PTP_TIMER pti, BOOL fCancelPendingCallbacks);

    __declspec(dllimport) void __stdcall CloseThreadpoolTimer(PTP_TIMER pti);

    __declspec(dllimport)

    PTP_WAIT __stdcall CreateThreadpoolWait(PTP_WAIT_CALLBACK pfnwa, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);

    __declspec(dllimport) void __stdcall SetThreadpoolWait(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout);

    __declspec(dllimport) void __stdcall WaitForThreadpoolWaitCallbacks(PTP_WAIT pwa, BOOL fCancelPendingCallbacks);

    __declspec(dllimport) void __stdcall CloseThreadpoolWait(PTP_WAIT pwa);

    __declspec(dllimport)

    PTP_IO __stdcall CreateThreadpoolIo(HANDLE fl, PTP_WIN32_IO_CALLBACK pfnio, PVOID pv, PTP_CALLBACK_ENVIRON pcbe);

    __declspec(dllimport) void __stdcall StartThreadpoolIo(PTP_IO pio);

    __declspec(dllimport) void __stdcall CancelThreadpoolIo(PTP_IO pio);

    __declspec(dllimport) void __stdcall WaitForThreadpoolIoCallbacks(PTP_IO pio, BOOL fCancelPendingCallbacks);

    __declspec(dllimport) void __stdcall CloseThreadpoolIo(PTP_IO pio);

    __declspec(dllimport) BOOL
    __stdcall SetThreadpoolTimerEx(PTP_TIMER pti, PFILETIME pftDueTime, DWORD msPeriod, DWORD msWindowLength);

    __declspec(dllimport) BOOL __stdcall SetThreadpoolWaitEx(PTP_WAIT pwa, HANDLE h, PFILETIME pftTimeout, PVOID Reserved);

#pragma endregion

#pragma region Desktop Family or OneCore Family

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsProcessInJob(HANDLE ProcessHandle, HANDLE JobHandle, PBOOL Result);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    typedef struct JOBOBJECT_IO_RATE_CONTROL_INFORMATION
    {
        LONG64 MaxIops;
        LONG64 MaxBandwidth;
        LONG64 ReservationIops;
        PCWSTR VolumeName;
        ULONG BaseIoSize;
        ULONG ControlFlags;
    } JOBOBJECT_IO_RATE_CONTROL_INFORMATION;

    __declspec(dllimport) HANDLE __stdcall CreateJobObjectW(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCWSTR lpName);

    __declspec(dllimport) void __stdcall FreeMemoryJobObject(void* Buffer);

    __declspec(dllimport) HANDLE __stdcall OpenJobObjectW(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCWSTR lpName);

    __declspec(dllimport) BOOL __stdcall AssignProcessToJobObject(HANDLE hJob, HANDLE hProcess);

    __declspec(dllimport) BOOL __stdcall TerminateJobObject(HANDLE hJob, UINT uExitCode);

    __declspec(dllimport) BOOL __stdcall SetInformationJobObject(HANDLE hJob,
                                                                 JOBOBJECTINFOCLASS JobObjectInformationClass,
                                                                 LPVOID lpJobObjectInformation,
                                                                 DWORD cbJobObjectInformationLength);

    __declspec(dllimport) DWORD
    __stdcall SetIoRateControlInformationJobObject(HANDLE hJob, JOBOBJECT_IO_RATE_CONTROL_INFORMATION* IoRateControlInfo);

    __declspec(dllimport) BOOL __stdcall QueryInformationJobObject(HANDLE hJob,
                                                                   JOBOBJECTINFOCLASS JobObjectInformationClass,
                                                                   LPVOID lpJobObjectInformation,
                                                                   DWORD cbJobObjectInformationLength,
                                                                   LPDWORD lpReturnLength);

    __declspec(dllimport) DWORD __stdcall QueryIoRateControlInformationJobObject(
    HANDLE hJob, PCWSTR VolumeName, JOBOBJECT_IO_RATE_CONTROL_INFORMATION** InfoBlocks, ULONG* InfoBlockCount);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall Wow64DisableWow64FsRedirection(PVOID* OldValue);

    __declspec(dllimport) BOOL __stdcall Wow64RevertWow64FsRedirection(PVOID OlValue);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsWow64Process(HANDLE hProcess, PBOOL Wow64Process);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    UINT __stdcall GetSystemWow64DirectoryA(LPSTR lpBuffer, UINT uSize);

    __declspec(dllimport)

    UINT __stdcall GetSystemWow64DirectoryW(LPWSTR lpBuffer, UINT uSize);

    __declspec(dllimport) USHORT __stdcall Wow64SetThreadDefaultGuestMachine(USHORT Machine);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsWow64Process2(HANDLE hProcess, USHORT* pProcessMachine, USHORT* pNativeMachine);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    UINT __stdcall GetSystemWow64Directory2A(LPSTR lpBuffer, UINT uSize, WORD ImageFileMachineType);

    __declspec(dllimport)

    UINT __stdcall GetSystemWow64Directory2W(LPWSTR lpBuffer, UINT uSize, WORD ImageFileMachineType);

    __declspec(dllimport)

    HRESULT __stdcall IsWow64GuestMachineSupported(USHORT WowGuestMachine, BOOL* MachineIsSupported);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    typedef struct tagENUMUILANG
    {
        ULONG NumOfEnumUILang;
        ULONG SizeOfEnumUIBuffer;
        LANGID* pEnumUIBuffer;
    } ENUMUILANG, *PENUMUILANG;

    typedef BOOL(__stdcall* ENUMRESLANGPROCA)(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LONG_PTR lParam);
    typedef BOOL(__stdcall* ENUMRESLANGPROCW)(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LONG_PTR lParam);

    typedef BOOL(__stdcall* ENUMRESNAMEPROCA)(HMODULE hModule, LPCSTR lpType, LPSTR lpName, LONG_PTR lParam);
    typedef BOOL(__stdcall* ENUMRESNAMEPROCW)(HMODULE hModule, LPCWSTR lpType, LPWSTR lpName, LONG_PTR lParam);

    typedef BOOL(__stdcall* ENUMRESTYPEPROCA)(HMODULE hModule, LPSTR lpType, LONG_PTR lParam);
    typedef BOOL(__stdcall* ENUMRESTYPEPROCW)(HMODULE hModule, LPWSTR lpType, LONG_PTR lParam);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall DisableThreadLibraryCalls(HMODULE hLibModule);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    HRSRC __stdcall FindResourceExW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) int __stdcall FindStringOrdinal(
    DWORD dwFindStringOrdinalFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, BOOL bIgnoreCase);

    __declspec(dllimport) BOOL __stdcall FreeLibrary(HMODULE hLibModule);

    __declspec(dllimport) __declspec(noreturn) void __stdcall FreeLibraryAndExitThread(HMODULE hLibModule, DWORD dwExitCode);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall FreeResource(HGLOBAL hResData);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    DWORD __stdcall GetModuleFileNameA(HMODULE hModule, LPSTR lpFilename, DWORD nSize);

    __declspec(dllimport)

    DWORD __stdcall GetModuleFileNameW(HMODULE hModule, LPWSTR lpFilename, DWORD nSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    HMODULE __stdcall GetModuleHandleA(LPCSTR lpModuleName);

    __declspec(dllimport)

    HMODULE __stdcall GetModuleHandleW(LPCWSTR lpModuleName);

    typedef BOOL(__stdcall* PGET_MODULE_HANDLE_EXA)(DWORD dwFlags, LPCSTR lpModuleName, HMODULE* phModule);
    typedef BOOL(__stdcall* PGET_MODULE_HANDLE_EXW)(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE* phModule);

    __declspec(dllimport) BOOL __stdcall GetModuleHandleExA(DWORD dwFlags, LPCSTR lpModuleName, HMODULE* phModule);

    __declspec(dllimport) BOOL __stdcall GetModuleHandleExW(DWORD dwFlags, LPCWSTR lpModuleName, HMODULE* phModule);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) FARPROC __stdcall GetProcAddress(HMODULE hModule, LPCSTR lpProcName);

    typedef struct _REDIRECTION_FUNCTION_DESCRIPTOR
    {
        PCSTR DllName;
        PCSTR FunctionName;
        PVOID RedirectionTarget;
    } REDIRECTION_FUNCTION_DESCRIPTOR, *PREDIRECTION_FUNCTION_DESCRIPTOR;

    typedef const REDIRECTION_FUNCTION_DESCRIPTOR* PCREDIRECTION_FUNCTION_DESCRIPTOR;

    typedef struct _REDIRECTION_DESCRIPTOR
    {
        ULONG Version;
        ULONG FunctionCount;
        PCREDIRECTION_FUNCTION_DESCRIPTOR Redirections;
    } REDIRECTION_DESCRIPTOR, *PREDIRECTION_DESCRIPTOR;

    typedef const REDIRECTION_DESCRIPTOR* PCREDIRECTION_DESCRIPTOR;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    HMODULE __stdcall LoadLibraryExA(LPCSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);

    __declspec(dllimport)

    HMODULE __stdcall LoadLibraryExW(LPCWSTR lpLibFileName, HANDLE hFile, DWORD dwFlags);

    __declspec(dllimport)

    HGLOBAL __stdcall LoadResource(HMODULE hModule, HRSRC hResInfo);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) int __stdcall LoadStringA(HINSTANCE hInstance, UINT uID, LPSTR lpBuffer, int cchBufferMax);

    __declspec(dllimport) int __stdcall LoadStringW(HINSTANCE hInstance, UINT uID, LPWSTR lpBuffer, int cchBufferMax);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) LPVOID __stdcall LockResource(HGLOBAL hResData);

    __declspec(dllimport) DWORD __stdcall SizeofResource(HMODULE hModule, HRSRC hResInfo);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef PVOID DLL_DIRECTORY_COOKIE, *PDLL_DIRECTORY_COOKIE;

    __declspec(dllimport) DLL_DIRECTORY_COOKIE __stdcall AddDllDirectory(PCWSTR NewDirectory);

    __declspec(dllimport) BOOL __stdcall RemoveDllDirectory(DLL_DIRECTORY_COOKIE Cookie);

    __declspec(dllimport) BOOL __stdcall SetDefaultDllDirectories(DWORD DirectoryFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall EnumResourceLanguagesExA(
    HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);

    __declspec(dllimport) BOOL __stdcall EnumResourceLanguagesExW(
    HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);

    __declspec(dllimport) BOOL
    __stdcall EnumResourceNamesExA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);

    __declspec(dllimport) BOOL
    __stdcall EnumResourceNamesExW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);

    __declspec(dllimport) BOOL
    __stdcall EnumResourceTypesExA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);

    __declspec(dllimport) BOOL
    __stdcall EnumResourceTypesExW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam, DWORD dwFlags, LANGID LangId);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    HRSRC __stdcall FindResourceW(HMODULE hModule, LPCWSTR lpName, LPCWSTR lpType);

    __declspec(dllimport)

    HMODULE __stdcall LoadLibraryA(LPCSTR lpLibFileName);

    __declspec(dllimport)

    HMODULE __stdcall LoadLibraryW(LPCWSTR lpLibFileName);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall EnumResourceNamesW(HMODULE hModule, LPCWSTR lpType, ENUMRESNAMEPROCW lpEnumFunc, LONG_PTR lParam);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall AccessCheck(PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                     HANDLE ClientToken,
                                                     DWORD DesiredAccess,
                                                     PGENERIC_MAPPING GenericMapping,
                                                     PPRIVILEGE_SET PrivilegeSet,
                                                     LPDWORD PrivilegeSetLength,
                                                     LPDWORD GrantedAccess,
                                                     LPBOOL AccessStatus);

    __declspec(dllimport) BOOL __stdcall AccessCheckAndAuditAlarmW(LPCWSTR SubsystemName,
                                                                   LPVOID HandleId,
                                                                   LPWSTR ObjectTypeName,
                                                                   LPWSTR ObjectName,
                                                                   PSECURITY_DESCRIPTOR SecurityDescriptor,
                                                                   DWORD DesiredAccess,
                                                                   PGENERIC_MAPPING GenericMapping,
                                                                   BOOL ObjectCreation,
                                                                   LPDWORD GrantedAccess,
                                                                   LPBOOL AccessStatus,
                                                                   LPBOOL pfGenerateOnClose);

    __declspec(dllimport) BOOL __stdcall AccessCheckByType(PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                           PSID PrincipalSelfSid,
                                                           HANDLE ClientToken,
                                                           DWORD DesiredAccess,
                                                           POBJECT_TYPE_LIST ObjectTypeList,
                                                           DWORD ObjectTypeListLength,
                                                           PGENERIC_MAPPING GenericMapping,
                                                           PPRIVILEGE_SET PrivilegeSet,
                                                           LPDWORD PrivilegeSetLength,
                                                           LPDWORD GrantedAccess,
                                                           LPBOOL AccessStatus);

    __declspec(dllimport) BOOL __stdcall AccessCheckByTypeResultList(PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                                     PSID PrincipalSelfSid,
                                                                     HANDLE ClientToken,
                                                                     DWORD DesiredAccess,
                                                                     POBJECT_TYPE_LIST ObjectTypeList,
                                                                     DWORD ObjectTypeListLength,
                                                                     PGENERIC_MAPPING GenericMapping,
                                                                     PPRIVILEGE_SET PrivilegeSet,
                                                                     LPDWORD PrivilegeSetLength,
                                                                     LPDWORD GrantedAccessList,
                                                                     LPDWORD AccessStatusList);

    __declspec(dllimport) BOOL __stdcall AccessCheckByTypeAndAuditAlarmW(LPCWSTR SubsystemName,
                                                                         LPVOID HandleId,
                                                                         LPCWSTR ObjectTypeName,
                                                                         LPCWSTR ObjectName,
                                                                         PSECURITY_DESCRIPTOR SecurityDescriptor,
                                                                         PSID PrincipalSelfSid,
                                                                         DWORD DesiredAccess,
                                                                         AUDIT_EVENT_TYPE AuditType,
                                                                         DWORD Flags,
                                                                         POBJECT_TYPE_LIST ObjectTypeList,
                                                                         DWORD ObjectTypeListLength,
                                                                         PGENERIC_MAPPING GenericMapping,
                                                                         BOOL ObjectCreation,
                                                                         LPDWORD GrantedAccess,
                                                                         LPBOOL AccessStatus,
                                                                         LPBOOL pfGenerateOnClose);

    __declspec(dllimport) BOOL __stdcall AccessCheckByTypeResultListAndAuditAlarmW(LPCWSTR SubsystemName,
                                                                                   LPVOID HandleId,
                                                                                   LPCWSTR ObjectTypeName,
                                                                                   LPCWSTR ObjectName,
                                                                                   PSECURITY_DESCRIPTOR SecurityDescriptor,
                                                                                   PSID PrincipalSelfSid,
                                                                                   DWORD DesiredAccess,
                                                                                   AUDIT_EVENT_TYPE AuditType,
                                                                                   DWORD Flags,
                                                                                   POBJECT_TYPE_LIST ObjectTypeList,
                                                                                   DWORD ObjectTypeListLength,
                                                                                   PGENERIC_MAPPING GenericMapping,
                                                                                   BOOL ObjectCreation,
                                                                                   LPDWORD GrantedAccessList,
                                                                                   LPDWORD AccessStatusList,
                                                                                   LPBOOL pfGenerateOnClose);

    __declspec(dllimport) BOOL __stdcall AccessCheckByTypeResultListAndAuditAlarmByHandleW(LPCWSTR SubsystemName,
                                                                                           LPVOID HandleId,
                                                                                           HANDLE ClientToken,
                                                                                           LPCWSTR ObjectTypeName,
                                                                                           LPCWSTR ObjectName,
                                                                                           PSECURITY_DESCRIPTOR SecurityDescriptor,
                                                                                           PSID PrincipalSelfSid,
                                                                                           DWORD DesiredAccess,
                                                                                           AUDIT_EVENT_TYPE AuditType,
                                                                                           DWORD Flags,
                                                                                           POBJECT_TYPE_LIST ObjectTypeList,
                                                                                           DWORD ObjectTypeListLength,
                                                                                           PGENERIC_MAPPING GenericMapping,
                                                                                           BOOL ObjectCreation,
                                                                                           LPDWORD GrantedAccessList,
                                                                                           LPDWORD AccessStatusList,
                                                                                           LPBOOL pfGenerateOnClose);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall AddAccessAllowedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid);

    __declspec(dllimport) BOOL
    __stdcall AddAccessAllowedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall AddAccessAllowedObjectAce(
    PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID* ObjectTypeGuid, GUID* InheritedObjectTypeGuid, PSID pSid);

    __declspec(dllimport) BOOL __stdcall AddAccessDeniedAce(PACL pAcl, DWORD dwAceRevision, DWORD AccessMask, PSID pSid);

    __declspec(dllimport) BOOL
    __stdcall AddAccessDeniedAceEx(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid);

    __declspec(dllimport) BOOL __stdcall AddAccessDeniedObjectAce(
    PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, GUID* ObjectTypeGuid, GUID* InheritedObjectTypeGuid, PSID pSid);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall AddAce(PACL pAcl, DWORD dwAceRevision, DWORD dwStartingAceIndex, LPVOID pAceList, DWORD nAceListLength);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall AddAuditAccessAce(PACL pAcl, DWORD dwAceRevision, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure);

    __declspec(dllimport) BOOL __stdcall AddAuditAccessAceEx(
    PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD dwAccessMask, PSID pSid, BOOL bAuditSuccess, BOOL bAuditFailure);

    __declspec(dllimport) BOOL __stdcall AddAuditAccessObjectAce(PACL pAcl,
                                                                 DWORD dwAceRevision,
                                                                 DWORD AceFlags,
                                                                 DWORD AccessMask,
                                                                 GUID* ObjectTypeGuid,
                                                                 GUID* InheritedObjectTypeGuid,
                                                                 PSID pSid,
                                                                 BOOL bAuditSuccess,
                                                                 BOOL bAuditFailure);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall AddMandatoryAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD MandatoryPolicy, PSID pLabelSid);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall AddResourceAttributeAce(PACL pAcl,
                                                                 DWORD dwAceRevision,
                                                                 DWORD AceFlags,
                                                                 DWORD AccessMask,
                                                                 PSID pSid,
                                                                 PCLAIM_SECURITY_ATTRIBUTES_INFORMATION pAttributeInfo,
                                                                 PDWORD pReturnLength);

    __declspec(dllimport) BOOL
    __stdcall AddScopedPolicyIDAce(PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, DWORD AccessMask, PSID pSid);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall AdjustTokenGroups(
    HANDLE TokenHandle, BOOL ResetToDefault, PTOKEN_GROUPS NewState, DWORD BufferLength, PTOKEN_GROUPS PreviousState, PDWORD ReturnLength);

    __declspec(dllimport) BOOL __stdcall AdjustTokenPrivileges(HANDLE TokenHandle,
                                                               BOOL DisableAllPrivileges,
                                                               PTOKEN_PRIVILEGES NewState,
                                                               DWORD BufferLength,
                                                               PTOKEN_PRIVILEGES PreviousState,
                                                               PDWORD ReturnLength);

    __declspec(dllimport) BOOL __stdcall AllocateAndInitializeSid(PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority,
                                                                  BYTE nSubAuthorityCount,
                                                                  DWORD nSubAuthority0,
                                                                  DWORD nSubAuthority1,
                                                                  DWORD nSubAuthority2,
                                                                  DWORD nSubAuthority3,
                                                                  DWORD nSubAuthority4,
                                                                  DWORD nSubAuthority5,
                                                                  DWORD nSubAuthority6,
                                                                  DWORD nSubAuthority7,
                                                                  PSID* pSid);

    __declspec(dllimport) BOOL __stdcall AllocateLocallyUniqueId(PLUID Luid);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall AreAllAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess);

    __declspec(dllimport) BOOL __stdcall AreAnyAccessesGranted(DWORD GrantedAccess, DWORD DesiredAccess);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CheckTokenMembership(HANDLE TokenHandle, PSID SidToCheck, PBOOL IsMember);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CheckTokenCapability(HANDLE TokenHandle, PSID CapabilitySidToCheck, PBOOL HasCapability);

    __declspec(dllimport) BOOL
    __stdcall GetAppContainerAce(PACL Acl, DWORD StartingAceIndex, PVOID* AppContainerAce, DWORD* AppContainerAceIndex);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CheckTokenMembershipEx(HANDLE TokenHandle, PSID SidToCheck, DWORD Flags, PBOOL IsMember);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall ConvertToAutoInheritPrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor,
                                                                                   PSECURITY_DESCRIPTOR CurrentSecurityDescriptor,
                                                                                   PSECURITY_DESCRIPTOR* NewSecurityDescriptor,
                                                                                   GUID* ObjectType,
                                                                                   BOOLEAN IsDirectoryObject,
                                                                                   PGENERIC_MAPPING GenericMapping);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CopySid(DWORD nDestinationSidLength, PSID pDestinationSid, PSID pSourceSid);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CreatePrivateObjectSecurity(PSECURITY_DESCRIPTOR ParentDescriptor,
                                                                     PSECURITY_DESCRIPTOR CreatorDescriptor,
                                                                     PSECURITY_DESCRIPTOR* NewDescriptor,
                                                                     BOOL IsDirectoryObject,
                                                                     HANDLE Token,
                                                                     PGENERIC_MAPPING GenericMapping);

    __declspec(dllimport) BOOL __stdcall CreatePrivateObjectSecurityEx(PSECURITY_DESCRIPTOR ParentDescriptor,
                                                                       PSECURITY_DESCRIPTOR CreatorDescriptor,
                                                                       PSECURITY_DESCRIPTOR* NewDescriptor,
                                                                       GUID* ObjectType,
                                                                       BOOL IsContainerObject,
                                                                       ULONG AutoInheritFlags,
                                                                       HANDLE Token,
                                                                       PGENERIC_MAPPING GenericMapping);

    __declspec(dllimport) BOOL
    __stdcall CreatePrivateObjectSecurityWithMultipleInheritance(PSECURITY_DESCRIPTOR ParentDescriptor,
                                                                 PSECURITY_DESCRIPTOR CreatorDescriptor,
                                                                 PSECURITY_DESCRIPTOR* NewDescriptor,
                                                                 GUID** ObjectTypes,
                                                                 ULONG GuidCount,
                                                                 BOOL IsContainerObject,
                                                                 ULONG AutoInheritFlags,
                                                                 HANDLE Token,
                                                                 PGENERIC_MAPPING GenericMapping);

    __declspec(dllimport) BOOL __stdcall CreateRestrictedToken(HANDLE ExistingTokenHandle,
                                                               DWORD Flags,
                                                               DWORD DisableSidCount,
                                                               PSID_AND_ATTRIBUTES SidsToDisable,
                                                               DWORD DeletePrivilegeCount,
                                                               PLUID_AND_ATTRIBUTES PrivilegesToDelete,
                                                               DWORD RestrictedSidCount,
                                                               PSID_AND_ATTRIBUTES SidsToRestrict,
                                                               PHANDLE NewTokenHandle);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall CreateWellKnownSid(WELL_KNOWN_SID_TYPE WellKnownSidType, PSID DomainSid, PSID pSid, DWORD* cbSid);

    __declspec(dllimport)

    BOOL __stdcall EqualDomainSid(PSID pSid1, PSID pSid2, BOOL* pfEqual);

    __declspec(dllimport) BOOL __stdcall DeleteAce(PACL pAcl, DWORD dwAceIndex);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall DestroyPrivateObjectSecurity(PSECURITY_DESCRIPTOR* ObjectDescriptor);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall DuplicateToken(HANDLE ExistingTokenHandle, SECURITY_IMPERSONATION_LEVEL ImpersonationLevel, PHANDLE DuplicateTokenHandle);

    __declspec(dllimport) BOOL __stdcall DuplicateTokenEx(HANDLE hExistingToken,
                                                          DWORD dwDesiredAccess,
                                                          LPSECURITY_ATTRIBUTES lpTokenAttributes,
                                                          SECURITY_IMPERSONATION_LEVEL ImpersonationLevel,
                                                          TOKEN_TYPE TokenType,
                                                          PHANDLE phNewToken);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall EqualPrefixSid(PSID pSid1, PSID pSid2);

    __declspec(dllimport) BOOL __stdcall EqualSid(PSID pSid1, PSID pSid2);

    __declspec(dllimport) BOOL __stdcall FindFirstFreeAce(PACL pAcl, LPVOID* pAce);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) PVOID __stdcall FreeSid(PSID pSid);

    __declspec(dllimport) BOOL __stdcall GetAce(PACL pAcl, DWORD dwAceIndex, LPVOID* pAce);

    __declspec(dllimport) BOOL
    __stdcall GetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetFileSecurityW(LPCWSTR lpFileName,
                                                          SECURITY_INFORMATION RequestedInformation,
                                                          PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                          DWORD nLength,
                                                          LPDWORD lpnLengthNeeded);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetKernelObjectSecurity(HANDLE Handle,
                                                                 SECURITY_INFORMATION RequestedInformation,
                                                                 PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                                 DWORD nLength,
                                                                 LPDWORD lpnLengthNeeded);

    __declspec(dllimport)

    DWORD __stdcall GetLengthSid(PSID pSid);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall GetPrivateObjectSecurity(PSECURITY_DESCRIPTOR ObjectDescriptor,
                                            SECURITY_INFORMATION SecurityInformation,
                                            PSECURITY_DESCRIPTOR ResultantDescriptor,
                                            DWORD DescriptorLength,
                                            PDWORD ReturnLength);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                                      PSECURITY_DESCRIPTOR_CONTROL pControl,
                                                                      LPDWORD lpdwRevision);

    __declspec(dllimport) BOOL
    __stdcall GetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbDaclPresent, PACL* pDacl, LPBOOL lpbDaclDefaulted);

    __declspec(dllimport) BOOL
    __stdcall GetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID* pGroup, LPBOOL lpbGroupDefaulted);

    __declspec(dllimport) DWORD __stdcall GetSecurityDescriptorLength(PSECURITY_DESCRIPTOR pSecurityDescriptor);

    __declspec(dllimport) BOOL
    __stdcall GetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID* pOwner, LPBOOL lpbOwnerDefaulted);

    __declspec(dllimport) DWORD __stdcall GetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl);

    __declspec(dllimport) BOOL
    __stdcall GetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, LPBOOL lpbSaclPresent, PACL* pSacl, LPBOOL lpbSaclDefaulted);

    __declspec(dllimport) PSID_IDENTIFIER_AUTHORITY __stdcall GetSidIdentifierAuthority(PSID pSid);

    __declspec(dllimport) DWORD __stdcall GetSidLengthRequired(UCHAR nSubAuthorityCount);

    __declspec(dllimport) PDWORD __stdcall GetSidSubAuthority(PSID pSid, DWORD nSubAuthority);

    __declspec(dllimport) PUCHAR __stdcall GetSidSubAuthorityCount(PSID pSid);

    __declspec(dllimport) BOOL __stdcall GetTokenInformation(HANDLE TokenHandle,
                                                             TOKEN_INFORMATION_CLASS TokenInformationClass,
                                                             LPVOID TokenInformation,
                                                             DWORD TokenInformationLength,
                                                             PDWORD ReturnLength);

    __declspec(dllimport)

    BOOL __stdcall GetWindowsAccountDomainSid(PSID pSid, PSID pDomainSid, DWORD* cbDomainSid);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall ImpersonateAnonymousToken(HANDLE ThreadHandle);

    __declspec(dllimport) BOOL __stdcall ImpersonateLoggedOnUser(HANDLE hToken);

    __declspec(dllimport) BOOL __stdcall ImpersonateSelf(SECURITY_IMPERSONATION_LEVEL ImpersonationLevel);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall InitializeAcl(PACL pAcl, DWORD nAclLength, DWORD dwAclRevision);

    __declspec(dllimport) BOOL __stdcall InitializeSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor, DWORD dwRevision);

    __declspec(dllimport) BOOL
    __stdcall InitializeSid(PSID Sid, PSID_IDENTIFIER_AUTHORITY pIdentifierAuthority, BYTE nSubAuthorityCount);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsTokenRestricted(HANDLE TokenHandle);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsValidAcl(PACL pAcl);

    __declspec(dllimport) BOOL __stdcall IsValidSecurityDescriptor(PSECURITY_DESCRIPTOR pSecurityDescriptor);

    __declspec(dllimport) BOOL __stdcall IsValidSid(PSID pSid);

    __declspec(dllimport) BOOL __stdcall IsWellKnownSid(PSID pSid, WELL_KNOWN_SID_TYPE WellKnownSidType);

    __declspec(dllimport)

    BOOL __stdcall MakeAbsoluteSD(PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
                                  PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
                                  LPDWORD lpdwAbsoluteSecurityDescriptorSize,
                                  PACL pDacl,
                                  LPDWORD lpdwDaclSize,
                                  PACL pSacl,
                                  LPDWORD lpdwSaclSize,
                                  PSID pOwner,
                                  LPDWORD lpdwOwnerSize,
                                  PSID pPrimaryGroup,
                                  LPDWORD lpdwPrimaryGroupSize);

    __declspec(dllimport)

    BOOL __stdcall MakeSelfRelativeSD(PSECURITY_DESCRIPTOR pAbsoluteSecurityDescriptor,
                                      PSECURITY_DESCRIPTOR pSelfRelativeSecurityDescriptor,
                                      LPDWORD lpdwBufferLength);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) void __stdcall MapGenericMask(PDWORD AccessMask, PGENERIC_MAPPING GenericMapping);

    __declspec(dllimport) BOOL __stdcall ObjectCloseAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose);

    __declspec(dllimport) BOOL __stdcall ObjectDeleteAuditAlarmW(LPCWSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose);

    __declspec(dllimport) BOOL __stdcall ObjectOpenAuditAlarmW(LPCWSTR SubsystemName,
                                                               LPVOID HandleId,
                                                               LPWSTR ObjectTypeName,
                                                               LPWSTR ObjectName,
                                                               PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                               HANDLE ClientToken,
                                                               DWORD DesiredAccess,
                                                               DWORD GrantedAccess,
                                                               PPRIVILEGE_SET Privileges,
                                                               BOOL ObjectCreation,
                                                               BOOL AccessGranted,
                                                               LPBOOL GenerateOnClose);

    __declspec(dllimport) BOOL __stdcall ObjectPrivilegeAuditAlarmW(
    LPCWSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted);

    __declspec(dllimport) BOOL __stdcall PrivilegeCheck(HANDLE ClientToken, PPRIVILEGE_SET RequiredPrivileges, LPBOOL pfResult);

    __declspec(dllimport) BOOL __stdcall PrivilegedServiceAuditAlarmW(
    LPCWSTR SubsystemName, LPCWSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted);

    __declspec(dllimport) void __stdcall QuerySecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess);

    __declspec(dllimport) BOOL __stdcall RevertToSelf(void);

    __declspec(dllimport) BOOL
    __stdcall SetAclInformation(PACL pAcl, LPVOID pAclInformation, DWORD nAclInformationLength, ACL_INFORMATION_CLASS dwAclInformationClass);

    __declspec(dllimport) BOOL
    __stdcall SetFileSecurityW(LPCWSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall SetKernelObjectSecurity(HANDLE Handle, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR SecurityDescriptor);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetPrivateObjectSecurity(SECURITY_INFORMATION SecurityInformation,
                                                                  PSECURITY_DESCRIPTOR ModificationDescriptor,
                                                                  PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor,
                                                                  PGENERIC_MAPPING GenericMapping,
                                                                  HANDLE Token);

    __declspec(dllimport) BOOL __stdcall SetPrivateObjectSecurityEx(SECURITY_INFORMATION SecurityInformation,
                                                                    PSECURITY_DESCRIPTOR ModificationDescriptor,
                                                                    PSECURITY_DESCRIPTOR* ObjectsSecurityDescriptor,
                                                                    ULONG AutoInheritFlags,
                                                                    PGENERIC_MAPPING GenericMapping,
                                                                    HANDLE Token);

    __declspec(dllimport) void __stdcall SetSecurityAccessMask(SECURITY_INFORMATION SecurityInformation, LPDWORD DesiredAccess);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetSecurityDescriptorControl(PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                                      SECURITY_DESCRIPTOR_CONTROL ControlBitsOfInterest,
                                                                      SECURITY_DESCRIPTOR_CONTROL ControlBitsToSet);

    __declspec(dllimport) BOOL
    __stdcall SetSecurityDescriptorDacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bDaclPresent, PACL pDacl, BOOL bDaclDefaulted);

    __declspec(dllimport) BOOL
    __stdcall SetSecurityDescriptorGroup(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pGroup, BOOL bGroupDefaulted);

    __declspec(dllimport) BOOL
    __stdcall SetSecurityDescriptorOwner(PSECURITY_DESCRIPTOR pSecurityDescriptor, PSID pOwner, BOOL bOwnerDefaulted);

    __declspec(dllimport) DWORD __stdcall SetSecurityDescriptorRMControl(PSECURITY_DESCRIPTOR SecurityDescriptor, PUCHAR RMControl);

    __declspec(dllimport) BOOL
    __stdcall SetSecurityDescriptorSacl(PSECURITY_DESCRIPTOR pSecurityDescriptor, BOOL bSaclPresent, PACL pSacl, BOOL bSaclDefaulted);

    __declspec(dllimport) BOOL __stdcall SetTokenInformation(HANDLE TokenHandle,
                                                             TOKEN_INFORMATION_CLASS TokenInformationClass,
                                                             LPVOID TokenInformation,
                                                             DWORD TokenInformationLength);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall SetCachedSigningLevel(PHANDLE SourceFiles, ULONG SourceFileCount, ULONG Flags, HANDLE TargetFile);

    __declspec(dllimport) BOOL
    __stdcall GetCachedSigningLevel(HANDLE File, PULONG Flags, PULONG SigningLevel, PUCHAR Thumbprint, PULONG ThumbprintSize, PULONG ThumbprintAlgorithm);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) LONG __stdcall CveEventWrite(PCWSTR CveId, PCWSTR AdditionalDetails);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall DeriveCapabilitySidsFromName(LPCWSTR CapName,
                                                                      PSID** CapabilityGroupSids,
                                                                      DWORD* CapabilityGroupSidCount,
                                                                      PSID** CapabilitySids,
                                                                      DWORD* CapabilitySidCount);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) HANDLE __stdcall CreatePrivateNamespaceW(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes,
                                                                   LPVOID lpBoundaryDescriptor,
                                                                   LPCWSTR lpAliasPrefix);

    __declspec(dllimport) HANDLE __stdcall OpenPrivateNamespaceW(LPVOID lpBoundaryDescriptor, LPCWSTR lpAliasPrefix);

    __declspec(dllimport) BOOLEAN __stdcall ClosePrivateNamespace(HANDLE Handle, ULONG Flags);

    __declspec(dllimport) HANDLE __stdcall CreateBoundaryDescriptorW(LPCWSTR Name, ULONG Flags);

    __declspec(dllimport) BOOL __stdcall AddSIDToBoundaryDescriptor(HANDLE* BoundaryDescriptor, PSID RequiredSid);

    __declspec(dllimport) void __stdcall DeleteBoundaryDescriptor(HANDLE BoundaryDescriptor);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetNumaHighestNodeNumber(PULONG HighestNodeNumber);

    __declspec(dllimport) BOOL __stdcall GetNumaNodeProcessorMaskEx(USHORT Node, PGROUP_AFFINITY ProcessorMask);

    __declspec(dllimport) BOOL __stdcall GetNumaProximityNodeEx(ULONG ProximityId, PUSHORT NodeNumber);

#pragma endregion
}

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetProcessGroupAffinity(HANDLE hProcess, PUSHORT GroupCount, PUSHORT GroupArray);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetThreadGroupAffinity(HANDLE hThread, PGROUP_AFFINITY GroupAffinity);

    __declspec(dllimport) BOOL
    __stdcall SetThreadGroupAffinity(HANDLE hThread, const GROUP_AFFINITY* GroupAffinity, PGROUP_AFFINITY PreviousGroupAffinity);

#pragma endregion
}

#pragma once

#pragma region Desktop Family or OneCore Family

extern "C"
{
    BOOL __stdcall GetAppContainerNamedObjectPath(HANDLE Token, PSID AppContainerSid, ULONG ObjectPathLength, LPWSTR ObjectPath, PULONG ReturnLength);
}

#pragma endregion

#pragma once

extern "C"
{
#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall QueryThreadCycleTime(HANDLE ThreadHandle, PULONG64 CycleTime);

    __declspec(dllimport) BOOL __stdcall QueryProcessCycleTime(HANDLE ProcessHandle, PULONG64 CycleTime);

    __declspec(dllimport) BOOL __stdcall QueryIdleProcessorCycleTime(PULONG BufferLength, PULONG64 ProcessorIdleCycleTime);

    __declspec(dllimport) BOOL
    __stdcall QueryIdleProcessorCycleTimeEx(USHORT Group, PULONG BufferLength, PULONG64 ProcessorIdleCycleTime);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) void __stdcall QueryInterruptTimePrecise(PULONGLONG lpInterruptTimePrecise);

    __declspec(dllimport) void __stdcall QueryUnbiasedInterruptTimePrecise(PULONGLONG lpUnbiasedInterruptTimePrecise);

    __declspec(dllimport) void __stdcall QueryInterruptTime(PULONGLONG lpInterruptTime);

    __declspec(dllimport) BOOL __stdcall QueryUnbiasedInterruptTime(PULONGLONG UnbiasedTime);

    __declspec(dllimport) HRESULT __stdcall QueryAuxiliaryCounterFrequency(PULONGLONG lpAuxiliaryCounterFrequency);

    __declspec(dllimport) HRESULT __stdcall ConvertAuxiliaryCounterToPerformanceCounter(ULONGLONG ullAuxiliaryCounterValue,
                                                                                        PULONGLONG lpPerformanceCounterValue,
                                                                                        PULONGLONG lpConversionError);

    __declspec(dllimport) HRESULT __stdcall ConvertPerformanceCounterToAuxiliaryCounter(ULONGLONG ullPerformanceCounterValue,
                                                                                        PULONGLONG lpAuxiliaryCounterValue,
                                                                                        PULONGLONG lpConversionError);

#pragma endregion
}

extern "C"
{
#pragma region Application Family

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef void(__stdcall* PFIBER_START_ROUTINE)(LPVOID lpFiberParameter);
    typedef PFIBER_START_ROUTINE LPFIBER_START_ROUTINE;

    typedef LPVOID(__stdcall* PFIBER_CALLOUT_ROUTINE)(LPVOID lpParameter);

    typedef LPVOID LPLDT_ENTRY;

    typedef struct _COMMPROP
    {
        WORD wPacketLength;
        WORD wPacketVersion;
        DWORD dwServiceMask;
        DWORD dwReserved1;
        DWORD dwMaxTxQueue;
        DWORD dwMaxRxQueue;
        DWORD dwMaxBaud;
        DWORD dwProvSubType;
        DWORD dwProvCapabilities;
        DWORD dwSettableParams;
        DWORD dwSettableBaud;
        WORD wSettableData;
        WORD wSettableStopParity;
        DWORD dwCurrentTxQueue;
        DWORD dwCurrentRxQueue;
        DWORD dwProvSpec1;
        DWORD dwProvSpec2;
        WCHAR wcProvChar[1];
    } COMMPROP, *LPCOMMPROP;

    typedef struct _COMSTAT
    {
        DWORD fCtsHold : 1;
        DWORD fDsrHold : 1;
        DWORD fRlsdHold : 1;
        DWORD fXoffHold : 1;
        DWORD fXoffSent : 1;
        DWORD fEof : 1;
        DWORD fTxim : 1;
        DWORD fReserved : 25;
        DWORD cbInQue;
        DWORD cbOutQue;
    } COMSTAT, *LPCOMSTAT;

    typedef struct _DCB
    {
        DWORD DCBlength;
        DWORD BaudRate;
        DWORD fBinary : 1;
        DWORD fParity : 1;
        DWORD fOutxCtsFlow : 1;
        DWORD fOutxDsrFlow : 1;
        DWORD fDtrControl : 2;
        DWORD fDsrSensitivity : 1;
        DWORD fTXContinueOnXoff : 1;
        DWORD fOutX : 1;
        DWORD fInX : 1;
        DWORD fErrorChar : 1;
        DWORD fNull : 1;
        DWORD fRtsControl : 2;
        DWORD fAbortOnError : 1;
        DWORD fDummy2 : 17;
        WORD wReserved;
        WORD XonLim;
        WORD XoffLim;
        BYTE ByteSize;
        BYTE Parity;
        BYTE StopBits;
        char XonChar;
        char XoffChar;
        char ErrorChar;
        char EofChar;
        char EvtChar;
        WORD wReserved1;
    } DCB, *LPDCB;

    typedef struct _COMMTIMEOUTS
    {
        DWORD ReadIntervalTimeout;
        DWORD ReadTotalTimeoutMultiplier;
        DWORD ReadTotalTimeoutConstant;
        DWORD WriteTotalTimeoutMultiplier;
        DWORD WriteTotalTimeoutConstant;
    } COMMTIMEOUTS, *LPCOMMTIMEOUTS;

    typedef struct _COMMCONFIG
    {
        DWORD dwSize;
        WORD wVersion;
        WORD wReserved;
        DCB dcb;
        DWORD dwProviderSubType;

        DWORD dwProviderOffset;

        DWORD dwProviderSize;
        WCHAR wcProviderData[1];
    } COMMCONFIG, *LPCOMMCONFIG;

    typedef struct _MEMORYSTATUS
    {
        DWORD dwLength;
        DWORD dwMemoryLoad;
        SIZE_T dwTotalPhys;
        SIZE_T dwAvailPhys;
        SIZE_T dwTotalPageFile;
        SIZE_T dwAvailPageFile;
        SIZE_T dwTotalVirtual;
        SIZE_T dwAvailVirtual;
    } MEMORYSTATUS, *LPMEMORYSTATUS;

    typedef struct _JIT_DEBUG_INFO
    {
        DWORD dwSize;
        DWORD dwProcessorArchitecture;
        DWORD dwThreadID;
        DWORD dwReserved0;
        ULONG64 lpExceptionAddress;
        ULONG64 lpExceptionRecord;
        ULONG64 lpContextRecord;
    } JIT_DEBUG_INFO, *LPJIT_DEBUG_INFO;

    typedef JIT_DEBUG_INFO JIT_DEBUG_INFO32, *LPJIT_DEBUG_INFO32;
    typedef JIT_DEBUG_INFO JIT_DEBUG_INFO64, *LPJIT_DEBUG_INFO64;

    typedef PEXCEPTION_RECORD LPEXCEPTION_RECORD;
    typedef PEXCEPTION_POINTERS LPEXCEPTION_POINTERS;

    typedef struct _OFSTRUCT
    {
        BYTE cBytes;
        BYTE fFixedDisk;
        WORD nErrCode;
        WORD Reserved1;
        WORD Reserved2;
        CHAR szPathName[128];
    } OFSTRUCT, *LPOFSTRUCT, *POFSTRUCT;

#pragma endregion

#pragma region Desktop Family

    int

    __stdcall

    WinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPSTR lpCmdLine, int nShowCmd);

    int

    __stdcall wWinMain(HINSTANCE hInstance, HINSTANCE hPrevInstance, LPWSTR lpCmdLine, int nShowCmd);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    __declspec(allocator) HGLOBAL __stdcall GlobalAlloc(UINT uFlags, SIZE_T dwBytes);

#pragma endregion

#pragma region Application Family

    __declspec(dllimport)

    __declspec(allocator) HGLOBAL __stdcall GlobalReAlloc(HGLOBAL hMem, SIZE_T dwBytes, UINT uFlags);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) SIZE_T __stdcall GlobalSize(HGLOBAL hMem);

    __declspec(dllimport) BOOL __stdcall GlobalUnlock(HGLOBAL hMem);

    __declspec(dllimport)

    LPVOID __stdcall GlobalLock(HGLOBAL hMem);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) UINT __stdcall GlobalFlags(HGLOBAL hMem);

    __declspec(dllimport)

    HGLOBAL __stdcall GlobalHandle(LPCVOID pMem);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    HGLOBAL __stdcall GlobalFree(HGLOBAL hMem);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) SIZE_T __stdcall GlobalCompact(DWORD dwMinFree);

    __declspec(dllimport) void __stdcall GlobalFix(HGLOBAL hMem);

    __declspec(dllimport) void __stdcall GlobalUnfix(HGLOBAL hMem);

    __declspec(dllimport) LPVOID __stdcall GlobalWire(HGLOBAL hMem);

    __declspec(dllimport) BOOL __stdcall GlobalUnWire(HGLOBAL hMem);

    __declspec(dllimport) void __stdcall GlobalMemoryStatus(LPMEMORYSTATUS lpBuffer);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    __declspec(allocator) HLOCAL __stdcall LocalAlloc(UINT uFlags, SIZE_T uBytes);

    __declspec(dllimport)

    __declspec(allocator) HLOCAL __stdcall LocalReAlloc(HLOCAL hMem, SIZE_T uBytes, UINT uFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    LPVOID __stdcall LocalLock(HLOCAL hMem);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport)

    HLOCAL __stdcall LocalHandle(LPCVOID pMem);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall LocalUnlock(HLOCAL hMem);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) SIZE_T __stdcall LocalSize(HLOCAL hMem);

    __declspec(dllimport) UINT __stdcall LocalFlags(HLOCAL hMem);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    HLOCAL __stdcall LocalFree(HLOCAL hMem);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) SIZE_T __stdcall LocalShrink(HLOCAL hMem, UINT cbNewSize);

    __declspec(dllimport) SIZE_T __stdcall LocalCompact(UINT uMinFree);

    __declspec(dllimport) BOOL __stdcall GetBinaryTypeA(LPCSTR lpApplicationName, LPDWORD lpBinaryType);
    __declspec(dllimport) BOOL __stdcall GetBinaryTypeW(LPCWSTR lpApplicationName, LPDWORD lpBinaryType);

    __declspec(dllimport)

    DWORD __stdcall GetShortPathNameA(LPCSTR lpszLongPath, LPSTR lpszShortPath, DWORD cchBuffer);

    __declspec(dllimport)

    DWORD __stdcall GetLongPathNameTransactedA(LPCSTR lpszShortPath, LPSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction);
    __declspec(dllimport)

    DWORD __stdcall GetLongPathNameTransactedW(LPCWSTR lpszShortPath, LPWSTR lpszLongPath, DWORD cchBuffer, HANDLE hTransaction);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetProcessAffinityMask(HANDLE hProcess, PDWORD_PTR lpProcessAffinityMask, PDWORD_PTR lpSystemAffinityMask);

    __declspec(dllimport) BOOL __stdcall SetProcessAffinityMask(HANDLE hProcess, DWORD_PTR dwProcessAffinityMask);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GetProcessIoCounters(HANDLE hProcess, PIO_COUNTERS lpIoCounters);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetProcessWorkingSetSize(HANDLE hProcess, PSIZE_T lpMinimumWorkingSetSize, PSIZE_T lpMaximumWorkingSetSize);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL
    __stdcall SetProcessWorkingSetSize(HANDLE hProcess, SIZE_T dwMinimumWorkingSetSize, SIZE_T dwMaximumWorkingSetSize);

    __declspec(dllimport)

    void __stdcall FatalExit(int ExitCode);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetEnvironmentStringsA(LPCH NewEnvironment);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) void __stdcall SwitchToFiber(LPVOID lpFiber);

    __declspec(dllimport) void __stdcall DeleteFiber(LPVOID lpFiber);

    __declspec(dllimport) BOOL __stdcall ConvertFiberToThread(void);

    __declspec(dllimport)

    LPVOID
    __stdcall CreateFiberEx(SIZE_T dwStackCommitSize, SIZE_T dwStackReserveSize, DWORD dwFlags, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter);

    __declspec(dllimport)

    LPVOID __stdcall ConvertThreadToFiberEx(LPVOID lpParameter, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    LPVOID __stdcall CreateFiber(SIZE_T dwStackSize, LPFIBER_START_ROUTINE lpStartAddress, LPVOID lpParameter);

    __declspec(dllimport)

    LPVOID __stdcall ConvertThreadToFiber(LPVOID lpParameter);

#pragma endregion

#pragma region Desktop Family

    typedef void* PUMS_CONTEXT;

    typedef void* PUMS_COMPLETION_LIST;

    typedef enum _RTL_UMS_THREAD_INFO_CLASS UMS_THREAD_INFO_CLASS, *PUMS_THREAD_INFO_CLASS;

    typedef enum _RTL_UMS_SCHEDULER_REASON UMS_SCHEDULER_REASON;

    typedef PRTL_UMS_SCHEDULER_ENTRY_POINT PUMS_SCHEDULER_ENTRY_POINT;

    typedef struct _UMS_SCHEDULER_STARTUP_INFO
    {
        ULONG UmsVersion;

        PUMS_COMPLETION_LIST CompletionList;

        PUMS_SCHEDULER_ENTRY_POINT SchedulerProc;

        PVOID SchedulerParam;

    } UMS_SCHEDULER_STARTUP_INFO, *PUMS_SCHEDULER_STARTUP_INFO;

    typedef struct _UMS_SYSTEM_THREAD_INFORMATION
    {
        ULONG UmsVersion;
        union
        {
            struct
            {
                ULONG IsUmsSchedulerThread : 1;
                ULONG IsUmsWorkerThread : 1;
            };
            ULONG ThreadUmsFlags;
        };
    } UMS_SYSTEM_THREAD_INFORMATION, *PUMS_SYSTEM_THREAD_INFORMATION;

    __declspec(dllimport) BOOL __stdcall CreateUmsCompletionList(PUMS_COMPLETION_LIST* UmsCompletionList);

    __declspec(dllimport) BOOL
    __stdcall DequeueUmsCompletionListItems(PUMS_COMPLETION_LIST UmsCompletionList, DWORD WaitTimeOut, PUMS_CONTEXT* UmsThreadList);

    __declspec(dllimport) BOOL
    __stdcall GetUmsCompletionListEvent(PUMS_COMPLETION_LIST UmsCompletionList, PHANDLE UmsCompletionEvent);

    __declspec(dllimport) BOOL __stdcall ExecuteUmsThread(PUMS_CONTEXT UmsThread);

    __declspec(dllimport) BOOL __stdcall UmsThreadYield(PVOID SchedulerParam);

    __declspec(dllimport) BOOL __stdcall DeleteUmsCompletionList(PUMS_COMPLETION_LIST UmsCompletionList);

    __declspec(dllimport) PUMS_CONTEXT __stdcall GetCurrentUmsThread(void);

    __declspec(dllimport) PUMS_CONTEXT __stdcall GetNextUmsListItem(PUMS_CONTEXT UmsContext);

    __declspec(dllimport) BOOL __stdcall QueryUmsThreadInformation(PUMS_CONTEXT UmsThread,
                                                                   UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
                                                                   PVOID UmsThreadInformation,
                                                                   ULONG UmsThreadInformationLength,
                                                                   PULONG ReturnLength);

    __declspec(dllimport) BOOL __stdcall SetUmsThreadInformation(PUMS_CONTEXT UmsThread,
                                                                 UMS_THREAD_INFO_CLASS UmsThreadInfoClass,
                                                                 PVOID UmsThreadInformation,
                                                                 ULONG UmsThreadInformationLength);

    __declspec(dllimport) BOOL __stdcall DeleteUmsThreadContext(PUMS_CONTEXT UmsThread);

    __declspec(dllimport) BOOL __stdcall CreateUmsThreadContext(PUMS_CONTEXT* lpUmsThread);

    __declspec(dllimport) BOOL __stdcall EnterUmsSchedulingMode(PUMS_SCHEDULER_STARTUP_INFO SchedulerStartupInfo);

    __declspec(dllimport) BOOL
    __stdcall GetUmsSystemThreadInformation(HANDLE ThreadHandle, PUMS_SYSTEM_THREAD_INFORMATION SystemThreadInfo);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD_PTR __stdcall SetThreadAffinityMask(HANDLE hThread, DWORD_PTR dwThreadAffinityMask);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall SetProcessDEPPolicy(DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall GetProcessDEPPolicy(HANDLE hProcess, LPDWORD lpFlags, PBOOL lpPermanent);

    __declspec(dllimport) BOOL __stdcall RequestWakeupLatency(LATENCY_TIME latency);

    __declspec(dllimport) BOOL __stdcall IsSystemResumeAutomatic(void);

    __declspec(dllimport) BOOL __stdcall GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, LPLDT_ENTRY lpSelectorEntry);

    __declspec(dllimport) EXECUTION_STATE __stdcall SetThreadExecutionState(EXECUTION_STATE esFlags);

    typedef REASON_CONTEXT POWER_REQUEST_CONTEXT, *PPOWER_REQUEST_CONTEXT, *LPPOWER_REQUEST_CONTEXT;

    __declspec(dllimport) HANDLE __stdcall PowerCreateRequest(PREASON_CONTEXT Context);

    __declspec(dllimport) BOOL __stdcall PowerSetRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);

    __declspec(dllimport) BOOL __stdcall PowerClearRequest(HANDLE PowerRequest, POWER_REQUEST_TYPE RequestType);

#pragma endregion

#pragma region Application Family

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetFileCompletionNotificationModes(HANDLE FileHandle, UCHAR Flags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall Wow64GetThreadContext(HANDLE hThread, PWOW64_CONTEXT lpContext);

    __declspec(dllimport) BOOL __stdcall Wow64SetThreadContext(HANDLE hThread, const WOW64_CONTEXT* lpContext);

    __declspec(dllimport) BOOL
    __stdcall Wow64GetThreadSelectorEntry(HANDLE hThread, DWORD dwSelector, PWOW64_LDT_ENTRY lpSelectorEntry);

    __declspec(dllimport) DWORD __stdcall Wow64SuspendThread(HANDLE hThread);

    __declspec(dllimport) BOOL __stdcall DebugSetProcessKillOnExit(BOOL KillOnExit);

    __declspec(dllimport) BOOL __stdcall DebugBreakProcess(HANDLE Process);

#pragma endregion

#pragma region Application Family

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall PulseEvent(HANDLE hEvent);

    __declspec(dllimport) ATOM __stdcall GlobalDeleteAtom(ATOM nAtom);

    __declspec(dllimport) BOOL __stdcall InitAtomTable(DWORD nSize);

    __declspec(dllimport) ATOM __stdcall DeleteAtom(ATOM nAtom);

    __declspec(dllimport) UINT __stdcall SetHandleCount(UINT uNumber);

    __declspec(dllimport) BOOL __stdcall RequestDeviceWakeup(HANDLE hDevice);

    __declspec(dllimport) BOOL __stdcall CancelDeviceWakeupRequest(HANDLE hDevice);

    __declspec(dllimport) BOOL __stdcall GetDevicePowerState(HANDLE hDevice, BOOL* pfOn);

    __declspec(dllimport) BOOL __stdcall SetMessageWaitingIndicator(HANDLE hMsgIndicator, ULONG ulMsgCount);

    __declspec(dllimport) BOOL __stdcall SetFileShortNameA(HANDLE hFile, LPCSTR lpShortName);
    __declspec(dllimport) BOOL __stdcall SetFileShortNameW(HANDLE hFile, LPCWSTR lpShortName);

    __declspec(dllimport) DWORD __stdcall LoadModule(LPCSTR lpModuleName, LPVOID lpParameterBlock);

    __declspec(dllimport) UINT __stdcall WinExec(LPCSTR lpCmdLine, UINT uCmdShow);

#pragma endregion

#pragma region Desktop Family or OneCore or App Family

    __declspec(dllimport) BOOL __stdcall ClearCommBreak(HANDLE hFile);

    __declspec(dllimport) BOOL __stdcall ClearCommError(HANDLE hFile, LPDWORD lpErrors, LPCOMSTAT lpStat);

    __declspec(dllimport) BOOL __stdcall SetupComm(HANDLE hFile, DWORD dwInQueue, DWORD dwOutQueue);

    __declspec(dllimport) BOOL __stdcall EscapeCommFunction(HANDLE hFile, DWORD dwFunc);

    __declspec(dllimport)

    BOOL __stdcall GetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);

    __declspec(dllimport) BOOL __stdcall GetCommMask(HANDLE hFile, LPDWORD lpEvtMask);

    __declspec(dllimport) BOOL __stdcall GetCommProperties(HANDLE hFile, LPCOMMPROP lpCommProp);

    __declspec(dllimport) BOOL __stdcall GetCommModemStatus(HANDLE hFile, LPDWORD lpModemStat);

    __declspec(dllimport) BOOL __stdcall GetCommState(HANDLE hFile, LPDCB lpDCB);

    __declspec(dllimport) BOOL __stdcall GetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);

    __declspec(dllimport) BOOL __stdcall PurgeComm(HANDLE hFile, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall SetCommBreak(HANDLE hFile);

    __declspec(dllimport) BOOL __stdcall SetCommConfig(HANDLE hCommDev, LPCOMMCONFIG lpCC, DWORD dwSize);

    __declspec(dllimport) BOOL __stdcall SetCommMask(HANDLE hFile, DWORD dwEvtMask);

    __declspec(dllimport) BOOL __stdcall SetCommState(HANDLE hFile, LPDCB lpDCB);

    __declspec(dllimport) BOOL __stdcall SetCommTimeouts(HANDLE hFile, LPCOMMTIMEOUTS lpCommTimeouts);

    __declspec(dllimport) BOOL __stdcall TransmitCommChar(HANDLE hFile, char cChar);

    __declspec(dllimport) BOOL __stdcall WaitCommEvent(HANDLE hFile, LPDWORD lpEvtMask, LPOVERLAPPED lpOverlapped);

    __declspec(dllimport) HANDLE __stdcall OpenCommPort(ULONG uPortNumber, DWORD dwDesiredAccess, DWORD dwFlagsAndAttributes);

    __declspec(dllimport) ULONG __stdcall GetCommPorts(PULONG lpPortNumbers, ULONG uPortNumbersCount, PULONG puPortNumbersFound);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) DWORD
    __stdcall SetTapePosition(HANDLE hDevice, DWORD dwPositionMethod, DWORD dwPartition, DWORD dwOffsetLow, DWORD dwOffsetHigh, BOOL bImmediate);

    __declspec(dllimport) DWORD
    __stdcall GetTapePosition(HANDLE hDevice, DWORD dwPositionType, LPDWORD lpdwPartition, LPDWORD lpdwOffsetLow, LPDWORD lpdwOffsetHigh);

    __declspec(dllimport) DWORD __stdcall PrepareTape(HANDLE hDevice, DWORD dwOperation, BOOL bImmediate);

    __declspec(dllimport) DWORD __stdcall EraseTape(HANDLE hDevice, DWORD dwEraseType, BOOL bImmediate);

    __declspec(dllimport) DWORD __stdcall CreateTapePartition(HANDLE hDevice, DWORD dwPartitionMethod, DWORD dwCount, DWORD dwSize);

    __declspec(dllimport) DWORD
    __stdcall WriteTapemark(HANDLE hDevice, DWORD dwTapemarkType, DWORD dwTapemarkCount, BOOL bImmediate);

    __declspec(dllimport) DWORD __stdcall GetTapeStatus(HANDLE hDevice);

    __declspec(dllimport) DWORD
    __stdcall GetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPDWORD lpdwSize, LPVOID lpTapeInformation);

    __declspec(dllimport) DWORD __stdcall SetTapeParameters(HANDLE hDevice, DWORD dwOperation, LPVOID lpTapeInformation);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) int __stdcall MulDiv(int nNumber, int nNumerator, int nDenominator);

#pragma endregion

#pragma region Desktop Family

    typedef enum _DEP_SYSTEM_POLICY_TYPE
    {
        DEPPolicyAlwaysOff = 0,
        DEPPolicyAlwaysOn,
        DEPPolicyOptIn,
        DEPPolicyOptOut,
        DEPTotalPolicyCount
    } DEP_SYSTEM_POLICY_TYPE;

    __declspec(dllimport) DEP_SYSTEM_POLICY_TYPE __stdcall GetSystemDEPPolicy(void);

    __declspec(dllimport) BOOL __stdcall GetSystemRegistryQuota(PDWORD pdwQuotaAllowed, PDWORD pdwQuotaUsed);

    __declspec(dllimport) BOOL __stdcall FileTimeToDosDateTime(const FILETIME* lpFileTime, LPWORD lpFatDate, LPWORD lpFatTime);

    __declspec(dllimport) BOOL __stdcall DosDateTimeToFileTime(WORD wFatDate, WORD wFatTime, LPFILETIME lpFileTime);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    DWORD __stdcall FormatMessageA(DWORD dwFlags,
                                   LPCVOID lpSource,
                                   DWORD dwMessageId,
                                   DWORD dwLanguageId,

                                   LPSTR lpBuffer,
                                   DWORD nSize,
                                   va_list* Arguments);
    __declspec(dllimport)

    DWORD __stdcall FormatMessageW(DWORD dwFlags,
                                   LPCVOID lpSource,
                                   DWORD dwMessageId,
                                   DWORD dwLanguageId,

                                   LPWSTR lpBuffer,
                                   DWORD nSize,
                                   va_list* Arguments);

    __inline DWORD
    FormatMessage(DWORD dwFlags, LPCVOID lpSource, DWORD dwMessageId, DWORD dwLanguageId, LPTSTR lpBuffer, DWORD nSize, va_list* Arguments)
    {
        return FormatMessageA(dwFlags, lpSource, dwMessageId, dwLanguageId, lpBuffer, nSize, Arguments);
    }

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HANDLE
    __stdcall CreateMailslotA(LPCSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
    __declspec(dllimport) HANDLE
    __stdcall CreateMailslotW(LPCWSTR lpName, DWORD nMaxMessageSize, DWORD lReadTimeout, LPSECURITY_ATTRIBUTES lpSecurityAttributes);

    __declspec(dllimport) BOOL
    __stdcall GetMailslotInfo(HANDLE hMailslot, LPDWORD lpMaxMessageSize, LPDWORD lpNextSize, LPDWORD lpMessageCount, LPDWORD lpReadTimeout);

    __declspec(dllimport) BOOL __stdcall SetMailslotInfo(HANDLE hMailslot, DWORD lReadTimeout);

    __declspec(dllimport) BOOL __stdcall EncryptFileA(LPCSTR lpFileName);
    __declspec(dllimport) BOOL __stdcall EncryptFileW(LPCWSTR lpFileName);

    __declspec(dllimport) BOOL __stdcall DecryptFileA(LPCSTR lpFileName, DWORD dwReserved);
    __declspec(dllimport) BOOL __stdcall DecryptFileW(LPCWSTR lpFileName, DWORD dwReserved);

    __declspec(dllimport) BOOL __stdcall FileEncryptionStatusA(LPCSTR lpFileName, LPDWORD lpStatus);
    __declspec(dllimport) BOOL __stdcall FileEncryptionStatusW(LPCWSTR lpFileName, LPDWORD lpStatus);

    typedef DWORD(__stdcall* PFE_EXPORT_FUNC)(PBYTE pbData, PVOID pvCallbackContext, ULONG ulLength);

    typedef DWORD(__stdcall* PFE_IMPORT_FUNC)(PBYTE pbData, PVOID pvCallbackContext, PULONG ulLength);

    __declspec(dllimport) DWORD __stdcall OpenEncryptedFileRawA(LPCSTR lpFileName, ULONG ulFlags, PVOID* pvContext);
    __declspec(dllimport) DWORD __stdcall OpenEncryptedFileRawW(LPCWSTR lpFileName, ULONG ulFlags, PVOID* pvContext);

    __declspec(dllimport) DWORD
    __stdcall ReadEncryptedFileRaw(PFE_EXPORT_FUNC pfExportCallback, PVOID pvCallbackContext, PVOID pvContext);

    __declspec(dllimport) DWORD
    __stdcall WriteEncryptedFileRaw(PFE_IMPORT_FUNC pfImportCallback, PVOID pvCallbackContext, PVOID pvContext);

    __declspec(dllimport) void __stdcall CloseEncryptedFileRaw(PVOID pvContext);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) int __stdcall lstrcmpA(LPCSTR lpString1, LPCSTR lpString2);
    __declspec(dllimport) int __stdcall lstrcmpW(LPCWSTR lpString1, LPCWSTR lpString2);

    __declspec(dllimport) int __stdcall lstrcmpiA(LPCSTR lpString1, LPCSTR lpString2);
    __declspec(dllimport) int __stdcall lstrcmpiW(LPCWSTR lpString1, LPCWSTR lpString2);

#pragma warning(push)
#pragma warning(disable : 4995)

    __declspec(dllimport)

    LPSTR __stdcall lstrcpynA(LPSTR lpString1, LPCSTR lpString2, int iMaxLength);
    __declspec(dllimport)

    LPWSTR __stdcall lstrcpynW(LPWSTR lpString1, LPCWSTR lpString2, int iMaxLength);

    __declspec(dllimport) LPSTR __stdcall lstrcpyA(LPSTR lpString1, LPCSTR lpString2);
    __declspec(dllimport) LPWSTR __stdcall lstrcpyW(LPWSTR lpString1, LPCWSTR lpString2);

    __declspec(dllimport) LPSTR __stdcall lstrcatA(LPSTR lpString1, LPCSTR lpString2);
    __declspec(dllimport) LPWSTR __stdcall lstrcatW(LPWSTR lpString1, LPCWSTR lpString2);

#pragma warning(pop)

    __declspec(dllimport) int __stdcall lstrlenA(LPCSTR lpString);
    __declspec(dllimport) int __stdcall lstrlenW(LPCWSTR lpString);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HFILE __stdcall OpenFile(LPCSTR lpFileName, LPOFSTRUCT lpReOpenBuff, UINT uStyle);

    __declspec(dllimport) HFILE __stdcall _lopen(LPCSTR lpPathName, int iReadWrite);

    __declspec(dllimport) HFILE __stdcall _lcreat(LPCSTR lpPathName, int iAttribute);

    __declspec(dllimport) UINT __stdcall _lread(HFILE hFile, LPVOID lpBuffer, UINT uBytes);

    __declspec(dllimport) UINT __stdcall _lwrite(HFILE hFile, LPCCH lpBuffer, UINT uBytes);

    __declspec(dllimport) long __stdcall _hread(HFILE hFile, LPVOID lpBuffer, long lBytes);

    __declspec(dllimport) long __stdcall _hwrite(HFILE hFile, LPCCH lpBuffer, long lBytes);

    __declspec(dllimport) HFILE __stdcall _lclose(HFILE hFile);

    __declspec(dllimport) LONG __stdcall _llseek(HFILE hFile, LONG lOffset, int iOrigin);

    __declspec(dllimport) BOOL __stdcall IsTextUnicode(const void* lpv, int iSize, LPINT lpiResult);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD
    __stdcall SignalObjectAndWait(HANDLE hObjectToSignal, HANDLE hObjectToWaitOn, DWORD dwMilliseconds, BOOL bAlertable);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall BackupRead(HANDLE hFile,
                                                    LPBYTE lpBuffer,
                                                    DWORD nNumberOfBytesToRead,
                                                    LPDWORD lpNumberOfBytesRead,
                                                    BOOL bAbort,
                                                    BOOL bProcessSecurity,
                                                    LPVOID* lpContext);

    __declspec(dllimport) BOOL __stdcall BackupSeek(HANDLE hFile,
                                                    DWORD dwLowBytesToSeek,
                                                    DWORD dwHighBytesToSeek,
                                                    LPDWORD lpdwLowByteSeeked,
                                                    LPDWORD lpdwHighByteSeeked,
                                                    LPVOID* lpContext);

    __declspec(dllimport) BOOL __stdcall BackupWrite(HANDLE hFile,
                                                     LPBYTE lpBuffer,
                                                     DWORD nNumberOfBytesToWrite,
                                                     LPDWORD lpNumberOfBytesWritten,
                                                     BOOL bAbort,
                                                     BOOL bProcessSecurity,
                                                     LPVOID* lpContext);

    typedef struct _WIN32_STREAM_ID
    {
        DWORD dwStreamId;
        DWORD dwStreamAttributes;
        LARGE_INTEGER Size;
        DWORD dwStreamNameSize;
        WCHAR cStreamName[1];
    } WIN32_STREAM_ID, *LPWIN32_STREAM_ID;

    typedef struct _STARTUPINFOEXA
    {
        STARTUPINFOA StartupInfo;
        LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
    } STARTUPINFOEXA, *LPSTARTUPINFOEXA;
    typedef struct _STARTUPINFOEXW
    {
        STARTUPINFOW StartupInfo;
        LPPROC_THREAD_ATTRIBUTE_LIST lpAttributeList;
    } STARTUPINFOEXW, *LPSTARTUPINFOEXW;

    typedef STARTUPINFOEXA STARTUPINFOEX;
    typedef LPSTARTUPINFOEXA LPSTARTUPINFOEX;

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    HANDLE __stdcall OpenMutexA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);

    __declspec(dllimport)

    HANDLE
    __stdcall CreateSemaphoreA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes, LONG lInitialCount, LONG lMaximumCount, LPCSTR lpName);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    HANDLE __stdcall OpenSemaphoreA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    HANDLE __stdcall CreateWaitableTimerA(LPSECURITY_ATTRIBUTES lpTimerAttributes, BOOL bManualReset, LPCSTR lpTimerName);

    __declspec(dllimport)

    HANDLE __stdcall OpenWaitableTimerA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpTimerName);

    __declspec(dllimport)

    HANDLE __stdcall CreateSemaphoreExA(LPSECURITY_ATTRIBUTES lpSemaphoreAttributes,
                                        LONG lInitialCount,
                                        LONG lMaximumCount,
                                        LPCSTR lpName,
                                        DWORD dwFlags,
                                        DWORD dwDesiredAccess);

    __declspec(dllimport)

    HANDLE
    __stdcall CreateWaitableTimerExA(LPSECURITY_ATTRIBUTES lpTimerAttributes, LPCSTR lpTimerName, DWORD dwFlags, DWORD dwDesiredAccess);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport)

    HANDLE __stdcall CreateFileMappingA(HANDLE hFile,
                                        LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
                                        DWORD flProtect,
                                        DWORD dwMaximumSizeHigh,
                                        DWORD dwMaximumSizeLow,
                                        LPCSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall CreateFileMappingNumaA(HANDLE hFile,
                                            LPSECURITY_ATTRIBUTES lpFileMappingAttributes,
                                            DWORD flProtect,
                                            DWORD dwMaximumSizeHigh,
                                            DWORD dwMaximumSizeLow,
                                            LPCSTR lpName,
                                            DWORD nndPreferred);

    __declspec(dllimport) HANDLE __stdcall OpenFileMappingA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    DWORD __stdcall GetLogicalDriveStringsA(DWORD nBufferLength, LPSTR lpBuffer);

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    HMODULE __stdcall LoadPackagedLibrary(LPCWSTR lpwLibFileName, DWORD Reserved);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall QueryFullProcessImageNameA(HANDLE hProcess, DWORD dwFlags, LPSTR lpExeName, PDWORD lpdwSize);
    __declspec(dllimport) BOOL
    __stdcall QueryFullProcessImageNameW(HANDLE hProcess, DWORD dwFlags, LPWSTR lpExeName, PDWORD lpdwSize);

    typedef enum _PROC_THREAD_ATTRIBUTE_NUM
    {
        ProcThreadAttributeParentProcess = 0,
        ProcThreadAttributeHandleList = 2,

        ProcThreadAttributeGroupAffinity = 3,
        ProcThreadAttributePreferredNode = 4,
        ProcThreadAttributeIdealProcessor = 5,
        ProcThreadAttributeUmsThread = 6,
        ProcThreadAttributeMitigationPolicy = 7,

        ProcThreadAttributeSecurityCapabilities = 9,
        ProcThreadAttributeProtectionLevel = 11,

        ProcThreadAttributeJobList = 13,
        ProcThreadAttributeChildProcessPolicy = 14,
        ProcThreadAttributeAllApplicationPackagesPolicy = 15,
        ProcThreadAttributeWin32kFilter = 16,

        ProcThreadAttributeSafeOpenPromptOriginClaim = 17,

        ProcThreadAttributeDesktopAppPolicy = 18,

        ProcThreadAttributePseudoConsole = 22,
    } PROC_THREAD_ATTRIBUTE_NUM;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) void __stdcall GetStartupInfoA(LPSTARTUPINFOA lpStartupInfo);

#pragma warning(push)
#pragma warning(disable : 6103)

    __inline DWORD GetEnvironmentVariable(LPCTSTR lpName, LPTSTR lpBuffer, DWORD nSize)
    {
        return GetEnvironmentVariableA(lpName, lpBuffer, nSize);
    }

#pragma warning(pop)

    __inline BOOL SetEnvironmentVariable(LPCTSTR lpName, LPCTSTR lpValue)
    {
        return SetEnvironmentVariableA(lpName, lpValue);
    }

#pragma endregion

#pragma region OneCore Family or App Family

    __declspec(dllimport) DWORD __stdcall GetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize);
    __declspec(dllimport) DWORD
    __stdcall GetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize);

    __declspec(dllimport) DWORD
    __stdcall GetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes);
    __declspec(dllimport) DWORD
    __stdcall GetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pBuffer, DWORD nSize, PDWORD pdwAttribubutes);

    __declspec(dllimport) BOOL __stdcall SetFirmwareEnvironmentVariableA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize);
    __declspec(dllimport) BOOL __stdcall SetFirmwareEnvironmentVariableW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize);

    __declspec(dllimport) BOOL
    __stdcall SetFirmwareEnvironmentVariableExA(LPCSTR lpName, LPCSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes);
    __declspec(dllimport) BOOL
    __stdcall SetFirmwareEnvironmentVariableExW(LPCWSTR lpName, LPCWSTR lpGuid, PVOID pValue, DWORD nSize, DWORD dwAttributes);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GetFirmwareType(PFIRMWARE_TYPE FirmwareType);

    __declspec(dllimport) BOOL __stdcall IsNativeVhdBoot(PBOOL NativeVhdBoot);

    __declspec(dllimport)

    HRSRC __stdcall FindResourceA(HMODULE hModule, LPCSTR lpName, LPCSTR lpType);

    __declspec(dllimport)

    HRSRC __stdcall FindResourceExA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, WORD wLanguage);

    __declspec(dllimport) BOOL __stdcall EnumResourceTypesA(HMODULE hModule, ENUMRESTYPEPROCA lpEnumFunc, LONG_PTR lParam);
    __declspec(dllimport) BOOL __stdcall EnumResourceTypesW(HMODULE hModule, ENUMRESTYPEPROCW lpEnumFunc, LONG_PTR lParam);

    __declspec(dllimport) BOOL
    __stdcall EnumResourceNamesA(HMODULE hModule, LPCSTR lpType, ENUMRESNAMEPROCA lpEnumFunc, LONG_PTR lParam);

    __declspec(dllimport) BOOL
    __stdcall EnumResourceLanguagesA(HMODULE hModule, LPCSTR lpType, LPCSTR lpName, ENUMRESLANGPROCA lpEnumFunc, LONG_PTR lParam);
    __declspec(dllimport) BOOL
    __stdcall EnumResourceLanguagesW(HMODULE hModule, LPCWSTR lpType, LPCWSTR lpName, ENUMRESLANGPROCW lpEnumFunc, LONG_PTR lParam);

    __declspec(dllimport) HANDLE __stdcall BeginUpdateResourceA(LPCSTR pFileName, BOOL bDeleteExistingResources);
    __declspec(dllimport) HANDLE __stdcall BeginUpdateResourceW(LPCWSTR pFileName, BOOL bDeleteExistingResources);

    __declspec(dllimport) BOOL
    __stdcall UpdateResourceA(HANDLE hUpdate, LPCSTR lpType, LPCSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb);
    __declspec(dllimport) BOOL
    __stdcall UpdateResourceW(HANDLE hUpdate, LPCWSTR lpType, LPCWSTR lpName, WORD wLanguage, LPVOID lpData, DWORD cb);

    __declspec(dllimport) BOOL __stdcall EndUpdateResourceA(HANDLE hUpdate, BOOL fDiscard);
    __declspec(dllimport) BOOL __stdcall EndUpdateResourceW(HANDLE hUpdate, BOOL fDiscard);

    __declspec(dllimport) ATOM __stdcall GlobalAddAtomA(LPCSTR lpString);
    __declspec(dllimport) ATOM __stdcall GlobalAddAtomW(LPCWSTR lpString);

    __declspec(dllimport) ATOM __stdcall GlobalAddAtomExA(LPCSTR lpString, DWORD Flags);
    __declspec(dllimport) ATOM __stdcall GlobalAddAtomExW(LPCWSTR lpString, DWORD Flags);

    __declspec(dllimport) ATOM __stdcall GlobalFindAtomA(LPCSTR lpString);
    __declspec(dllimport) ATOM __stdcall GlobalFindAtomW(LPCWSTR lpString);

    __declspec(dllimport) UINT __stdcall GlobalGetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize);
    __declspec(dllimport) UINT __stdcall GlobalGetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);

    __declspec(dllimport) ATOM __stdcall AddAtomA(LPCSTR lpString);
    __declspec(dllimport) ATOM __stdcall AddAtomW(LPCWSTR lpString);

    __declspec(dllimport) ATOM __stdcall FindAtomA(LPCSTR lpString);
    __declspec(dllimport) ATOM __stdcall FindAtomW(LPCWSTR lpString);

    __declspec(dllimport) UINT __stdcall GetAtomNameA(ATOM nAtom, LPSTR lpBuffer, int nSize);
    __declspec(dllimport) UINT __stdcall GetAtomNameW(ATOM nAtom, LPWSTR lpBuffer, int nSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) UINT __stdcall GetProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault);
    __declspec(dllimport) UINT __stdcall GetProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault);

    __declspec(dllimport) DWORD
    __stdcall GetProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize);
    __declspec(dllimport) DWORD
    __stdcall GetProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall WriteProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString);
    __declspec(dllimport) BOOL __stdcall WriteProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall GetProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize);
    __declspec(dllimport) DWORD __stdcall GetProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall WriteProfileSectionA(LPCSTR lpAppName, LPCSTR lpString);
    __declspec(dllimport) BOOL __stdcall WriteProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) UINT __stdcall GetPrivateProfileIntA(LPCSTR lpAppName, LPCSTR lpKeyName, INT nDefault, LPCSTR lpFileName);
    __declspec(dllimport) UINT
    __stdcall GetPrivateProfileIntW(LPCWSTR lpAppName, LPCWSTR lpKeyName, INT nDefault, LPCWSTR lpFileName);

    __inline UINT GetPrivateProfileInt(LPCTSTR lpAppName, LPCTSTR lpKeyName, INT nDefault, LPCTSTR lpFileName)
    {
        return GetPrivateProfileIntA(lpAppName, lpKeyName, nDefault, lpFileName);
    }

    __declspec(dllimport) DWORD __stdcall GetPrivateProfileStringA(
    LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpDefault, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
    __declspec(dllimport) DWORD __stdcall GetPrivateProfileStringW(
    LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpDefault, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);

    __inline DWORD
    GetPrivateProfileString(LPCTSTR lpAppName, LPCTSTR lpKeyName, LPCTSTR lpDefault, LPTSTR lpReturnedString, DWORD nSize, LPCTSTR lpFileName)
    {
        return GetPrivateProfileStringA(lpAppName, lpKeyName, lpDefault, lpReturnedString, nSize, lpFileName);
    }

    __declspec(dllimport) BOOL
    __stdcall WritePrivateProfileStringA(LPCSTR lpAppName, LPCSTR lpKeyName, LPCSTR lpString, LPCSTR lpFileName);
    __declspec(dllimport) BOOL
    __stdcall WritePrivateProfileStringW(LPCWSTR lpAppName, LPCWSTR lpKeyName, LPCWSTR lpString, LPCWSTR lpFileName);

    __declspec(dllimport) DWORD
    __stdcall GetPrivateProfileSectionA(LPCSTR lpAppName, LPSTR lpReturnedString, DWORD nSize, LPCSTR lpFileName);
    __declspec(dllimport) DWORD
    __stdcall GetPrivateProfileSectionW(LPCWSTR lpAppName, LPWSTR lpReturnedString, DWORD nSize, LPCWSTR lpFileName);

    __inline DWORD GetPrivateProfileSection(LPCTSTR lpAppName, LPTSTR lpReturnedString, DWORD nSize, LPCTSTR lpFileName)
    {
        return GetPrivateProfileSectionA(lpAppName, lpReturnedString, nSize, lpFileName);
    }

    __declspec(dllimport) BOOL __stdcall WritePrivateProfileSectionA(LPCSTR lpAppName, LPCSTR lpString, LPCSTR lpFileName);
    __declspec(dllimport) BOOL __stdcall WritePrivateProfileSectionW(LPCWSTR lpAppName, LPCWSTR lpString, LPCWSTR lpFileName);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) DWORD __stdcall GetPrivateProfileSectionNamesA(LPSTR lpszReturnBuffer, DWORD nSize, LPCSTR lpFileName);
    __declspec(dllimport) DWORD __stdcall GetPrivateProfileSectionNamesW(LPWSTR lpszReturnBuffer, DWORD nSize, LPCWSTR lpFileName);

    __inline DWORD GetPrivateProfileSectionNames(LPTSTR lpszReturnBuffer, DWORD nSize, LPCTSTR lpFileName)
    {
        return GetPrivateProfileSectionNamesA(lpszReturnBuffer, nSize, lpFileName);
    }

    __declspec(dllimport) BOOL
    __stdcall GetPrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile);
    __declspec(dllimport) BOOL
    __stdcall GetPrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);

    __inline BOOL GetPrivateProfileStruct(LPCTSTR lpszSection, LPCTSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCTSTR szFile)
    {
        return GetPrivateProfileStructA(lpszSection, lpszKey, lpStruct, uSizeStruct, szFile);
    }

    __declspec(dllimport) BOOL
    __stdcall WritePrivateProfileStructA(LPCSTR lpszSection, LPCSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCSTR szFile);
    __declspec(dllimport) BOOL
    __stdcall WritePrivateProfileStructW(LPCWSTR lpszSection, LPCWSTR lpszKey, LPVOID lpStruct, UINT uSizeStruct, LPCWSTR szFile);

    __inline UINT GetTempFileName(LPCTSTR lpPathName, LPCTSTR lpPrefixString, UINT uUnique, LPTSTR lpTempFileName)
    {
        return GetTempFileNameA(lpPathName, lpPrefixString, uUnique, lpTempFileName);
    }

    __declspec(dllimport) BOOLEAN __stdcall Wow64EnableWow64FsRedirection(BOOLEAN Wow64FsEnableRedirection);

    typedef UINT(__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_A)(LPSTR lpBuffer, UINT uSize);
    typedef UINT(__stdcall* PGET_SYSTEM_WOW64_DIRECTORY_W)(LPWSTR lpBuffer, UINT uSize);

    __inline BOOL SetCurrentDirectory(LPCTSTR lpPathName)
    {
        return SetCurrentDirectoryA(lpPathName);
    }

    __inline DWORD GetCurrentDirectory(DWORD nBufferLength, LPTSTR lpBuffer)
    {
        return GetCurrentDirectoryA(nBufferLength, lpBuffer);
    }

    __declspec(dllimport) BOOL __stdcall SetDllDirectoryA(LPCSTR lpPathName);
    __declspec(dllimport) BOOL __stdcall SetDllDirectoryW(LPCWSTR lpPathName);

    __declspec(dllimport)

    DWORD __stdcall GetDllDirectoryA(DWORD nBufferLength, LPSTR lpBuffer);
    __declspec(dllimport)

    DWORD __stdcall GetDllDirectoryW(DWORD nBufferLength, LPWSTR lpBuffer);

    __declspec(dllimport) BOOL __stdcall SetSearchPathMode(DWORD Flags);

#pragma endregion

#pragma region Application Family

    __inline BOOL CreateDirectory(LPCTSTR lpPathName, LPSECURITY_ATTRIBUTES lpSecurityAttributes)
    {
        return CreateDirectoryA(lpPathName, lpSecurityAttributes);
    }

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall CreateDirectoryExA(LPCSTR lpTemplateDirectory, LPCSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
    __declspec(dllimport) BOOL
    __stdcall CreateDirectoryExW(LPCWSTR lpTemplateDirectory, LPCWSTR lpNewDirectory, LPSECURITY_ATTRIBUTES lpSecurityAttributes);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall CreateDirectoryTransactedA(LPCSTR lpTemplateDirectory,
                                                                    LPCSTR lpNewDirectory,
                                                                    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                                    HANDLE hTransaction);
    __declspec(dllimport) BOOL __stdcall CreateDirectoryTransactedW(LPCWSTR lpTemplateDirectory,
                                                                    LPCWSTR lpNewDirectory,
                                                                    LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                                    HANDLE hTransaction);

    __declspec(dllimport) BOOL __stdcall RemoveDirectoryTransactedA(LPCSTR lpPathName, HANDLE hTransaction);
    __declspec(dllimport) BOOL __stdcall RemoveDirectoryTransactedW(LPCWSTR lpPathName, HANDLE hTransaction);

    __declspec(dllimport)

    DWORD
    __stdcall GetFullPathNameTransactedA(LPCSTR lpFileName, DWORD nBufferLength, LPSTR lpBuffer, LPSTR* lpFilePart, HANDLE hTransaction);
    __declspec(dllimport)

    DWORD
    __stdcall GetFullPathNameTransactedW(LPCWSTR lpFileName, DWORD nBufferLength, LPWSTR lpBuffer, LPWSTR* lpFilePart, HANDLE hTransaction);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall DefineDosDeviceA(DWORD dwFlags, LPCSTR lpDeviceName, LPCSTR lpTargetPath);

    __declspec(dllimport) DWORD __stdcall QueryDosDeviceA(LPCSTR lpDeviceName, LPSTR lpTargetPath, DWORD ucchMax);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HANDLE __stdcall CreateFileTransactedA(LPCSTR lpFileName,
                                                                 DWORD dwDesiredAccess,
                                                                 DWORD dwShareMode,
                                                                 LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                                 DWORD dwCreationDisposition,
                                                                 DWORD dwFlagsAndAttributes,
                                                                 HANDLE hTemplateFile,
                                                                 HANDLE hTransaction,
                                                                 PUSHORT pusMiniVersion,
                                                                 PVOID lpExtendedParameter);
    __declspec(dllimport) HANDLE __stdcall CreateFileTransactedW(LPCWSTR lpFileName,
                                                                 DWORD dwDesiredAccess,
                                                                 DWORD dwShareMode,
                                                                 LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                                 DWORD dwCreationDisposition,
                                                                 DWORD dwFlagsAndAttributes,
                                                                 HANDLE hTemplateFile,
                                                                 HANDLE hTransaction,
                                                                 PUSHORT pusMiniVersion,
                                                                 PVOID lpExtendedParameter);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) HANDLE
    __stdcall ReOpenFile(HANDLE hOriginalFile, DWORD dwDesiredAccess, DWORD dwShareMode, DWORD dwFlagsAndAttributes);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL
    __stdcall SetFileAttributesTransactedA(LPCSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction);
    __declspec(dllimport) BOOL
    __stdcall SetFileAttributesTransactedW(LPCWSTR lpFileName, DWORD dwFileAttributes, HANDLE hTransaction);

    __declspec(dllimport) BOOL
    __stdcall GetFileAttributesTransactedA(LPCSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction);
    __declspec(dllimport) BOOL
    __stdcall GetFileAttributesTransactedW(LPCWSTR lpFileName, GET_FILEEX_INFO_LEVELS fInfoLevelId, LPVOID lpFileInformation, HANDLE hTransaction);

    __declspec(dllimport) DWORD
    __stdcall GetCompressedFileSizeTransactedA(LPCSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction);
    __declspec(dllimport) DWORD
    __stdcall GetCompressedFileSizeTransactedW(LPCWSTR lpFileName, LPDWORD lpFileSizeHigh, HANDLE hTransaction);

    __declspec(dllimport) BOOL __stdcall DeleteFileTransactedA(LPCSTR lpFileName, HANDLE hTransaction);
    __declspec(dllimport) BOOL __stdcall DeleteFileTransactedW(LPCWSTR lpFileName, HANDLE hTransaction);

#pragma endregion

#pragma region Application Family

    __inline BOOL DeleteFile(LPCTSTR lpFileName)
    {
        return DeleteFileA(lpFileName);
    }

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL
    __stdcall CheckNameLegalDOS8Dot3A(LPCSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal);
    __declspec(dllimport) BOOL
    __stdcall CheckNameLegalDOS8Dot3W(LPCWSTR lpName, LPSTR lpOemName, DWORD OemNameSize, PBOOL pbNameContainsSpaces, PBOOL pbNameLegal);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HANDLE __stdcall FindFirstFileTransactedA(LPCSTR lpFileName,
                                                                    FINDEX_INFO_LEVELS fInfoLevelId,
                                                                    LPVOID lpFindFileData,
                                                                    FINDEX_SEARCH_OPS fSearchOp,
                                                                    LPVOID lpSearchFilter,
                                                                    DWORD dwAdditionalFlags,
                                                                    HANDLE hTransaction);
    __declspec(dllimport) HANDLE __stdcall FindFirstFileTransactedW(LPCWSTR lpFileName,
                                                                    FINDEX_INFO_LEVELS fInfoLevelId,
                                                                    LPVOID lpFindFileData,
                                                                    FINDEX_SEARCH_OPS fSearchOp,
                                                                    LPVOID lpSearchFilter,
                                                                    DWORD dwAdditionalFlags,
                                                                    HANDLE hTransaction);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CopyFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, BOOL bFailIfExists);
    __declspec(dllimport) BOOL __stdcall CopyFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, BOOL bFailIfExists);

    __inline BOOL CopyFile(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName, BOOL bFailIfExists)
    {
        return CopyFileA(lpExistingFileName, lpNewFileName, bFailIfExists);
    }

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef DWORD(__stdcall* LPPROGRESS_ROUTINE)(LARGE_INTEGER TotalFileSize,
                                                 LARGE_INTEGER TotalBytesTransferred,
                                                 LARGE_INTEGER StreamSize,
                                                 LARGE_INTEGER StreamBytesTransferred,
                                                 DWORD dwStreamNumber,
                                                 DWORD dwCallbackReason,
                                                 HANDLE hSourceFile,
                                                 HANDLE hDestinationFile,
                                                 LPVOID lpData);

    __declspec(dllimport) BOOL __stdcall CopyFileExA(LPCSTR lpExistingFileName,
                                                     LPCSTR lpNewFileName,
                                                     LPPROGRESS_ROUTINE lpProgressRoutine,
                                                     LPVOID lpData,

                                                     LPBOOL pbCancel,
                                                     DWORD dwCopyFlags);
    __declspec(dllimport) BOOL __stdcall CopyFileExW(LPCWSTR lpExistingFileName,
                                                     LPCWSTR lpNewFileName,
                                                     LPPROGRESS_ROUTINE lpProgressRoutine,
                                                     LPVOID lpData,

                                                     LPBOOL pbCancel,
                                                     DWORD dwCopyFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall CopyFileTransactedA(LPCSTR lpExistingFileName,
                                                             LPCSTR lpNewFileName,
                                                             LPPROGRESS_ROUTINE lpProgressRoutine,
                                                             LPVOID lpData,
                                                             LPBOOL pbCancel,
                                                             DWORD dwCopyFlags,
                                                             HANDLE hTransaction);
    __declspec(dllimport) BOOL __stdcall CopyFileTransactedW(LPCWSTR lpExistingFileName,
                                                             LPCWSTR lpNewFileName,
                                                             LPPROGRESS_ROUTINE lpProgressRoutine,
                                                             LPVOID lpData,
                                                             LPBOOL pbCancel,
                                                             DWORD dwCopyFlags,
                                                             HANDLE hTransaction);

#pragma endregion

#pragma region Application Family

    typedef enum _COPYFILE2_MESSAGE_TYPE
    {
        COPYFILE2_CALLBACK_NONE = 0,
        COPYFILE2_CALLBACK_CHUNK_STARTED,
        COPYFILE2_CALLBACK_CHUNK_FINISHED,
        COPYFILE2_CALLBACK_STREAM_STARTED,
        COPYFILE2_CALLBACK_STREAM_FINISHED,
        COPYFILE2_CALLBACK_POLL_CONTINUE,
        COPYFILE2_CALLBACK_ERROR,
        COPYFILE2_CALLBACK_MAX,
    } COPYFILE2_MESSAGE_TYPE;

    typedef enum _COPYFILE2_MESSAGE_ACTION
    {
        COPYFILE2_PROGRESS_CONTINUE = 0,
        COPYFILE2_PROGRESS_CANCEL,
        COPYFILE2_PROGRESS_STOP,
        COPYFILE2_PROGRESS_QUIET,
        COPYFILE2_PROGRESS_PAUSE,
    } COPYFILE2_MESSAGE_ACTION;

    typedef enum _COPYFILE2_COPY_PHASE
    {
        COPYFILE2_PHASE_NONE = 0,
        COPYFILE2_PHASE_PREPARE_SOURCE,
        COPYFILE2_PHASE_PREPARE_DEST,
        COPYFILE2_PHASE_READ_SOURCE,
        COPYFILE2_PHASE_WRITE_DESTINATION,
        COPYFILE2_PHASE_SERVER_COPY,
        COPYFILE2_PHASE_NAMEGRAFT_COPY,

        COPYFILE2_PHASE_MAX,
    } COPYFILE2_COPY_PHASE;

    typedef struct COPYFILE2_MESSAGE
    {
        COPYFILE2_MESSAGE_TYPE Type;
        DWORD dwPadding;

        union
        {
            struct
            {
                DWORD dwStreamNumber;
                DWORD dwReserved;
                HANDLE hSourceFile;
                HANDLE hDestinationFile;
                ULARGE_INTEGER uliChunkNumber;
                ULARGE_INTEGER uliChunkSize;
                ULARGE_INTEGER uliStreamSize;
                ULARGE_INTEGER uliTotalFileSize;
            } ChunkStarted;

            struct
            {
                DWORD dwStreamNumber;
                DWORD dwFlags;
                HANDLE hSourceFile;
                HANDLE hDestinationFile;
                ULARGE_INTEGER uliChunkNumber;
                ULARGE_INTEGER uliChunkSize;
                ULARGE_INTEGER uliStreamSize;
                ULARGE_INTEGER uliStreamBytesTransferred;
                ULARGE_INTEGER uliTotalFileSize;
                ULARGE_INTEGER uliTotalBytesTransferred;
            } ChunkFinished;

            struct
            {
                DWORD dwStreamNumber;
                DWORD dwReserved;
                HANDLE hSourceFile;
                HANDLE hDestinationFile;
                ULARGE_INTEGER uliStreamSize;
                ULARGE_INTEGER uliTotalFileSize;
            } StreamStarted;

            struct
            {
                DWORD dwStreamNumber;
                DWORD dwReserved;
                HANDLE hSourceFile;
                HANDLE hDestinationFile;
                ULARGE_INTEGER uliStreamSize;
                ULARGE_INTEGER uliStreamBytesTransferred;
                ULARGE_INTEGER uliTotalFileSize;
                ULARGE_INTEGER uliTotalBytesTransferred;
            } StreamFinished;

            struct
            {
                DWORD dwReserved;
            } PollContinue;

            struct
            {
                COPYFILE2_COPY_PHASE CopyPhase;
                DWORD dwStreamNumber;
                HRESULT hrFailure;
                DWORD dwReserved;
                ULARGE_INTEGER uliChunkNumber;
                ULARGE_INTEGER uliStreamSize;
                ULARGE_INTEGER uliStreamBytesTransferred;
                ULARGE_INTEGER uliTotalFileSize;
                ULARGE_INTEGER uliTotalBytesTransferred;
            } Error;

        } Info;

    } COPYFILE2_MESSAGE;

    typedef COPYFILE2_MESSAGE_ACTION(__stdcall* PCOPYFILE2_PROGRESS_ROUTINE)(const COPYFILE2_MESSAGE* pMessage, PVOID pvCallbackContext);

    typedef struct COPYFILE2_EXTENDED_PARAMETERS
    {
        DWORD dwSize;
        DWORD dwCopyFlags;
        BOOL* pfCancel;
        PCOPYFILE2_PROGRESS_ROUTINE pProgressRoutine;
        PVOID pvCallbackContext;
    } COPYFILE2_EXTENDED_PARAMETERS;

    __declspec(dllimport) HRESULT
    __stdcall CopyFile2(PCWSTR pwszExistingFileName, PCWSTR pwszNewFileName, COPYFILE2_EXTENDED_PARAMETERS* pExtendedParameters);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall MoveFileA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName);
    __declspec(dllimport) BOOL __stdcall MoveFileW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName);

    __inline BOOL MoveFile(LPCTSTR lpExistingFileName, LPCTSTR lpNewFileName)
    {
        return MoveFileA(lpExistingFileName, lpNewFileName);
    }

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall MoveFileExA(LPCSTR lpExistingFileName, LPCSTR lpNewFileName, DWORD dwFlags);
    __declspec(dllimport) BOOL __stdcall MoveFileExW(LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall MoveFileWithProgressA(
    LPCSTR lpExistingFileName, LPCSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);
    __declspec(dllimport) BOOL __stdcall MoveFileWithProgressW(
    LPCWSTR lpExistingFileName, LPCWSTR lpNewFileName, LPPROGRESS_ROUTINE lpProgressRoutine, LPVOID lpData, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall MoveFileTransactedA(LPCSTR lpExistingFileName,
                                                             LPCSTR lpNewFileName,
                                                             LPPROGRESS_ROUTINE lpProgressRoutine,
                                                             LPVOID lpData,
                                                             DWORD dwFlags,
                                                             HANDLE hTransaction);
    __declspec(dllimport) BOOL __stdcall MoveFileTransactedW(LPCWSTR lpExistingFileName,
                                                             LPCWSTR lpNewFileName,
                                                             LPPROGRESS_ROUTINE lpProgressRoutine,
                                                             LPVOID lpData,
                                                             DWORD dwFlags,
                                                             HANDLE hTransaction);

#pragma endregion

#pragma region Application Family

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma region Application Family

    __declspec(dllimport) BOOL __stdcall ReplaceFileA(LPCSTR lpReplacedFileName,
                                                      LPCSTR lpReplacementFileName,
                                                      LPCSTR lpBackupFileName,
                                                      DWORD dwReplaceFlags,
                                                      LPVOID lpExclude,
                                                      LPVOID lpReserved);
    __declspec(dllimport) BOOL __stdcall ReplaceFileW(LPCWSTR lpReplacedFileName,
                                                      LPCWSTR lpReplacementFileName,
                                                      LPCWSTR lpBackupFileName,
                                                      DWORD dwReplaceFlags,
                                                      LPVOID lpExclude,
                                                      LPVOID lpReserved);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall CreateHardLinkA(LPCSTR lpFileName, LPCSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);
    __declspec(dllimport) BOOL
    __stdcall CreateHardLinkW(LPCWSTR lpFileName, LPCWSTR lpExistingFileName, LPSECURITY_ATTRIBUTES lpSecurityAttributes);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall CreateHardLinkTransactedA(LPCSTR lpFileName,
                                                                   LPCSTR lpExistingFileName,
                                                                   LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                                   HANDLE hTransaction);
    __declspec(dllimport) BOOL __stdcall CreateHardLinkTransactedW(LPCWSTR lpFileName,
                                                                   LPCWSTR lpExistingFileName,
                                                                   LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                                   HANDLE hTransaction);

    __declspec(dllimport) HANDLE __stdcall FindFirstStreamTransactedW(
    LPCWSTR lpFileName, STREAM_INFO_LEVELS InfoLevel, LPVOID lpFindStreamData, DWORD dwFlags, HANDLE hTransaction);

    __declspec(dllimport) HANDLE
    __stdcall FindFirstFileNameTransactedW(LPCWSTR lpFileName, DWORD dwFlags, LPDWORD StringLength, PWSTR LinkName, HANDLE hTransaction);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) HANDLE __stdcall CreateNamedPipeA(LPCSTR lpName,
                                                            DWORD dwOpenMode,
                                                            DWORD dwPipeMode,
                                                            DWORD nMaxInstances,
                                                            DWORD nOutBufferSize,
                                                            DWORD nInBufferSize,
                                                            DWORD nDefaultTimeOut,
                                                            LPSECURITY_ATTRIBUTES lpSecurityAttributes);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetNamedPipeHandleStateA(HANDLE hNamedPipe,
                                                                  LPDWORD lpState,
                                                                  LPDWORD lpCurInstances,
                                                                  LPDWORD lpMaxCollectionCount,
                                                                  LPDWORD lpCollectDataTimeout,
                                                                  LPSTR lpUserName,
                                                                  DWORD nMaxUserNameSize);

    __declspec(dllimport) BOOL __stdcall CallNamedPipeA(LPCSTR lpNamedPipeName,
                                                        LPVOID lpInBuffer,
                                                        DWORD nInBufferSize,
                                                        LPVOID lpOutBuffer,
                                                        DWORD nOutBufferSize,
                                                        LPDWORD lpBytesRead,
                                                        DWORD nTimeOut);

    __declspec(dllimport) BOOL __stdcall WaitNamedPipeA(LPCSTR lpNamedPipeName, DWORD nTimeOut);

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetNamedPipeClientComputerNameA(HANDLE Pipe, LPSTR ClientComputerName, ULONG ClientComputerNameLength);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GetNamedPipeClientProcessId(HANDLE Pipe, PULONG ClientProcessId);

    __declspec(dllimport) BOOL __stdcall GetNamedPipeClientSessionId(HANDLE Pipe, PULONG ClientSessionId);

    __declspec(dllimport) BOOL __stdcall GetNamedPipeServerProcessId(HANDLE Pipe, PULONG ServerProcessId);

    __declspec(dllimport) BOOL __stdcall GetNamedPipeServerSessionId(HANDLE Pipe, PULONG ServerSessionId);

#pragma endregion

#pragma region Application Family or Desktop Family

    __declspec(dllimport) BOOL __stdcall SetVolumeLabelA(LPCSTR lpRootPathName, LPCSTR lpVolumeName);
    __declspec(dllimport) BOOL __stdcall SetVolumeLabelW(LPCWSTR lpRootPathName, LPCWSTR lpVolumeName);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall SetFileBandwidthReservation(HANDLE hFile,
                                                                     DWORD nPeriodMilliseconds,
                                                                     DWORD nBytesPerPeriod,
                                                                     BOOL bDiscardable,
                                                                     LPDWORD lpTransferSize,
                                                                     LPDWORD lpNumOutstandingRequests);

    __declspec(dllimport) BOOL __stdcall GetFileBandwidthReservation(HANDLE hFile,
                                                                     LPDWORD lpPeriodMilliseconds,
                                                                     LPDWORD lpBytesPerPeriod,
                                                                     LPBOOL pDiscardable,
                                                                     LPDWORD lpTransferSize,
                                                                     LPDWORD lpNumOutstandingRequests);

    __declspec(dllimport) BOOL __stdcall ClearEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName);
    __declspec(dllimport) BOOL __stdcall ClearEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName);

    __declspec(dllimport) BOOL __stdcall BackupEventLogA(HANDLE hEventLog, LPCSTR lpBackupFileName);
    __declspec(dllimport) BOOL __stdcall BackupEventLogW(HANDLE hEventLog, LPCWSTR lpBackupFileName);

    __declspec(dllimport) BOOL __stdcall CloseEventLog(HANDLE hEventLog);

    __declspec(dllimport) BOOL __stdcall DeregisterEventSource(HANDLE hEventLog);

    __declspec(dllimport) BOOL __stdcall NotifyChangeEventLog(HANDLE hEventLog, HANDLE hEvent);

    __declspec(dllimport) BOOL __stdcall GetNumberOfEventLogRecords(HANDLE hEventLog, PDWORD NumberOfRecords);

    __declspec(dllimport) BOOL __stdcall GetOldestEventLogRecord(HANDLE hEventLog, PDWORD OldestRecord);

    __declspec(dllimport) HANDLE __stdcall OpenEventLogA(LPCSTR lpUNCServerName, LPCSTR lpSourceName);
    __declspec(dllimport) HANDLE __stdcall OpenEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName);

    __declspec(dllimport) HANDLE __stdcall RegisterEventSourceA(LPCSTR lpUNCServerName, LPCSTR lpSourceName);
    __declspec(dllimport) HANDLE __stdcall RegisterEventSourceW(LPCWSTR lpUNCServerName, LPCWSTR lpSourceName);

    __declspec(dllimport) HANDLE __stdcall OpenBackupEventLogA(LPCSTR lpUNCServerName, LPCSTR lpFileName);
    __declspec(dllimport) HANDLE __stdcall OpenBackupEventLogW(LPCWSTR lpUNCServerName, LPCWSTR lpFileName);

    __declspec(dllimport) BOOL __stdcall ReadEventLogA(HANDLE hEventLog,
                                                       DWORD dwReadFlags,
                                                       DWORD dwRecordOffset,
                                                       LPVOID lpBuffer,
                                                       DWORD nNumberOfBytesToRead,
                                                       DWORD* pnBytesRead,
                                                       DWORD* pnMinNumberOfBytesNeeded);
    __declspec(dllimport) BOOL __stdcall ReadEventLogW(HANDLE hEventLog,
                                                       DWORD dwReadFlags,
                                                       DWORD dwRecordOffset,
                                                       LPVOID lpBuffer,
                                                       DWORD nNumberOfBytesToRead,
                                                       DWORD* pnBytesRead,
                                                       DWORD* pnMinNumberOfBytesNeeded);

    __declspec(dllimport) BOOL __stdcall ReportEventA(
    HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCSTR* lpStrings, LPVOID lpRawData);
    __declspec(dllimport) BOOL __stdcall ReportEventW(
    HANDLE hEventLog, WORD wType, WORD wCategory, DWORD dwEventID, PSID lpUserSid, WORD wNumStrings, DWORD dwDataSize, LPCWSTR* lpStrings, LPVOID lpRawData);

    typedef struct _EVENTLOG_FULL_INFORMATION
    {
        DWORD dwFull;
    } EVENTLOG_FULL_INFORMATION, *LPEVENTLOG_FULL_INFORMATION;

    __declspec(dllimport) BOOL
    __stdcall GetEventLogInformation(HANDLE hEventLog, DWORD dwInfoLevel, LPVOID lpBuffer, DWORD cbBufSize, LPDWORD pcbBytesNeeded);

    typedef ULONG OPERATION_ID;

    typedef struct _OPERATION_START_PARAMETERS
    {
        ULONG Version;
        OPERATION_ID OperationId;
        ULONG Flags;
    } OPERATION_START_PARAMETERS, *POPERATION_START_PARAMETERS;

    typedef struct _OPERATION_END_PARAMETERS
    {
        ULONG Version;
        OPERATION_ID OperationId;
        ULONG Flags;
    } OPERATION_END_PARAMETERS, *POPERATION_END_PARAMETERS;

    __declspec(dllimport) BOOL __stdcall OperationStart(OPERATION_START_PARAMETERS* OperationStartParams);

    __declspec(dllimport) BOOL __stdcall OperationEnd(OPERATION_END_PARAMETERS* OperationEndParams);

    __declspec(dllimport) BOOL __stdcall AccessCheckAndAuditAlarmA(LPCSTR SubsystemName,
                                                                   LPVOID HandleId,
                                                                   LPSTR ObjectTypeName,
                                                                   LPSTR ObjectName,
                                                                   PSECURITY_DESCRIPTOR SecurityDescriptor,
                                                                   DWORD DesiredAccess,
                                                                   PGENERIC_MAPPING GenericMapping,
                                                                   BOOL ObjectCreation,
                                                                   LPDWORD GrantedAccess,
                                                                   LPBOOL AccessStatus,
                                                                   LPBOOL pfGenerateOnClose);

    __declspec(dllimport) BOOL __stdcall AccessCheckByTypeAndAuditAlarmA(LPCSTR SubsystemName,
                                                                         LPVOID HandleId,
                                                                         LPCSTR ObjectTypeName,
                                                                         LPCSTR ObjectName,
                                                                         PSECURITY_DESCRIPTOR SecurityDescriptor,
                                                                         PSID PrincipalSelfSid,
                                                                         DWORD DesiredAccess,
                                                                         AUDIT_EVENT_TYPE AuditType,
                                                                         DWORD Flags,
                                                                         POBJECT_TYPE_LIST ObjectTypeList,
                                                                         DWORD ObjectTypeListLength,
                                                                         PGENERIC_MAPPING GenericMapping,
                                                                         BOOL ObjectCreation,
                                                                         LPDWORD GrantedAccess,
                                                                         LPBOOL AccessStatus,
                                                                         LPBOOL pfGenerateOnClose);

    __declspec(dllimport) BOOL __stdcall AccessCheckByTypeResultListAndAuditAlarmA(LPCSTR SubsystemName,
                                                                                   LPVOID HandleId,
                                                                                   LPCSTR ObjectTypeName,
                                                                                   LPCSTR ObjectName,
                                                                                   PSECURITY_DESCRIPTOR SecurityDescriptor,
                                                                                   PSID PrincipalSelfSid,
                                                                                   DWORD DesiredAccess,
                                                                                   AUDIT_EVENT_TYPE AuditType,
                                                                                   DWORD Flags,
                                                                                   POBJECT_TYPE_LIST ObjectTypeList,
                                                                                   DWORD ObjectTypeListLength,
                                                                                   PGENERIC_MAPPING GenericMapping,
                                                                                   BOOL ObjectCreation,
                                                                                   LPDWORD GrantedAccess,
                                                                                   LPDWORD AccessStatusList,
                                                                                   LPBOOL pfGenerateOnClose);

    __declspec(dllimport) BOOL __stdcall AccessCheckByTypeResultListAndAuditAlarmByHandleA(LPCSTR SubsystemName,
                                                                                           LPVOID HandleId,
                                                                                           HANDLE ClientToken,
                                                                                           LPCSTR ObjectTypeName,
                                                                                           LPCSTR ObjectName,
                                                                                           PSECURITY_DESCRIPTOR SecurityDescriptor,
                                                                                           PSID PrincipalSelfSid,
                                                                                           DWORD DesiredAccess,
                                                                                           AUDIT_EVENT_TYPE AuditType,
                                                                                           DWORD Flags,
                                                                                           POBJECT_TYPE_LIST ObjectTypeList,
                                                                                           DWORD ObjectTypeListLength,
                                                                                           PGENERIC_MAPPING GenericMapping,
                                                                                           BOOL ObjectCreation,
                                                                                           LPDWORD GrantedAccess,
                                                                                           LPDWORD AccessStatusList,
                                                                                           LPBOOL pfGenerateOnClose);

    __declspec(dllimport) BOOL __stdcall ObjectOpenAuditAlarmA(LPCSTR SubsystemName,
                                                               LPVOID HandleId,
                                                               LPSTR ObjectTypeName,
                                                               LPSTR ObjectName,
                                                               PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                               HANDLE ClientToken,
                                                               DWORD DesiredAccess,
                                                               DWORD GrantedAccess,
                                                               PPRIVILEGE_SET Privileges,
                                                               BOOL ObjectCreation,
                                                               BOOL AccessGranted,
                                                               LPBOOL GenerateOnClose);

    __declspec(dllimport) BOOL __stdcall ObjectPrivilegeAuditAlarmA(
    LPCSTR SubsystemName, LPVOID HandleId, HANDLE ClientToken, DWORD DesiredAccess, PPRIVILEGE_SET Privileges, BOOL AccessGranted);

    __declspec(dllimport) BOOL __stdcall ObjectCloseAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose);

    __declspec(dllimport) BOOL __stdcall ObjectDeleteAuditAlarmA(LPCSTR SubsystemName, LPVOID HandleId, BOOL GenerateOnClose);

    __declspec(dllimport) BOOL __stdcall PrivilegedServiceAuditAlarmA(
    LPCSTR SubsystemName, LPCSTR ServiceName, HANDLE ClientToken, PPRIVILEGE_SET Privileges, BOOL AccessGranted);

    __declspec(dllimport) BOOL __stdcall AddConditionalAce(
    PACL pAcl, DWORD dwAceRevision, DWORD AceFlags, UCHAR AceType, DWORD AccessMask, PSID pSid, PWCHAR ConditionStr, DWORD* ReturnLength);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall SetFileSecurityA(LPCSTR lpFileName, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);

    __declspec(dllimport) BOOL __stdcall GetFileSecurityA(LPCSTR lpFileName,
                                                          SECURITY_INFORMATION RequestedInformation,
                                                          PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                          DWORD nLength,
                                                          LPDWORD lpnLengthNeeded);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall ReadDirectoryChangesW(HANDLE hDirectory,
                                                               LPVOID lpBuffer,
                                                               DWORD nBufferLength,
                                                               BOOL bWatchSubtree,
                                                               DWORD dwNotifyFilter,
                                                               LPDWORD lpBytesReturned,
                                                               LPOVERLAPPED lpOverlapped,
                                                               LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine);

    __declspec(dllimport) BOOL
    __stdcall ReadDirectoryChangesExW(HANDLE hDirectory,
                                      LPVOID lpBuffer,
                                      DWORD nBufferLength,
                                      BOOL bWatchSubtree,
                                      DWORD dwNotifyFilter,
                                      LPDWORD lpBytesReturned,
                                      LPOVERLAPPED lpOverlapped,
                                      LPOVERLAPPED_COMPLETION_ROUTINE lpCompletionRoutine,
                                      READ_DIRECTORY_NOTIFY_INFORMATION_CLASS ReadDirectoryNotifyInformationClass);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport)

    LPVOID __stdcall MapViewOfFileExNuma(HANDLE hFileMappingObject,
                                         DWORD dwDesiredAccess,
                                         DWORD dwFileOffsetHigh,
                                         DWORD dwFileOffsetLow,
                                         SIZE_T dwNumberOfBytesToMap,
                                         LPVOID lpBaseAddress,
                                         DWORD nndPreferred);

    __declspec(dllimport) BOOL __stdcall IsBadReadPtr(const void* lp, UINT_PTR ucb);

    __declspec(dllimport) BOOL __stdcall IsBadWritePtr(LPVOID lp, UINT_PTR ucb);

    __declspec(dllimport) BOOL __stdcall IsBadHugeReadPtr(const void* lp, UINT_PTR ucb);

    __declspec(dllimport) BOOL __stdcall IsBadHugeWritePtr(LPVOID lp, UINT_PTR ucb);

    __declspec(dllimport) BOOL __stdcall IsBadCodePtr(FARPROC lpfn);

    __declspec(dllimport) BOOL __stdcall IsBadStringPtrA(LPCSTR lpsz, UINT_PTR ucchMax);
    __declspec(dllimport) BOOL __stdcall IsBadStringPtrW(LPCWSTR lpsz, UINT_PTR ucchMax);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall LookupAccountSidA(
    LPCSTR lpSystemName, PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
    __declspec(dllimport) BOOL __stdcall LookupAccountSidW(LPCWSTR lpSystemName,
                                                           PSID Sid,
                                                           LPWSTR Name,
                                                           LPDWORD cchName,
                                                           LPWSTR ReferencedDomainName,
                                                           LPDWORD cchReferencedDomainName,
                                                           PSID_NAME_USE peUse);

    __declspec(dllimport) BOOL __stdcall LookupAccountNameA(LPCSTR lpSystemName,
                                                            LPCSTR lpAccountName,
                                                            PSID Sid,
                                                            LPDWORD cbSid,
                                                            LPSTR ReferencedDomainName,
                                                            LPDWORD cchReferencedDomainName,
                                                            PSID_NAME_USE peUse);
    __declspec(dllimport) BOOL __stdcall LookupAccountNameW(LPCWSTR lpSystemName,
                                                            LPCWSTR lpAccountName,
                                                            PSID Sid,
                                                            LPDWORD cbSid,
                                                            LPWSTR ReferencedDomainName,
                                                            LPDWORD cchReferencedDomainName,
                                                            PSID_NAME_USE peUse);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall LookupAccountNameLocalA(
    LPCSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
    __declspec(dllimport) BOOL __stdcall LookupAccountNameLocalW(
    LPCWSTR lpAccountName, PSID Sid, LPDWORD cbSid, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);

    __declspec(dllimport) BOOL __stdcall LookupAccountSidLocalA(
    PSID Sid, LPSTR Name, LPDWORD cchName, LPSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);
    __declspec(dllimport) BOOL __stdcall LookupAccountSidLocalW(
    PSID Sid, LPWSTR Name, LPDWORD cchName, LPWSTR ReferencedDomainName, LPDWORD cchReferencedDomainName, PSID_NAME_USE peUse);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall LookupPrivilegeValueA(LPCSTR lpSystemName, LPCSTR lpName, PLUID lpLuid);
    __declspec(dllimport) BOOL __stdcall LookupPrivilegeValueW(LPCWSTR lpSystemName, LPCWSTR lpName, PLUID lpLuid);

    __declspec(dllimport) BOOL __stdcall LookupPrivilegeNameA(LPCSTR lpSystemName, PLUID lpLuid, LPSTR lpName, LPDWORD cchName);
    __declspec(dllimport) BOOL __stdcall LookupPrivilegeNameW(LPCWSTR lpSystemName, PLUID lpLuid, LPWSTR lpName, LPDWORD cchName);

    __declspec(dllimport) BOOL
    __stdcall LookupPrivilegeDisplayNameA(LPCSTR lpSystemName, LPCSTR lpName, LPSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId);
    __declspec(dllimport) BOOL
    __stdcall LookupPrivilegeDisplayNameW(LPCWSTR lpSystemName, LPCWSTR lpName, LPWSTR lpDisplayName, LPDWORD cchDisplayName, LPDWORD lpLanguageId);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall BuildCommDCBA(LPCSTR lpDef, LPDCB lpDCB);
    __declspec(dllimport) BOOL __stdcall BuildCommDCBW(LPCWSTR lpDef, LPDCB lpDCB);

    __declspec(dllimport) BOOL __stdcall BuildCommDCBAndTimeoutsA(LPCSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts);
    __declspec(dllimport) BOOL __stdcall BuildCommDCBAndTimeoutsW(LPCWSTR lpDef, LPDCB lpDCB, LPCOMMTIMEOUTS lpCommTimeouts);

    __declspec(dllimport) BOOL __stdcall CommConfigDialogA(LPCSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC);
    __declspec(dllimport) BOOL __stdcall CommConfigDialogW(LPCWSTR lpszName, HWND hWnd, LPCOMMCONFIG lpCC);

    __declspec(dllimport) BOOL __stdcall GetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);
    __declspec(dllimport) BOOL __stdcall GetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, LPDWORD lpdwSize);

    __declspec(dllimport) BOOL __stdcall SetDefaultCommConfigA(LPCSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize);
    __declspec(dllimport) BOOL __stdcall SetDefaultCommConfigW(LPCWSTR lpszName, LPCOMMCONFIG lpCC, DWORD dwSize);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall GetComputerNameA(LPSTR lpBuffer, LPDWORD nSize);
    __declspec(dllimport)

    BOOL __stdcall GetComputerNameW(LPWSTR lpBuffer, LPDWORD nSize);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport)

    BOOL __stdcall DnsHostnameToComputerNameA(LPCSTR Hostname, LPSTR ComputerName, LPDWORD nSize);
    __declspec(dllimport)

    BOOL __stdcall DnsHostnameToComputerNameW(LPCWSTR Hostname, LPWSTR ComputerName, LPDWORD nSize);

    __declspec(dllimport) BOOL __stdcall GetUserNameA(LPSTR lpBuffer, LPDWORD pcbBuffer);
    __declspec(dllimport) BOOL __stdcall GetUserNameW(LPWSTR lpBuffer, LPDWORD pcbBuffer);

    __declspec(dllimport) BOOL
    __stdcall LogonUserA(LPCSTR lpszUsername, LPCSTR lpszDomain, LPCSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken);
    __declspec(dllimport) BOOL
    __stdcall LogonUserW(LPCWSTR lpszUsername, LPCWSTR lpszDomain, LPCWSTR lpszPassword, DWORD dwLogonType, DWORD dwLogonProvider, PHANDLE phToken);

    __declspec(dllimport) BOOL __stdcall LogonUserExA(LPCSTR lpszUsername,
                                                      LPCSTR lpszDomain,
                                                      LPCSTR lpszPassword,
                                                      DWORD dwLogonType,
                                                      DWORD dwLogonProvider,
                                                      PHANDLE phToken,
                                                      PSID* ppLogonSid,
                                                      PVOID* ppProfileBuffer,
                                                      LPDWORD pdwProfileLength,
                                                      PQUOTA_LIMITS pQuotaLimits);
    __declspec(dllimport) BOOL __stdcall LogonUserExW(LPCWSTR lpszUsername,
                                                      LPCWSTR lpszDomain,
                                                      LPCWSTR lpszPassword,
                                                      DWORD dwLogonType,
                                                      DWORD dwLogonProvider,
                                                      PHANDLE phToken,
                                                      PSID* ppLogonSid,
                                                      PVOID* ppProfileBuffer,
                                                      LPDWORD pdwProfileLength,
                                                      PQUOTA_LIMITS pQuotaLimits);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall CreateProcessWithLogonW(LPCWSTR lpUsername,
                                                                 LPCWSTR lpDomain,
                                                                 LPCWSTR lpPassword,
                                                                 DWORD dwLogonFlags,
                                                                 LPCWSTR lpApplicationName,
                                                                 LPWSTR lpCommandLine,
                                                                 DWORD dwCreationFlags,
                                                                 LPVOID lpEnvironment,
                                                                 LPCWSTR lpCurrentDirectory,
                                                                 LPSTARTUPINFOW lpStartupInfo,
                                                                 LPPROCESS_INFORMATION lpProcessInformation);

    __declspec(dllimport) BOOL __stdcall CreateProcessWithTokenW(HANDLE hToken,
                                                                 DWORD dwLogonFlags,
                                                                 LPCWSTR lpApplicationName,
                                                                 LPWSTR lpCommandLine,
                                                                 DWORD dwCreationFlags,
                                                                 LPVOID lpEnvironment,
                                                                 LPCWSTR lpCurrentDirectory,
                                                                 LPSTARTUPINFOW lpStartupInfo,
                                                                 LPPROCESS_INFORMATION lpProcessInformation);

    __declspec(dllimport) BOOL __stdcall IsTokenUntrusted(HANDLE TokenHandle);

    __declspec(dllimport) BOOL __stdcall RegisterWaitForSingleObject(
    PHANDLE phNewWaitObject, HANDLE hObject, WAITORTIMERCALLBACK Callback, PVOID Context, ULONG dwMilliseconds, ULONG dwFlags);

    __declspec(dllimport)

    BOOL __stdcall UnregisterWait(HANDLE WaitHandle);

    __declspec(dllimport) BOOL
    __stdcall BindIoCompletionCallback(HANDLE FileHandle, LPOVERLAPPED_COMPLETION_ROUTINE Function, ULONG Flags);

    __declspec(dllimport) HANDLE
    __stdcall SetTimerQueueTimer(HANDLE TimerQueue, WAITORTIMERCALLBACK Callback, PVOID Parameter, DWORD DueTime, DWORD Period, BOOL PreferIo);

    __declspec(dllimport)

    BOOL __stdcall CancelTimerQueueTimer(HANDLE TimerQueue, HANDLE Timer);

    __declspec(dllimport)

    BOOL __stdcall DeleteTimerQueue(HANDLE TimerQueue);

    __forceinline void InitializeThreadpoolEnvironment(PTP_CALLBACK_ENVIRON pcbe)
    {
        TpInitializeCallbackEnviron(pcbe);
    }

    __forceinline void SetThreadpoolCallbackPool(PTP_CALLBACK_ENVIRON pcbe, PTP_POOL ptpp)
    {
        TpSetCallbackThreadpool(pcbe, ptpp);
    }

    __forceinline void
    SetThreadpoolCallbackCleanupGroup(PTP_CALLBACK_ENVIRON pcbe, PTP_CLEANUP_GROUP ptpcg, PTP_CLEANUP_GROUP_CANCEL_CALLBACK pfng)
    {
        TpSetCallbackCleanupGroup(pcbe, ptpcg, pfng);
    }

    __forceinline void SetThreadpoolCallbackRunsLong(PTP_CALLBACK_ENVIRON pcbe)
    {
        TpSetCallbackLongFunction(pcbe);
    }

    __forceinline void SetThreadpoolCallbackLibrary(PTP_CALLBACK_ENVIRON pcbe, PVOID mod)
    {
        TpSetCallbackRaceWithDll(pcbe, mod);
    }

    __forceinline void SetThreadpoolCallbackPriority(PTP_CALLBACK_ENVIRON pcbe, TP_CALLBACK_PRIORITY Priority)
    {
        TpSetCallbackPriority(pcbe, Priority);
    }

    __forceinline void DestroyThreadpoolEnvironment(PTP_CALLBACK_ENVIRON pcbe)
    {
        TpDestroyCallbackEnviron(pcbe);
    }

#pragma region Desktop Family

    __forceinline void SetThreadpoolCallbackPersistent(PTP_CALLBACK_ENVIRON pcbe)
    {
        TpSetCallbackPersistent(pcbe);
    }

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    HANDLE
    __stdcall CreatePrivateNamespaceA(LPSECURITY_ATTRIBUTES lpPrivateNamespaceAttributes, LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix);

    __declspec(dllimport)

    HANDLE __stdcall OpenPrivateNamespaceA(LPVOID lpBoundaryDescriptor, LPCSTR lpAliasPrefix);

    __declspec(dllimport)

    HANDLE __stdcall CreateBoundaryDescriptorA(LPCSTR Name, ULONG Flags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall AddIntegrityLabelToBoundaryDescriptor(HANDLE* BoundaryDescriptor, PSID IntegrityLabel);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagHW_PROFILE_INFOA
    {
        DWORD dwDockInfo;
        CHAR szHwProfileGuid[39];
        CHAR szHwProfileName[80];
    } HW_PROFILE_INFOA, *LPHW_PROFILE_INFOA;
    typedef struct tagHW_PROFILE_INFOW
    {
        DWORD dwDockInfo;
        WCHAR szHwProfileGuid[39];
        WCHAR szHwProfileName[80];
    } HW_PROFILE_INFOW, *LPHW_PROFILE_INFOW;

    typedef HW_PROFILE_INFOA HW_PROFILE_INFO;
    typedef LPHW_PROFILE_INFOA LPHW_PROFILE_INFO;

    __declspec(dllimport) BOOL __stdcall GetCurrentHwProfileA(LPHW_PROFILE_INFOA lpHwProfileInfo);
    __declspec(dllimport) BOOL __stdcall GetCurrentHwProfileW(LPHW_PROFILE_INFOW lpHwProfileInfo);

    __declspec(dllimport) BOOL
    __stdcall VerifyVersionInfoA(LPOSVERSIONINFOEXA lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);
    __declspec(dllimport) BOOL
    __stdcall VerifyVersionInfoW(LPOSVERSIONINFOEXW lpVersionInformation, DWORD dwTypeMask, DWORDLONG dwlConditionMask);

#pragma endregion

#pragma once

    constexpr __forceinline HRESULT HRESULT_FROM_WIN32(unsigned long x)
    {
        return (HRESULT)(x) <= 0 ? (HRESULT)(x) : (HRESULT)(((x)&0x0000FFFF) | (7 << 16) | 0x80000000);
    }

#pragma once

    extern "C"
    {
#pragma region Application Family or OneCore Family

        typedef struct _TIME_ZONE_INFORMATION
        {
            LONG Bias;
            WCHAR StandardName[32];
            SYSTEMTIME StandardDate;
            LONG StandardBias;
            WCHAR DaylightName[32];
            SYSTEMTIME DaylightDate;
            LONG DaylightBias;
        } TIME_ZONE_INFORMATION, *PTIME_ZONE_INFORMATION, *LPTIME_ZONE_INFORMATION;

        typedef struct _TIME_DYNAMIC_ZONE_INFORMATION
        {
            LONG Bias;
            WCHAR StandardName[32];
            SYSTEMTIME StandardDate;
            LONG StandardBias;
            WCHAR DaylightName[32];
            SYSTEMTIME DaylightDate;
            LONG DaylightBias;
            WCHAR TimeZoneKeyName[128];
            BOOLEAN DynamicDaylightTimeDisabled;
        } DYNAMIC_TIME_ZONE_INFORMATION, *PDYNAMIC_TIME_ZONE_INFORMATION;

        __declspec(dllimport)

        BOOL __stdcall SystemTimeToTzSpecificLocalTime(const TIME_ZONE_INFORMATION* lpTimeZoneInformation,
                                                       const SYSTEMTIME* lpUniversalTime,
                                                       LPSYSTEMTIME lpLocalTime);

        __declspec(dllimport)

        BOOL __stdcall TzSpecificLocalTimeToSystemTime(const TIME_ZONE_INFORMATION* lpTimeZoneInformation,
                                                       const SYSTEMTIME* lpLocalTime,
                                                       LPSYSTEMTIME lpUniversalTime);

        __declspec(dllimport)

        BOOL __stdcall FileTimeToSystemTime(const FILETIME* lpFileTime, LPSYSTEMTIME lpSystemTime);

        __declspec(dllimport)

        BOOL __stdcall SystemTimeToFileTime(const SYSTEMTIME* lpSystemTime, LPFILETIME lpFileTime);

        __declspec(dllimport)

        DWORD __stdcall GetTimeZoneInformation(LPTIME_ZONE_INFORMATION lpTimeZoneInformation);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport) BOOL __stdcall SetTimeZoneInformation(const TIME_ZONE_INFORMATION* lpTimeZoneInformation);

        __declspec(dllimport) BOOL
        __stdcall SetDynamicTimeZoneInformation(const DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        DWORD __stdcall GetDynamicTimeZoneInformation(PDYNAMIC_TIME_ZONE_INFORMATION pTimeZoneInformation);

        BOOL __stdcall GetTimeZoneInformationForYear(USHORT wYear, PDYNAMIC_TIME_ZONE_INFORMATION pdtzi, LPTIME_ZONE_INFORMATION ptzi);

        __declspec(dllimport)

        DWORD __stdcall EnumDynamicTimeZoneInformation(const DWORD dwIndex, PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation);

        __declspec(dllimport)

        DWORD __stdcall GetDynamicTimeZoneInformationEffectiveYears(const PDYNAMIC_TIME_ZONE_INFORMATION lpTimeZoneInformation,
                                                                    LPDWORD FirstYear,
                                                                    LPDWORD LastYear);

        __declspec(dllimport)

        BOOL __stdcall SystemTimeToTzSpecificLocalTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation,
                                                         const SYSTEMTIME* lpUniversalTime,
                                                         LPSYSTEMTIME lpLocalTime);

        __declspec(dllimport)

        BOOL __stdcall TzSpecificLocalTimeToSystemTimeEx(const DYNAMIC_TIME_ZONE_INFORMATION* lpTimeZoneInformation,
                                                         const SYSTEMTIME* lpLocalTime,
                                                         LPSYSTEMTIME lpUniversalTime);

        __declspec(dllimport)

        BOOL __stdcall LocalFileTimeToLocalSystemTime(const TIME_ZONE_INFORMATION* timeZoneInformation,
                                                      const FILETIME* localFileTime,
                                                      SYSTEMTIME* localSystemTime);

        __declspec(dllimport)

        BOOL __stdcall LocalSystemTimeToLocalFileTime(const TIME_ZONE_INFORMATION* timeZoneInformation,
                                                      const SYSTEMTIME* localSystemTime,
                                                      FILETIME* localFileTime);

#pragma endregion
    }

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall SetSystemPowerState(BOOL fSuspend, BOOL fForce);

#pragma endregion

#pragma region Desktop or PC Family

    typedef struct _SYSTEM_POWER_STATUS
    {
        BYTE ACLineStatus;
        BYTE BatteryFlag;
        BYTE BatteryLifePercent;
        BYTE SystemStatusFlag;
        DWORD BatteryLifeTime;
        DWORD BatteryFullLifeTime;
    } SYSTEM_POWER_STATUS, *LPSYSTEM_POWER_STATUS;

    __declspec(dllimport) BOOL __stdcall GetSystemPowerStatus(LPSYSTEM_POWER_STATUS lpSystemPowerStatus);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL
    __stdcall MapUserPhysicalPagesScatter(PVOID* VirtualAddresses, ULONG_PTR NumberOfPages, PULONG_PTR PageArray);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport)

    HANDLE __stdcall CreateJobObjectA(LPSECURITY_ATTRIBUTES lpJobAttributes, LPCSTR lpName);

    __declspec(dllimport)

    HANDLE __stdcall OpenJobObjectA(DWORD dwDesiredAccess, BOOL bInheritHandle, LPCSTR lpName);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall CreateJobSet(ULONG NumJob, PJOB_SET_ARRAY UserJobSet, ULONG Flags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) HANDLE __stdcall FindFirstVolumeA(LPSTR lpszVolumeName, DWORD cchBufferLength);

    __declspec(dllimport) BOOL __stdcall FindNextVolumeA(HANDLE hFindVolume, LPSTR lpszVolumeName, DWORD cchBufferLength);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HANDLE
    __stdcall FindFirstVolumeMountPointA(LPCSTR lpszRootPathName, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength);
    __declspec(dllimport) HANDLE
    __stdcall FindFirstVolumeMountPointW(LPCWSTR lpszRootPathName, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength);

    __declspec(dllimport) BOOL
    __stdcall FindNextVolumeMountPointA(HANDLE hFindVolumeMountPoint, LPSTR lpszVolumeMountPoint, DWORD cchBufferLength);
    __declspec(dllimport) BOOL
    __stdcall FindNextVolumeMountPointW(HANDLE hFindVolumeMountPoint, LPWSTR lpszVolumeMountPoint, DWORD cchBufferLength);

    __declspec(dllimport) BOOL __stdcall FindVolumeMountPointClose(HANDLE hFindVolumeMountPoint);

    __declspec(dllimport) BOOL __stdcall SetVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPCSTR lpszVolumeName);
    __declspec(dllimport) BOOL __stdcall SetVolumeMountPointW(LPCWSTR lpszVolumeMountPoint, LPCWSTR lpszVolumeName);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall DeleteVolumeMountPointA(LPCSTR lpszVolumeMountPoint);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetVolumeNameForVolumeMountPointA(LPCSTR lpszVolumeMountPoint, LPSTR lpszVolumeName, DWORD cchBufferLength);

    __declspec(dllimport) BOOL __stdcall GetVolumePathNameA(LPCSTR lpszFileName, LPSTR lpszVolumePathName, DWORD cchBufferLength);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetVolumePathNamesForVolumeNameA(LPCSTR lpszVolumeName, LPCH lpszVolumePathNames, DWORD cchBufferLength, PDWORD lpcchReturnLength);

    typedef struct tagACTCTXA
    {
        ULONG cbSize;
        DWORD dwFlags;
        LPCSTR lpSource;
        USHORT wProcessorArchitecture;
        LANGID wLangId;
        LPCSTR lpAssemblyDirectory;
        LPCSTR lpResourceName;
        LPCSTR lpApplicationName;
        HMODULE hModule;
    } ACTCTXA, *PACTCTXA;
    typedef struct tagACTCTXW
    {
        ULONG cbSize;
        DWORD dwFlags;
        LPCWSTR lpSource;
        USHORT wProcessorArchitecture;
        LANGID wLangId;
        LPCWSTR lpAssemblyDirectory;
        LPCWSTR lpResourceName;
        LPCWSTR lpApplicationName;
        HMODULE hModule;
    } ACTCTXW, *PACTCTXW;

    typedef ACTCTXA ACTCTX;
    typedef PACTCTXA PACTCTX;

    typedef const ACTCTXA* PCACTCTXA;
    typedef const ACTCTXW* PCACTCTXW;

    typedef PCACTCTXA PCACTCTX;

    __declspec(dllimport) HANDLE __stdcall CreateActCtxA(PCACTCTXA pActCtx);
    __declspec(dllimport) HANDLE __stdcall CreateActCtxW(PCACTCTXW pActCtx);

    __declspec(dllimport) void __stdcall AddRefActCtx(HANDLE hActCtx);

    __declspec(dllimport) void __stdcall ReleaseActCtx(HANDLE hActCtx);

    __declspec(dllimport) BOOL __stdcall ZombifyActCtx(HANDLE hActCtx);

    __declspec(dllimport) BOOL __stdcall ActivateActCtx(HANDLE hActCtx, ULONG_PTR* lpCookie);

    __declspec(dllimport) BOOL __stdcall DeactivateActCtx(DWORD dwFlags, ULONG_PTR ulCookie);

    __declspec(dllimport) BOOL __stdcall GetCurrentActCtx(HANDLE* lphActCtx);

    typedef struct tagACTCTX_SECTION_KEYED_DATA_2600
    {
        ULONG cbSize;
        ULONG ulDataFormatVersion;
        PVOID lpData;
        ULONG ulLength;
        PVOID lpSectionGlobalData;
        ULONG ulSectionGlobalDataLength;
        PVOID lpSectionBase;
        ULONG ulSectionTotalLength;
        HANDLE hActCtx;
        ULONG ulAssemblyRosterIndex;
    } ACTCTX_SECTION_KEYED_DATA_2600, *PACTCTX_SECTION_KEYED_DATA_2600;
    typedef const ACTCTX_SECTION_KEYED_DATA_2600* PCACTCTX_SECTION_KEYED_DATA_2600;

    typedef struct tagACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA
    {
        PVOID lpInformation;
        PVOID lpSectionBase;
        ULONG ulSectionLength;
        PVOID lpSectionGlobalDataBase;
        ULONG ulSectionGlobalDataLength;
    } ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA, *PACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;
    typedef const ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA* PCACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA;

    typedef struct tagACTCTX_SECTION_KEYED_DATA
    {
        ULONG cbSize;
        ULONG ulDataFormatVersion;
        PVOID lpData;
        ULONG ulLength;
        PVOID lpSectionGlobalData;
        ULONG ulSectionGlobalDataLength;
        PVOID lpSectionBase;
        ULONG ulSectionTotalLength;
        HANDLE hActCtx;
        ULONG ulAssemblyRosterIndex;

        ULONG ulFlags;
        ACTCTX_SECTION_KEYED_DATA_ASSEMBLY_METADATA AssemblyMetadata;
    } ACTCTX_SECTION_KEYED_DATA, *PACTCTX_SECTION_KEYED_DATA;
    typedef const ACTCTX_SECTION_KEYED_DATA* PCACTCTX_SECTION_KEYED_DATA;

    __declspec(dllimport) BOOL __stdcall FindActCtxSectionStringA(DWORD dwFlags,
                                                                  const GUID* lpExtensionGuid,
                                                                  ULONG ulSectionId,
                                                                  LPCSTR lpStringToFind,
                                                                  PACTCTX_SECTION_KEYED_DATA ReturnedData);

    __declspec(dllimport) BOOL __stdcall FindActCtxSectionStringW(DWORD dwFlags,
                                                                  const GUID* lpExtensionGuid,
                                                                  ULONG ulSectionId,
                                                                  LPCWSTR lpStringToFind,
                                                                  PACTCTX_SECTION_KEYED_DATA ReturnedData);

    __declspec(dllimport) BOOL __stdcall FindActCtxSectionGuid(DWORD dwFlags,
                                                               const GUID* lpExtensionGuid,
                                                               ULONG ulSectionId,
                                                               const GUID* lpGuidToFind,
                                                               PACTCTX_SECTION_KEYED_DATA ReturnedData);

    typedef struct _ACTIVATION_CONTEXT_BASIC_INFORMATION
    {
        HANDLE hActCtx;
        DWORD dwFlags;
    } ACTIVATION_CONTEXT_BASIC_INFORMATION, *PACTIVATION_CONTEXT_BASIC_INFORMATION;

    typedef const struct _ACTIVATION_CONTEXT_BASIC_INFORMATION* PCACTIVATION_CONTEXT_BASIC_INFORMATION;

    __declspec(dllimport) BOOL __stdcall QueryActCtxW(
    DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T* pcbWrittenOrRequired);

    typedef BOOL(__stdcall* PQUERYACTCTXW_FUNC)(
    DWORD dwFlags, HANDLE hActCtx, PVOID pvSubInstance, ULONG ulInfoClass, PVOID pvBuffer, SIZE_T cbBuffer, SIZE_T* pcbWrittenOrRequired);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) DWORD __stdcall WTSGetActiveConsoleSessionId(void);

    __declspec(dllimport) DWORD __stdcall WTSGetServiceSessionId(void);

    __declspec(dllimport) BOOLEAN __stdcall WTSIsServerContainer(void);

    __declspec(dllimport) WORD __stdcall GetActiveProcessorGroupCount(void);

    __declspec(dllimport) WORD __stdcall GetMaximumProcessorGroupCount(void);

    __declspec(dllimport) DWORD __stdcall GetActiveProcessorCount(WORD GroupNumber);

    __declspec(dllimport) DWORD __stdcall GetMaximumProcessorCount(WORD GroupNumber);

    __declspec(dllimport) BOOL __stdcall GetNumaProcessorNode(UCHAR Processor, PUCHAR NodeNumber);

    __declspec(dllimport) BOOL __stdcall GetNumaNodeNumberFromHandle(HANDLE hFile, PUSHORT NodeNumber);

    __declspec(dllimport) BOOL __stdcall GetNumaProcessorNodeEx(PPROCESSOR_NUMBER Processor, PUSHORT NodeNumber);

    __declspec(dllimport) BOOL __stdcall GetNumaNodeProcessorMask(UCHAR Node, PULONGLONG ProcessorMask);

    __declspec(dllimport) BOOL __stdcall GetNumaAvailableMemoryNode(UCHAR Node, PULONGLONG AvailableBytes);

    __declspec(dllimport) BOOL __stdcall GetNumaAvailableMemoryNodeEx(USHORT Node, PULONGLONG AvailableBytes);

    __declspec(dllimport) BOOL __stdcall GetNumaProximityNode(ULONG ProximityId, PUCHAR NodeNumber);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef DWORD(__stdcall* APPLICATION_RECOVERY_CALLBACK)(PVOID pvParameter);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HRESULT __stdcall RegisterApplicationRecoveryCallback(APPLICATION_RECOVERY_CALLBACK pRecoveyCallback,
                                                                                PVOID pvParameter,
                                                                                DWORD dwPingInterval,
                                                                                DWORD dwFlags);

    __declspec(dllimport) HRESULT __stdcall UnregisterApplicationRecoveryCallback(void);

    __declspec(dllimport) HRESULT __stdcall RegisterApplicationRestart(PCWSTR pwzCommandline, DWORD dwFlags);

    __declspec(dllimport) HRESULT __stdcall UnregisterApplicationRestart(void);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) HRESULT __stdcall GetApplicationRecoveryCallback(HANDLE hProcess,
                                                                           APPLICATION_RECOVERY_CALLBACK* pRecoveryCallback,
                                                                           PVOID* ppvParameter,
                                                                           PDWORD pdwPingInterval,
                                                                           PDWORD pdwFlags);

    __declspec(dllimport) HRESULT
    __stdcall GetApplicationRestartSettings(HANDLE hProcess, PWSTR pwzCommandline, PDWORD pcchSize, PDWORD pdwFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HRESULT __stdcall ApplicationRecoveryInProgress(PBOOL pbCancelled);

    __declspec(dllimport) void __stdcall ApplicationRecoveryFinished(BOOL bSuccess);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct _FILE_BASIC_INFO
    {
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        DWORD FileAttributes;
    } FILE_BASIC_INFO, *PFILE_BASIC_INFO;

    typedef struct _FILE_STANDARD_INFO
    {
        LARGE_INTEGER AllocationSize;
        LARGE_INTEGER EndOfFile;
        DWORD NumberOfLinks;
        BOOLEAN DeletePending;
        BOOLEAN Directory;
    } FILE_STANDARD_INFO, *PFILE_STANDARD_INFO;

    typedef struct _FILE_NAME_INFO
    {
        DWORD FileNameLength;
        WCHAR FileName[1];
    } FILE_NAME_INFO, *PFILE_NAME_INFO;

    typedef struct _FILE_RENAME_INFO
    {
        union
        {
            BOOLEAN ReplaceIfExists;
            DWORD Flags;
        };

        HANDLE RootDirectory;
        DWORD FileNameLength;
        WCHAR FileName[1];
    } FILE_RENAME_INFO, *PFILE_RENAME_INFO;

    typedef struct _FILE_ALLOCATION_INFO
    {
        LARGE_INTEGER AllocationSize;
    } FILE_ALLOCATION_INFO, *PFILE_ALLOCATION_INFO;

    typedef struct _FILE_END_OF_FILE_INFO
    {
        LARGE_INTEGER EndOfFile;
    } FILE_END_OF_FILE_INFO, *PFILE_END_OF_FILE_INFO;

    typedef struct _FILE_STREAM_INFO
    {
        DWORD NextEntryOffset;
        DWORD StreamNameLength;
        LARGE_INTEGER StreamSize;
        LARGE_INTEGER StreamAllocationSize;
        WCHAR StreamName[1];
    } FILE_STREAM_INFO, *PFILE_STREAM_INFO;

    typedef struct _FILE_COMPRESSION_INFO
    {
        LARGE_INTEGER CompressedFileSize;
        WORD CompressionFormat;
        UCHAR CompressionUnitShift;
        UCHAR ChunkShift;
        UCHAR ClusterShift;
        UCHAR Reserved[3];
    } FILE_COMPRESSION_INFO, *PFILE_COMPRESSION_INFO;

    typedef struct _FILE_ATTRIBUTE_TAG_INFO
    {
        DWORD FileAttributes;
        DWORD ReparseTag;
    } FILE_ATTRIBUTE_TAG_INFO, *PFILE_ATTRIBUTE_TAG_INFO;

    typedef struct _FILE_DISPOSITION_INFO
    {
        BOOLEAN DeleteFile;
    } FILE_DISPOSITION_INFO, *PFILE_DISPOSITION_INFO;

    typedef struct _FILE_DISPOSITION_INFO_EX
    {
        DWORD Flags;
    } FILE_DISPOSITION_INFO_EX, *PFILE_DISPOSITION_INFO_EX;

    typedef struct _FILE_ID_BOTH_DIR_INFO
    {
        DWORD NextEntryOffset;
        DWORD FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        DWORD FileAttributes;
        DWORD FileNameLength;
        DWORD EaSize;
        CCHAR ShortNameLength;
        WCHAR ShortName[12];
        LARGE_INTEGER FileId;
        WCHAR FileName[1];
    } FILE_ID_BOTH_DIR_INFO, *PFILE_ID_BOTH_DIR_INFO;

    typedef struct _FILE_FULL_DIR_INFO
    {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        WCHAR FileName[1];
    } FILE_FULL_DIR_INFO, *PFILE_FULL_DIR_INFO;

    typedef enum _PRIORITY_HINT
    {
        IoPriorityHintVeryLow = 0,
        IoPriorityHintLow,
        IoPriorityHintNormal,
        MaximumIoPriorityHintType
    } PRIORITY_HINT;

    typedef struct _FILE_IO_PRIORITY_HINT_INFO
    {
        PRIORITY_HINT PriorityHint;
    } FILE_IO_PRIORITY_HINT_INFO, *PFILE_IO_PRIORITY_HINT_INFO;

    typedef struct _FILE_ALIGNMENT_INFO
    {
        ULONG AlignmentRequirement;
    } FILE_ALIGNMENT_INFO, *PFILE_ALIGNMENT_INFO;

    typedef struct _FILE_STORAGE_INFO
    {
        ULONG LogicalBytesPerSector;
        ULONG PhysicalBytesPerSectorForAtomicity;
        ULONG PhysicalBytesPerSectorForPerformance;
        ULONG FileSystemEffectivePhysicalBytesPerSectorForAtomicity;
        ULONG Flags;
        ULONG ByteOffsetForSectorAlignment;
        ULONG ByteOffsetForPartitionAlignment;
    } FILE_STORAGE_INFO, *PFILE_STORAGE_INFO;

    typedef struct _FILE_ID_INFO
    {
        ULONGLONG VolumeSerialNumber;
        FILE_ID_128 FileId;
    } FILE_ID_INFO, *PFILE_ID_INFO;

    typedef struct _FILE_ID_EXTD_DIR_INFO
    {
        ULONG NextEntryOffset;
        ULONG FileIndex;
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        LARGE_INTEGER EndOfFile;
        LARGE_INTEGER AllocationSize;
        ULONG FileAttributes;
        ULONG FileNameLength;
        ULONG EaSize;
        ULONG ReparsePointTag;
        FILE_ID_128 FileId;
        WCHAR FileName[1];
    } FILE_ID_EXTD_DIR_INFO, *PFILE_ID_EXTD_DIR_INFO;

    typedef struct _FILE_REMOTE_PROTOCOL_INFO
    {
        USHORT StructureVersion;
        USHORT StructureSize;

        ULONG Protocol;

        USHORT ProtocolMajorVersion;
        USHORT ProtocolMinorVersion;
        USHORT ProtocolRevision;

        USHORT Reserved;

        ULONG Flags;

        struct
        {
            ULONG Reserved[8];
        } GenericReserved;

        union
        {
            struct
            {
                struct
                {
                    ULONG Capabilities;
                } Server;

                struct
                {
                    ULONG Capabilities;
                    ULONG CachingFlags;
                } Share;

            } Smb2;

            ULONG Reserved[16];

        } ProtocolSpecific;

    } FILE_REMOTE_PROTOCOL_INFO, *PFILE_REMOTE_PROTOCOL_INFO;

    __declspec(dllimport) BOOL __stdcall GetFileInformationByHandleEx(HANDLE hFile,
                                                                      FILE_INFO_BY_HANDLE_CLASS FileInformationClass,
                                                                      LPVOID lpFileInformation,
                                                                      DWORD dwBufferSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef enum _FILE_ID_TYPE
    {
        FileIdType,
        ObjectIdType,
        ExtendedFileIdType,
        MaximumFileIdType
    } FILE_ID_TYPE,
    *PFILE_ID_TYPE;

    typedef struct FILE_ID_DESCRIPTOR
    {
        DWORD dwSize;
        FILE_ID_TYPE Type;
        union
        {
            LARGE_INTEGER FileId;
            GUID ObjectId;

            FILE_ID_128 ExtendedFileId;
        };
    } FILE_ID_DESCRIPTOR, *LPFILE_ID_DESCRIPTOR;

    __declspec(dllimport) HANDLE __stdcall OpenFileById(HANDLE hVolumeHint,
                                                        LPFILE_ID_DESCRIPTOR lpFileId,
                                                        DWORD dwDesiredAccess,
                                                        DWORD dwShareMode,
                                                        LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                        DWORD dwFlagsAndAttributes);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOLEAN __stdcall CreateSymbolicLinkA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags);
    __declspec(dllimport) BOOLEAN __stdcall CreateSymbolicLinkW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall QueryActCtxSettingsW(
    DWORD dwFlags, HANDLE hActCtx, PCWSTR settingsNameSpace, PCWSTR settingName, PWSTR pvBuffer, SIZE_T dwBuffer, SIZE_T* pdwWrittenOrRequired);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOLEAN
    __stdcall CreateSymbolicLinkTransactedA(LPCSTR lpSymlinkFileName, LPCSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction);
    __declspec(dllimport) BOOLEAN
    __stdcall CreateSymbolicLinkTransactedW(LPCWSTR lpSymlinkFileName, LPCWSTR lpTargetFileName, DWORD dwFlags, HANDLE hTransaction);

    __declspec(dllimport) BOOL __stdcall ReplacePartitionUnit(PWSTR TargetPartition, PWSTR SparePartition, ULONG Flags);

    __declspec(dllimport) BOOL __stdcall AddSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);

    __declspec(dllimport) BOOL __stdcall RemoveSecureMemoryCacheCallback(PSECURE_MEMORY_CACHE_CALLBACK pfnCallBack);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CopyContext(PCONTEXT Destination, DWORD ContextFlags, PCONTEXT Source);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall InitializeContext(PVOID Buffer, DWORD ContextFlags, PCONTEXT* Context, PDWORD ContextLength);

    __declspec(dllimport) BOOL
    __stdcall InitializeContext2(PVOID Buffer, DWORD ContextFlags, PCONTEXT* Context, PDWORD ContextLength, ULONG64 XStateCompactionMask);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD64 __stdcall GetEnabledXStateFeatures(void);

    __declspec(dllimport) BOOL __stdcall GetXStateFeaturesMask(PCONTEXT Context, PDWORD64 FeatureMask);

    __declspec(dllimport) PVOID __stdcall LocateXStateFeature(PCONTEXT Context, DWORD FeatureId, PDWORD Length);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetXStateFeaturesMask(PCONTEXT Context, DWORD64 FeatureMask);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) DWORD
    __stdcall EnableThreadProfiling(HANDLE ThreadHandle, DWORD Flags, DWORD64 HardwareCounters, HANDLE* PerformanceDataHandle);

    __declspec(dllimport) DWORD __stdcall DisableThreadProfiling(HANDLE PerformanceDataHandle);

    __declspec(dllimport) DWORD __stdcall QueryThreadProfiling(HANDLE ThreadHandle, PBOOLEAN Enabled);

    __declspec(dllimport) DWORD
    __stdcall ReadThreadProfilingData(HANDLE PerformanceDataHandle, DWORD Flags, PPERFORMANCE_DATA PerformanceData);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD
    __stdcall RaiseCustomSystemEventTrigger(PCUSTOM_SYSTEM_EVENT_TRIGGER_CONFIG CustomSystemEventTriggerConfig);

#pragma endregion
}

#pragma warning(pop)

#pragma once

extern "C++"
{
    __forceinline unsigned _InterlockedIncrement(unsigned volatile* Addend)
    {
        return (unsigned)_InterlockedIncrement((volatile long*)Addend);
    }

    __forceinline unsigned long _InterlockedIncrement(unsigned long volatile* Addend)
    {
        return (unsigned long)_InterlockedIncrement((volatile long*)Addend);
    }

    __forceinline unsigned __int64 _InterlockedIncrement(unsigned __int64 volatile* Addend)
    {
        return (unsigned __int64)(_InterlockedIncrement64)((volatile __int64*)Addend);
    }

    __forceinline unsigned _InterlockedDecrement(unsigned volatile* Addend)
    {
        return (unsigned long)_InterlockedDecrement((volatile long*)Addend);
    }

    __forceinline unsigned long _InterlockedDecrement(unsigned long volatile* Addend)
    {
        return (unsigned long)_InterlockedDecrement((volatile long*)Addend);
    }

    __forceinline unsigned __int64 _InterlockedDecrement(unsigned __int64 volatile* Addend)
    {
        return (unsigned __int64)(_InterlockedDecrement64)((volatile __int64*)Addend);
    }

    __forceinline unsigned _InterlockedExchange(unsigned volatile* Target, unsigned Value)
    {
        return (unsigned)_InterlockedExchange((volatile long*)Target, (long)Value);
    }

    __forceinline unsigned long _InterlockedExchange(unsigned long volatile* Target, unsigned long Value)
    {
        return (unsigned long)_InterlockedExchange((volatile long*)Target, (long)Value);
    }

    __forceinline unsigned __int64 _InterlockedExchange(unsigned __int64 volatile* Target, unsigned __int64 Value)
    {
        return (unsigned __int64)_InterlockedExchange64((volatile __int64*)Target, (__int64)Value);
    }

    __forceinline unsigned _InterlockedExchangeAdd(unsigned volatile* Addend, unsigned Value)
    {
        return (unsigned)_InterlockedExchangeAdd((volatile long*)Addend, (long)Value);
    }

    __forceinline unsigned InterlockedExchangeSubtract(unsigned volatile* Addend, unsigned Value)
    {
        return (unsigned)_InterlockedExchangeAdd((volatile long*)Addend, -(long)Value);
    }

    __forceinline unsigned long _InterlockedExchangeAdd(unsigned long volatile* Addend, unsigned long Value)
    {
        return (unsigned long)_InterlockedExchangeAdd((volatile long*)Addend, (long)Value);
    }

    __forceinline unsigned long InterlockedExchangeSubtract(unsigned long volatile* Addend, unsigned long Value)
    {
        return (unsigned long)_InterlockedExchangeAdd((volatile long*)Addend, -(long)Value);
    }

    __forceinline unsigned __int64 _InterlockedExchangeAdd(unsigned __int64 volatile* Addend, unsigned __int64 Value)
    {
        return (unsigned __int64)_InterlockedExchangeAdd64((volatile __int64*)Addend, (__int64)Value);
    }

    __forceinline unsigned __int64 InterlockedExchangeSubtract(unsigned __int64 volatile* Addend, unsigned __int64 Value)
    {
        return (unsigned __int64)_InterlockedExchangeAdd64((volatile __int64*)Addend, -(__int64)Value);
    }

    __forceinline unsigned _InterlockedCompareExchange(unsigned volatile* Destination, unsigned Exchange, unsigned Comperand)
    {
        return (unsigned)_InterlockedCompareExchange((volatile long*)Destination, (long)Exchange, (long)Comperand);
    }

    __forceinline unsigned long
    _InterlockedCompareExchange(unsigned long volatile* Destination, unsigned long Exchange, unsigned long Comperand)
    {
        return (unsigned long)_InterlockedCompareExchange((volatile long*)Destination, (long)Exchange, (long)Comperand);
    }

    __forceinline unsigned __int64
    _InterlockedCompareExchange(unsigned __int64 volatile* Destination, unsigned __int64 Exchange, unsigned __int64 Comperand)
    {
        return (unsigned __int64)_InterlockedCompareExchange64((volatile __int64*)Destination, (__int64)Exchange, (__int64)Comperand);
    }

    __forceinline unsigned __int64 _InterlockedAnd(unsigned __int64 volatile* Destination, unsigned __int64 Value)
    {
        return (unsigned __int64)_InterlockedAnd64((volatile __int64*)Destination, (__int64)Value);
    }

    __forceinline unsigned __int64 _InterlockedOr(unsigned __int64 volatile* Destination, unsigned __int64 Value)
    {
        return (unsigned __int64)_InterlockedOr64((volatile __int64*)Destination, (__int64)Value);
    }

    __forceinline unsigned __int64 _InterlockedXor(unsigned __int64 volatile* Destination, unsigned __int64 Value)
    {
        return (unsigned __int64)_InterlockedXor64((volatile __int64*)Destination, (__int64)Value);
    }
}

#pragma once

#pragma warning(push)
#pragma warning(disable : 4201)

#pragma warning(disable : 4820)

extern "C"
{
#pragma region Desktop Family

    typedef struct _DRAWPATRECT
    {
        POINT ptPosition;
        POINT ptSize;
        WORD wStyle;
        WORD wPattern;
    } DRAWPATRECT, *PDRAWPATRECT;

#pragma endregion

#pragma region Desktop Family

    typedef struct _PSINJECTDATA
    {
        DWORD DataBytes;
        WORD InjectionPoint;
        WORD PageNumber;

    } PSINJECTDATA, *PPSINJECTDATA;

#pragma endregion

#pragma region Desktop Family

    typedef struct _PSFEATURE_OUTPUT
    {
        BOOL bPageIndependent;
        BOOL bSetPageDevice;

    } PSFEATURE_OUTPUT, *PPSFEATURE_OUTPUT;

    typedef struct _PSFEATURE_CUSTPAPER
    {
        LONG lOrientation;
        LONG lWidth;
        LONG lHeight;
        LONG lWidthOffset;
        LONG lHeightOffset;

    } PSFEATURE_CUSTPAPER, *PPSFEATURE_CUSTPAPER;

#pragma endregion

#pragma region Application Family

    typedef struct tagXFORM
    {
        FLOAT eM11;
        FLOAT eM12;
        FLOAT eM21;
        FLOAT eM22;
        FLOAT eDx;
        FLOAT eDy;
    } XFORM, *PXFORM, *LPXFORM;

    typedef struct tagBITMAP
    {
        LONG bmType;
        LONG bmWidth;
        LONG bmHeight;
        LONG bmWidthBytes;
        WORD bmPlanes;
        WORD bmBitsPixel;
        LPVOID bmBits;
    } BITMAP, *PBITMAP, *NPBITMAP, *LPBITMAP;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(push, 1)

#pragma region Application Family

    typedef struct tagRGBTRIPLE
    {
        BYTE rgbtBlue;
        BYTE rgbtGreen;
        BYTE rgbtRed;
    } RGBTRIPLE, *PRGBTRIPLE, *NPRGBTRIPLE, *LPRGBTRIPLE;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma region Application Family

    typedef struct tagRGBQUAD
    {
        BYTE rgbBlue;
        BYTE rgbGreen;
        BYTE rgbRed;
        BYTE rgbReserved;
    } RGBQUAD;

#pragma endregion

#pragma region Desktop Family

    typedef RGBQUAD* LPRGBQUAD;

#pragma endregion

#pragma region Application Family

    typedef LONG LCSCSTYPE;

    typedef LONG LCSGAMUTMATCH;

    typedef long FXPT16DOT16, *LPFXPT16DOT16;
    typedef long FXPT2DOT30, *LPFXPT2DOT30;

    typedef struct tagCIEXYZ
    {
        FXPT2DOT30 ciexyzX;
        FXPT2DOT30 ciexyzY;
        FXPT2DOT30 ciexyzZ;
    } CIEXYZ;

#pragma endregion

#pragma region Desktop Family

    typedef CIEXYZ* LPCIEXYZ;

#pragma endregion

#pragma region Application Family

    typedef struct tagICEXYZTRIPLE
    {
        CIEXYZ ciexyzRed;
        CIEXYZ ciexyzGreen;
        CIEXYZ ciexyzBlue;
    } CIEXYZTRIPLE;

#pragma endregion

#pragma region Desktop Family

    typedef CIEXYZTRIPLE* LPCIEXYZTRIPLE;

#pragma endregion

#pragma region Application Family

    typedef struct tagLOGCOLORSPACEA
    {
        DWORD lcsSignature;
        DWORD lcsVersion;
        DWORD lcsSize;
        LCSCSTYPE lcsCSType;
        LCSGAMUTMATCH lcsIntent;
        CIEXYZTRIPLE lcsEndpoints;
        DWORD lcsGammaRed;
        DWORD lcsGammaGreen;
        DWORD lcsGammaBlue;
        CHAR lcsFilename[260];
    } LOGCOLORSPACEA, *LPLOGCOLORSPACEA;
    typedef struct tagLOGCOLORSPACEW
    {
        DWORD lcsSignature;
        DWORD lcsVersion;
        DWORD lcsSize;
        LCSCSTYPE lcsCSType;
        LCSGAMUTMATCH lcsIntent;
        CIEXYZTRIPLE lcsEndpoints;
        DWORD lcsGammaRed;
        DWORD lcsGammaGreen;
        DWORD lcsGammaBlue;
        WCHAR lcsFilename[260];
    } LOGCOLORSPACEW, *LPLOGCOLORSPACEW;

    typedef LOGCOLORSPACEA LOGCOLORSPACE;
    typedef LPLOGCOLORSPACEA LPLOGCOLORSPACE;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagBITMAPCOREHEADER
    {
        DWORD bcSize;
        WORD bcWidth;
        WORD bcHeight;
        WORD bcPlanes;
        WORD bcBitCount;
    } BITMAPCOREHEADER, *LPBITMAPCOREHEADER, *PBITMAPCOREHEADER;

#pragma endregion

#pragma region Application Family

    typedef struct tagBITMAPINFOHEADER
    {
        DWORD biSize;
        LONG biWidth;
        LONG biHeight;
        WORD biPlanes;
        WORD biBitCount;
        DWORD biCompression;
        DWORD biSizeImage;
        LONG biXPelsPerMeter;
        LONG biYPelsPerMeter;
        DWORD biClrUsed;
        DWORD biClrImportant;
    } BITMAPINFOHEADER, *LPBITMAPINFOHEADER, *PBITMAPINFOHEADER;

#pragma endregion

#pragma region Desktop Family

    typedef struct
    {
        DWORD bV4Size;
        LONG bV4Width;
        LONG bV4Height;
        WORD bV4Planes;
        WORD bV4BitCount;
        DWORD bV4V4Compression;
        DWORD bV4SizeImage;
        LONG bV4XPelsPerMeter;
        LONG bV4YPelsPerMeter;
        DWORD bV4ClrUsed;
        DWORD bV4ClrImportant;
        DWORD bV4RedMask;
        DWORD bV4GreenMask;
        DWORD bV4BlueMask;
        DWORD bV4AlphaMask;
        DWORD bV4CSType;
        CIEXYZTRIPLE bV4Endpoints;
        DWORD bV4GammaRed;
        DWORD bV4GammaGreen;
        DWORD bV4GammaBlue;
    } BITMAPV4HEADER, *LPBITMAPV4HEADER, *PBITMAPV4HEADER;

#pragma endregion

#pragma region Desktop Family

    typedef struct
    {
        DWORD bV5Size;
        LONG bV5Width;
        LONG bV5Height;
        WORD bV5Planes;
        WORD bV5BitCount;
        DWORD bV5Compression;
        DWORD bV5SizeImage;
        LONG bV5XPelsPerMeter;
        LONG bV5YPelsPerMeter;
        DWORD bV5ClrUsed;
        DWORD bV5ClrImportant;
        DWORD bV5RedMask;
        DWORD bV5GreenMask;
        DWORD bV5BlueMask;
        DWORD bV5AlphaMask;
        DWORD bV5CSType;
        CIEXYZTRIPLE bV5Endpoints;
        DWORD bV5GammaRed;
        DWORD bV5GammaGreen;
        DWORD bV5GammaBlue;
        DWORD bV5Intent;
        DWORD bV5ProfileData;
        DWORD bV5ProfileSize;
        DWORD bV5Reserved;
    } BITMAPV5HEADER, *LPBITMAPV5HEADER, *PBITMAPV5HEADER;

#pragma endregion

#pragma region Application Family

    typedef struct tagBITMAPINFO
    {
        BITMAPINFOHEADER bmiHeader;
        RGBQUAD bmiColors[1];
    } BITMAPINFO, *LPBITMAPINFO, *PBITMAPINFO;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagBITMAPCOREINFO
    {
        BITMAPCOREHEADER bmciHeader;
        RGBTRIPLE bmciColors[1];
    } BITMAPCOREINFO, *LPBITMAPCOREINFO, *PBITMAPCOREINFO;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(push, 2)

#pragma region Desktop Family

    typedef struct tagBITMAPFILEHEADER
    {
        WORD bfType;
        DWORD bfSize;
        WORD bfReserved1;
        WORD bfReserved2;
        DWORD bfOffBits;
    } BITMAPFILEHEADER, *LPBITMAPFILEHEADER, *PBITMAPFILEHEADER;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma region Application Family

    typedef struct tagFONTSIGNATURE
    {
        DWORD fsUsb[4];
        DWORD fsCsb[2];
    } FONTSIGNATURE, *PFONTSIGNATURE, *LPFONTSIGNATURE;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagCHARSETINFO
    {
        UINT ciCharset;
        UINT ciACP;
        FONTSIGNATURE fs;
    } CHARSETINFO, *PCHARSETINFO, *NPCHARSETINFO, *LPCHARSETINFO;

#pragma endregion

#pragma region Application Family

    typedef struct tagLOCALESIGNATURE
    {
        DWORD lsUsb[4];
        DWORD lsCsbDefault[2];
        DWORD lsCsbSupported[2];
    } LOCALESIGNATURE, *PLOCALESIGNATURE, *LPLOCALESIGNATURE;

#pragma endregion

#pragma region Application Family

    typedef struct tagHANDLETABLE
    {
        HGDIOBJ objectHandle[1];
    } HANDLETABLE, *PHANDLETABLE, *LPHANDLETABLE;

    typedef struct tagMETARECORD
    {
        DWORD rdSize;
        WORD rdFunction;
        WORD rdParm[1];
    } METARECORD;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagMETARECORD __unaligned* PMETARECORD;

#pragma endregion

#pragma region Application Family

    typedef struct tagMETARECORD __unaligned* LPMETARECORD;

    typedef struct tagMETAFILEPICT
    {
        LONG mm;
        LONG xExt;
        LONG yExt;
        HMETAFILE hMF;
    } METAFILEPICT, *LPMETAFILEPICT;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(push, 2)

#pragma region Desktop Family

    typedef struct tagMETAHEADER
    {
        WORD mtType;
        WORD mtHeaderSize;
        WORD mtVersion;
        DWORD mtSize;
        WORD mtNoObjects;
        DWORD mtMaxRecord;
        WORD mtNoParameters;
    } METAHEADER;
    typedef struct tagMETAHEADER __unaligned* PMETAHEADER;
    typedef struct tagMETAHEADER __unaligned* LPMETAHEADER;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma region Application Family

    typedef struct tagENHMETARECORD
    {
        DWORD iType;
        DWORD nSize;
        DWORD dParm[1];
    } ENHMETARECORD, *PENHMETARECORD, *LPENHMETARECORD;

    typedef struct tagENHMETAHEADER
    {
        DWORD iType;
        DWORD nSize;

        RECTL rclBounds;
        RECTL rclFrame;
        DWORD dSignature;
        DWORD nVersion;
        DWORD nBytes;
        DWORD nRecords;
        WORD nHandles;

        WORD sReserved;
        DWORD nDescription;

        DWORD offDescription;

        DWORD nPalEntries;
        SIZEL szlDevice;
        SIZEL szlMillimeters;

        DWORD cbPixelFormat;

        DWORD offPixelFormat;

        DWORD bOpenGL;

        SIZEL szlMicrometers;

    } ENHMETAHEADER, *PENHMETAHEADER, *LPENHMETAHEADER;

#pragma endregion

#pragma region Desktop Family

    typedef BYTE BCHAR;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(push, 4)

#pragma region Application Family

    typedef struct tagTEXTMETRICA
    {
        LONG tmHeight;
        LONG tmAscent;
        LONG tmDescent;
        LONG tmInternalLeading;
        LONG tmExternalLeading;
        LONG tmAveCharWidth;
        LONG tmMaxCharWidth;
        LONG tmWeight;
        LONG tmOverhang;
        LONG tmDigitizedAspectX;
        LONG tmDigitizedAspectY;
        BYTE tmFirstChar;
        BYTE tmLastChar;
        BYTE tmDefaultChar;
        BYTE tmBreakChar;
        BYTE tmItalic;
        BYTE tmUnderlined;
        BYTE tmStruckOut;
        BYTE tmPitchAndFamily;
        BYTE tmCharSet;
    } TEXTMETRICA, *PTEXTMETRICA, *NPTEXTMETRICA, *LPTEXTMETRICA;
    typedef struct tagTEXTMETRICW
    {
        LONG tmHeight;
        LONG tmAscent;
        LONG tmDescent;
        LONG tmInternalLeading;
        LONG tmExternalLeading;
        LONG tmAveCharWidth;
        LONG tmMaxCharWidth;
        LONG tmWeight;
        LONG tmOverhang;
        LONG tmDigitizedAspectX;
        LONG tmDigitizedAspectY;
        WCHAR tmFirstChar;
        WCHAR tmLastChar;
        WCHAR tmDefaultChar;
        WCHAR tmBreakChar;
        BYTE tmItalic;
        BYTE tmUnderlined;
        BYTE tmStruckOut;
        BYTE tmPitchAndFamily;
        BYTE tmCharSet;
    } TEXTMETRICW, *PTEXTMETRICW, *NPTEXTMETRICW, *LPTEXTMETRICW;

    typedef TEXTMETRICA TEXTMETRIC;
    typedef PTEXTMETRICA PTEXTMETRIC;
    typedef NPTEXTMETRICA NPTEXTMETRIC;
    typedef LPTEXTMETRICA LPTEXTMETRIC;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(disable : 4103)

#pragma pack(push, 4)

#pragma region Desktop Family

    typedef struct tagNEWTEXTMETRICA
    {
        LONG tmHeight;
        LONG tmAscent;
        LONG tmDescent;
        LONG tmInternalLeading;
        LONG tmExternalLeading;
        LONG tmAveCharWidth;
        LONG tmMaxCharWidth;
        LONG tmWeight;
        LONG tmOverhang;
        LONG tmDigitizedAspectX;
        LONG tmDigitizedAspectY;
        BYTE tmFirstChar;
        BYTE tmLastChar;
        BYTE tmDefaultChar;
        BYTE tmBreakChar;
        BYTE tmItalic;
        BYTE tmUnderlined;
        BYTE tmStruckOut;
        BYTE tmPitchAndFamily;
        BYTE tmCharSet;
        DWORD ntmFlags;
        UINT ntmSizeEM;
        UINT ntmCellHeight;
        UINT ntmAvgWidth;
    } NEWTEXTMETRICA, *PNEWTEXTMETRICA, *NPNEWTEXTMETRICA, *LPNEWTEXTMETRICA;
    typedef struct tagNEWTEXTMETRICW
    {
        LONG tmHeight;
        LONG tmAscent;
        LONG tmDescent;
        LONG tmInternalLeading;
        LONG tmExternalLeading;
        LONG tmAveCharWidth;
        LONG tmMaxCharWidth;
        LONG tmWeight;
        LONG tmOverhang;
        LONG tmDigitizedAspectX;
        LONG tmDigitizedAspectY;
        WCHAR tmFirstChar;
        WCHAR tmLastChar;
        WCHAR tmDefaultChar;
        WCHAR tmBreakChar;
        BYTE tmItalic;
        BYTE tmUnderlined;
        BYTE tmStruckOut;
        BYTE tmPitchAndFamily;
        BYTE tmCharSet;
        DWORD ntmFlags;
        UINT ntmSizeEM;
        UINT ntmCellHeight;
        UINT ntmAvgWidth;
    } NEWTEXTMETRICW, *PNEWTEXTMETRICW, *NPNEWTEXTMETRICW, *LPNEWTEXTMETRICW;

    typedef NEWTEXTMETRICA NEWTEXTMETRIC;
    typedef PNEWTEXTMETRICA PNEWTEXTMETRIC;
    typedef NPNEWTEXTMETRICA NPNEWTEXTMETRIC;
    typedef LPNEWTEXTMETRICA LPNEWTEXTMETRIC;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma region Desktop Family

    typedef struct tagNEWTEXTMETRICEXA
    {
        NEWTEXTMETRICA ntmTm;
        FONTSIGNATURE ntmFontSig;
    } NEWTEXTMETRICEXA;
    typedef struct tagNEWTEXTMETRICEXW
    {
        NEWTEXTMETRICW ntmTm;
        FONTSIGNATURE ntmFontSig;
    } NEWTEXTMETRICEXW;

    typedef NEWTEXTMETRICEXA NEWTEXTMETRICEX;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagPELARRAY
    {
        LONG paXCount;
        LONG paYCount;
        LONG paXExt;
        LONG paYExt;
        BYTE paRGBs;
    } PELARRAY, *PPELARRAY, *NPPELARRAY, *LPPELARRAY;

#pragma endregion

#pragma region Application Family

    typedef struct tagLOGBRUSH
    {
        UINT lbStyle;
        COLORREF lbColor;
        ULONG_PTR lbHatch;
    } LOGBRUSH, *PLOGBRUSH, *NPLOGBRUSH, *LPLOGBRUSH;

    typedef struct tagLOGBRUSH32
    {
        UINT lbStyle;
        COLORREF lbColor;
        ULONG lbHatch;
    } LOGBRUSH32, *PLOGBRUSH32, *NPLOGBRUSH32, *LPLOGBRUSH32;

#pragma endregion

#pragma region Desktop Family

    typedef LOGBRUSH PATTERN;
    typedef PATTERN* PPATTERN;
    typedef PATTERN* NPPATTERN;
    typedef PATTERN* LPPATTERN;

#pragma endregion

#pragma region Application Family

    typedef struct tagLOGPEN
    {
        UINT lopnStyle;
        POINT lopnWidth;
        COLORREF lopnColor;
    } LOGPEN, *PLOGPEN, *NPLOGPEN, *LPLOGPEN;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagEXTLOGPEN
    {
        DWORD elpPenStyle;
        DWORD elpWidth;
        UINT elpBrushStyle;
        COLORREF elpColor;
        ULONG_PTR elpHatch;
        DWORD elpNumEntries;
        DWORD elpStyleEntry[1];
    } EXTLOGPEN, *PEXTLOGPEN, *NPEXTLOGPEN, *LPEXTLOGPEN;

#pragma endregion

#pragma region Application Family

    typedef struct tagEXTLOGPEN32
    {
        DWORD elpPenStyle;
        DWORD elpWidth;
        UINT elpBrushStyle;
        COLORREF elpColor;
        ULONG elpHatch;
        DWORD elpNumEntries;
        DWORD elpStyleEntry[1];
    } EXTLOGPEN32, *PEXTLOGPEN32, *NPEXTLOGPEN32, *LPEXTLOGPEN32;

    typedef struct tagPALETTEENTRY
    {
        BYTE peRed;
        BYTE peGreen;
        BYTE peBlue;
        BYTE peFlags;
    } PALETTEENTRY, *PPALETTEENTRY, *LPPALETTEENTRY;

    typedef struct tagLOGPALETTE
    {
        WORD palVersion;
        WORD palNumEntries;
        PALETTEENTRY palPalEntry[1];
    } LOGPALETTE, *PLOGPALETTE, *NPLOGPALETTE, *LPLOGPALETTE;

    typedef struct tagLOGFONTA
    {
        LONG lfHeight;
        LONG lfWidth;
        LONG lfEscapement;
        LONG lfOrientation;
        LONG lfWeight;
        BYTE lfItalic;
        BYTE lfUnderline;
        BYTE lfStrikeOut;
        BYTE lfCharSet;
        BYTE lfOutPrecision;
        BYTE lfClipPrecision;
        BYTE lfQuality;
        BYTE lfPitchAndFamily;
        CHAR lfFaceName[32];
    } LOGFONTA, *PLOGFONTA, *NPLOGFONTA, *LPLOGFONTA;
    typedef struct tagLOGFONTW
    {
        LONG lfHeight;
        LONG lfWidth;
        LONG lfEscapement;
        LONG lfOrientation;
        LONG lfWeight;
        BYTE lfItalic;
        BYTE lfUnderline;
        BYTE lfStrikeOut;
        BYTE lfCharSet;
        BYTE lfOutPrecision;
        BYTE lfClipPrecision;
        BYTE lfQuality;
        BYTE lfPitchAndFamily;
        WCHAR lfFaceName[32];
    } LOGFONTW, *PLOGFONTW, *NPLOGFONTW, *LPLOGFONTW;

    typedef LOGFONTA LOGFONT;
    typedef PLOGFONTA PLOGFONT;
    typedef NPLOGFONTA NPLOGFONT;
    typedef LPLOGFONTA LPLOGFONT;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagENUMLOGFONTA
    {
        LOGFONTA elfLogFont;
        BYTE elfFullName[64];
        BYTE elfStyle[32];
    } ENUMLOGFONTA, *LPENUMLOGFONTA;

    typedef struct tagENUMLOGFONTW
    {
        LOGFONTW elfLogFont;
        WCHAR elfFullName[64];
        WCHAR elfStyle[32];
    } ENUMLOGFONTW, *LPENUMLOGFONTW;

    typedef ENUMLOGFONTA ENUMLOGFONT;
    typedef LPENUMLOGFONTA LPENUMLOGFONT;

    typedef struct tagENUMLOGFONTEXA
    {
        LOGFONTA elfLogFont;
        BYTE elfFullName[64];
        BYTE elfStyle[32];
        BYTE elfScript[32];
    } ENUMLOGFONTEXA, *LPENUMLOGFONTEXA;
    typedef struct tagENUMLOGFONTEXW
    {
        LOGFONTW elfLogFont;
        WCHAR elfFullName[64];
        WCHAR elfStyle[32];
        WCHAR elfScript[32];
    } ENUMLOGFONTEXW, *LPENUMLOGFONTEXW;

    typedef ENUMLOGFONTEXA ENUMLOGFONTEX;
    typedef LPENUMLOGFONTEXA LPENUMLOGFONTEX;

#pragma endregion

#pragma region Application Family

    typedef struct tagPANOSE
    {
        BYTE bFamilyType;
        BYTE bSerifStyle;
        BYTE bWeight;
        BYTE bProportion;
        BYTE bContrast;
        BYTE bStrokeVariation;
        BYTE bArmStyle;
        BYTE bLetterform;
        BYTE bMidline;
        BYTE bXHeight;
    } PANOSE, *LPPANOSE;

    typedef struct tagEXTLOGFONTA
    {
        LOGFONTA elfLogFont;
        BYTE elfFullName[64];
        BYTE elfStyle[32];
        DWORD elfVersion;
        DWORD elfStyleSize;
        DWORD elfMatch;
        DWORD elfReserved;
        BYTE elfVendorId[4];
        DWORD elfCulture;
        PANOSE elfPanose;
    } EXTLOGFONTA, *PEXTLOGFONTA, *NPEXTLOGFONTA, *LPEXTLOGFONTA;
    typedef struct tagEXTLOGFONTW
    {
        LOGFONTW elfLogFont;
        WCHAR elfFullName[64];
        WCHAR elfStyle[32];
        DWORD elfVersion;
        DWORD elfStyleSize;
        DWORD elfMatch;
        DWORD elfReserved;
        BYTE elfVendorId[4];
        DWORD elfCulture;
        PANOSE elfPanose;
    } EXTLOGFONTW, *PEXTLOGFONTW, *NPEXTLOGFONTW, *LPEXTLOGFONTW;

    typedef EXTLOGFONTA EXTLOGFONT;
    typedef PEXTLOGFONTA PEXTLOGFONT;
    typedef NPEXTLOGFONTA NPEXTLOGFONT;
    typedef LPEXTLOGFONTA LPEXTLOGFONT;

#pragma endregion

#pragma region Application Family

    typedef struct _devicemodeA
    {
        BYTE dmDeviceName[32];
        WORD dmSpecVersion;
        WORD dmDriverVersion;
        WORD dmSize;
        WORD dmDriverExtra;
        DWORD dmFields;
        union
        {
            struct
            {
                short dmOrientation;
                short dmPaperSize;
                short dmPaperLength;
                short dmPaperWidth;
                short dmScale;
                short dmCopies;
                short dmDefaultSource;
                short dmPrintQuality;
            };

            struct
            {
                POINTL dmPosition;
                DWORD dmDisplayOrientation;
                DWORD dmDisplayFixedOutput;
            };
        };
        short dmColor;
        short dmDuplex;
        short dmYResolution;
        short dmTTOption;
        short dmCollate;
        BYTE dmFormName[32];
        WORD dmLogPixels;
        DWORD dmBitsPerPel;
        DWORD dmPelsWidth;
        DWORD dmPelsHeight;
        union
        {
            DWORD dmDisplayFlags;
            DWORD dmNup;
        };
        DWORD dmDisplayFrequency;

        DWORD dmICMMethod;
        DWORD dmICMIntent;
        DWORD dmMediaType;
        DWORD dmDitherType;
        DWORD dmReserved1;
        DWORD dmReserved2;

        DWORD dmPanningWidth;
        DWORD dmPanningHeight;
    } DEVMODEA, *PDEVMODEA, *NPDEVMODEA, *LPDEVMODEA;
    typedef struct _devicemodeW
    {
        WCHAR dmDeviceName[32];
        WORD dmSpecVersion;
        WORD dmDriverVersion;
        WORD dmSize;
        WORD dmDriverExtra;
        DWORD dmFields;
        union
        {
            struct
            {
                short dmOrientation;
                short dmPaperSize;
                short dmPaperLength;
                short dmPaperWidth;
                short dmScale;
                short dmCopies;
                short dmDefaultSource;
                short dmPrintQuality;
            };

            struct
            {
                POINTL dmPosition;
                DWORD dmDisplayOrientation;
                DWORD dmDisplayFixedOutput;
            };
        };
        short dmColor;
        short dmDuplex;
        short dmYResolution;
        short dmTTOption;
        short dmCollate;
        WCHAR dmFormName[32];
        WORD dmLogPixels;
        DWORD dmBitsPerPel;
        DWORD dmPelsWidth;
        DWORD dmPelsHeight;
        union
        {
            DWORD dmDisplayFlags;
            DWORD dmNup;
        };
        DWORD dmDisplayFrequency;

        DWORD dmICMMethod;
        DWORD dmICMIntent;
        DWORD dmMediaType;
        DWORD dmDitherType;
        DWORD dmReserved1;
        DWORD dmReserved2;

        DWORD dmPanningWidth;
        DWORD dmPanningHeight;
    } DEVMODEW, *PDEVMODEW, *NPDEVMODEW, *LPDEVMODEW;

    typedef DEVMODEA DEVMODE;
    typedef PDEVMODEA PDEVMODE;
    typedef NPDEVMODEA NPDEVMODE;
    typedef LPDEVMODEA LPDEVMODE;

#pragma endregion

#pragma region Application Family

    typedef struct _DISPLAY_DEVICEA
    {
        DWORD cb;
        CHAR DeviceName[32];
        CHAR DeviceString[128];
        DWORD StateFlags;
        CHAR DeviceID[128];
        CHAR DeviceKey[128];
    } DISPLAY_DEVICEA, *PDISPLAY_DEVICEA, *LPDISPLAY_DEVICEA;
    typedef struct _DISPLAY_DEVICEW
    {
        DWORD cb;
        WCHAR DeviceName[32];
        WCHAR DeviceString[128];
        DWORD StateFlags;
        WCHAR DeviceID[128];
        WCHAR DeviceKey[128];
    } DISPLAY_DEVICEW, *PDISPLAY_DEVICEW, *LPDISPLAY_DEVICEW;

    typedef DISPLAY_DEVICEA DISPLAY_DEVICE;
    typedef PDISPLAY_DEVICEA PDISPLAY_DEVICE;
    typedef LPDISPLAY_DEVICEA LPDISPLAY_DEVICE;

#pragma endregion

#pragma region Application Family

    typedef struct DISPLAYCONFIG_RATIONAL
    {
        UINT32 Numerator;
        UINT32 Denominator;
    } DISPLAYCONFIG_RATIONAL;

    typedef enum
    {
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_OTHER = -1,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HD15 = 0,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SVIDEO = 1,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPOSITE_VIDEO = 2,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_COMPONENT_VIDEO = 3,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DVI = 4,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_HDMI = 5,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_LVDS = 6,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_D_JPN = 8,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDI = 9,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EXTERNAL = 10,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_DISPLAYPORT_EMBEDDED = 11,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EXTERNAL = 12,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_UDI_EMBEDDED = 13,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_SDTVDONGLE = 14,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_MIRACAST = 15,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_WIRED = 16,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INDIRECT_VIRTUAL = 17,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_INTERNAL = 0x80000000,
        DISPLAYCONFIG_OUTPUT_TECHNOLOGY_FORCE_UINT32 = 0xFFFFFFFF
    } DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY;

    typedef enum
    {
        DISPLAYCONFIG_SCANLINE_ORDERING_UNSPECIFIED = 0,
        DISPLAYCONFIG_SCANLINE_ORDERING_PROGRESSIVE = 1,
        DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED = 2,
        DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_UPPERFIELDFIRST = DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED,
        DISPLAYCONFIG_SCANLINE_ORDERING_INTERLACED_LOWERFIELDFIRST = 3,
        DISPLAYCONFIG_SCANLINE_ORDERING_FORCE_UINT32 = 0xFFFFFFFF
    } DISPLAYCONFIG_SCANLINE_ORDERING;

    typedef struct DISPLAYCONFIG_2DREGION
    {
        UINT32 cx;
        UINT32 cy;
    } DISPLAYCONFIG_2DREGION;

    typedef struct DISPLAYCONFIG_VIDEO_SIGNAL_INFO
    {
        UINT64 pixelRate;
        DISPLAYCONFIG_RATIONAL hSyncFreq;
        DISPLAYCONFIG_RATIONAL vSyncFreq;
        DISPLAYCONFIG_2DREGION activeSize;
        DISPLAYCONFIG_2DREGION totalSize;

        union
        {
            struct
            {
                UINT32 videoStandard : 16;

                UINT32 vSyncFreqDivider : 6;

                UINT32 reserved : 10;
            } AdditionalSignalInfo;

            UINT32 videoStandard;
        };

        DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
    } DISPLAYCONFIG_VIDEO_SIGNAL_INFO;

    typedef enum
    {
        DISPLAYCONFIG_SCALING_IDENTITY = 1,
        DISPLAYCONFIG_SCALING_CENTERED = 2,
        DISPLAYCONFIG_SCALING_STRETCHED = 3,
        DISPLAYCONFIG_SCALING_ASPECTRATIOCENTEREDMAX = 4,
        DISPLAYCONFIG_SCALING_CUSTOM = 5,
        DISPLAYCONFIG_SCALING_PREFERRED = 128,
        DISPLAYCONFIG_SCALING_FORCE_UINT32 = 0xFFFFFFFF
    } DISPLAYCONFIG_SCALING;

    typedef enum
    {
        DISPLAYCONFIG_ROTATION_IDENTITY = 1,
        DISPLAYCONFIG_ROTATION_ROTATE90 = 2,
        DISPLAYCONFIG_ROTATION_ROTATE180 = 3,
        DISPLAYCONFIG_ROTATION_ROTATE270 = 4,
        DISPLAYCONFIG_ROTATION_FORCE_UINT32 = 0xFFFFFFFF
    } DISPLAYCONFIG_ROTATION;

    typedef enum
    {
        DISPLAYCONFIG_MODE_INFO_TYPE_SOURCE = 1,
        DISPLAYCONFIG_MODE_INFO_TYPE_TARGET = 2,
        DISPLAYCONFIG_MODE_INFO_TYPE_DESKTOP_IMAGE = 3,
        DISPLAYCONFIG_MODE_INFO_TYPE_FORCE_UINT32 = 0xFFFFFFFF
    } DISPLAYCONFIG_MODE_INFO_TYPE;

    typedef enum
    {
        DISPLAYCONFIG_PIXELFORMAT_8BPP = 1,
        DISPLAYCONFIG_PIXELFORMAT_16BPP = 2,
        DISPLAYCONFIG_PIXELFORMAT_24BPP = 3,
        DISPLAYCONFIG_PIXELFORMAT_32BPP = 4,
        DISPLAYCONFIG_PIXELFORMAT_NONGDI = 5,
        DISPLAYCONFIG_PIXELFORMAT_FORCE_UINT32 = 0xffffffff
    } DISPLAYCONFIG_PIXELFORMAT;

    typedef struct DISPLAYCONFIG_SOURCE_MODE
    {
        UINT32 width;
        UINT32 height;
        DISPLAYCONFIG_PIXELFORMAT pixelFormat;
        POINTL position;
    } DISPLAYCONFIG_SOURCE_MODE;

    typedef struct DISPLAYCONFIG_TARGET_MODE
    {
        DISPLAYCONFIG_VIDEO_SIGNAL_INFO targetVideoSignalInfo;
    } DISPLAYCONFIG_TARGET_MODE;

    typedef struct DISPLAYCONFIG_DESKTOP_IMAGE_INFO
    {
        POINTL PathSourceSize;
        RECTL DesktopImageRegion;
        RECTL DesktopImageClip;
    } DISPLAYCONFIG_DESKTOP_IMAGE_INFO;

    typedef struct DISPLAYCONFIG_MODE_INFO
    {
        DISPLAYCONFIG_MODE_INFO_TYPE infoType;
        UINT32 id;
        LUID adapterId;
        union
        {
            DISPLAYCONFIG_TARGET_MODE targetMode;
            DISPLAYCONFIG_SOURCE_MODE sourceMode;
            DISPLAYCONFIG_DESKTOP_IMAGE_INFO desktopImageInfo;
        };
    } DISPLAYCONFIG_MODE_INFO;

    typedef struct DISPLAYCONFIG_PATH_SOURCE_INFO
    {
        LUID adapterId;
        UINT32 id;
        union
        {
            UINT32 modeInfoIdx;
            struct
            {
                UINT32 cloneGroupId : 16;
                UINT32 sourceModeInfoIdx : 16;
            };
        };

        UINT32 statusFlags;
    } DISPLAYCONFIG_PATH_SOURCE_INFO;

    typedef struct DISPLAYCONFIG_PATH_TARGET_INFO
    {
        LUID adapterId;
        UINT32 id;
        union
        {
            UINT32 modeInfoIdx;
            struct
            {
                UINT32 desktopModeInfoIdx : 16;
                UINT32 targetModeInfoIdx : 16;
            };
        };
        DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
        DISPLAYCONFIG_ROTATION rotation;
        DISPLAYCONFIG_SCALING scaling;
        DISPLAYCONFIG_RATIONAL refreshRate;
        DISPLAYCONFIG_SCANLINE_ORDERING scanLineOrdering;
        BOOL targetAvailable;
        UINT32 statusFlags;
    } DISPLAYCONFIG_PATH_TARGET_INFO;

    typedef struct DISPLAYCONFIG_PATH_INFO
    {
        DISPLAYCONFIG_PATH_SOURCE_INFO sourceInfo;
        DISPLAYCONFIG_PATH_TARGET_INFO targetInfo;
        UINT32 flags;
    } DISPLAYCONFIG_PATH_INFO;

    typedef enum DISPLAYCONFIG_TOPOLOGY_ID
    {
        DISPLAYCONFIG_TOPOLOGY_INTERNAL = 0x00000001,
        DISPLAYCONFIG_TOPOLOGY_CLONE = 0x00000002,
        DISPLAYCONFIG_TOPOLOGY_EXTEND = 0x00000004,
        DISPLAYCONFIG_TOPOLOGY_EXTERNAL = 0x00000008,
        DISPLAYCONFIG_TOPOLOGY_FORCE_UINT32 = 0xFFFFFFFF
    } DISPLAYCONFIG_TOPOLOGY_ID;

    typedef enum
    {
        DISPLAYCONFIG_DEVICE_INFO_GET_SOURCE_NAME = 1,
        DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_NAME = 2,
        DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_PREFERRED_MODE = 3,
        DISPLAYCONFIG_DEVICE_INFO_GET_ADAPTER_NAME = 4,
        DISPLAYCONFIG_DEVICE_INFO_SET_TARGET_PERSISTENCE = 5,
        DISPLAYCONFIG_DEVICE_INFO_GET_TARGET_BASE_TYPE = 6,
        DISPLAYCONFIG_DEVICE_INFO_GET_SUPPORT_VIRTUAL_RESOLUTION = 7,
        DISPLAYCONFIG_DEVICE_INFO_SET_SUPPORT_VIRTUAL_RESOLUTION = 8,
        DISPLAYCONFIG_DEVICE_INFO_GET_ADVANCED_COLOR_INFO = 9,
        DISPLAYCONFIG_DEVICE_INFO_SET_ADVANCED_COLOR_STATE = 10,
        DISPLAYCONFIG_DEVICE_INFO_GET_SDR_WHITE_LEVEL = 11,
        DISPLAYCONFIG_DEVICE_INFO_FORCE_UINT32 = 0xFFFFFFFF
    } DISPLAYCONFIG_DEVICE_INFO_TYPE;

#pragma endregion

#pragma region Application Family

    typedef struct DISPLAYCONFIG_DEVICE_INFO_HEADER
    {
        DISPLAYCONFIG_DEVICE_INFO_TYPE type;
        UINT32 size;
        LUID adapterId;
        UINT32 id;
    } DISPLAYCONFIG_DEVICE_INFO_HEADER;

#pragma endregion

#pragma region Desktop Family

    typedef struct DISPLAYCONFIG_SOURCE_DEVICE_NAME
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;
        WCHAR viewGdiDeviceName[32];
    } DISPLAYCONFIG_SOURCE_DEVICE_NAME;

    typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS
    {
        union
        {
            struct
            {
                UINT32 friendlyNameFromEdid : 1;
                UINT32 friendlyNameForced : 1;
                UINT32 edidIdsValid : 1;
                UINT32 reserved : 29;
            };
            UINT32 value;
        };
    } DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS;

    typedef struct DISPLAYCONFIG_TARGET_DEVICE_NAME
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;
        DISPLAYCONFIG_TARGET_DEVICE_NAME_FLAGS flags;
        DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY outputTechnology;
        UINT16 edidManufactureId;
        UINT16 edidProductCodeId;
        UINT32 connectorInstance;
        WCHAR monitorFriendlyDeviceName[64];
        WCHAR monitorDevicePath[128];
    } DISPLAYCONFIG_TARGET_DEVICE_NAME;

    typedef struct DISPLAYCONFIG_TARGET_PREFERRED_MODE
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;
        UINT32 width;
        UINT32 height;
        DISPLAYCONFIG_TARGET_MODE targetMode;
    } DISPLAYCONFIG_TARGET_PREFERRED_MODE;

    typedef struct DISPLAYCONFIG_ADAPTER_NAME
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;
        WCHAR adapterDevicePath[128];
    } DISPLAYCONFIG_ADAPTER_NAME;

    typedef struct DISPLAYCONFIG_TARGET_BASE_TYPE
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;
        DISPLAYCONFIG_VIDEO_OUTPUT_TECHNOLOGY baseOutputTechnology;
    } DISPLAYCONFIG_TARGET_BASE_TYPE;

    typedef struct DISPLAYCONFIG_SET_TARGET_PERSISTENCE
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;
        union
        {
            struct
            {
                UINT32 bootPersistenceOn : 1;
                UINT32 reserved : 31;
            };
            UINT32 value;
        };
    } DISPLAYCONFIG_SET_TARGET_PERSISTENCE;

    typedef struct DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;
        union
        {
            struct
            {
                UINT32 disableMonitorVirtualResolution : 1;
                UINT32 reserved : 31;
            };
            UINT32 value;
        };
    } DISPLAYCONFIG_SUPPORT_VIRTUAL_RESOLUTION;

    typedef enum _DISPLAYCONFIG_COLOR_ENCODING
    {
        DISPLAYCONFIG_COLOR_ENCODING_RGB = 0,
        DISPLAYCONFIG_COLOR_ENCODING_YCBCR444 = 1,
        DISPLAYCONFIG_COLOR_ENCODING_YCBCR422 = 2,
        DISPLAYCONFIG_COLOR_ENCODING_YCBCR420 = 3,
        DISPLAYCONFIG_COLOR_ENCODING_INTENSITY = 4,
        DISPLAYCONFIG_COLOR_ENCODING_FORCE_UINT32 = 0xFFFFFFFF
    } DISPLAYCONFIG_COLOR_ENCODING;

    typedef struct _DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;
        union
        {
            struct
            {
                UINT32 advancedColorSupported : 1;
                UINT32 advancedColorEnabled : 1;
                UINT32 wideColorEnforced : 1;
                UINT32 advancedColorForceDisabled : 1;
                UINT32 reserved : 28;
            };

            UINT32 value;
        };

        DISPLAYCONFIG_COLOR_ENCODING colorEncoding;
        UINT32 bitsPerColorChannel;
    } DISPLAYCONFIG_GET_ADVANCED_COLOR_INFO;

    typedef struct _DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;
        union
        {
            struct
            {
                UINT32 enableAdvancedColor : 1;
                UINT32 reserved : 31;
            };

            UINT32 value;
        };
    } DISPLAYCONFIG_SET_ADVANCED_COLOR_STATE;

    typedef struct _DISPLAYCONFIG_SDR_WHITE_LEVEL
    {
        DISPLAYCONFIG_DEVICE_INFO_HEADER header;

        ULONG SDRWhiteLevel;
    } DISPLAYCONFIG_SDR_WHITE_LEVEL;

#pragma endregion

#pragma region Application Family

    typedef struct _RGNDATAHEADER
    {
        DWORD dwSize;
        DWORD iType;
        DWORD nCount;
        DWORD nRgnSize;
        RECT rcBound;
    } RGNDATAHEADER, *PRGNDATAHEADER;

    typedef struct _RGNDATA
    {
        RGNDATAHEADER rdh;
        char Buffer[1];
    } RGNDATA, *PRGNDATA, *NPRGNDATA, *LPRGNDATA;

#pragma endregion

#pragma region Desktop Family

    typedef struct _ABC
    {
        int abcA;
        UINT abcB;
        int abcC;
    } ABC, *PABC, *NPABC, *LPABC;

    typedef struct _ABCFLOAT
    {
        FLOAT abcfA;
        FLOAT abcfB;
        FLOAT abcfC;
    } ABCFLOAT, *PABCFLOAT, *NPABCFLOAT, *LPABCFLOAT;

#pragma endregion

#pragma region Desktop Family

    typedef struct _OUTLINETEXTMETRICA
    {
        UINT otmSize;
        TEXTMETRICA otmTextMetrics;
        BYTE otmFiller;
        PANOSE otmPanoseNumber;
        UINT otmfsSelection;
        UINT otmfsType;
        int otmsCharSlopeRise;
        int otmsCharSlopeRun;
        int otmItalicAngle;
        UINT otmEMSquare;
        int otmAscent;
        int otmDescent;
        UINT otmLineGap;
        UINT otmsCapEmHeight;
        UINT otmsXHeight;
        RECT otmrcFontBox;
        int otmMacAscent;
        int otmMacDescent;
        UINT otmMacLineGap;
        UINT otmusMinimumPPEM;
        POINT otmptSubscriptSize;
        POINT otmptSubscriptOffset;
        POINT otmptSuperscriptSize;
        POINT otmptSuperscriptOffset;
        UINT otmsStrikeoutSize;
        int otmsStrikeoutPosition;
        int otmsUnderscoreSize;
        int otmsUnderscorePosition;
        PSTR otmpFamilyName;
        PSTR otmpFaceName;
        PSTR otmpStyleName;
        PSTR otmpFullName;
    } OUTLINETEXTMETRICA, *POUTLINETEXTMETRICA, *NPOUTLINETEXTMETRICA, *LPOUTLINETEXTMETRICA;
    typedef struct _OUTLINETEXTMETRICW
    {
        UINT otmSize;
        TEXTMETRICW otmTextMetrics;
        BYTE otmFiller;
        PANOSE otmPanoseNumber;
        UINT otmfsSelection;
        UINT otmfsType;
        int otmsCharSlopeRise;
        int otmsCharSlopeRun;
        int otmItalicAngle;
        UINT otmEMSquare;
        int otmAscent;
        int otmDescent;
        UINT otmLineGap;
        UINT otmsCapEmHeight;
        UINT otmsXHeight;
        RECT otmrcFontBox;
        int otmMacAscent;
        int otmMacDescent;
        UINT otmMacLineGap;
        UINT otmusMinimumPPEM;
        POINT otmptSubscriptSize;
        POINT otmptSubscriptOffset;
        POINT otmptSuperscriptSize;
        POINT otmptSuperscriptOffset;
        UINT otmsStrikeoutSize;
        int otmsStrikeoutPosition;
        int otmsUnderscoreSize;
        int otmsUnderscorePosition;
        PSTR otmpFamilyName;
        PSTR otmpFaceName;
        PSTR otmpStyleName;
        PSTR otmpFullName;
    } OUTLINETEXTMETRICW, *POUTLINETEXTMETRICW, *NPOUTLINETEXTMETRICW, *LPOUTLINETEXTMETRICW;

    typedef OUTLINETEXTMETRICA OUTLINETEXTMETRIC;
    typedef POUTLINETEXTMETRICA POUTLINETEXTMETRIC;
    typedef NPOUTLINETEXTMETRICA NPOUTLINETEXTMETRIC;
    typedef LPOUTLINETEXTMETRICA LPOUTLINETEXTMETRIC;

#pragma endregion

#pragma region Application Family

    typedef struct tagPOLYTEXTA
    {
        int x;
        int y;
        UINT n;
        LPCSTR lpstr;
        UINT uiFlags;
        RECT rcl;
        int* pdx;
    } POLYTEXTA, *PPOLYTEXTA, *NPPOLYTEXTA, *LPPOLYTEXTA;
    typedef struct tagPOLYTEXTW
    {
        int x;
        int y;
        UINT n;
        LPCWSTR lpstr;
        UINT uiFlags;
        RECT rcl;
        int* pdx;
    } POLYTEXTW, *PPOLYTEXTW, *NPPOLYTEXTW, *LPPOLYTEXTW;

    typedef POLYTEXTA POLYTEXT;
    typedef PPOLYTEXTA PPOLYTEXT;
    typedef NPPOLYTEXTA NPPOLYTEXT;
    typedef LPPOLYTEXTA LPPOLYTEXT;

#pragma endregion

#pragma region Desktop Family

    typedef struct _FIXED
    {
        WORD fract;
        short value;

    } FIXED;

    typedef struct _MAT2
    {
        FIXED eM11;
        FIXED eM12;
        FIXED eM21;
        FIXED eM22;
    } MAT2, *LPMAT2;

    typedef struct _GLYPHMETRICS
    {
        UINT gmBlackBoxX;
        UINT gmBlackBoxY;
        POINT gmptGlyphOrigin;
        short gmCellIncX;
        short gmCellIncY;
    } GLYPHMETRICS, *LPGLYPHMETRICS;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagPOINTFX
    {
        FIXED x;
        FIXED y;
    } POINTFX, *LPPOINTFX;

    typedef struct tagTTPOLYCURVE
    {
        WORD wType;
        WORD cpfx;
        POINTFX apfx[1];
    } TTPOLYCURVE, *LPTTPOLYCURVE;

    typedef struct tagTTPOLYGONHEADER
    {
        DWORD cb;
        DWORD dwType;
        POINTFX pfxStart;
    } TTPOLYGONHEADER, *LPTTPOLYGONHEADER;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagGCP_RESULTSA
    {
        DWORD lStructSize;
        LPSTR lpOutString;
        UINT* lpOrder;
        int* lpDx;
        int* lpCaretPos;
        LPSTR lpClass;
        LPWSTR lpGlyphs;
        UINT nGlyphs;
        int nMaxFit;
    } GCP_RESULTSA, *LPGCP_RESULTSA;
    typedef struct tagGCP_RESULTSW
    {
        DWORD lStructSize;
        LPWSTR lpOutString;
        UINT* lpOrder;
        int* lpDx;
        int* lpCaretPos;
        LPSTR lpClass;
        LPWSTR lpGlyphs;
        UINT nGlyphs;
        int nMaxFit;
    } GCP_RESULTSW, *LPGCP_RESULTSW;

    typedef GCP_RESULTSA GCP_RESULTS;
    typedef LPGCP_RESULTSA LPGCP_RESULTS;

#pragma endregion

#pragma region Desktop Family

    typedef struct _RASTERIZER_STATUS
    {
        short nSize;
        short wFlags;
        short nLanguageID;
    } RASTERIZER_STATUS, *LPRASTERIZER_STATUS;

#pragma endregion

#pragma region Application Family

    typedef struct tagPIXELFORMATDESCRIPTOR
    {
        WORD nSize;
        WORD nVersion;
        DWORD dwFlags;
        BYTE iPixelType;
        BYTE cColorBits;
        BYTE cRedBits;
        BYTE cRedShift;
        BYTE cGreenBits;
        BYTE cGreenShift;
        BYTE cBlueBits;
        BYTE cBlueShift;
        BYTE cAlphaBits;
        BYTE cAlphaShift;
        BYTE cAccumBits;
        BYTE cAccumRedBits;
        BYTE cAccumGreenBits;
        BYTE cAccumBlueBits;
        BYTE cAccumAlphaBits;
        BYTE cDepthBits;
        BYTE cStencilBits;
        BYTE cAuxBuffers;
        BYTE iLayerType;
        BYTE bReserved;
        DWORD dwLayerMask;
        DWORD dwVisibleMask;
        DWORD dwDamageMask;
    } PIXELFORMATDESCRIPTOR, *PPIXELFORMATDESCRIPTOR, *LPPIXELFORMATDESCRIPTOR;

#pragma endregion

#pragma region Desktop Family

    typedef int(__stdcall* OLDFONTENUMPROCA)(const LOGFONTA*, const TEXTMETRICA*, DWORD, LPARAM);
    typedef int(__stdcall* OLDFONTENUMPROCW)(const LOGFONTW*, const TEXTMETRICW*, DWORD, LPARAM);

    typedef OLDFONTENUMPROCA FONTENUMPROCA;
    typedef OLDFONTENUMPROCW FONTENUMPROCW;

    typedef FONTENUMPROCA FONTENUMPROC;

    typedef int(__stdcall* GOBJENUMPROC)(LPVOID, LPARAM);
    typedef void(__stdcall* LINEDDAPROC)(int, int, LPARAM);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall AddFontResourceA(LPCSTR);
    __declspec(dllimport) int __stdcall AddFontResourceW(LPCWSTR);

    __declspec(dllimport) BOOL __stdcall AnimatePalette(HPALETTE hPal, UINT iStartIndex, UINT cEntries, const PALETTEENTRY* ppe);
    __declspec(dllimport) BOOL __stdcall Arc(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
    __declspec(dllimport) BOOL __stdcall BitBlt(HDC hdc, int x, int y, int cx, int cy, HDC hdcSrc, int x1, int y1, DWORD rop);
    __declspec(dllimport) BOOL __stdcall CancelDC(HDC hdc);
    __declspec(dllimport) BOOL __stdcall Chord(HDC hdc, int x1, int y1, int x2, int y2, int x3, int y3, int x4, int y4);
    __declspec(dllimport) int __stdcall ChoosePixelFormat(HDC hdc, const PIXELFORMATDESCRIPTOR* ppfd);
    __declspec(dllimport) HMETAFILE __stdcall CloseMetaFile(HDC hdc);
    __declspec(dllimport) int __stdcall CombineRgn(HRGN hrgnDst, HRGN hrgnSrc1, HRGN hrgnSrc2, int iMode);
    __declspec(dllimport) HMETAFILE __stdcall CopyMetaFileA(HMETAFILE, LPCSTR);
    __declspec(dllimport) HMETAFILE __stdcall CopyMetaFileW(HMETAFILE, LPCWSTR);

    __declspec(dllimport) HBITMAP __stdcall CreateBitmap(int nWidth, int nHeight, UINT nPlanes, UINT nBitCount, const void* lpBits);
    __declspec(dllimport) HBITMAP __stdcall CreateBitmapIndirect(const BITMAP* pbm);
    __declspec(dllimport) HBRUSH __stdcall CreateBrushIndirect(const LOGBRUSH* plbrush);
    __declspec(dllimport) HBITMAP __stdcall CreateCompatibleBitmap(HDC hdc, int cx, int cy);
    __declspec(dllimport) HBITMAP __stdcall CreateDiscardableBitmap(HDC hdc, int cx, int cy);
    __declspec(dllimport) HDC __stdcall CreateCompatibleDC(HDC hdc);
    __declspec(dllimport) HDC __stdcall CreateDCA(LPCSTR pwszDriver, LPCSTR pwszDevice, LPCSTR pszPort, const DEVMODEA* pdm);
    __declspec(dllimport) HDC __stdcall CreateDCW(LPCWSTR pwszDriver, LPCWSTR pwszDevice, LPCWSTR pszPort, const DEVMODEW* pdm);

    __declspec(dllimport) HBITMAP
    __stdcall CreateDIBitmap(HDC hdc, const BITMAPINFOHEADER* pbmih, DWORD flInit, const void* pjBits, const BITMAPINFO* pbmi, UINT iUsage);
    __declspec(dllimport) HBRUSH __stdcall CreateDIBPatternBrush(HGLOBAL h, UINT iUsage);
    __declspec(dllimport) HBRUSH __stdcall CreateDIBPatternBrushPt(const void* lpPackedDIB, UINT iUsage);
    __declspec(dllimport) HRGN __stdcall CreateEllipticRgn(int x1, int y1, int x2, int y2);
    __declspec(dllimport) HRGN __stdcall CreateEllipticRgnIndirect(const RECT* lprect);
    __declspec(dllimport) HFONT __stdcall CreateFontIndirectA(const LOGFONTA* lplf);
    __declspec(dllimport) HFONT __stdcall CreateFontIndirectW(const LOGFONTW* lplf);

    __declspec(dllimport) HFONT __stdcall CreateFontA(int cHeight,
                                                      int cWidth,
                                                      int cEscapement,
                                                      int cOrientation,
                                                      int cWeight,
                                                      DWORD bItalic,
                                                      DWORD bUnderline,
                                                      DWORD bStrikeOut,
                                                      DWORD iCharSet,
                                                      DWORD iOutPrecision,
                                                      DWORD iClipPrecision,
                                                      DWORD iQuality,
                                                      DWORD iPitchAndFamily,
                                                      LPCSTR pszFaceName);
    __declspec(dllimport) HFONT __stdcall CreateFontW(int cHeight,
                                                      int cWidth,
                                                      int cEscapement,
                                                      int cOrientation,
                                                      int cWeight,
                                                      DWORD bItalic,
                                                      DWORD bUnderline,
                                                      DWORD bStrikeOut,
                                                      DWORD iCharSet,
                                                      DWORD iOutPrecision,
                                                      DWORD iClipPrecision,
                                                      DWORD iQuality,
                                                      DWORD iPitchAndFamily,
                                                      LPCWSTR pszFaceName);

    __declspec(dllimport) HBRUSH __stdcall CreateHatchBrush(int iHatch, COLORREF color);
    __declspec(dllimport) HDC __stdcall CreateICA(LPCSTR pszDriver, LPCSTR pszDevice, LPCSTR pszPort, const DEVMODEA* pdm);
    __declspec(dllimport) HDC __stdcall CreateICW(LPCWSTR pszDriver, LPCWSTR pszDevice, LPCWSTR pszPort, const DEVMODEW* pdm);

    __declspec(dllimport) HDC __stdcall CreateMetaFileA(LPCSTR pszFile);
    __declspec(dllimport) HDC __stdcall CreateMetaFileW(LPCWSTR pszFile);

    __declspec(dllimport) HPALETTE __stdcall CreatePalette(const LOGPALETTE* plpal);
    __declspec(dllimport) HPEN __stdcall CreatePen(int iStyle, int cWidth, COLORREF color);
    __declspec(dllimport) HPEN __stdcall CreatePenIndirect(const LOGPEN* plpen);
    __declspec(dllimport) HRGN __stdcall CreatePolyPolygonRgn(const POINT* pptl, const INT* pc, int cPoly, int iMode);
    __declspec(dllimport) HBRUSH __stdcall CreatePatternBrush(HBITMAP hbm);
    __declspec(dllimport) HRGN __stdcall CreateRectRgn(int x1, int y1, int x2, int y2);
    __declspec(dllimport) HRGN __stdcall CreateRectRgnIndirect(const RECT* lprect);
    __declspec(dllimport) HRGN __stdcall CreateRoundRectRgn(int x1, int y1, int x2, int y2, int w, int h);
    __declspec(dllimport) BOOL
    __stdcall CreateScalableFontResourceA(DWORD fdwHidden, LPCSTR lpszFont, LPCSTR lpszFile, LPCSTR lpszPath);
    __declspec(dllimport) BOOL
    __stdcall CreateScalableFontResourceW(DWORD fdwHidden, LPCWSTR lpszFont, LPCWSTR lpszFile, LPCWSTR lpszPath);

    __declspec(dllimport) HBRUSH __stdcall CreateSolidBrush(COLORREF color);

    __declspec(dllimport) BOOL __stdcall DeleteDC(HDC hdc);
    __declspec(dllimport) BOOL __stdcall DeleteMetaFile(HMETAFILE hmf);
    __declspec(dllimport) BOOL __stdcall DeleteObject(HGDIOBJ ho);
    __declspec(dllimport) int __stdcall DescribePixelFormat(HDC hdc, int iPixelFormat, UINT nBytes, LPPIXELFORMATDESCRIPTOR ppfd);

    typedef UINT(__stdcall* LPFNDEVMODE)(HWND, HMODULE, LPDEVMODE, LPSTR, LPSTR, LPDEVMODE, LPSTR, UINT);

    typedef DWORD(__stdcall* LPFNDEVCAPS)(LPSTR, LPSTR, UINT, LPSTR, LPDEVMODE);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall DeviceCapabilitiesA(LPCSTR pDevice, LPCSTR pPort, WORD fwCapability, LPSTR pOutput, const DEVMODEA* pDevMode);
    __declspec(dllimport) int __stdcall DeviceCapabilitiesW(
    LPCWSTR pDevice, LPCWSTR pPort, WORD fwCapability, LPWSTR pOutput, const DEVMODEW* pDevMode);

    __declspec(dllimport) int __stdcall DrawEscape(HDC hdc, int iEscape, int cjIn, LPCSTR lpIn);

    __declspec(dllimport) BOOL __stdcall Ellipse(HDC hdc, int left, int top, int right, int bottom);

    __declspec(dllimport) int __stdcall EnumFontFamiliesExA(HDC hdc, LPLOGFONTA lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam, DWORD dwFlags);
    __declspec(dllimport) int __stdcall EnumFontFamiliesExW(HDC hdc, LPLOGFONTW lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam, DWORD dwFlags);

    __declspec(dllimport) int __stdcall EnumFontFamiliesA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
    __declspec(dllimport) int __stdcall EnumFontFamiliesW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);

    __declspec(dllimport) int __stdcall EnumFontsA(HDC hdc, LPCSTR lpLogfont, FONTENUMPROCA lpProc, LPARAM lParam);
    __declspec(dllimport) int __stdcall EnumFontsW(HDC hdc, LPCWSTR lpLogfont, FONTENUMPROCW lpProc, LPARAM lParam);

    __declspec(dllimport) int __stdcall EnumObjects(HDC hdc, int nType, GOBJENUMPROC lpFunc, LPARAM lParam);

    __declspec(dllimport) BOOL __stdcall EqualRgn(HRGN hrgn1, HRGN hrgn2);
    __declspec(dllimport) int __stdcall Escape(HDC hdc, int iEscape, int cjIn, LPCSTR pvIn, LPVOID pvOut);
    __declspec(dllimport) int __stdcall ExtEscape(HDC hdc, int iEscape, int cjInput, LPCSTR lpInData, int cjOutput, LPSTR lpOutData);
    __declspec(dllimport) int __stdcall ExcludeClipRect(HDC hdc, int left, int top, int right, int bottom);
    __declspec(dllimport) HRGN __stdcall ExtCreateRegion(const XFORM* lpx, DWORD nCount, const RGNDATA* lpData);
    __declspec(dllimport) BOOL __stdcall ExtFloodFill(HDC hdc, int x, int y, COLORREF color, UINT type);
    __declspec(dllimport) BOOL __stdcall FillRgn(HDC hdc, HRGN hrgn, HBRUSH hbr);
    __declspec(dllimport) BOOL __stdcall FloodFill(HDC hdc, int x, int y, COLORREF color);
    __declspec(dllimport) BOOL __stdcall FrameRgn(HDC hdc, HRGN hrgn, HBRUSH hbr, int w, int h);
    __declspec(dllimport) int __stdcall GetROP2(HDC hdc);
    __declspec(dllimport) BOOL __stdcall GetAspectRatioFilterEx(HDC hdc, LPSIZE lpsize);
    __declspec(dllimport) COLORREF __stdcall GetBkColor(HDC hdc);

    __declspec(dllimport) COLORREF __stdcall GetDCBrushColor(HDC hdc);
    __declspec(dllimport) COLORREF __stdcall GetDCPenColor(HDC hdc);

    __declspec(dllimport) int __stdcall GetBkMode(HDC hdc);

    __declspec(dllimport) LONG __stdcall GetBitmapBits(HBITMAP hbit, LONG cb, LPVOID lpvBits);

    __declspec(dllimport) BOOL __stdcall GetBitmapDimensionEx(HBITMAP hbit, LPSIZE lpsize);
    __declspec(dllimport) UINT __stdcall GetBoundsRect(HDC hdc, LPRECT lprect, UINT flags);

    __declspec(dllimport) BOOL __stdcall GetBrushOrgEx(HDC hdc, LPPOINT lppt);

    __declspec(dllimport) BOOL __stdcall GetCharWidthA(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
    __declspec(dllimport) BOOL __stdcall GetCharWidthW(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);

    __declspec(dllimport) BOOL __stdcall GetCharWidth32A(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);
    __declspec(dllimport) BOOL __stdcall GetCharWidth32W(HDC hdc, UINT iFirst, UINT iLast, LPINT lpBuffer);

    __declspec(dllimport) BOOL __stdcall GetCharWidthFloatA(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);
    __declspec(dllimport) BOOL __stdcall GetCharWidthFloatW(HDC hdc, UINT iFirst, UINT iLast, PFLOAT lpBuffer);

    __declspec(dllimport) BOOL __stdcall GetCharABCWidthsA(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC);
    __declspec(dllimport) BOOL __stdcall GetCharABCWidthsW(HDC hdc, UINT wFirst, UINT wLast, LPABC lpABC);

    __declspec(dllimport) BOOL __stdcall GetCharABCWidthsFloatA(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);
    __declspec(dllimport) BOOL __stdcall GetCharABCWidthsFloatW(HDC hdc, UINT iFirst, UINT iLast, LPABCFLOAT lpABC);

    __declspec(dllimport) int __stdcall GetClipBox(HDC hdc, LPRECT lprect);
    __declspec(dllimport) int __stdcall GetClipRgn(HDC hdc, HRGN hrgn);
    __declspec(dllimport) int __stdcall GetMetaRgn(HDC hdc, HRGN hrgn);
    __declspec(dllimport) HGDIOBJ __stdcall GetCurrentObject(HDC hdc, UINT type);
    __declspec(dllimport) BOOL __stdcall GetCurrentPositionEx(HDC hdc, LPPOINT lppt);
    __declspec(dllimport) int __stdcall GetDeviceCaps(HDC hdc, int index);
    __declspec(dllimport) int __stdcall GetDIBits(HDC hdc, HBITMAP hbm, UINT start, UINT cLines, LPVOID lpvBits, LPBITMAPINFO lpbmi, UINT usage);

    __declspec(dllimport) DWORD __stdcall GetFontData(HDC hdc, DWORD dwTable, DWORD dwOffset, PVOID pvBuffer, DWORD cjBuffer);

    __declspec(dllimport) DWORD
    __stdcall GetGlyphOutlineA(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2* lpmat2);
    __declspec(dllimport) DWORD
    __stdcall GetGlyphOutlineW(HDC hdc, UINT uChar, UINT fuFormat, LPGLYPHMETRICS lpgm, DWORD cjBuffer, LPVOID pvBuffer, const MAT2* lpmat2);

    __declspec(dllimport) int __stdcall GetGraphicsMode(HDC hdc);
    __declspec(dllimport) int __stdcall GetMapMode(HDC hdc);
    __declspec(dllimport) UINT __stdcall GetMetaFileBitsEx(HMETAFILE hMF, UINT cbBuffer, LPVOID lpData);
    __declspec(dllimport) HMETAFILE __stdcall GetMetaFileA(LPCSTR lpName);
    __declspec(dllimport) HMETAFILE __stdcall GetMetaFileW(LPCWSTR lpName);

    __declspec(dllimport) COLORREF __stdcall GetNearestColor(HDC hdc, COLORREF color);
    __declspec(dllimport) UINT __stdcall GetNearestPaletteIndex(HPALETTE h, COLORREF color);
    __declspec(dllimport) DWORD __stdcall GetObjectType(HGDIOBJ h);

    __declspec(dllimport) UINT __stdcall GetOutlineTextMetricsA(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICA potm);
    __declspec(dllimport) UINT __stdcall GetOutlineTextMetricsW(HDC hdc, UINT cjCopy, LPOUTLINETEXTMETRICW potm);

    __declspec(dllimport) UINT __stdcall GetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries);
    __declspec(dllimport) COLORREF __stdcall GetPixel(HDC hdc, int x, int y);
    __declspec(dllimport) int __stdcall GetPixelFormat(HDC hdc);
    __declspec(dllimport) int __stdcall GetPolyFillMode(HDC hdc);
    __declspec(dllimport) BOOL __stdcall GetRasterizerCaps(LPRASTERIZER_STATUS lpraststat, UINT cjBytes);

    __declspec(dllimport) int __stdcall GetRandomRgn(HDC hdc, HRGN hrgn, INT i);
    __declspec(dllimport) DWORD __stdcall GetRegionData(HRGN hrgn, DWORD nCount, LPRGNDATA lpRgnData);
    __declspec(dllimport) int __stdcall GetRgnBox(HRGN hrgn, LPRECT lprc);
    __declspec(dllimport) HGDIOBJ __stdcall GetStockObject(int i);
    __declspec(dllimport) int __stdcall GetStretchBltMode(HDC hdc);
    __declspec(dllimport) UINT __stdcall GetSystemPaletteEntries(HDC hdc, UINT iStart, UINT cEntries, LPPALETTEENTRY pPalEntries);

    __declspec(dllimport) UINT __stdcall GetSystemPaletteUse(HDC hdc);
    __declspec(dllimport) int __stdcall GetTextCharacterExtra(HDC hdc);
    __declspec(dllimport) UINT __stdcall GetTextAlign(HDC hdc);
    __declspec(dllimport) COLORREF __stdcall GetTextColor(HDC hdc);

    __declspec(dllimport) BOOL __stdcall GetTextExtentPointA(HDC hdc, LPCSTR lpString, int c, LPSIZE lpsz);
    __declspec(dllimport) BOOL __stdcall GetTextExtentPointW(HDC hdc, LPCWSTR lpString, int c, LPSIZE lpsz);

    __declspec(dllimport) BOOL __stdcall GetTextExtentPoint32A(HDC hdc, LPCSTR lpString, int c, LPSIZE psizl);
    __declspec(dllimport) BOOL __stdcall GetTextExtentPoint32W(HDC hdc, LPCWSTR lpString, int c, LPSIZE psizl);

    __declspec(dllimport) BOOL
    __stdcall GetTextExtentExPointA(HDC hdc, LPCSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize);
    __declspec(dllimport) BOOL
    __stdcall GetTextExtentExPointW(HDC hdc, LPCWSTR lpszString, int cchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize);

    __declspec(dllimport) int __stdcall GetTextCharset(HDC hdc);
    __declspec(dllimport) int __stdcall GetTextCharsetInfo(HDC hdc, LPFONTSIGNATURE lpSig, DWORD dwFlags);
    __declspec(dllimport) BOOL __stdcall TranslateCharsetInfo(DWORD* lpSrc, LPCHARSETINFO lpCs, DWORD dwFlags);
    __declspec(dllimport) DWORD __stdcall GetFontLanguageInfo(HDC hdc);
    __declspec(dllimport) DWORD
    __stdcall GetCharacterPlacementA(HDC hdc, LPCSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSA lpResults, DWORD dwFlags);
    __declspec(dllimport) DWORD
    __stdcall GetCharacterPlacementW(HDC hdc, LPCWSTR lpString, int nCount, int nMexExtent, LPGCP_RESULTSW lpResults, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagWCRANGE
    {
        WCHAR wcLow;
        USHORT cGlyphs;
    } WCRANGE, *PWCRANGE, *LPWCRANGE;

    typedef struct tagGLYPHSET
    {
        DWORD cbThis;
        DWORD flAccel;
        DWORD cGlyphsSupported;
        DWORD cRanges;
        WCRANGE ranges[1];
    } GLYPHSET, *PGLYPHSET, *LPGLYPHSET;

    __declspec(dllimport) DWORD __stdcall GetFontUnicodeRanges(HDC hdc, LPGLYPHSET lpgs);
    __declspec(dllimport) DWORD __stdcall GetGlyphIndicesA(HDC hdc, LPCSTR lpstr, int c, LPWORD pgi, DWORD fl);
    __declspec(dllimport) DWORD __stdcall GetGlyphIndicesW(HDC hdc, LPCWSTR lpstr, int c, LPWORD pgi, DWORD fl);

    __declspec(dllimport) BOOL __stdcall GetTextExtentPointI(HDC hdc, LPWORD pgiIn, int cgi, LPSIZE psize);
    __declspec(dllimport) BOOL
    __stdcall GetTextExtentExPointI(HDC hdc, LPWORD lpwszString, int cwchString, int nMaxExtent, LPINT lpnFit, LPINT lpnDx, LPSIZE lpSize);

    __declspec(dllimport) BOOL __stdcall GetCharWidthI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPINT piWidths);

    __declspec(dllimport) BOOL __stdcall GetCharABCWidthsI(HDC hdc, UINT giFirst, UINT cgi, LPWORD pgi, LPABC pabc);

    typedef struct tagDESIGNVECTOR
    {
        DWORD dvReserved;
        DWORD dvNumAxes;
        LONG dvValues[16];
    } DESIGNVECTOR, *PDESIGNVECTOR, *LPDESIGNVECTOR;

    __declspec(dllimport) int __stdcall AddFontResourceExA(LPCSTR name, DWORD fl, PVOID res);
    __declspec(dllimport) int __stdcall AddFontResourceExW(LPCWSTR name, DWORD fl, PVOID res);

    __declspec(dllimport) BOOL __stdcall RemoveFontResourceExA(LPCSTR name, DWORD fl, PVOID pdv);
    __declspec(dllimport) BOOL __stdcall RemoveFontResourceExW(LPCWSTR name, DWORD fl, PVOID pdv);

    __declspec(dllimport) HANDLE __stdcall AddFontMemResourceEx(PVOID pFileView, DWORD cjSize, PVOID pvResrved, DWORD* pNumFonts);

    __declspec(dllimport) BOOL __stdcall RemoveFontMemResourceEx(HANDLE h);

    typedef struct tagAXISINFOA
    {
        LONG axMinValue;
        LONG axMaxValue;
        BYTE axAxisName[16];
    } AXISINFOA, *PAXISINFOA, *LPAXISINFOA;
    typedef struct tagAXISINFOW
    {
        LONG axMinValue;
        LONG axMaxValue;
        WCHAR axAxisName[16];
    } AXISINFOW, *PAXISINFOW, *LPAXISINFOW;

    typedef AXISINFOA AXISINFO;
    typedef PAXISINFOA PAXISINFO;
    typedef LPAXISINFOA LPAXISINFO;

    typedef struct tagAXESLISTA
    {
        DWORD axlReserved;
        DWORD axlNumAxes;
        AXISINFOA axlAxisInfo[16];
    } AXESLISTA, *PAXESLISTA, *LPAXESLISTA;
    typedef struct tagAXESLISTW
    {
        DWORD axlReserved;
        DWORD axlNumAxes;
        AXISINFOW axlAxisInfo[16];
    } AXESLISTW, *PAXESLISTW, *LPAXESLISTW;

    typedef AXESLISTA AXESLIST;
    typedef PAXESLISTA PAXESLIST;
    typedef LPAXESLISTA LPAXESLIST;

    typedef struct tagENUMLOGFONTEXDVA
    {
        ENUMLOGFONTEXA elfEnumLogfontEx;
        DESIGNVECTOR elfDesignVector;
    } ENUMLOGFONTEXDVA, *PENUMLOGFONTEXDVA, *LPENUMLOGFONTEXDVA;
    typedef struct tagENUMLOGFONTEXDVW
    {
        ENUMLOGFONTEXW elfEnumLogfontEx;
        DESIGNVECTOR elfDesignVector;
    } ENUMLOGFONTEXDVW, *PENUMLOGFONTEXDVW, *LPENUMLOGFONTEXDVW;

    typedef ENUMLOGFONTEXDVA ENUMLOGFONTEXDV;
    typedef PENUMLOGFONTEXDVA PENUMLOGFONTEXDV;
    typedef LPENUMLOGFONTEXDVA LPENUMLOGFONTEXDV;

    __declspec(dllimport) HFONT __stdcall CreateFontIndirectExA(const ENUMLOGFONTEXDVA*);
    __declspec(dllimport) HFONT __stdcall CreateFontIndirectExW(const ENUMLOGFONTEXDVW*);

    typedef struct tagENUMTEXTMETRICA
    {
        NEWTEXTMETRICEXA etmNewTextMetricEx;
        AXESLISTA etmAxesList;
    } ENUMTEXTMETRICA, *PENUMTEXTMETRICA, *LPENUMTEXTMETRICA;
    typedef struct tagENUMTEXTMETRICW
    {
        NEWTEXTMETRICEXW etmNewTextMetricEx;
        AXESLISTW etmAxesList;
    } ENUMTEXTMETRICW, *PENUMTEXTMETRICW, *LPENUMTEXTMETRICW;

    typedef ENUMTEXTMETRICA ENUMTEXTMETRIC;
    typedef PENUMTEXTMETRICA PENUMTEXTMETRIC;
    typedef LPENUMTEXTMETRICA LPENUMTEXTMETRIC;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GetViewportExtEx(HDC hdc, LPSIZE lpsize);
    __declspec(dllimport) BOOL __stdcall GetViewportOrgEx(HDC hdc, LPPOINT lppoint);
    __declspec(dllimport) BOOL __stdcall GetWindowExtEx(HDC hdc, LPSIZE lpsize);
    __declspec(dllimport) BOOL __stdcall GetWindowOrgEx(HDC hdc, LPPOINT lppoint);

    __declspec(dllimport) int __stdcall IntersectClipRect(HDC hdc, int left, int top, int right, int bottom);
    __declspec(dllimport) BOOL __stdcall InvertRgn(HDC hdc, HRGN hrgn);
    __declspec(dllimport) BOOL __stdcall LineDDA(int xStart, int yStart, int xEnd, int yEnd, LINEDDAPROC lpProc, LPARAM data);
    __declspec(dllimport) BOOL __stdcall LineTo(HDC hdc, int x, int y);
    __declspec(dllimport) BOOL __stdcall MaskBlt(
    HDC hdcDest, int xDest, int yDest, int width, int height, HDC hdcSrc, int xSrc, int ySrc, HBITMAP hbmMask, int xMask, int yMask, DWORD rop);
    __declspec(dllimport) BOOL __stdcall PlgBlt(
    HDC hdcDest, const POINT* lpPoint, HDC hdcSrc, int xSrc, int ySrc, int width, int height, HBITMAP hbmMask, int xMask, int yMask);

    __declspec(dllimport) int __stdcall OffsetClipRgn(HDC hdc, int x, int y);
    __declspec(dllimport) int __stdcall OffsetRgn(HRGN hrgn, int x, int y);
    __declspec(dllimport) BOOL __stdcall PatBlt(HDC hdc, int x, int y, int w, int h, DWORD rop);
    __declspec(dllimport) BOOL
    __stdcall Pie(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
    __declspec(dllimport) BOOL __stdcall PlayMetaFile(HDC hdc, HMETAFILE hmf);
    __declspec(dllimport) BOOL __stdcall PaintRgn(HDC hdc, HRGN hrgn);
    __declspec(dllimport) BOOL __stdcall PolyPolygon(HDC hdc, const POINT* apt, const INT* asz, int csz);
    __declspec(dllimport) BOOL __stdcall PtInRegion(HRGN hrgn, int x, int y);
    __declspec(dllimport) BOOL __stdcall PtVisible(HDC hdc, int x, int y);
    __declspec(dllimport) BOOL __stdcall RectInRegion(HRGN hrgn, const RECT* lprect);
    __declspec(dllimport) BOOL __stdcall RectVisible(HDC hdc, const RECT* lprect);
    __declspec(dllimport) BOOL __stdcall Rectangle(HDC hdc, int left, int top, int right, int bottom);
    __declspec(dllimport) BOOL __stdcall RestoreDC(HDC hdc, int nSavedDC);
    __declspec(dllimport) HDC __stdcall ResetDCA(HDC hdc, const DEVMODEA* lpdm);
    __declspec(dllimport) HDC __stdcall ResetDCW(HDC hdc, const DEVMODEW* lpdm);

    __declspec(dllimport) UINT __stdcall RealizePalette(HDC hdc);
    __declspec(dllimport) BOOL __stdcall RemoveFontResourceA(LPCSTR lpFileName);
    __declspec(dllimport) BOOL __stdcall RemoveFontResourceW(LPCWSTR lpFileName);

    __declspec(dllimport) BOOL __stdcall RoundRect(HDC hdc, int left, int top, int right, int bottom, int width, int height);
    __declspec(dllimport) BOOL __stdcall ResizePalette(HPALETTE hpal, UINT n);

    __declspec(dllimport) int __stdcall SaveDC(HDC hdc);
    __declspec(dllimport) int __stdcall SelectClipRgn(HDC hdc, HRGN hrgn);
    __declspec(dllimport) int __stdcall ExtSelectClipRgn(HDC hdc, HRGN hrgn, int mode);
    __declspec(dllimport) int __stdcall SetMetaRgn(HDC hdc);
    __declspec(dllimport) HGDIOBJ __stdcall SelectObject(HDC hdc, HGDIOBJ h);
    __declspec(dllimport) HPALETTE __stdcall SelectPalette(HDC hdc, HPALETTE hPal, BOOL bForceBkgd);
    __declspec(dllimport) COLORREF __stdcall SetBkColor(HDC hdc, COLORREF color);

    __declspec(dllimport) COLORREF __stdcall SetDCBrushColor(HDC hdc, COLORREF color);
    __declspec(dllimport) COLORREF __stdcall SetDCPenColor(HDC hdc, COLORREF color);

    __declspec(dllimport) int __stdcall SetBkMode(HDC hdc, int mode);

    __declspec(dllimport) LONG __stdcall SetBitmapBits(HBITMAP hbm, DWORD cb, const void* pvBits);

    __declspec(dllimport) UINT __stdcall SetBoundsRect(HDC hdc, const RECT* lprect, UINT flags);
    __declspec(dllimport) int __stdcall SetDIBits(
    HDC hdc, HBITMAP hbm, UINT start, UINT cLines, const void* lpBits, const BITMAPINFO* lpbmi, UINT ColorUse);
    __declspec(dllimport) int __stdcall SetDIBitsToDevice(
    HDC hdc, int xDest, int yDest, DWORD w, DWORD h, int xSrc, int ySrc, UINT StartScan, UINT cLines, const void* lpvBits, const BITMAPINFO* lpbmi, UINT ColorUse);
    __declspec(dllimport) DWORD __stdcall SetMapperFlags(HDC hdc, DWORD flags);
    __declspec(dllimport) int __stdcall SetGraphicsMode(HDC hdc, int iMode);
    __declspec(dllimport) int __stdcall SetMapMode(HDC hdc, int iMode);

    __declspec(dllimport) DWORD __stdcall SetLayout(HDC hdc, DWORD l);
    __declspec(dllimport) DWORD __stdcall GetLayout(HDC hdc);

    __declspec(dllimport) HMETAFILE __stdcall SetMetaFileBitsEx(UINT cbBuffer, const BYTE* lpData);
    __declspec(dllimport) UINT
    __stdcall SetPaletteEntries(HPALETTE hpal, UINT iStart, UINT cEntries, const PALETTEENTRY* pPalEntries);
    __declspec(dllimport) COLORREF __stdcall SetPixel(HDC hdc, int x, int y, COLORREF color);
    __declspec(dllimport) BOOL __stdcall SetPixelV(HDC hdc, int x, int y, COLORREF color);
    __declspec(dllimport) BOOL __stdcall SetPixelFormat(HDC hdc, int format, const PIXELFORMATDESCRIPTOR* ppfd);
    __declspec(dllimport) int __stdcall SetPolyFillMode(HDC hdc, int mode);
    __declspec(dllimport) BOOL __stdcall StretchBlt(
    HDC hdcDest, int xDest, int yDest, int wDest, int hDest, HDC hdcSrc, int xSrc, int ySrc, int wSrc, int hSrc, DWORD rop);
    __declspec(dllimport) BOOL __stdcall SetRectRgn(HRGN hrgn, int left, int top, int right, int bottom);
    __declspec(dllimport) int __stdcall StretchDIBits(HDC hdc,
                                                      int xDest,
                                                      int yDest,
                                                      int DestWidth,
                                                      int DestHeight,
                                                      int xSrc,
                                                      int ySrc,
                                                      int SrcWidth,
                                                      int SrcHeight,
                                                      const void* lpBits,
                                                      const BITMAPINFO* lpbmi,
                                                      UINT iUsage,
                                                      DWORD rop);
    __declspec(dllimport) int __stdcall SetROP2(HDC hdc, int rop2);
    __declspec(dllimport) int __stdcall SetStretchBltMode(HDC hdc, int mode);
    __declspec(dllimport) UINT __stdcall SetSystemPaletteUse(HDC hdc, UINT use);
    __declspec(dllimport) int __stdcall SetTextCharacterExtra(HDC hdc, int extra);
    __declspec(dllimport) COLORREF __stdcall SetTextColor(HDC hdc, COLORREF color);
    __declspec(dllimport) UINT __stdcall SetTextAlign(HDC hdc, UINT align);
    __declspec(dllimport) BOOL __stdcall SetTextJustification(HDC hdc, int extra, int count);
    __declspec(dllimport) BOOL __stdcall UpdateColors(HDC hdc);

#pragma endregion

#pragma region Application Family

    typedef USHORT COLOR16;

    typedef struct _TRIVERTEX
    {
        LONG x;
        LONG y;
        COLOR16 Red;
        COLOR16 Green;
        COLOR16 Blue;
        COLOR16 Alpha;
    } TRIVERTEX, *PTRIVERTEX, *LPTRIVERTEX;

#pragma endregion

#pragma region Desktop Family

    typedef struct _GRADIENT_TRIANGLE
    {
        ULONG Vertex1;
        ULONG Vertex2;
        ULONG Vertex3;
    } GRADIENT_TRIANGLE, *PGRADIENT_TRIANGLE, *LPGRADIENT_TRIANGLE;

    typedef struct _GRADIENT_RECT
    {
        ULONG UpperLeft;
        ULONG LowerRight;
    } GRADIENT_RECT, *PGRADIENT_RECT, *LPGRADIENT_RECT;

#pragma endregion

#pragma region Application Family

    typedef struct _BLENDFUNCTION
    {
        BYTE BlendOp;
        BYTE BlendFlags;
        BYTE SourceConstantAlpha;
        BYTE AlphaFormat;
    } BLENDFUNCTION, *PBLENDFUNCTION;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall AlphaBlend(
    HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);

    __declspec(dllimport) BOOL __stdcall TransparentBlt(
    HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent);

    __declspec(dllimport) BOOL
    __stdcall GradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nMesh, ULONG ulMode);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GdiAlphaBlend(
    HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, BLENDFUNCTION ftn);

    __declspec(dllimport) BOOL __stdcall GdiTransparentBlt(
    HDC hdcDest, int xoriginDest, int yoriginDest, int wDest, int hDest, HDC hdcSrc, int xoriginSrc, int yoriginSrc, int wSrc, int hSrc, UINT crTransparent);

    __declspec(dllimport) BOOL
    __stdcall GdiGradientFill(HDC hdc, PTRIVERTEX pVertex, ULONG nVertex, PVOID pMesh, ULONG nCount, ULONG ulMode);

    __declspec(dllimport) BOOL __stdcall PlayMetaFileRecord(HDC hdc, LPHANDLETABLE lpHandleTable, LPMETARECORD lpMR, UINT noObjs);

    typedef int(__stdcall* MFENUMPROC)(HDC hdc, HANDLETABLE* lpht, METARECORD* lpMR, int nObj, LPARAM param);
    __declspec(dllimport) BOOL __stdcall EnumMetaFile(HDC hdc, HMETAFILE hmf, MFENUMPROC proc, LPARAM param);

    typedef int(__stdcall* ENHMFENUMPROC)(HDC hdc, HANDLETABLE* lpht, const ENHMETARECORD* lpmr, int nHandles, LPARAM data);

    __declspec(dllimport) HENHMETAFILE __stdcall CloseEnhMetaFile(HDC hdc);
    __declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileA(HENHMETAFILE hEnh, LPCSTR lpFileName);
    __declspec(dllimport) HENHMETAFILE __stdcall CopyEnhMetaFileW(HENHMETAFILE hEnh, LPCWSTR lpFileName);

    __declspec(dllimport) HDC __stdcall CreateEnhMetaFileA(HDC hdc, LPCSTR lpFilename, const RECT* lprc, LPCSTR lpDesc);
    __declspec(dllimport) HDC __stdcall CreateEnhMetaFileW(HDC hdc, LPCWSTR lpFilename, const RECT* lprc, LPCWSTR lpDesc);

    __declspec(dllimport) BOOL __stdcall DeleteEnhMetaFile(HENHMETAFILE hmf);
    __declspec(dllimport) BOOL
    __stdcall EnumEnhMetaFile(HDC hdc, HENHMETAFILE hmf, ENHMFENUMPROC proc, LPVOID param, const RECT* lpRect);
    __declspec(dllimport) HENHMETAFILE __stdcall GetEnhMetaFileA(LPCSTR lpName);
    __declspec(dllimport) HENHMETAFILE __stdcall GetEnhMetaFileW(LPCWSTR lpName);

    __declspec(dllimport) UINT __stdcall GetEnhMetaFileBits(HENHMETAFILE hEMF, UINT nSize, LPBYTE lpData);
    __declspec(dllimport) UINT __stdcall GetEnhMetaFileDescriptionA(HENHMETAFILE hemf, UINT cchBuffer, LPSTR lpDescription);
    __declspec(dllimport) UINT __stdcall GetEnhMetaFileDescriptionW(HENHMETAFILE hemf, UINT cchBuffer, LPWSTR lpDescription);

    __declspec(dllimport) UINT __stdcall GetEnhMetaFileHeader(HENHMETAFILE hemf, UINT nSize, LPENHMETAHEADER lpEnhMetaHeader);
    __declspec(dllimport) UINT
    __stdcall GetEnhMetaFilePaletteEntries(HENHMETAFILE hemf, UINT nNumEntries, LPPALETTEENTRY lpPaletteEntries);

    __declspec(dllimport) UINT __stdcall GetEnhMetaFilePixelFormat(HENHMETAFILE hemf, UINT cbBuffer, PIXELFORMATDESCRIPTOR* ppfd);
    __declspec(dllimport) UINT
    __stdcall GetWinMetaFileBits(HENHMETAFILE hemf, UINT cbData16, LPBYTE pData16, INT iMapMode, HDC hdcRef);
    __declspec(dllimport) BOOL __stdcall PlayEnhMetaFile(HDC hdc, HENHMETAFILE hmf, const RECT* lprect);
    __declspec(dllimport) BOOL __stdcall PlayEnhMetaFileRecord(HDC hdc, LPHANDLETABLE pht, const ENHMETARECORD* pmr, UINT cht);

    __declspec(dllimport) HENHMETAFILE __stdcall SetEnhMetaFileBits(UINT nSize, const BYTE* pb);

    __declspec(dllimport) HENHMETAFILE
    __stdcall SetWinMetaFileBits(UINT nSize, const BYTE* lpMeta16Data, HDC hdcRef, const METAFILEPICT* lpMFP);
    __declspec(dllimport) BOOL __stdcall GdiComment(HDC hdc, UINT nSize, const BYTE* lpData);

    __declspec(dllimport) BOOL __stdcall GetTextMetricsA(HDC hdc, LPTEXTMETRICA lptm);
    __declspec(dllimport) BOOL __stdcall GetTextMetricsW(HDC hdc, LPTEXTMETRICW lptm);

    __inline BOOL GetTextMetrics(HDC hdc, LPTEXTMETRIC lptm)
    {
        return GetTextMetricsA(hdc, lptm);
    }

    typedef struct tagDIBSECTION
    {
        BITMAP dsBm;
        BITMAPINFOHEADER dsBmih;
        DWORD dsBitfields[3];
        HANDLE dshSection;
        DWORD dsOffset;
    } DIBSECTION, *LPDIBSECTION, *PDIBSECTION;

    __declspec(dllimport) BOOL __stdcall AngleArc(HDC hdc, int x, int y, DWORD r, FLOAT StartAngle, FLOAT SweepAngle);
    __declspec(dllimport) BOOL __stdcall PolyPolyline(HDC hdc, const POINT* apt, const DWORD* asz, DWORD csz);
    __declspec(dllimport) BOOL __stdcall GetWorldTransform(HDC hdc, LPXFORM lpxf);
    __declspec(dllimport) BOOL __stdcall SetWorldTransform(HDC hdc, const XFORM* lpxf);
    __declspec(dllimport) BOOL __stdcall ModifyWorldTransform(HDC hdc, const XFORM* lpxf, DWORD mode);
    __declspec(dllimport) BOOL __stdcall CombineTransform(LPXFORM lpxfOut, const XFORM* lpxf1, const XFORM* lpxf2);

    __declspec(dllimport) HBITMAP __stdcall CreateDIBSection(HDC hdc,
                                                             const BITMAPINFO* pbmi,
                                                             UINT usage,

                                                             void** ppvBits,
                                                             HANDLE hSection,
                                                             DWORD offset);

    __declspec(dllimport) UINT __stdcall GetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, RGBQUAD* prgbq);
    __declspec(dllimport) UINT __stdcall SetDIBColorTable(HDC hdc, UINT iStart, UINT cEntries, const RGBQUAD* prgbq);

    typedef struct tagCOLORADJUSTMENT
    {
        WORD caSize;
        WORD caFlags;
        WORD caIlluminantIndex;
        WORD caRedGamma;
        WORD caGreenGamma;
        WORD caBlueGamma;
        WORD caReferenceBlack;
        WORD caReferenceWhite;
        SHORT caContrast;
        SHORT caBrightness;
        SHORT caColorfulness;
        SHORT caRedGreenTint;
    } COLORADJUSTMENT, *PCOLORADJUSTMENT, *LPCOLORADJUSTMENT;

    __declspec(dllimport) BOOL __stdcall SetColorAdjustment(HDC hdc, const COLORADJUSTMENT* lpca);
    __declspec(dllimport) BOOL __stdcall GetColorAdjustment(HDC hdc, LPCOLORADJUSTMENT lpca);
    __declspec(dllimport) HPALETTE __stdcall CreateHalftonePalette(HDC hdc);

    typedef BOOL(__stdcall* ABORTPROC)(HDC, int);

    typedef struct _DOCINFOA
    {
        int cbSize;
        LPCSTR lpszDocName;
        LPCSTR lpszOutput;

        LPCSTR lpszDatatype;
        DWORD fwType;
    } DOCINFOA, *LPDOCINFOA;
    typedef struct _DOCINFOW
    {
        int cbSize;
        LPCWSTR lpszDocName;
        LPCWSTR lpszOutput;

        LPCWSTR lpszDatatype;
        DWORD fwType;
    } DOCINFOW, *LPDOCINFOW;

    typedef DOCINFOA DOCINFO;
    typedef LPDOCINFOA LPDOCINFO;

    __declspec(dllimport) int __stdcall StartDocA(HDC hdc, const DOCINFOA* lpdi);
    __declspec(dllimport) int __stdcall StartDocW(HDC hdc, const DOCINFOW* lpdi);

    __declspec(dllimport) int __stdcall EndDoc(HDC hdc);
    __declspec(dllimport) int __stdcall StartPage(HDC hdc);
    __declspec(dllimport) int __stdcall EndPage(HDC hdc);
    __declspec(dllimport) int __stdcall AbortDoc(HDC hdc);
    __declspec(dllimport) int __stdcall SetAbortProc(HDC hdc, ABORTPROC proc);

    __declspec(dllimport) BOOL __stdcall AbortPath(HDC hdc);
    __declspec(dllimport) BOOL
    __stdcall ArcTo(HDC hdc, int left, int top, int right, int bottom, int xr1, int yr1, int xr2, int yr2);
    __declspec(dllimport) BOOL __stdcall BeginPath(HDC hdc);
    __declspec(dllimport) BOOL __stdcall CloseFigure(HDC hdc);
    __declspec(dllimport) BOOL __stdcall EndPath(HDC hdc);
    __declspec(dllimport) BOOL __stdcall FillPath(HDC hdc);
    __declspec(dllimport) BOOL __stdcall FlattenPath(HDC hdc);
    __declspec(dllimport) int __stdcall GetPath(HDC hdc, LPPOINT apt, LPBYTE aj, int cpt);
    __declspec(dllimport) HRGN __stdcall PathToRegion(HDC hdc);
    __declspec(dllimport) BOOL __stdcall PolyDraw(HDC hdc, const POINT* apt, const BYTE* aj, int cpt);
    __declspec(dllimport) BOOL __stdcall SelectClipPath(HDC hdc, int mode);
    __declspec(dllimport) int __stdcall SetArcDirection(HDC hdc, int dir);
    __declspec(dllimport) BOOL __stdcall SetMiterLimit(HDC hdc, FLOAT limit, PFLOAT old);
    __declspec(dllimport) BOOL __stdcall StrokeAndFillPath(HDC hdc);
    __declspec(dllimport) BOOL __stdcall StrokePath(HDC hdc);
    __declspec(dllimport) BOOL __stdcall WidenPath(HDC hdc);
    __declspec(dllimport) HPEN
    __stdcall ExtCreatePen(DWORD iPenStyle, DWORD cWidth, const LOGBRUSH* plbrush, DWORD cStyle, const DWORD* pstyle);
    __declspec(dllimport) BOOL __stdcall GetMiterLimit(HDC hdc, PFLOAT plimit);
    __declspec(dllimport) int __stdcall GetArcDirection(HDC hdc);

    __declspec(dllimport) int __stdcall GetObjectA(HANDLE h, int c, LPVOID pv);
    __declspec(dllimport) int __stdcall GetObjectW(HANDLE h, int c, LPVOID pv);

    __inline int GetObject(HANDLE h, int c, LPVOID pv)
    {
        return GetObjectA(h, c, pv);
    }

    __declspec(dllimport) BOOL __stdcall MoveToEx(HDC hdc, int x, int y, LPPOINT lppt);
    __declspec(dllimport) BOOL __stdcall TextOutA(HDC hdc, int x, int y, LPCSTR lpString, int c);
    __declspec(dllimport) BOOL __stdcall TextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int c);

    __declspec(dllimport) BOOL
    __stdcall ExtTextOutA(HDC hdc, int x, int y, UINT options, const RECT* lprect, LPCSTR lpString, UINT c, const INT* lpDx);
    __declspec(dllimport) BOOL
    __stdcall ExtTextOutW(HDC hdc, int x, int y, UINT options, const RECT* lprect, LPCWSTR lpString, UINT c, const INT* lpDx);

    __declspec(dllimport) BOOL __stdcall PolyTextOutA(HDC hdc, const POLYTEXTA* ppt, int nstrings);
    __declspec(dllimport) BOOL __stdcall PolyTextOutW(HDC hdc, const POLYTEXTW* ppt, int nstrings);

    __declspec(dllimport) HRGN __stdcall CreatePolygonRgn(const POINT* pptl, int cPoint, int iMode);
    __declspec(dllimport) BOOL __stdcall DPtoLP(HDC hdc, LPPOINT lppt, int c);
    __declspec(dllimport) BOOL __stdcall LPtoDP(HDC hdc, LPPOINT lppt, int c);
    __declspec(dllimport) BOOL __stdcall Polygon(HDC hdc, const POINT* apt, int cpt);
    __declspec(dllimport) BOOL __stdcall Polyline(HDC hdc, const POINT* apt, int cpt);

    __declspec(dllimport) BOOL __stdcall PolyBezier(HDC hdc, const POINT* apt, DWORD cpt);
    __declspec(dllimport) BOOL __stdcall PolyBezierTo(HDC hdc, const POINT* apt, DWORD cpt);
    __declspec(dllimport) BOOL __stdcall PolylineTo(HDC hdc, const POINT* apt, DWORD cpt);

    __declspec(dllimport) BOOL __stdcall SetViewportExtEx(HDC hdc, int x, int y, LPSIZE lpsz);
    __declspec(dllimport) BOOL __stdcall SetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
    __declspec(dllimport) BOOL __stdcall SetWindowExtEx(HDC hdc, int x, int y, LPSIZE lpsz);
    __declspec(dllimport) BOOL __stdcall SetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt);

    __declspec(dllimport) BOOL __stdcall OffsetViewportOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
    __declspec(dllimport) BOOL __stdcall OffsetWindowOrgEx(HDC hdc, int x, int y, LPPOINT lppt);
    __declspec(dllimport) BOOL __stdcall ScaleViewportExtEx(HDC hdc, int xn, int dx, int yn, int yd, LPSIZE lpsz);
    __declspec(dllimport) BOOL __stdcall ScaleWindowExtEx(HDC hdc, int xn, int xd, int yn, int yd, LPSIZE lpsz);
    __declspec(dllimport) BOOL __stdcall SetBitmapDimensionEx(HBITMAP hbm, int w, int h, LPSIZE lpsz);
    __declspec(dllimport) BOOL __stdcall SetBrushOrgEx(HDC hdc, int x, int y, LPPOINT lppt);

    __declspec(dllimport) int __stdcall GetTextFaceA(HDC hdc, int c, LPSTR lpName);
    __declspec(dllimport) int __stdcall GetTextFaceW(HDC hdc, int c, LPWSTR lpName);

    typedef struct tagKERNINGPAIR
    {
        WORD wFirst;
        WORD wSecond;
        int iKernAmount;
    } KERNINGPAIR, *LPKERNINGPAIR;

    __declspec(dllimport) DWORD __stdcall GetKerningPairsA(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair);
    __declspec(dllimport) DWORD __stdcall GetKerningPairsW(HDC hdc, DWORD nPairs, LPKERNINGPAIR lpKernPair);

    __declspec(dllimport) BOOL __stdcall GetDCOrgEx(HDC hdc, LPPOINT lppt);
    __declspec(dllimport) BOOL __stdcall FixBrushOrgEx(HDC hdc, int x, int y, LPPOINT ptl);
    __declspec(dllimport) BOOL __stdcall UnrealizeObject(HGDIOBJ h);

    __declspec(dllimport) BOOL __stdcall GdiFlush(void);
    __declspec(dllimport) DWORD __stdcall GdiSetBatchLimit(DWORD dw);
    __declspec(dllimport) DWORD __stdcall GdiGetBatchLimit(void);

    typedef int(__stdcall* ICMENUMPROCA)(LPSTR, LPARAM);
    typedef int(__stdcall* ICMENUMPROCW)(LPWSTR, LPARAM);

    __declspec(dllimport) int __stdcall SetICMMode(HDC hdc, int mode);
    __declspec(dllimport) BOOL __stdcall CheckColorsInGamut(HDC hdc, LPRGBTRIPLE lpRGBTriple, LPVOID dlpBuffer, DWORD nCount);

    __declspec(dllimport) HCOLORSPACE __stdcall GetColorSpace(HDC hdc);
    __declspec(dllimport) BOOL __stdcall GetLogColorSpaceA(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEA lpBuffer, DWORD nSize);
    __declspec(dllimport) BOOL __stdcall GetLogColorSpaceW(HCOLORSPACE hColorSpace, LPLOGCOLORSPACEW lpBuffer, DWORD nSize);

    __declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceA(LPLOGCOLORSPACEA lplcs);
    __declspec(dllimport) HCOLORSPACE __stdcall CreateColorSpaceW(LPLOGCOLORSPACEW lplcs);

    __declspec(dllimport) HCOLORSPACE __stdcall SetColorSpace(HDC hdc, HCOLORSPACE hcs);
    __declspec(dllimport) BOOL __stdcall DeleteColorSpace(HCOLORSPACE hcs);
    __declspec(dllimport) BOOL __stdcall GetICMProfileA(HDC hdc, LPDWORD pBufSize, LPSTR pszFilename);
    __declspec(dllimport) BOOL __stdcall GetICMProfileW(HDC hdc, LPDWORD pBufSize, LPWSTR pszFilename);

    __declspec(dllimport) BOOL __stdcall SetICMProfileA(HDC hdc, LPSTR lpFileName);
    __declspec(dllimport) BOOL __stdcall SetICMProfileW(HDC hdc, LPWSTR lpFileName);

    __declspec(dllimport) BOOL __stdcall GetDeviceGammaRamp(HDC hdc, LPVOID lpRamp);
    __declspec(dllimport) BOOL __stdcall SetDeviceGammaRamp(HDC hdc, LPVOID lpRamp);
    __declspec(dllimport) BOOL __stdcall ColorMatchToTarget(HDC hdc, HDC hdcTarget, DWORD action);
    __declspec(dllimport) int __stdcall EnumICMProfilesA(HDC hdc, ICMENUMPROCA proc, LPARAM param);
    __declspec(dllimport) int __stdcall EnumICMProfilesW(HDC hdc, ICMENUMPROCW proc, LPARAM param);

    __declspec(dllimport) BOOL __stdcall UpdateICMRegKeyA(DWORD reserved, LPSTR lpszCMID, LPSTR lpszFileName, UINT command);

    __declspec(dllimport) BOOL __stdcall UpdateICMRegKeyW(DWORD reserved, LPWSTR lpszCMID, LPWSTR lpszFileName, UINT command);

#pragma deprecated(UpdateICMRegKeyW)
#pragma deprecated(UpdateICMRegKeyA)

    __declspec(dllimport) BOOL __stdcall ColorCorrectPalette(HDC hdc, HPALETTE hPal, DWORD deFirst, DWORD num);

    typedef struct tagEMR
    {
        DWORD iType;
        DWORD nSize;

    } EMR, *PEMR;

    typedef struct tagEMRTEXT
    {
        POINTL ptlReference;
        DWORD nChars;
        DWORD offString;
        DWORD fOptions;
        RECTL rcl;
        DWORD offDx;

    } EMRTEXT, *PEMRTEXT;

    typedef struct tagABORTPATH
    {
        EMR emr;
    } EMRABORTPATH, *PEMRABORTPATH, EMRBEGINPATH, *PEMRBEGINPATH, EMRENDPATH, *PEMRENDPATH, EMRCLOSEFIGURE,
    *PEMRCLOSEFIGURE, EMRFLATTENPATH, *PEMRFLATTENPATH, EMRWIDENPATH, *PEMRWIDENPATH, EMRSETMETARGN, *PEMRSETMETARGN,
    EMRSAVEDC, *PEMRSAVEDC, EMRREALIZEPALETTE, *PEMRREALIZEPALETTE;

    typedef struct tagEMRSELECTCLIPPATH
    {
        EMR emr;
        DWORD iMode;
    } EMRSELECTCLIPPATH, *PEMRSELECTCLIPPATH, EMRSETBKMODE, *PEMRSETBKMODE, EMRSETMAPMODE, *PEMRSETMAPMODE,

    EMRSETLAYOUT, *PEMRSETLAYOUT, EMRSETPOLYFILLMODE, *PEMRSETPOLYFILLMODE, EMRSETROP2, *PEMRSETROP2,
    EMRSETSTRETCHBLTMODE, *PEMRSETSTRETCHBLTMODE, EMRSETICMMODE, *PEMRSETICMMODE, EMRSETTEXTALIGN, *PEMRSETTEXTALIGN;

    typedef struct tagEMRSETMITERLIMIT
    {
        EMR emr;
        FLOAT eMiterLimit;
    } EMRSETMITERLIMIT, *PEMRSETMITERLIMIT;

    typedef struct tagEMRRESTOREDC
    {
        EMR emr;
        LONG iRelative;
    } EMRRESTOREDC, *PEMRRESTOREDC;

    typedef struct tagEMRSETARCDIRECTION
    {
        EMR emr;
        DWORD iArcDirection;

    } EMRSETARCDIRECTION, *PEMRSETARCDIRECTION;

    typedef struct tagEMRSETMAPPERFLAGS
    {
        EMR emr;
        DWORD dwFlags;
    } EMRSETMAPPERFLAGS, *PEMRSETMAPPERFLAGS;

    typedef struct tagEMRSETTEXTCOLOR
    {
        EMR emr;
        COLORREF crColor;
    } EMRSETBKCOLOR, *PEMRSETBKCOLOR, EMRSETTEXTCOLOR, *PEMRSETTEXTCOLOR;

    typedef struct tagEMRSELECTOBJECT
    {
        EMR emr;
        DWORD ihObject;
    } EMRSELECTOBJECT, *PEMRSELECTOBJECT, EMRDELETEOBJECT, *PEMRDELETEOBJECT;

    typedef struct tagEMRSELECTPALETTE
    {
        EMR emr;
        DWORD ihPal;
    } EMRSELECTPALETTE, *PEMRSELECTPALETTE;

    typedef struct tagEMRRESIZEPALETTE
    {
        EMR emr;
        DWORD ihPal;
        DWORD cEntries;
    } EMRRESIZEPALETTE, *PEMRRESIZEPALETTE;

    typedef struct tagEMRSETPALETTEENTRIES
    {
        EMR emr;
        DWORD ihPal;
        DWORD iStart;
        DWORD cEntries;
        PALETTEENTRY aPalEntries[1];
    } EMRSETPALETTEENTRIES, *PEMRSETPALETTEENTRIES;

    typedef struct tagEMRSETCOLORADJUSTMENT
    {
        EMR emr;
        COLORADJUSTMENT ColorAdjustment;
    } EMRSETCOLORADJUSTMENT, *PEMRSETCOLORADJUSTMENT;

    typedef struct tagEMRGDICOMMENT
    {
        EMR emr;
        DWORD cbData;
        BYTE Data[1];
    } EMRGDICOMMENT, *PEMRGDICOMMENT;

    typedef struct tagEMREOF
    {
        EMR emr;
        DWORD nPalEntries;
        DWORD offPalEntries;
        DWORD nSizeLast;

    } EMREOF, *PEMREOF;

    typedef struct tagEMRLINETO
    {
        EMR emr;
        POINTL ptl;
    } EMRLINETO, *PEMRLINETO, EMRMOVETOEX, *PEMRMOVETOEX;

    typedef struct tagEMROFFSETCLIPRGN
    {
        EMR emr;
        POINTL ptlOffset;
    } EMROFFSETCLIPRGN, *PEMROFFSETCLIPRGN;

    typedef struct tagEMRFILLPATH
    {
        EMR emr;
        RECTL rclBounds;
    } EMRFILLPATH, *PEMRFILLPATH, EMRSTROKEANDFILLPATH, *PEMRSTROKEANDFILLPATH, EMRSTROKEPATH, *PEMRSTROKEPATH;

    typedef struct tagEMREXCLUDECLIPRECT
    {
        EMR emr;
        RECTL rclClip;
    } EMREXCLUDECLIPRECT, *PEMREXCLUDECLIPRECT, EMRINTERSECTCLIPRECT, *PEMRINTERSECTCLIPRECT;

    typedef struct tagEMRSETVIEWPORTORGEX
    {
        EMR emr;
        POINTL ptlOrigin;
    } EMRSETVIEWPORTORGEX, *PEMRSETVIEWPORTORGEX, EMRSETWINDOWORGEX, *PEMRSETWINDOWORGEX, EMRSETBRUSHORGEX, *PEMRSETBRUSHORGEX;

    typedef struct tagEMRSETVIEWPORTEXTEX
    {
        EMR emr;
        SIZEL szlExtent;
    } EMRSETVIEWPORTEXTEX, *PEMRSETVIEWPORTEXTEX, EMRSETWINDOWEXTEX, *PEMRSETWINDOWEXTEX;

    typedef struct tagEMRSCALEVIEWPORTEXTEX
    {
        EMR emr;
        LONG xNum;
        LONG xDenom;
        LONG yNum;
        LONG yDenom;
    } EMRSCALEVIEWPORTEXTEX, *PEMRSCALEVIEWPORTEXTEX, EMRSCALEWINDOWEXTEX, *PEMRSCALEWINDOWEXTEX;

    typedef struct tagEMRSETWORLDTRANSFORM
    {
        EMR emr;
        XFORM xform;
    } EMRSETWORLDTRANSFORM, *PEMRSETWORLDTRANSFORM;

    typedef struct tagEMRMODIFYWORLDTRANSFORM
    {
        EMR emr;
        XFORM xform;
        DWORD iMode;
    } EMRMODIFYWORLDTRANSFORM, *PEMRMODIFYWORLDTRANSFORM;

    typedef struct tagEMRSETPIXELV
    {
        EMR emr;
        POINTL ptlPixel;
        COLORREF crColor;
    } EMRSETPIXELV, *PEMRSETPIXELV;

    typedef struct tagEMREXTFLOODFILL
    {
        EMR emr;
        POINTL ptlStart;
        COLORREF crColor;
        DWORD iMode;
    } EMREXTFLOODFILL, *PEMREXTFLOODFILL;

    typedef struct tagEMRELLIPSE
    {
        EMR emr;
        RECTL rclBox;
    } EMRELLIPSE, *PEMRELLIPSE, EMRRECTANGLE, *PEMRRECTANGLE;

    typedef struct tagEMRROUNDRECT
    {
        EMR emr;
        RECTL rclBox;
        SIZEL szlCorner;
    } EMRROUNDRECT, *PEMRROUNDRECT;

    typedef struct tagEMRARC
    {
        EMR emr;
        RECTL rclBox;
        POINTL ptlStart;
        POINTL ptlEnd;
    } EMRARC, *PEMRARC, EMRARCTO, *PEMRARCTO, EMRCHORD, *PEMRCHORD, EMRPIE, *PEMRPIE;

    typedef struct tagEMRANGLEARC
    {
        EMR emr;
        POINTL ptlCenter;
        DWORD nRadius;
        FLOAT eStartAngle;
        FLOAT eSweepAngle;
    } EMRANGLEARC, *PEMRANGLEARC;

    typedef struct tagEMRPOLYLINE
    {
        EMR emr;
        RECTL rclBounds;
        DWORD cptl;
        POINTL aptl[1];
    } EMRPOLYLINE, *PEMRPOLYLINE, EMRPOLYBEZIER, *PEMRPOLYBEZIER, EMRPOLYGON, *PEMRPOLYGON, EMRPOLYBEZIERTO,
    *PEMRPOLYBEZIERTO, EMRPOLYLINETO, *PEMRPOLYLINETO;

    typedef struct tagEMRPOLYLINE16
    {
        EMR emr;
        RECTL rclBounds;
        DWORD cpts;
        POINTS apts[1];
    } EMRPOLYLINE16, *PEMRPOLYLINE16, EMRPOLYBEZIER16, *PEMRPOLYBEZIER16, EMRPOLYGON16, *PEMRPOLYGON16,
    EMRPOLYBEZIERTO16, *PEMRPOLYBEZIERTO16, EMRPOLYLINETO16, *PEMRPOLYLINETO16;

    typedef struct tagEMRPOLYDRAW
    {
        EMR emr;
        RECTL rclBounds;
        DWORD cptl;
        POINTL aptl[1];
        BYTE abTypes[1];
    } EMRPOLYDRAW, *PEMRPOLYDRAW;

    typedef struct tagEMRPOLYDRAW16
    {
        EMR emr;
        RECTL rclBounds;
        DWORD cpts;
        POINTS apts[1];
        BYTE abTypes[1];
    } EMRPOLYDRAW16, *PEMRPOLYDRAW16;

    typedef struct tagEMRPOLYPOLYLINE
    {
        EMR emr;
        RECTL rclBounds;
        DWORD nPolys;
        DWORD cptl;
        DWORD aPolyCounts[1];
        POINTL aptl[1];
    } EMRPOLYPOLYLINE, *PEMRPOLYPOLYLINE, EMRPOLYPOLYGON, *PEMRPOLYPOLYGON;

    typedef struct tagEMRPOLYPOLYLINE16
    {
        EMR emr;
        RECTL rclBounds;
        DWORD nPolys;
        DWORD cpts;
        DWORD aPolyCounts[1];
        POINTS apts[1];
    } EMRPOLYPOLYLINE16, *PEMRPOLYPOLYLINE16, EMRPOLYPOLYGON16, *PEMRPOLYPOLYGON16;

    typedef struct tagEMRINVERTRGN
    {
        EMR emr;
        RECTL rclBounds;
        DWORD cbRgnData;
        BYTE RgnData[1];
    } EMRINVERTRGN, *PEMRINVERTRGN, EMRPAINTRGN, *PEMRPAINTRGN;

    typedef struct tagEMRFILLRGN
    {
        EMR emr;
        RECTL rclBounds;
        DWORD cbRgnData;
        DWORD ihBrush;
        BYTE RgnData[1];
    } EMRFILLRGN, *PEMRFILLRGN;

    typedef struct tagEMRFRAMERGN
    {
        EMR emr;
        RECTL rclBounds;
        DWORD cbRgnData;
        DWORD ihBrush;
        SIZEL szlStroke;
        BYTE RgnData[1];
    } EMRFRAMERGN, *PEMRFRAMERGN;

    typedef struct tagEMREXTSELECTCLIPRGN
    {
        EMR emr;
        DWORD cbRgnData;
        DWORD iMode;
        BYTE RgnData[1];
    } EMREXTSELECTCLIPRGN, *PEMREXTSELECTCLIPRGN;

    typedef struct tagEMREXTTEXTOUTA
    {
        EMR emr;
        RECTL rclBounds;
        DWORD iGraphicsMode;
        FLOAT exScale;
        FLOAT eyScale;
        EMRTEXT emrtext;

    } EMREXTTEXTOUTA, *PEMREXTTEXTOUTA, EMREXTTEXTOUTW, *PEMREXTTEXTOUTW;

    typedef struct tagEMRPOLYTEXTOUTA
    {
        EMR emr;
        RECTL rclBounds;
        DWORD iGraphicsMode;
        FLOAT exScale;
        FLOAT eyScale;
        LONG cStrings;
        EMRTEXT aemrtext[1];

    } EMRPOLYTEXTOUTA, *PEMRPOLYTEXTOUTA, EMRPOLYTEXTOUTW, *PEMRPOLYTEXTOUTW;

    typedef struct tagEMRBITBLT
    {
        EMR emr;
        RECTL rclBounds;
        LONG xDest;
        LONG yDest;
        LONG cxDest;
        LONG cyDest;
        DWORD dwRop;
        LONG xSrc;
        LONG ySrc;
        XFORM xformSrc;
        COLORREF crBkColorSrc;
        DWORD iUsageSrc;

        DWORD offBmiSrc;
        DWORD cbBmiSrc;
        DWORD offBitsSrc;
        DWORD cbBitsSrc;
    } EMRBITBLT, *PEMRBITBLT;

    typedef struct tagEMRSTRETCHBLT
    {
        EMR emr;
        RECTL rclBounds;
        LONG xDest;
        LONG yDest;
        LONG cxDest;
        LONG cyDest;
        DWORD dwRop;
        LONG xSrc;
        LONG ySrc;
        XFORM xformSrc;
        COLORREF crBkColorSrc;
        DWORD iUsageSrc;

        DWORD offBmiSrc;
        DWORD cbBmiSrc;
        DWORD offBitsSrc;
        DWORD cbBitsSrc;
        LONG cxSrc;
        LONG cySrc;
    } EMRSTRETCHBLT, *PEMRSTRETCHBLT;

    typedef struct tagEMRMASKBLT
    {
        EMR emr;
        RECTL rclBounds;
        LONG xDest;
        LONG yDest;
        LONG cxDest;
        LONG cyDest;
        DWORD dwRop;
        LONG xSrc;
        LONG ySrc;
        XFORM xformSrc;
        COLORREF crBkColorSrc;
        DWORD iUsageSrc;

        DWORD offBmiSrc;
        DWORD cbBmiSrc;
        DWORD offBitsSrc;
        DWORD cbBitsSrc;
        LONG xMask;
        LONG yMask;
        DWORD iUsageMask;
        DWORD offBmiMask;
        DWORD cbBmiMask;
        DWORD offBitsMask;
        DWORD cbBitsMask;
    } EMRMASKBLT, *PEMRMASKBLT;

    typedef struct tagEMRPLGBLT
    {
        EMR emr;
        RECTL rclBounds;
        POINTL aptlDest[3];
        LONG xSrc;
        LONG ySrc;
        LONG cxSrc;
        LONG cySrc;
        XFORM xformSrc;
        COLORREF crBkColorSrc;
        DWORD iUsageSrc;

        DWORD offBmiSrc;
        DWORD cbBmiSrc;
        DWORD offBitsSrc;
        DWORD cbBitsSrc;
        LONG xMask;
        LONG yMask;
        DWORD iUsageMask;
        DWORD offBmiMask;
        DWORD cbBmiMask;
        DWORD offBitsMask;
        DWORD cbBitsMask;
    } EMRPLGBLT, *PEMRPLGBLT;

    typedef struct tagEMRSETDIBITSTODEVICE
    {
        EMR emr;
        RECTL rclBounds;
        LONG xDest;
        LONG yDest;
        LONG xSrc;
        LONG ySrc;
        LONG cxSrc;
        LONG cySrc;
        DWORD offBmiSrc;
        DWORD cbBmiSrc;
        DWORD offBitsSrc;
        DWORD cbBitsSrc;
        DWORD iUsageSrc;
        DWORD iStartScan;
        DWORD cScans;
    } EMRSETDIBITSTODEVICE, *PEMRSETDIBITSTODEVICE;

    typedef struct tagEMRSTRETCHDIBITS
    {
        EMR emr;
        RECTL rclBounds;
        LONG xDest;
        LONG yDest;
        LONG xSrc;
        LONG ySrc;
        LONG cxSrc;
        LONG cySrc;
        DWORD offBmiSrc;
        DWORD cbBmiSrc;
        DWORD offBitsSrc;
        DWORD cbBitsSrc;
        DWORD iUsageSrc;
        DWORD dwRop;
        LONG cxDest;
        LONG cyDest;
    } EMRSTRETCHDIBITS, *PEMRSTRETCHDIBITS;

    typedef struct tagEMREXTCREATEFONTINDIRECTW
    {
        EMR emr;
        DWORD ihFont;
        EXTLOGFONTW elfw;
    } EMREXTCREATEFONTINDIRECTW, *PEMREXTCREATEFONTINDIRECTW;

    typedef struct tagEMRCREATEPALETTE
    {
        EMR emr;
        DWORD ihPal;
        LOGPALETTE lgpl;

    } EMRCREATEPALETTE, *PEMRCREATEPALETTE;

    typedef struct tagEMRCREATEPEN
    {
        EMR emr;
        DWORD ihPen;
        LOGPEN lopn;
    } EMRCREATEPEN, *PEMRCREATEPEN;

    typedef struct tagEMREXTCREATEPEN
    {
        EMR emr;
        DWORD ihPen;
        DWORD offBmi;
        DWORD cbBmi;

        DWORD offBits;
        DWORD cbBits;
        EXTLOGPEN32 elp;
    } EMREXTCREATEPEN, *PEMREXTCREATEPEN;

    typedef struct tagEMRCREATEBRUSHINDIRECT
    {
        EMR emr;
        DWORD ihBrush;
        LOGBRUSH32 lb;

    } EMRCREATEBRUSHINDIRECT, *PEMRCREATEBRUSHINDIRECT;

    typedef struct tagEMRCREATEMONOBRUSH
    {
        EMR emr;
        DWORD ihBrush;
        DWORD iUsage;
        DWORD offBmi;
        DWORD cbBmi;
        DWORD offBits;
        DWORD cbBits;
    } EMRCREATEMONOBRUSH, *PEMRCREATEMONOBRUSH;

    typedef struct tagEMRCREATEDIBPATTERNBRUSHPT
    {
        EMR emr;
        DWORD ihBrush;
        DWORD iUsage;
        DWORD offBmi;
        DWORD cbBmi;

        DWORD offBits;
        DWORD cbBits;
    } EMRCREATEDIBPATTERNBRUSHPT, *PEMRCREATEDIBPATTERNBRUSHPT;

    typedef struct tagEMRFORMAT
    {
        DWORD dSignature;
        DWORD nVersion;
        DWORD cbData;
        DWORD offData;

    } EMRFORMAT, *PEMRFORMAT;

    typedef struct tagEMRGLSRECORD
    {
        EMR emr;
        DWORD cbData;
        BYTE Data[1];
    } EMRGLSRECORD, *PEMRGLSRECORD;

    typedef struct tagEMRGLSBOUNDEDRECORD
    {
        EMR emr;
        RECTL rclBounds;
        DWORD cbData;
        BYTE Data[1];
    } EMRGLSBOUNDEDRECORD, *PEMRGLSBOUNDEDRECORD;

    typedef struct tagEMRPIXELFORMAT
    {
        EMR emr;
        PIXELFORMATDESCRIPTOR pfd;
    } EMRPIXELFORMAT, *PEMRPIXELFORMAT;

    typedef struct tagEMRCREATECOLORSPACE
    {
        EMR emr;
        DWORD ihCS;
        LOGCOLORSPACEA lcs;
    } EMRCREATECOLORSPACE, *PEMRCREATECOLORSPACE;

    typedef struct tagEMRSETCOLORSPACE
    {
        EMR emr;
        DWORD ihCS;
    } EMRSETCOLORSPACE, *PEMRSETCOLORSPACE, EMRSELECTCOLORSPACE, *PEMRSELECTCOLORSPACE, EMRDELETECOLORSPACE, *PEMRDELETECOLORSPACE;

    typedef struct tagEMREXTESCAPE
    {
        EMR emr;
        INT iEscape;
        INT cbEscData;
        BYTE EscData[1];
    } EMREXTESCAPE, *PEMREXTESCAPE, EMRDRAWESCAPE, *PEMRDRAWESCAPE;

    typedef struct tagEMRNAMEDESCAPE
    {
        EMR emr;
        INT iEscape;
        INT cbDriver;
        INT cbEscData;
        BYTE EscData[1];
    } EMRNAMEDESCAPE, *PEMRNAMEDESCAPE;

    typedef struct tagEMRSETICMPROFILE
    {
        EMR emr;
        DWORD dwFlags;
        DWORD cbName;
        DWORD cbData;
        BYTE Data[1];
    } EMRSETICMPROFILE, *PEMRSETICMPROFILE, EMRSETICMPROFILEA, *PEMRSETICMPROFILEA, EMRSETICMPROFILEW, *PEMRSETICMPROFILEW;

    typedef struct tagEMRCREATECOLORSPACEW
    {
        EMR emr;
        DWORD ihCS;
        LOGCOLORSPACEW lcs;
        DWORD dwFlags;
        DWORD cbData;
        BYTE Data[1];
    } EMRCREATECOLORSPACEW, *PEMRCREATECOLORSPACEW;

    typedef struct tagCOLORMATCHTOTARGET
    {
        EMR emr;
        DWORD dwAction;
        DWORD dwFlags;
        DWORD cbName;
        DWORD cbData;
        BYTE Data[1];
    } EMRCOLORMATCHTOTARGET, *PEMRCOLORMATCHTOTARGET;

    typedef struct tagCOLORCORRECTPALETTE
    {
        EMR emr;
        DWORD ihPalette;
        DWORD nFirstEntry;
        DWORD nPalEntries;
        DWORD nReserved;
    } EMRCOLORCORRECTPALETTE, *PEMRCOLORCORRECTPALETTE;

    typedef struct tagEMRALPHABLEND
    {
        EMR emr;
        RECTL rclBounds;
        LONG xDest;
        LONG yDest;
        LONG cxDest;
        LONG cyDest;
        DWORD dwRop;
        LONG xSrc;
        LONG ySrc;
        XFORM xformSrc;
        COLORREF crBkColorSrc;
        DWORD iUsageSrc;

        DWORD offBmiSrc;
        DWORD cbBmiSrc;
        DWORD offBitsSrc;
        DWORD cbBitsSrc;
        LONG cxSrc;
        LONG cySrc;
    } EMRALPHABLEND, *PEMRALPHABLEND;

    typedef struct tagEMRGRADIENTFILL
    {
        EMR emr;
        RECTL rclBounds;
        DWORD nVer;
        DWORD nTri;
        ULONG ulMode;
        TRIVERTEX Ver[1];
    } EMRGRADIENTFILL, *PEMRGRADIENTFILL;

    typedef struct tagEMRTRANSPARENTBLT
    {
        EMR emr;
        RECTL rclBounds;
        LONG xDest;
        LONG yDest;
        LONG cxDest;
        LONG cyDest;
        DWORD dwRop;
        LONG xSrc;
        LONG ySrc;
        XFORM xformSrc;
        COLORREF crBkColorSrc;
        DWORD iUsageSrc;

        DWORD offBmiSrc;
        DWORD cbBmiSrc;
        DWORD offBitsSrc;
        DWORD cbBitsSrc;
        LONG cxSrc;
        LONG cySrc;
    } EMRTRANSPARENTBLT, *PEMRTRANSPARENTBLT;

    __declspec(dllimport) BOOL __stdcall wglCopyContext(HGLRC, HGLRC, UINT);
    __declspec(dllimport) HGLRC __stdcall wglCreateContext(HDC);
    __declspec(dllimport) HGLRC __stdcall wglCreateLayerContext(HDC, int);
    __declspec(dllimport) BOOL __stdcall wglDeleteContext(HGLRC);
    __declspec(dllimport) HGLRC __stdcall wglGetCurrentContext(void);
    __declspec(dllimport) HDC __stdcall wglGetCurrentDC(void);
    __declspec(dllimport) PROC __stdcall wglGetProcAddress(LPCSTR);
    __declspec(dllimport) BOOL __stdcall wglMakeCurrent(HDC, HGLRC);
    __declspec(dllimport) BOOL __stdcall wglShareLists(HGLRC, HGLRC);
    __declspec(dllimport) BOOL __stdcall wglUseFontBitmapsA(HDC, DWORD, DWORD, DWORD);
    __declspec(dllimport) BOOL __stdcall wglUseFontBitmapsW(HDC, DWORD, DWORD, DWORD);

    __declspec(dllimport) BOOL __stdcall SwapBuffers(HDC);

    typedef struct _POINTFLOAT
    {
        FLOAT x;
        FLOAT y;
    } POINTFLOAT, *PPOINTFLOAT;

    typedef struct _GLYPHMETRICSFLOAT
    {
        FLOAT gmfBlackBoxX;
        FLOAT gmfBlackBoxY;
        POINTFLOAT gmfptGlyphOrigin;
        FLOAT gmfCellIncX;
        FLOAT gmfCellIncY;
    } GLYPHMETRICSFLOAT, *PGLYPHMETRICSFLOAT, *LPGLYPHMETRICSFLOAT;

    __declspec(dllimport) BOOL __stdcall wglUseFontOutlinesA(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT);
    __declspec(dllimport) BOOL __stdcall wglUseFontOutlinesW(HDC, DWORD, DWORD, DWORD, FLOAT, FLOAT, int, LPGLYPHMETRICSFLOAT);

    typedef struct tagLAYERPLANEDESCRIPTOR
    {
        WORD nSize;
        WORD nVersion;
        DWORD dwFlags;
        BYTE iPixelType;
        BYTE cColorBits;
        BYTE cRedBits;
        BYTE cRedShift;
        BYTE cGreenBits;
        BYTE cGreenShift;
        BYTE cBlueBits;
        BYTE cBlueShift;
        BYTE cAlphaBits;
        BYTE cAlphaShift;
        BYTE cAccumBits;
        BYTE cAccumRedBits;
        BYTE cAccumGreenBits;
        BYTE cAccumBlueBits;
        BYTE cAccumAlphaBits;
        BYTE cDepthBits;
        BYTE cStencilBits;
        BYTE cAuxBuffers;
        BYTE iLayerPlane;
        BYTE bReserved;
        COLORREF crTransparent;
    } LAYERPLANEDESCRIPTOR, *PLAYERPLANEDESCRIPTOR, *LPLAYERPLANEDESCRIPTOR;

    __declspec(dllimport) BOOL __stdcall wglDescribeLayerPlane(HDC, int, int, UINT, LPLAYERPLANEDESCRIPTOR);
    __declspec(dllimport) int __stdcall wglSetLayerPaletteEntries(HDC, int, int, int, const COLORREF*);
    __declspec(dllimport) int __stdcall wglGetLayerPaletteEntries(HDC, int, int, int, COLORREF*);
    __declspec(dllimport) BOOL __stdcall wglRealizeLayerPalette(HDC, int, BOOL);
    __declspec(dllimport) BOOL __stdcall wglSwapLayerBuffers(HDC, UINT);

    typedef struct _WGLSWAP
    {
        HDC hdc;
        UINT uiFlags;
    } WGLSWAP, *PWGLSWAP, *LPWGLSWAP;

    __declspec(dllimport) DWORD __stdcall wglSwapMultipleBuffers(UINT, const WGLSWAP*);

#pragma endregion

#pragma region Desktop Family

#pragma endregion
}

#pragma warning(pop)

#pragma once

extern "C"
{
#pragma warning(push)

#pragma warning(disable : 4820)

#pragma region Desktop Family

    typedef HANDLE HDWP;
    typedef void MENUTEMPLATEA;
    typedef void MENUTEMPLATEW;

    typedef MENUTEMPLATEA MENUTEMPLATE;
    typedef PVOID LPMENUTEMPLATEA;
    typedef PVOID LPMENUTEMPLATEW;

    typedef LPMENUTEMPLATEA LPMENUTEMPLATE;

    typedef LRESULT(__stdcall* WNDPROC)(HWND, UINT, WPARAM, LPARAM);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef INT_PTR(__stdcall* DLGPROC)(HWND, UINT, WPARAM, LPARAM);

#pragma endregion

#pragma region Desktop Family

    typedef void(__stdcall* TIMERPROC)(HWND, UINT, UINT_PTR, DWORD);
    typedef BOOL(__stdcall* GRAYSTRINGPROC)(HDC, LPARAM, int);
    typedef BOOL(__stdcall* WNDENUMPROC)(HWND, LPARAM);
    typedef LRESULT(__stdcall* HOOKPROC)(int code, WPARAM wParam, LPARAM lParam);
    typedef void(__stdcall* SENDASYNCPROC)(HWND, UINT, ULONG_PTR, LRESULT);

    typedef BOOL(__stdcall* PROPENUMPROCA)(HWND, LPCSTR, HANDLE);
    typedef BOOL(__stdcall* PROPENUMPROCW)(HWND, LPCWSTR, HANDLE);

    typedef BOOL(__stdcall* PROPENUMPROCEXA)(HWND, LPSTR, HANDLE, ULONG_PTR);
    typedef BOOL(__stdcall* PROPENUMPROCEXW)(HWND, LPWSTR, HANDLE, ULONG_PTR);

    typedef int(__stdcall* EDITWORDBREAKPROCA)(LPSTR lpch, int ichCurrent, int cch, int code);
    typedef int(__stdcall* EDITWORDBREAKPROCW)(LPWSTR lpch, int ichCurrent, int cch, int code);

    typedef BOOL(__stdcall* DRAWSTATEPROC)(HDC hdc, LPARAM lData, WPARAM wData, int cx, int cy);

#pragma endregion

#pragma region Desktop Family

    typedef PROPENUMPROCA PROPENUMPROC;
    typedef PROPENUMPROCEXA PROPENUMPROCEX;
    typedef EDITWORDBREAKPROCA EDITWORDBREAKPROC;

    typedef BOOL(__stdcall* NAMEENUMPROCA)(LPSTR, LPARAM);
    typedef BOOL(__stdcall* NAMEENUMPROCW)(LPWSTR, LPARAM);

    typedef NAMEENUMPROCA WINSTAENUMPROCA;
    typedef NAMEENUMPROCA DESKTOPENUMPROCA;
    typedef NAMEENUMPROCW WINSTAENUMPROCW;
    typedef NAMEENUMPROCW DESKTOPENUMPROCW;

    typedef WINSTAENUMPROCA WINSTAENUMPROC;
    typedef DESKTOPENUMPROCA DESKTOPENUMPROC;

#pragma endregion

#pragma region Desktop Family

#pragma warning(push)
#pragma warning(disable : 4995)

    __declspec(dllimport) int __stdcall wvsprintfA(LPSTR, LPCSTR, va_list arglist);
    __declspec(dllimport) int __stdcall wvsprintfW(LPWSTR, LPCWSTR, va_list arglist);

    __declspec(dllimport) int __cdecl wsprintfA(LPSTR, LPCSTR, ...);
    __declspec(dllimport) int __cdecl wsprintfW(LPWSTR, LPCWSTR, ...);

#pragma warning(pop)

#pragma endregion

#pragma region Desktop Family

    typedef struct tagCBT_CREATEWNDA
    {
        struct tagCREATESTRUCTA* lpcs;
        HWND hwndInsertAfter;
    } CBT_CREATEWNDA, *LPCBT_CREATEWNDA;

    typedef struct tagCBT_CREATEWNDW
    {
        struct tagCREATESTRUCTW* lpcs;
        HWND hwndInsertAfter;
    } CBT_CREATEWNDW, *LPCBT_CREATEWNDW;

    typedef CBT_CREATEWNDA CBT_CREATEWND;
    typedef LPCBT_CREATEWNDA LPCBT_CREATEWND;

    typedef struct tagCBTACTIVATESTRUCT
    {
        BOOL fMouse;
        HWND hWndActive;
    } CBTACTIVATESTRUCT, *LPCBTACTIVATESTRUCT;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagWTSSESSION_NOTIFICATION
    {
        DWORD cbSize;
        DWORD dwSessionId;

    } WTSSESSION_NOTIFICATION, *PWTSSESSION_NOTIFICATION;

#pragma endregion

#pragma region Desktop Family

    typedef struct
    {
        HWND hwnd;
        RECT rc;
    } SHELLHOOKINFO, *LPSHELLHOOKINFO;

    typedef struct tagEVENTMSG
    {
        UINT message;
        UINT paramL;
        UINT paramH;
        DWORD time;
        HWND hwnd;
    } EVENTMSG, *PEVENTMSGMSG, *NPEVENTMSGMSG, *LPEVENTMSGMSG;

    typedef struct tagEVENTMSG *PEVENTMSG, *NPEVENTMSG, *LPEVENTMSG;

    typedef struct tagCWPSTRUCT
    {
        LPARAM lParam;
        WPARAM wParam;
        UINT message;
        HWND hwnd;
    } CWPSTRUCT, *PCWPSTRUCT, *NPCWPSTRUCT, *LPCWPSTRUCT;

    typedef struct tagCWPRETSTRUCT
    {
        LRESULT lResult;
        LPARAM lParam;
        WPARAM wParam;
        UINT message;
        HWND hwnd;
    } CWPRETSTRUCT, *PCWPRETSTRUCT, *NPCWPRETSTRUCT, *LPCWPRETSTRUCT;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagKBDLLHOOKSTRUCT
    {
        DWORD vkCode;
        DWORD scanCode;
        DWORD flags;
        DWORD time;
        ULONG_PTR dwExtraInfo;
    } KBDLLHOOKSTRUCT, *LPKBDLLHOOKSTRUCT, *PKBDLLHOOKSTRUCT;

    typedef struct tagMSLLHOOKSTRUCT
    {
        POINT pt;
        DWORD mouseData;
        DWORD flags;
        DWORD time;
        ULONG_PTR dwExtraInfo;
    } MSLLHOOKSTRUCT, *LPMSLLHOOKSTRUCT, *PMSLLHOOKSTRUCT;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagDEBUGHOOKINFO
    {
        DWORD idThread;
        DWORD idThreadInstaller;
        LPARAM lParam;
        WPARAM wParam;
        int code;
    } DEBUGHOOKINFO, *PDEBUGHOOKINFO, *NPDEBUGHOOKINFO, *LPDEBUGHOOKINFO;

    typedef struct tagMOUSEHOOKSTRUCT
    {
        POINT pt;
        HWND hwnd;
        UINT wHitTestCode;
        ULONG_PTR dwExtraInfo;
    } MOUSEHOOKSTRUCT, *LPMOUSEHOOKSTRUCT, *PMOUSEHOOKSTRUCT;

    typedef struct tagMOUSEHOOKSTRUCTEX : public tagMOUSEHOOKSTRUCT
    {
        DWORD mouseData;
    } MOUSEHOOKSTRUCTEX, *LPMOUSEHOOKSTRUCTEX, *PMOUSEHOOKSTRUCTEX;

    typedef struct tagHARDWAREHOOKSTRUCT
    {
        HWND hwnd;
        UINT message;
        WPARAM wParam;
        LPARAM lParam;
    } HARDWAREHOOKSTRUCT, *LPHARDWAREHOOKSTRUCT, *PHARDWAREHOOKSTRUCT;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HKL __stdcall LoadKeyboardLayoutA(LPCSTR pwszKLID, UINT Flags);
    __declspec(dllimport) HKL __stdcall LoadKeyboardLayoutW(LPCWSTR pwszKLID, UINT Flags);

    __declspec(dllimport) HKL __stdcall ActivateKeyboardLayout(HKL hkl, UINT Flags);

    __declspec(dllimport) int __stdcall ToUnicodeEx(
    UINT wVirtKey, UINT wScanCode, const BYTE* lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags, HKL dwhkl);

    __declspec(dllimport) BOOL __stdcall UnloadKeyboardLayout(HKL hkl);

    __declspec(dllimport) BOOL __stdcall GetKeyboardLayoutNameA(LPSTR pwszKLID);
    __declspec(dllimport) BOOL __stdcall GetKeyboardLayoutNameW(LPWSTR pwszKLID);

    __declspec(dllimport) int __stdcall GetKeyboardLayoutList(int nBuff, HKL* lpList);

    __declspec(dllimport) HKL __stdcall GetKeyboardLayout(DWORD idThread);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagMOUSEMOVEPOINT
    {
        int x;
        int y;
        DWORD time;
        ULONG_PTR dwExtraInfo;
    } MOUSEMOVEPOINT, *PMOUSEMOVEPOINT, *LPMOUSEMOVEPOINT;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall GetMouseMovePointsEx(
    UINT cbSize, LPMOUSEMOVEPOINT lppt, LPMOUSEMOVEPOINT lpptBuf, int nBufPoints, DWORD resolution);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HDESK __stdcall CreateDesktopA(
    LPCSTR lpszDesktop, LPCSTR lpszDevice, DEVMODEA* pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
    __declspec(dllimport) HDESK __stdcall CreateDesktopW(
    LPCWSTR lpszDesktop, LPCWSTR lpszDevice, DEVMODEW* pDevmode, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);

    __declspec(dllimport) HDESK __stdcall CreateDesktopExA(LPCSTR lpszDesktop,
                                                           LPCSTR lpszDevice,
                                                           DEVMODEA* pDevmode,
                                                           DWORD dwFlags,
                                                           ACCESS_MASK dwDesiredAccess,
                                                           LPSECURITY_ATTRIBUTES lpsa,
                                                           ULONG ulHeapSize,
                                                           PVOID pvoid);
    __declspec(dllimport) HDESK __stdcall CreateDesktopExW(LPCWSTR lpszDesktop,
                                                           LPCWSTR lpszDevice,
                                                           DEVMODEW* pDevmode,
                                                           DWORD dwFlags,
                                                           ACCESS_MASK dwDesiredAccess,
                                                           LPSECURITY_ATTRIBUTES lpsa,
                                                           ULONG ulHeapSize,
                                                           PVOID pvoid);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HDESK
    __stdcall OpenDesktopA(LPCSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess);
    __declspec(dllimport) HDESK
    __stdcall OpenDesktopW(LPCWSTR lpszDesktop, DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess);

    __declspec(dllimport) HDESK __stdcall OpenInputDesktop(DWORD dwFlags, BOOL fInherit, ACCESS_MASK dwDesiredAccess);

    __declspec(dllimport) BOOL __stdcall EnumDesktopsA(HWINSTA hwinsta, DESKTOPENUMPROCA lpEnumFunc, LPARAM lParam);
    __declspec(dllimport) BOOL __stdcall EnumDesktopsW(HWINSTA hwinsta, DESKTOPENUMPROCW lpEnumFunc, LPARAM lParam);

    __declspec(dllimport) BOOL __stdcall EnumDesktopWindows(HDESK hDesktop, WNDENUMPROC lpfn, LPARAM lParam);

    __declspec(dllimport) BOOL __stdcall SwitchDesktop(HDESK hDesktop);

    __declspec(dllimport) BOOL __stdcall SetThreadDesktop(HDESK hDesktop);

    __declspec(dllimport) BOOL __stdcall CloseDesktop(HDESK hDesktop);

    __declspec(dllimport) HDESK __stdcall GetThreadDesktop(DWORD dwThreadId);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HWINSTA
    __stdcall CreateWindowStationA(LPCSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);
    __declspec(dllimport) HWINSTA
    __stdcall CreateWindowStationW(LPCWSTR lpwinsta, DWORD dwFlags, ACCESS_MASK dwDesiredAccess, LPSECURITY_ATTRIBUTES lpsa);

    __declspec(dllimport) HWINSTA __stdcall OpenWindowStationA(LPCSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess);
    __declspec(dllimport) HWINSTA __stdcall OpenWindowStationW(LPCWSTR lpszWinSta, BOOL fInherit, ACCESS_MASK dwDesiredAccess);

    __declspec(dllimport) BOOL __stdcall EnumWindowStationsA(WINSTAENUMPROCA lpEnumFunc, LPARAM lParam);
    __declspec(dllimport) BOOL __stdcall EnumWindowStationsW(WINSTAENUMPROCW lpEnumFunc, LPARAM lParam);

    __declspec(dllimport) BOOL __stdcall CloseWindowStation(HWINSTA hWinSta);

    __declspec(dllimport) BOOL __stdcall SetProcessWindowStation(HWINSTA hWinSta);

    __declspec(dllimport) HWINSTA __stdcall GetProcessWindowStation(void);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL
    __stdcall SetUserObjectSecurity(HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID);

    __declspec(dllimport) BOOL __stdcall GetUserObjectSecurity(
    HANDLE hObj, PSECURITY_INFORMATION pSIRequested, PSECURITY_DESCRIPTOR pSID, DWORD nLength, LPDWORD lpnLengthNeeded);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagUSEROBJECTFLAGS
    {
        BOOL fInherit;
        BOOL fReserved;
        DWORD dwFlags;
    } USEROBJECTFLAGS, *PUSEROBJECTFLAGS;

    __declspec(dllimport) BOOL
    __stdcall GetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded);
    __declspec(dllimport) BOOL
    __stdcall GetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength, LPDWORD lpnLengthNeeded);

    __declspec(dllimport) BOOL __stdcall SetUserObjectInformationA(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength);
    __declspec(dllimport) BOOL __stdcall SetUserObjectInformationW(HANDLE hObj, int nIndex, PVOID pvInfo, DWORD nLength);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagWNDCLASSEXA
    {
        UINT cbSize;

        UINT style;
        WNDPROC lpfnWndProc;
        int cbClsExtra;
        int cbWndExtra;
        HINSTANCE hInstance;
        HICON hIcon;
        HCURSOR hCursor;
        HBRUSH hbrBackground;
        LPCSTR lpszMenuName;
        LPCSTR lpszClassName;

        HICON hIconSm;
    } WNDCLASSEXA, *PWNDCLASSEXA, *NPWNDCLASSEXA, *LPWNDCLASSEXA;
    typedef struct tagWNDCLASSEXW
    {
        UINT cbSize;

        UINT style;
        WNDPROC lpfnWndProc;
        int cbClsExtra;
        int cbWndExtra;
        HINSTANCE hInstance;
        HICON hIcon;
        HCURSOR hCursor;
        HBRUSH hbrBackground;
        LPCWSTR lpszMenuName;
        LPCWSTR lpszClassName;

        HICON hIconSm;
    } WNDCLASSEXW, *PWNDCLASSEXW, *NPWNDCLASSEXW, *LPWNDCLASSEXW;

    typedef WNDCLASSEXA WNDCLASSEX;
    typedef PWNDCLASSEXA PWNDCLASSEX;
    typedef NPWNDCLASSEXA NPWNDCLASSEX;
    typedef LPWNDCLASSEXA LPWNDCLASSEX;

    typedef struct tagWNDCLASSA
    {
        UINT style;
        WNDPROC lpfnWndProc;
        int cbClsExtra;
        int cbWndExtra;
        HINSTANCE hInstance;
        HICON hIcon;
        HCURSOR hCursor;
        HBRUSH hbrBackground;
        LPCSTR lpszMenuName;
        LPCSTR lpszClassName;
    } WNDCLASSA, *PWNDCLASSA, *NPWNDCLASSA, *LPWNDCLASSA;
    typedef struct tagWNDCLASSW
    {
        UINT style;
        WNDPROC lpfnWndProc;
        int cbClsExtra;
        int cbWndExtra;
        HINSTANCE hInstance;
        HICON hIcon;
        HCURSOR hCursor;
        HBRUSH hbrBackground;
        LPCWSTR lpszMenuName;
        LPCWSTR lpszClassName;
    } WNDCLASSW, *PWNDCLASSW, *NPWNDCLASSW, *LPWNDCLASSW;

    typedef WNDCLASSA WNDCLASS;
    typedef PWNDCLASSA PWNDCLASS;
    typedef NPWNDCLASSA NPWNDCLASS;
    typedef LPWNDCLASSA LPWNDCLASS;

    __declspec(dllimport) BOOL __stdcall IsHungAppWindow(HWND hwnd);

    __declspec(dllimport) void __stdcall DisableProcessWindowsGhosting(void);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct tagMSG
    {
        HWND hwnd;
        UINT message;
        WPARAM wParam;
        LPARAM lParam;
        DWORD time;
        POINT pt;

    } MSG, *PMSG, *NPMSG, *LPMSG;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagMINMAXINFO
    {
        POINT ptReserved;
        POINT ptMaxSize;
        POINT ptMaxPosition;
        POINT ptMinTrackSize;
        POINT ptMaxTrackSize;
    } MINMAXINFO, *PMINMAXINFO, *LPMINMAXINFO;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagCOPYDATASTRUCT
    {
        ULONG_PTR dwData;
        DWORD cbData;
        PVOID lpData;
    } COPYDATASTRUCT, *PCOPYDATASTRUCT;

    typedef struct tagMDINEXTMENU
    {
        HMENU hmenuIn;
        HMENU hmenuNext;
        HWND hwndNext;
    } MDINEXTMENU, *PMDINEXTMENU, *LPMDINEXTMENU;

#pragma endregion

#pragma region Desktop Family

    typedef struct
    {
        GUID PowerSetting;
        DWORD DataLength;
        UCHAR Data[1];
    } POWERBROADCAST_SETTING, *PPOWERBROADCAST_SETTING;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) UINT __stdcall RegisterWindowMessageA(LPCSTR lpString);
    __declspec(dllimport) UINT __stdcall RegisterWindowMessageW(LPCWSTR lpString);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagWINDOWPOS
    {
        HWND hwnd;
        HWND hwndInsertAfter;
        int x;
        int y;
        int cx;
        int cy;
        UINT flags;
    } WINDOWPOS, *LPWINDOWPOS, *PWINDOWPOS;

    typedef struct tagNCCALCSIZE_PARAMS
    {
        RECT rgrc[3];
        PWINDOWPOS lppos;
    } NCCALCSIZE_PARAMS, *LPNCCALCSIZE_PARAMS;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagTRACKMOUSEEVENT
    {
        DWORD cbSize;
        DWORD dwFlags;
        HWND hwndTrack;
        DWORD dwHoverTime;
    } TRACKMOUSEEVENT, *LPTRACKMOUSEEVENT;

    __declspec(dllimport) BOOL __stdcall TrackMouseEvent(LPTRACKMOUSEEVENT lpEventTrack);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall DrawEdge(HDC hdc, LPRECT qrc, UINT edge, UINT grfFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall DrawFrameControl(HDC, LPRECT, UINT, UINT);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall DrawCaption(HWND hwnd, HDC hdc, const RECT* lprect, UINT flags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall DrawAnimatedRects(HWND hwnd, int idAni, const RECT* lprcFrom, const RECT* lprcTo);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagACCEL
    {
        BYTE fVirt;
        WORD key;
        WORD cmd;

    } ACCEL, *LPACCEL;

    typedef struct tagPAINTSTRUCT
    {
        HDC hdc;
        BOOL fErase;
        RECT rcPaint;
        BOOL fRestore;
        BOOL fIncUpdate;
        BYTE rgbReserved[32];
    } PAINTSTRUCT, *PPAINTSTRUCT, *NPPAINTSTRUCT, *LPPAINTSTRUCT;

    typedef struct tagCREATESTRUCTA
    {
        LPVOID lpCreateParams;
        HINSTANCE hInstance;
        HMENU hMenu;
        HWND hwndParent;
        int cy;
        int cx;
        int y;
        int x;
        LONG style;
        LPCSTR lpszName;
        LPCSTR lpszClass;
        DWORD dwExStyle;
    } CREATESTRUCTA, *LPCREATESTRUCTA;
    typedef struct tagCREATESTRUCTW
    {
        LPVOID lpCreateParams;
        HINSTANCE hInstance;
        HMENU hMenu;
        HWND hwndParent;
        int cy;
        int cx;
        int y;
        int x;
        LONG style;
        LPCWSTR lpszName;
        LPCWSTR lpszClass;
        DWORD dwExStyle;
    } CREATESTRUCTW, *LPCREATESTRUCTW;

    typedef CREATESTRUCTA CREATESTRUCT;
    typedef LPCREATESTRUCTA LPCREATESTRUCT;

    typedef struct tagWINDOWPLACEMENT
    {
        UINT length;
        UINT flags;
        UINT showCmd;
        POINT ptMinPosition;
        POINT ptMaxPosition;
        RECT rcNormalPosition;

    } WINDOWPLACEMENT;
    typedef WINDOWPLACEMENT *PWINDOWPLACEMENT, *LPWINDOWPLACEMENT;

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct tagNMHDR
    {
        HWND hwndFrom;
        UINT_PTR idFrom;
        UINT code;
    } NMHDR;

#pragma endregion

#pragma region Desktop Family

    typedef NMHDR* LPNMHDR;

    typedef struct tagSTYLESTRUCT
    {
        DWORD styleOld;
        DWORD styleNew;
    } STYLESTRUCT, *LPSTYLESTRUCT;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagMEASUREITEMSTRUCT
    {
        UINT CtlType;
        UINT CtlID;
        UINT itemID;
        UINT itemWidth;
        UINT itemHeight;
        ULONG_PTR itemData;
    } MEASUREITEMSTRUCT, *PMEASUREITEMSTRUCT, *LPMEASUREITEMSTRUCT;

    typedef struct tagDRAWITEMSTRUCT
    {
        UINT CtlType;
        UINT CtlID;
        UINT itemID;
        UINT itemAction;
        UINT itemState;
        HWND hwndItem;
        HDC hDC;
        RECT rcItem;
        ULONG_PTR itemData;
    } DRAWITEMSTRUCT, *PDRAWITEMSTRUCT, *LPDRAWITEMSTRUCT;

    typedef struct tagDELETEITEMSTRUCT
    {
        UINT CtlType;
        UINT CtlID;
        UINT itemID;
        HWND hwndItem;
        ULONG_PTR itemData;
    } DELETEITEMSTRUCT, *PDELETEITEMSTRUCT, *LPDELETEITEMSTRUCT;

    typedef struct tagCOMPAREITEMSTRUCT
    {
        UINT CtlType;
        UINT CtlID;
        HWND hwndItem;
        UINT itemID1;
        ULONG_PTR itemData1;
        UINT itemID2;
        ULONG_PTR itemData2;
        DWORD dwLocaleId;
    } COMPAREITEMSTRUCT, *PCOMPAREITEMSTRUCT, *LPCOMPAREITEMSTRUCT;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GetMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);
    __declspec(dllimport) BOOL __stdcall GetMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax);

    __inline BOOL GetMessage(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax)
    {
        return GetMessageA(lpMsg, hWnd, wMsgFilterMin, wMsgFilterMax);
    }

    __declspec(dllimport) BOOL __stdcall TranslateMessage(const MSG* lpMsg);

    __declspec(dllimport) LRESULT __stdcall DispatchMessageA(const MSG* lpMsg);
    __declspec(dllimport) LRESULT __stdcall DispatchMessageW(const MSG* lpMsg);

    __inline LRESULT DispatchMessage(const MSG* lpMsg)
    {
        return DispatchMessageA(lpMsg);
    }

    __declspec(dllimport) BOOL __stdcall SetMessageQueue(int cMessagesMax);

    __declspec(dllimport) BOOL
    __stdcall PeekMessageA(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);
    __declspec(dllimport) BOOL
    __stdcall PeekMessageW(LPMSG lpMsg, HWND hWnd, UINT wMsgFilterMin, UINT wMsgFilterMax, UINT wRemoveMsg);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall RegisterHotKey(HWND hWnd, int id, UINT fsModifiers, UINT vk);

    __declspec(dllimport) BOOL __stdcall UnregisterHotKey(HWND hWnd, int id);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall ExitWindowsEx(UINT uFlags, DWORD dwReason);

    __declspec(dllimport) BOOL __stdcall SwapMouseButton(BOOL fSwap);

    __declspec(dllimport) DWORD __stdcall GetMessagePos(void);

    __declspec(dllimport) LONG __stdcall GetMessageTime(void);

    __declspec(dllimport) LPARAM __stdcall GetMessageExtraInfo(void);

    __declspec(dllimport) DWORD __stdcall GetUnpredictedMessagePos(void);

    __declspec(dllimport) BOOL __stdcall IsWow64Message(void);

    __declspec(dllimport) LPARAM __stdcall SetMessageExtraInfo(LPARAM lParam);

    __declspec(dllimport) LRESULT __stdcall SendMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport) LRESULT __stdcall SendMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

    __inline LRESULT SendMessage(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam)
    {
        return SendMessageA(hWnd, Msg, wParam, lParam);
    }

    __declspec(dllimport) LRESULT
    __stdcall SendMessageTimeoutA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult);
    __declspec(dllimport) LRESULT
    __stdcall SendMessageTimeoutW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, UINT fuFlags, UINT uTimeout, PDWORD_PTR lpdwResult);

    __declspec(dllimport) BOOL __stdcall SendNotifyMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport) BOOL __stdcall SendNotifyMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

    __declspec(dllimport) BOOL
    __stdcall SendMessageCallbackA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData);
    __declspec(dllimport) BOOL
    __stdcall SendMessageCallbackW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam, SENDASYNCPROC lpResultCallBack, ULONG_PTR dwData);

    typedef struct
    {
        UINT cbSize;
        HDESK hdesk;
        HWND hwnd;
        LUID luid;
    } BSMINFO, *PBSMINFO;

    __declspec(dllimport) long __stdcall BroadcastSystemMessageExA(
    DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo);
    __declspec(dllimport) long __stdcall BroadcastSystemMessageExW(
    DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam, PBSMINFO pbsmInfo);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) long __stdcall BroadcastSystemMessageA(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport) long __stdcall BroadcastSystemMessageW(DWORD flags, LPDWORD lpInfo, UINT Msg, WPARAM wParam, LPARAM lParam);

#pragma endregion

#pragma region Desktop Family

    typedef PVOID HDEVNOTIFY;
    typedef HDEVNOTIFY* PHDEVNOTIFY;

    __declspec(dllimport) HDEVNOTIFY
    __stdcall RegisterDeviceNotificationA(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags);
    __declspec(dllimport) HDEVNOTIFY
    __stdcall RegisterDeviceNotificationW(HANDLE hRecipient, LPVOID NotificationFilter, DWORD Flags);

    __declspec(dllimport) BOOL __stdcall UnregisterDeviceNotification(HDEVNOTIFY Handle);

    typedef PVOID HPOWERNOTIFY;
    typedef HPOWERNOTIFY* PHPOWERNOTIFY;

    __declspec(dllimport) HPOWERNOTIFY
    __stdcall RegisterPowerSettingNotification(HANDLE hRecipient, LPCGUID PowerSettingGuid, DWORD Flags);

    __declspec(dllimport) BOOL __stdcall UnregisterPowerSettingNotification(HPOWERNOTIFY Handle);

    __declspec(dllimport) HPOWERNOTIFY __stdcall RegisterSuspendResumeNotification(HANDLE hRecipient, DWORD Flags);

    __declspec(dllimport) BOOL __stdcall UnregisterSuspendResumeNotification(HPOWERNOTIFY Handle);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall PostMessageA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport) BOOL __stdcall PostMessageW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

    __declspec(dllimport) BOOL __stdcall PostThreadMessageA(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport) BOOL __stdcall PostThreadMessageW(DWORD idThread, UINT Msg, WPARAM wParam, LPARAM lParam);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall AttachThreadInput(DWORD idAttach, DWORD idAttachTo, BOOL fAttach);

    __declspec(dllimport) BOOL __stdcall ReplyMessage(LRESULT lResult);

    __declspec(dllimport) BOOL __stdcall WaitMessage(void);

    __declspec(dllimport) DWORD __stdcall WaitForInputIdle(HANDLE hProcess, DWORD dwMilliseconds);

    __declspec(dllimport)

    LRESULT __stdcall

    DefWindowProcA(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport)

    LRESULT __stdcall

    DefWindowProcW(HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

    __declspec(dllimport) void __stdcall PostQuitMessage(int nExitCode);

    __declspec(dllimport) LRESULT
    __stdcall CallWindowProcA(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport) LRESULT
    __stdcall CallWindowProcW(WNDPROC lpPrevWndFunc, HWND hWnd, UINT Msg, WPARAM wParam, LPARAM lParam);

    __declspec(dllimport) BOOL __stdcall InSendMessage(void);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) DWORD __stdcall InSendMessageEx(LPVOID lpReserved);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) UINT __stdcall GetDoubleClickTime(void);

    __declspec(dllimport) BOOL __stdcall SetDoubleClickTime(UINT);

    __declspec(dllimport) ATOM __stdcall RegisterClassA(const WNDCLASSA* lpWndClass);
    __declspec(dllimport) ATOM __stdcall RegisterClassW(const WNDCLASSW* lpWndClass);

    __declspec(dllimport) BOOL __stdcall UnregisterClassA(LPCSTR lpClassName, HINSTANCE hInstance);
    __declspec(dllimport) BOOL __stdcall UnregisterClassW(LPCWSTR lpClassName, HINSTANCE hInstance);

    __declspec(dllimport) BOOL __stdcall GetClassInfoA(HINSTANCE hInstance, LPCSTR lpClassName, LPWNDCLASSA lpWndClass);

    __declspec(dllimport) BOOL __stdcall GetClassInfoW(HINSTANCE hInstance, LPCWSTR lpClassName, LPWNDCLASSW lpWndClass);

    __declspec(dllimport) ATOM __stdcall RegisterClassExA(const WNDCLASSEXA*);
    __declspec(dllimport) ATOM __stdcall RegisterClassExW(const WNDCLASSEXW*);

    __declspec(dllimport) BOOL __stdcall GetClassInfoExA(HINSTANCE hInstance, LPCSTR lpszClass, LPWNDCLASSEXA lpwcx);

    __declspec(dllimport) BOOL __stdcall GetClassInfoExW(HINSTANCE hInstance, LPCWSTR lpszClass, LPWNDCLASSEXW lpwcx);

#pragma endregion

#pragma region Desktop Family

    typedef BOOLEAN(__stdcall* PREGISTERCLASSNAMEW)(LPCWSTR);

    __declspec(dllimport) HWND __stdcall CreateWindowExA(DWORD dwExStyle,
                                                         LPCSTR lpClassName,
                                                         LPCSTR lpWindowName,
                                                         DWORD dwStyle,
                                                         int X,
                                                         int Y,
                                                         int nWidth,
                                                         int nHeight,
                                                         HWND hWndParent,
                                                         HMENU hMenu,
                                                         HINSTANCE hInstance,
                                                         LPVOID lpParam);
    __declspec(dllimport) HWND __stdcall CreateWindowExW(DWORD dwExStyle,
                                                         LPCWSTR lpClassName,
                                                         LPCWSTR lpWindowName,
                                                         DWORD dwStyle,
                                                         int X,
                                                         int Y,
                                                         int nWidth,
                                                         int nHeight,
                                                         HWND hWndParent,
                                                         HMENU hMenu,
                                                         HINSTANCE hInstance,
                                                         LPVOID lpParam);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall IsWindow(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall IsMenu(HMENU hMenu);

    __declspec(dllimport) BOOL __stdcall IsChild(HWND hWndParent, HWND hWnd);

    __declspec(dllimport) BOOL __stdcall DestroyWindow(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall ShowWindow(HWND hWnd, int nCmdShow);

    __declspec(dllimport) BOOL __stdcall AnimateWindow(HWND hWnd, DWORD dwTime, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall UpdateLayeredWindow(
    HWND hWnd, HDC hdcDst, POINT* pptDst, SIZE* psize, HDC hdcSrc, POINT* pptSrc, COLORREF crKey, BLENDFUNCTION* pblend, DWORD dwFlags);

    typedef struct tagUPDATELAYEREDWINDOWINFO
    {
        DWORD cbSize;
        HDC hdcDst;
        const POINT* pptDst;
        const SIZE* psize;
        HDC hdcSrc;
        const POINT* pptSrc;
        COLORREF crKey;
        const BLENDFUNCTION* pblend;
        DWORD dwFlags;
        const RECT* prcDirty;
    } UPDATELAYEREDWINDOWINFO, *PUPDATELAYEREDWINDOWINFO;

    __declspec(dllimport) BOOL __stdcall UpdateLayeredWindowIndirect(HWND hWnd, const UPDATELAYEREDWINDOWINFO* pULWInfo);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GetLayeredWindowAttributes(HWND hwnd, COLORREF* pcrKey, BYTE* pbAlpha, DWORD* pdwFlags);

    __declspec(dllimport) BOOL __stdcall PrintWindow(HWND hwnd, HDC hdcBlt, UINT nFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall SetLayeredWindowAttributes(HWND hwnd, COLORREF crKey, BYTE bAlpha, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall ShowWindowAsync(HWND hWnd, int nCmdShow);

    __declspec(dllimport) BOOL __stdcall FlashWindow(HWND hWnd, BOOL bInvert);

    typedef struct
    {
        UINT cbSize;
        HWND hwnd;
        DWORD dwFlags;
        UINT uCount;
        DWORD dwTimeout;
    } FLASHWINFO, *PFLASHWINFO;

    __declspec(dllimport) BOOL __stdcall FlashWindowEx(PFLASHWINFO pfwi);

    __declspec(dllimport) BOOL __stdcall ShowOwnedPopups(HWND hWnd, BOOL fShow);

    __declspec(dllimport) BOOL __stdcall OpenIcon(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall CloseWindow(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall MoveWindow(HWND hWnd, int X, int Y, int nWidth, int nHeight, BOOL bRepaint);

    __declspec(dllimport) BOOL __stdcall SetWindowPos(HWND hWnd, HWND hWndInsertAfter, int X, int Y, int cx, int cy, UINT uFlags);

    __declspec(dllimport) BOOL __stdcall GetWindowPlacement(HWND hWnd, WINDOWPLACEMENT* lpwndpl);

    __declspec(dllimport) BOOL __stdcall SetWindowPlacement(HWND hWnd, const WINDOWPLACEMENT* lpwndpl);

    __declspec(dllimport) BOOL __stdcall GetWindowDisplayAffinity(HWND hWnd, DWORD* pdwAffinity);

    __declspec(dllimport) BOOL __stdcall SetWindowDisplayAffinity(HWND hWnd, DWORD dwAffinity);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HDWP __stdcall BeginDeferWindowPos(int nNumWindows);

    __declspec(dllimport) HDWP
    __stdcall DeferWindowPos(HDWP hWinPosInfo, HWND hWnd, HWND hWndInsertAfter, int x, int y, int cx, int cy, UINT uFlags);

    __declspec(dllimport) BOOL __stdcall EndDeferWindowPos(HDWP hWinPosInfo);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall IsWindowVisible(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall IsIconic(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall AnyPopup(void);

    __declspec(dllimport) BOOL __stdcall BringWindowToTop(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall IsZoomed(HWND hWnd);

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(push, 2)

#pragma region Application Family or OneCore Family

    typedef struct
    {
        DWORD style;
        DWORD dwExtendedStyle;
        WORD cdit;
        short x;
        short y;
        short cx;
        short cy;
    } DLGTEMPLATE;

#pragma endregion

#pragma region Desktop Family

    typedef DLGTEMPLATE* LPDLGTEMPLATEA;
    typedef DLGTEMPLATE* LPDLGTEMPLATEW;

    typedef LPDLGTEMPLATEA LPDLGTEMPLATE;

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef const DLGTEMPLATE* LPCDLGTEMPLATEA;
    typedef const DLGTEMPLATE* LPCDLGTEMPLATEW;

    typedef LPCDLGTEMPLATEA LPCDLGTEMPLATE;

#pragma endregion

#pragma region Desktop Family

    typedef struct
    {
        DWORD style;
        DWORD dwExtendedStyle;
        short x;
        short y;
        short cx;
        short cy;
        WORD id;
    } DLGITEMTEMPLATE;
    typedef DLGITEMTEMPLATE* PDLGITEMTEMPLATEA;
    typedef DLGITEMTEMPLATE* PDLGITEMTEMPLATEW;

    typedef PDLGITEMTEMPLATEA PDLGITEMTEMPLATE;
    typedef DLGITEMTEMPLATE* LPDLGITEMTEMPLATEA;
    typedef DLGITEMTEMPLATE* LPDLGITEMTEMPLATEW;

    typedef LPDLGITEMTEMPLATEA LPDLGITEMTEMPLATE;

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma region Desktop Family

    __declspec(dllimport) HWND
    __stdcall CreateDialogParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
    __declspec(dllimport) HWND
    __stdcall CreateDialogParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);

    __declspec(dllimport) HWND
    __stdcall CreateDialogIndirectParamA(HINSTANCE hInstance, LPCDLGTEMPLATEA lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
    __declspec(dllimport) HWND
    __stdcall CreateDialogIndirectParamW(HINSTANCE hInstance, LPCDLGTEMPLATEW lpTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);

    __declspec(dllimport) INT_PTR
    __stdcall DialogBoxParamA(HINSTANCE hInstance, LPCSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
    __declspec(dllimport) INT_PTR
    __stdcall DialogBoxParamW(HINSTANCE hInstance, LPCWSTR lpTemplateName, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);

    __declspec(dllimport) INT_PTR __stdcall DialogBoxIndirectParamA(
    HINSTANCE hInstance, LPCDLGTEMPLATEA hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);
    __declspec(dllimport) INT_PTR __stdcall DialogBoxIndirectParamW(
    HINSTANCE hInstance, LPCDLGTEMPLATEW hDialogTemplate, HWND hWndParent, DLGPROC lpDialogFunc, LPARAM dwInitParam);

    __declspec(dllimport) BOOL __stdcall EndDialog(HWND hDlg, INT_PTR nResult);

    __declspec(dllimport) HWND __stdcall GetDlgItem(HWND hDlg, int nIDDlgItem);

    __declspec(dllimport) BOOL __stdcall SetDlgItemInt(HWND hDlg, int nIDDlgItem, UINT uValue, BOOL bSigned);

    __declspec(dllimport) UINT __stdcall GetDlgItemInt(HWND hDlg, int nIDDlgItem, BOOL* lpTranslated, BOOL bSigned);

    __declspec(dllimport) BOOL __stdcall SetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPCSTR lpString);
    __declspec(dllimport) BOOL __stdcall SetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPCWSTR lpString);

    __declspec(dllimport) UINT __stdcall GetDlgItemTextA(HWND hDlg, int nIDDlgItem, LPSTR lpString, int cchMax);

    __declspec(dllimport) UINT __stdcall GetDlgItemTextW(HWND hDlg, int nIDDlgItem, LPWSTR lpString, int cchMax);

    __declspec(dllimport) BOOL __stdcall CheckDlgButton(HWND hDlg, int nIDButton, UINT uCheck);

    __declspec(dllimport) BOOL __stdcall CheckRadioButton(HWND hDlg, int nIDFirstButton, int nIDLastButton, int nIDCheckButton);

    __declspec(dllimport) UINT __stdcall IsDlgButtonChecked(HWND hDlg, int nIDButton);

    __declspec(dllimport) LRESULT __stdcall SendDlgItemMessageA(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport) LRESULT __stdcall SendDlgItemMessageW(HWND hDlg, int nIDDlgItem, UINT Msg, WPARAM wParam, LPARAM lParam);

    __declspec(dllimport) HWND __stdcall GetNextDlgGroupItem(HWND hDlg, HWND hCtl, BOOL bPrevious);

    __declspec(dllimport) HWND __stdcall GetNextDlgTabItem(HWND hDlg, HWND hCtl, BOOL bPrevious);

    __declspec(dllimport) int __stdcall GetDlgCtrlID(HWND hWnd);

    __declspec(dllimport) long __stdcall GetDialogBaseUnits(void);

    __declspec(dllimport)

    LRESULT __stdcall

    DefDlgProcA(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport)

    LRESULT __stdcall

    DefDlgProcW(HWND hDlg, UINT Msg, WPARAM wParam, LPARAM lParam);

    typedef enum DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS
    {
        DCDC_DEFAULT = 0x0000,
        DCDC_DISABLE_FONT_UPDATE = 0x0001,
        DCDC_DISABLE_RELAYOUT = 0x0002,
    } DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS;

    extern "C++"
    {
        inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS
        operator|(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(
            ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a)
            | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS&
        operator|=(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS& a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return (
            DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type&)a)
                                                  |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS
        operator&(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(
            ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a)
            & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS&
        operator&=(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS& a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return (
            DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type&)a)
                                                  &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS operator~(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a) throw()
        {
            return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a));
        }
        inline constexpr DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS
        operator^(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS(
            ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)a)
            ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS&
        operator^=(DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS& a, DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return (
            DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type&)a)
                                                  ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS>::type)b));
        }
    };

    BOOL __stdcall SetDialogControlDpiChangeBehavior(HWND hWnd,
                                                     DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS mask,
                                                     DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS values);

    DIALOG_CONTROL_DPI_CHANGE_BEHAVIORS
    __stdcall GetDialogControlDpiChangeBehavior(HWND hWnd);

    typedef enum DIALOG_DPI_CHANGE_BEHAVIORS
    {
        DDC_DEFAULT = 0x0000,
        DDC_DISABLE_ALL = 0x0001,
        DDC_DISABLE_RESIZE = 0x0002,
        DDC_DISABLE_CONTROL_RELAYOUT = 0x0004,
    } DIALOG_DPI_CHANGE_BEHAVIORS;

    extern "C++"
    {
        inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator|(DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a)
                                               | ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline DIALOG_DPI_CHANGE_BEHAVIORS& operator|=(DIALOG_DPI_CHANGE_BEHAVIORS& a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return (DIALOG_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type&)a)
                                                  |= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator&(DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a)
                                               & ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline DIALOG_DPI_CHANGE_BEHAVIORS& operator&=(DIALOG_DPI_CHANGE_BEHAVIORS& a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return (DIALOG_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type&)a)
                                                  &= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator~(DIALOG_DPI_CHANGE_BEHAVIORS a) throw()
        {
            return DIALOG_DPI_CHANGE_BEHAVIORS(~((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a));
        }
        inline constexpr DIALOG_DPI_CHANGE_BEHAVIORS operator^(DIALOG_DPI_CHANGE_BEHAVIORS a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return DIALOG_DPI_CHANGE_BEHAVIORS(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)a)
                                               ^ ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b));
        }
        inline DIALOG_DPI_CHANGE_BEHAVIORS& operator^=(DIALOG_DPI_CHANGE_BEHAVIORS& a, DIALOG_DPI_CHANGE_BEHAVIORS b) throw()
        {
            return (DIALOG_DPI_CHANGE_BEHAVIORS&)(((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type&)a)
                                                  ^= ((_ENUM_FLAG_SIZED_INTEGER<DIALOG_DPI_CHANGE_BEHAVIORS>::type)b));
        }
    };

    BOOL __stdcall SetDialogDpiChangeBehavior(HWND hDlg, DIALOG_DPI_CHANGE_BEHAVIORS mask, DIALOG_DPI_CHANGE_BEHAVIORS values);

    DIALOG_DPI_CHANGE_BEHAVIORS
    __stdcall GetDialogDpiChangeBehavior(HWND hDlg);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall CallMsgFilterA(LPMSG lpMsg, int nCode);
    __declspec(dllimport) BOOL __stdcall CallMsgFilterW(LPMSG lpMsg, int nCode);

    __declspec(dllimport) BOOL __stdcall OpenClipboard(HWND hWndNewOwner);

    __declspec(dllimport) BOOL __stdcall CloseClipboard(void);

    __declspec(dllimport) DWORD __stdcall GetClipboardSequenceNumber(void);

    __declspec(dllimport) HWND __stdcall GetClipboardOwner(void);

    __declspec(dllimport) HWND __stdcall SetClipboardViewer(HWND hWndNewViewer);

    __declspec(dllimport) HWND __stdcall GetClipboardViewer(void);

    __declspec(dllimport) BOOL __stdcall ChangeClipboardChain(HWND hWndRemove, HWND hWndNewNext);

    __declspec(dllimport) HANDLE __stdcall SetClipboardData(UINT uFormat, HANDLE hMem);

    __declspec(dllimport) HANDLE __stdcall GetClipboardData(UINT uFormat);

    __declspec(dllimport) UINT __stdcall RegisterClipboardFormatA(LPCSTR lpszFormat);
    __declspec(dllimport) UINT __stdcall RegisterClipboardFormatW(LPCWSTR lpszFormat);

    __declspec(dllimport) int __stdcall CountClipboardFormats(void);

    __declspec(dllimport) UINT __stdcall EnumClipboardFormats(UINT format);

    __declspec(dllimport) int __stdcall GetClipboardFormatNameA(UINT format, LPSTR lpszFormatName, int cchMaxCount);
    __declspec(dllimport) int __stdcall GetClipboardFormatNameW(UINT format, LPWSTR lpszFormatName, int cchMaxCount);

    __declspec(dllimport) BOOL __stdcall EmptyClipboard(void);

    __declspec(dllimport) BOOL __stdcall IsClipboardFormatAvailable(UINT format);

    __declspec(dllimport) int __stdcall GetPriorityClipboardFormat(UINT* paFormatPriorityList, int cFormats);

    __declspec(dllimport) HWND __stdcall GetOpenClipboardWindow(void);

    __declspec(dllimport) BOOL __stdcall AddClipboardFormatListener(HWND hwnd);

    __declspec(dllimport) BOOL __stdcall RemoveClipboardFormatListener(HWND hwnd);

    __declspec(dllimport) BOOL __stdcall GetUpdatedClipboardFormats(PUINT lpuiFormats, UINT cFormats, PUINT pcFormatsOut);

    __declspec(dllimport) BOOL __stdcall CharToOemA(LPCSTR pSrc, LPSTR pDst);
    __declspec(dllimport) BOOL __stdcall CharToOemW(LPCWSTR pSrc, LPSTR pDst);

    __declspec(dllimport) BOOL __stdcall OemToCharA(LPCSTR pSrc, LPSTR pDst);

    __declspec(dllimport) BOOL __stdcall OemToCharW(LPCSTR pSrc, LPWSTR pDst);

    __declspec(dllimport) BOOL __stdcall CharToOemBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength);
    __declspec(dllimport) BOOL __stdcall CharToOemBuffW(LPCWSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength);

    __declspec(dllimport) BOOL __stdcall OemToCharBuffA(LPCSTR lpszSrc, LPSTR lpszDst, DWORD cchDstLength);
    __declspec(dllimport) BOOL __stdcall OemToCharBuffW(LPCSTR lpszSrc, LPWSTR lpszDst, DWORD cchDstLength);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) LPSTR __stdcall CharUpperA(LPSTR lpsz);
    __declspec(dllimport) LPWSTR __stdcall CharUpperW(LPWSTR lpsz);

    __declspec(dllimport) DWORD __stdcall CharUpperBuffA(LPSTR lpsz, DWORD cchLength);
    __declspec(dllimport) DWORD __stdcall CharUpperBuffW(LPWSTR lpsz, DWORD cchLength);

    __declspec(dllimport) LPSTR __stdcall CharLowerA(LPSTR lpsz);
    __declspec(dllimport) LPWSTR __stdcall CharLowerW(LPWSTR lpsz);

    __declspec(dllimport) DWORD __stdcall CharLowerBuffA(LPSTR lpsz, DWORD cchLength);
    __declspec(dllimport) DWORD __stdcall CharLowerBuffW(LPWSTR lpsz, DWORD cchLength);

    __declspec(dllimport) LPSTR __stdcall CharNextA(LPCSTR lpsz);
    __declspec(dllimport) LPWSTR __stdcall CharNextW(LPCWSTR lpsz);

    __declspec(dllimport) LPSTR __stdcall CharPrevA(LPCSTR lpszStart, LPCSTR lpszCurrent);
    __declspec(dllimport) LPWSTR __stdcall CharPrevW(LPCWSTR lpszStart, LPCWSTR lpszCurrent);

    __declspec(dllimport) LPSTR __stdcall CharNextExA(WORD CodePage, LPCSTR lpCurrentChar, DWORD dwFlags);

    __declspec(dllimport) LPSTR __stdcall CharPrevExA(WORD CodePage, LPCSTR lpStart, LPCSTR lpCurrentChar, DWORD dwFlags);

#pragma endregion

#pragma region Desktop or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsCharAlphaA(CHAR ch);
    __declspec(dllimport) BOOL __stdcall IsCharAlphaW(WCHAR ch);

    __declspec(dllimport) BOOL __stdcall IsCharAlphaNumericA(CHAR ch);
    __declspec(dllimport) BOOL __stdcall IsCharAlphaNumericW(WCHAR ch);

    __declspec(dllimport) BOOL __stdcall IsCharUpperA(CHAR ch);
    __declspec(dllimport) BOOL __stdcall IsCharUpperW(WCHAR ch);

    __declspec(dllimport) BOOL __stdcall IsCharLowerA(CHAR ch);
    __declspec(dllimport) BOOL __stdcall IsCharLowerW(WCHAR ch);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HWND __stdcall SetFocus(HWND hWnd);

    __declspec(dllimport) HWND __stdcall GetActiveWindow(void);

    __declspec(dllimport) HWND __stdcall GetFocus(void);

    __declspec(dllimport) UINT __stdcall GetKBCodePage(void);

    __declspec(dllimport) SHORT __stdcall GetKeyState(int nVirtKey);

    __declspec(dllimport) SHORT __stdcall GetAsyncKeyState(int vKey);

    __declspec(dllimport)

    BOOL __stdcall GetKeyboardState(PBYTE lpKeyState);

    __declspec(dllimport) BOOL __stdcall SetKeyboardState(LPBYTE lpKeyState);

#pragma endregion

#pragma region Desktop or PC Family

    __declspec(dllimport) int __stdcall GetKeyNameTextA(LONG lParam, LPSTR lpString, int cchSize);
    __declspec(dllimport) int __stdcall GetKeyNameTextW(LONG lParam, LPWSTR lpString, int cchSize);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall GetKeyboardType(int nTypeFlag);

    __declspec(dllimport) int __stdcall ToAscii(UINT uVirtKey, UINT uScanCode, const BYTE* lpKeyState, LPWORD lpChar, UINT uFlags);

    __declspec(dllimport) int __stdcall ToAsciiEx(UINT uVirtKey, UINT uScanCode, const BYTE* lpKeyState, LPWORD lpChar, UINT uFlags, HKL dwhkl);

    __declspec(dllimport) int __stdcall ToUnicode(UINT wVirtKey, UINT wScanCode, const BYTE* lpKeyState, LPWSTR pwszBuff, int cchBuff, UINT wFlags);

    __declspec(dllimport) DWORD __stdcall OemKeyScan(WORD wOemChar);

    __declspec(dllimport) SHORT __stdcall VkKeyScanA(CHAR ch);
    __declspec(dllimport) SHORT __stdcall VkKeyScanW(WCHAR ch);

    __declspec(dllimport) SHORT __stdcall VkKeyScanExA(CHAR ch, HKL dwhkl);
    __declspec(dllimport) SHORT __stdcall VkKeyScanExW(WCHAR ch, HKL dwhkl);

    __declspec(dllimport) void __stdcall keybd_event(BYTE bVk, BYTE bScan, DWORD dwFlags, ULONG_PTR dwExtraInfo);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) void __stdcall mouse_event(DWORD dwFlags, DWORD dx, DWORD dy, DWORD dwData, ULONG_PTR dwExtraInfo);

#pragma endregion

    typedef struct tagMOUSEINPUT
    {
        LONG dx;
        LONG dy;
        DWORD mouseData;
        DWORD dwFlags;
        DWORD time;
        ULONG_PTR dwExtraInfo;
    } MOUSEINPUT, *PMOUSEINPUT, *LPMOUSEINPUT;

    typedef struct tagKEYBDINPUT
    {
        WORD wVk;
        WORD wScan;
        DWORD dwFlags;
        DWORD time;
        ULONG_PTR dwExtraInfo;
    } KEYBDINPUT, *PKEYBDINPUT, *LPKEYBDINPUT;

#pragma region Desktop Family

    typedef struct tagHARDWAREINPUT
    {
        DWORD uMsg;
        WORD wParamL;
        WORD wParamH;
    } HARDWAREINPUT, *PHARDWAREINPUT, *LPHARDWAREINPUT;

    typedef struct tagINPUT
    {
        DWORD type;

        union
        {
            MOUSEINPUT mi;
            KEYBDINPUT ki;
            HARDWAREINPUT hi;
        };
    } INPUT, *PINPUT, *LPINPUT;

    __declspec(dllimport) UINT __stdcall SendInput(UINT cInputs, LPINPUT pInputs, int cbSize);

#pragma endregion

#pragma region Desktop Family

    struct HTOUCHINPUT__
    {
        int unused;
    };
    typedef struct HTOUCHINPUT__* HTOUCHINPUT;

    typedef struct tagTOUCHINPUT
    {
        LONG x;
        LONG y;
        HANDLE hSource;
        DWORD dwID;
        DWORD dwFlags;
        DWORD dwMask;
        DWORD dwTime;
        ULONG_PTR dwExtraInfo;
        DWORD cxContact;
        DWORD cyContact;
    } TOUCHINPUT, *PTOUCHINPUT;
    typedef TOUCHINPUT const* PCTOUCHINPUT;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GetTouchInputInfo(HTOUCHINPUT hTouchInput, UINT cInputs, PTOUCHINPUT pInputs, int cbSize);

    __declspec(dllimport) BOOL __stdcall CloseTouchInputHandle(HTOUCHINPUT hTouchInput);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall RegisterTouchWindow(HWND hwnd, ULONG ulFlags);

    __declspec(dllimport) BOOL __stdcall UnregisterTouchWindow(HWND hwnd);

    __declspec(dllimport) BOOL __stdcall IsTouchWindow(HWND hwnd, PULONG pulFlags);

#pragma endregion

#pragma region Desktop Family

    enum tagPOINTER_INPUT_TYPE
    {
        PT_POINTER = 1,
        PT_TOUCH = 2,
        PT_PEN = 3,
        PT_MOUSE = 4,

        PT_TOUCHPAD = 5,
    };

    typedef DWORD POINTER_INPUT_TYPE;

    typedef UINT32 POINTER_FLAGS;

#pragma endregion

#pragma region Desktop Family

    typedef enum tagPOINTER_BUTTON_CHANGE_TYPE
    {
        POINTER_CHANGE_NONE,
        POINTER_CHANGE_FIRSTBUTTON_DOWN,
        POINTER_CHANGE_FIRSTBUTTON_UP,
        POINTER_CHANGE_SECONDBUTTON_DOWN,
        POINTER_CHANGE_SECONDBUTTON_UP,
        POINTER_CHANGE_THIRDBUTTON_DOWN,
        POINTER_CHANGE_THIRDBUTTON_UP,
        POINTER_CHANGE_FOURTHBUTTON_DOWN,
        POINTER_CHANGE_FOURTHBUTTON_UP,
        POINTER_CHANGE_FIFTHBUTTON_DOWN,
        POINTER_CHANGE_FIFTHBUTTON_UP,
    } POINTER_BUTTON_CHANGE_TYPE;

    typedef struct tagPOINTER_INFO
    {
        POINTER_INPUT_TYPE pointerType;
        UINT32 pointerId;
        UINT32 frameId;
        POINTER_FLAGS pointerFlags;
        HANDLE sourceDevice;
        HWND hwndTarget;
        POINT ptPixelLocation;
        POINT ptHimetricLocation;
        POINT ptPixelLocationRaw;
        POINT ptHimetricLocationRaw;
        DWORD dwTime;
        UINT32 historyCount;
        INT32 InputData;
        DWORD dwKeyStates;
        UINT64 PerformanceCount;
        POINTER_BUTTON_CHANGE_TYPE ButtonChangeType;
    } POINTER_INFO;

    typedef UINT32 TOUCH_FLAGS;

    typedef UINT32 TOUCH_MASK;

    typedef struct tagPOINTER_TOUCH_INFO
    {
        POINTER_INFO pointerInfo;
        TOUCH_FLAGS touchFlags;
        TOUCH_MASK touchMask;
        RECT rcContact;
        RECT rcContactRaw;
        UINT32 orientation;
        UINT32 pressure;
    } POINTER_TOUCH_INFO;

    typedef UINT32 PEN_FLAGS;

    typedef UINT32 PEN_MASK;

    typedef struct tagPOINTER_PEN_INFO
    {
        POINTER_INFO pointerInfo;
        PEN_FLAGS penFlags;
        PEN_MASK penMask;
        UINT32 pressure;
        UINT32 rotation;
        INT32 tiltX;
        INT32 tiltY;
    } POINTER_PEN_INFO;

#pragma endregion

    typedef enum
    {
        POINTER_FEEDBACK_DEFAULT = 1,
        POINTER_FEEDBACK_INDIRECT = 2,
        POINTER_FEEDBACK_NONE = 3,
    } POINTER_FEEDBACK_MODE;

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall InitializeTouchInjection(UINT32 maxCount, DWORD dwMode);

    __declspec(dllimport) BOOL __stdcall InjectTouchInput(UINT32 count, const POINTER_TOUCH_INFO* contacts);

    typedef struct tagUSAGE_PROPERTIES
    {
        USHORT level;
        USHORT page;
        USHORT usage;
        INT32 logicalMinimum;
        INT32 logicalMaximum;
        USHORT unit;
        USHORT exponent;
        BYTE count;
        INT32 physicalMinimum;
        INT32 physicalMaximum;
    } USAGE_PROPERTIES, *PUSAGE_PROPERTIES;

    typedef struct tagPOINTER_TYPE_INFO
    {
        POINTER_INPUT_TYPE type;
        union
        {
            POINTER_TOUCH_INFO touchInfo;
            POINTER_PEN_INFO penInfo;
        };
    } POINTER_TYPE_INFO, *PPOINTER_TYPE_INFO;

    typedef struct tagINPUT_INJECTION_VALUE
    {
        USHORT page;
        USHORT usage;
        INT32 value;
        USHORT index;
    } INPUT_INJECTION_VALUE, *PINPUT_INJECTION_VALUE;

    __declspec(dllimport) BOOL __stdcall GetPointerType(UINT32 pointerId, POINTER_INPUT_TYPE* pointerType);

    __declspec(dllimport) BOOL __stdcall GetPointerCursorId(UINT32 pointerId, UINT32* cursorId);

    __declspec(dllimport) BOOL __stdcall GetPointerInfo(UINT32 pointerId, POINTER_INFO* pointerInfo);

    __declspec(dllimport) BOOL __stdcall GetPointerInfoHistory(UINT32 pointerId, UINT32* entriesCount, POINTER_INFO* pointerInfo);

    __declspec(dllimport) BOOL __stdcall GetPointerFrameInfo(UINT32 pointerId, UINT32* pointerCount, POINTER_INFO* pointerInfo);

    __declspec(dllimport) BOOL
    __stdcall GetPointerFrameInfoHistory(UINT32 pointerId, UINT32* entriesCount, UINT32* pointerCount, POINTER_INFO* pointerInfo);

    __declspec(dllimport) BOOL __stdcall GetPointerTouchInfo(UINT32 pointerId, POINTER_TOUCH_INFO* touchInfo);

    __declspec(dllimport) BOOL
    __stdcall GetPointerTouchInfoHistory(UINT32 pointerId, UINT32* entriesCount, POINTER_TOUCH_INFO* touchInfo);

    __declspec(dllimport) BOOL
    __stdcall GetPointerFrameTouchInfo(UINT32 pointerId, UINT32* pointerCount, POINTER_TOUCH_INFO* touchInfo);

    __declspec(dllimport) BOOL
    __stdcall GetPointerFrameTouchInfoHistory(UINT32 pointerId, UINT32* entriesCount, UINT32* pointerCount, POINTER_TOUCH_INFO* touchInfo);

    __declspec(dllimport) BOOL __stdcall GetPointerPenInfo(UINT32 pointerId, POINTER_PEN_INFO* penInfo);

    __declspec(dllimport) BOOL
    __stdcall GetPointerPenInfoHistory(UINT32 pointerId, UINT32* entriesCount, POINTER_PEN_INFO* penInfo);

    __declspec(dllimport) BOOL __stdcall GetPointerFramePenInfo(UINT32 pointerId, UINT32* pointerCount, POINTER_PEN_INFO* penInfo);

    __declspec(dllimport) BOOL
    __stdcall GetPointerFramePenInfoHistory(UINT32 pointerId, UINT32* entriesCount, UINT32* pointerCount, POINTER_PEN_INFO* penInfo);

    __declspec(dllimport) BOOL __stdcall SkipPointerFrameMessages(UINT32 pointerId);

    __declspec(dllimport) BOOL __stdcall RegisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType);

    __declspec(dllimport) BOOL __stdcall UnregisterPointerInputTarget(HWND hwnd, POINTER_INPUT_TYPE pointerType);

    __declspec(dllimport) BOOL __stdcall RegisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType, BOOL fObserve);

    __declspec(dllimport) BOOL __stdcall UnregisterPointerInputTargetEx(HWND hwnd, POINTER_INPUT_TYPE pointerType);

    struct HSYNTHETICPOINTERDEVICE__
    {
        int unused;
    };
    typedef struct HSYNTHETICPOINTERDEVICE__* HSYNTHETICPOINTERDEVICE;
    __declspec(dllimport) HSYNTHETICPOINTERDEVICE
    __stdcall CreateSyntheticPointerDevice(POINTER_INPUT_TYPE pointerType, ULONG maxCount, POINTER_FEEDBACK_MODE mode);

    __declspec(dllimport) BOOL
    __stdcall InjectSyntheticPointerInput(HSYNTHETICPOINTERDEVICE device, const POINTER_TYPE_INFO* pointerInfo, UINT32 count);

    __declspec(dllimport) void __stdcall DestroySyntheticPointerDevice(HSYNTHETICPOINTERDEVICE device);

    __declspec(dllimport) BOOL __stdcall EnableMouseInPointer(BOOL fEnable);

    __declspec(dllimport) BOOL __stdcall IsMouseInPointerEnabled(void);

    __declspec(dllimport) BOOL __stdcall EnableMouseInPointerForThread();

    __declspec(dllimport) BOOL __stdcall RegisterTouchHitTestingWindow(HWND hwnd, ULONG value);

    typedef struct tagTOUCH_HIT_TESTING_PROXIMITY_EVALUATION
    {
        UINT16 score;
        POINT adjustedPoint;
    } TOUCH_HIT_TESTING_PROXIMITY_EVALUATION, *PTOUCH_HIT_TESTING_PROXIMITY_EVALUATION;

    typedef struct tagTOUCH_HIT_TESTING_INPUT
    {
        UINT32 pointerId;
        POINT point;
        RECT boundingBox;
        RECT nonOccludedBoundingBox;
        UINT32 orientation;
    } TOUCH_HIT_TESTING_INPUT, *PTOUCH_HIT_TESTING_INPUT;

    __declspec(dllimport) BOOL __stdcall EvaluateProximityToRect(const RECT* controlBoundingBox,
                                                                 const TOUCH_HIT_TESTING_INPUT* pHitTestingInput,
                                                                 TOUCH_HIT_TESTING_PROXIMITY_EVALUATION* pProximityEval);

    __declspec(dllimport) BOOL __stdcall EvaluateProximityToPolygon(UINT32 numVertices,
                                                                    const POINT* controlPolygon,
                                                                    const TOUCH_HIT_TESTING_INPUT* pHitTestingInput,
                                                                    TOUCH_HIT_TESTING_PROXIMITY_EVALUATION* pProximityEval);

    __declspec(dllimport) LRESULT
    __stdcall PackTouchHitTestingProximityEvaluation(const TOUCH_HIT_TESTING_INPUT* pHitTestingInput,
                                                     const TOUCH_HIT_TESTING_PROXIMITY_EVALUATION* pProximityEval);

    typedef enum tagFEEDBACK_TYPE
    {
        FEEDBACK_TOUCH_CONTACTVISUALIZATION = 1,
        FEEDBACK_PEN_BARRELVISUALIZATION = 2,
        FEEDBACK_PEN_TAP = 3,
        FEEDBACK_PEN_DOUBLETAP = 4,
        FEEDBACK_PEN_PRESSANDHOLD = 5,
        FEEDBACK_PEN_RIGHTTAP = 6,
        FEEDBACK_TOUCH_TAP = 7,
        FEEDBACK_TOUCH_DOUBLETAP = 8,
        FEEDBACK_TOUCH_PRESSANDHOLD = 9,
        FEEDBACK_TOUCH_RIGHTTAP = 10,
        FEEDBACK_GESTURE_PRESSANDTAP = 11,
        FEEDBACK_MAX = 0xFFFFFFFF
    } FEEDBACK_TYPE;

    __declspec(dllimport) BOOL
    __stdcall GetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32* pSize, void* config);

    __declspec(dllimport) BOOL
    __stdcall SetWindowFeedbackSetting(HWND hwnd, FEEDBACK_TYPE feedback, DWORD dwFlags, UINT32 size, const void* configuration);

#pragma endregion

#pragma region Desktop Family

#pragma warning(push)
#pragma warning(disable : 4201)

    typedef struct tagINPUT_TRANSFORM
    {
        union
        {
            struct
            {
                float _11, _12, _13, _14;
                float _21, _22, _23, _24;
                float _31, _32, _33, _34;
                float _41, _42, _43, _44;
            };
            float m[4][4];
        };
    } INPUT_TRANSFORM;

#pragma warning(pop)

    __declspec(dllimport) BOOL
    __stdcall GetPointerInputTransform(UINT32 pointerId, UINT32 historyCount, INPUT_TRANSFORM* inputTransform);

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma region Desktop Family

    typedef struct tagLASTINPUTINFO
    {
        UINT cbSize;
        DWORD dwTime;
    } LASTINPUTINFO, *PLASTINPUTINFO;

    __declspec(dllimport) BOOL __stdcall GetLastInputInfo(PLASTINPUTINFO plii);

#pragma endregion

#pragma region Desktop or PC Family

    __declspec(dllimport) UINT __stdcall MapVirtualKeyA(UINT uCode, UINT uMapType);
    __declspec(dllimport) UINT __stdcall MapVirtualKeyW(UINT uCode, UINT uMapType);

    __declspec(dllimport) UINT __stdcall MapVirtualKeyExA(UINT uCode, UINT uMapType, HKL dwhkl);
    __declspec(dllimport) UINT __stdcall MapVirtualKeyExW(UINT uCode, UINT uMapType, HKL dwhkl);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GetInputState(void);

    __declspec(dllimport) DWORD __stdcall GetQueueStatus(UINT flags);

    __declspec(dllimport) HWND __stdcall GetCapture(void);

    __declspec(dllimport) HWND __stdcall SetCapture(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall ReleaseCapture(void);

    __declspec(dllimport) DWORD
    __stdcall MsgWaitForMultipleObjects(DWORD nCount, const HANDLE* pHandles, BOOL fWaitAll, DWORD dwMilliseconds, DWORD dwWakeMask);

    __declspec(dllimport) DWORD
    __stdcall MsgWaitForMultipleObjectsEx(DWORD nCount, const HANDLE* pHandles, DWORD dwMilliseconds, DWORD dwWakeMask, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) UINT_PTR __stdcall SetTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc);

    __declspec(dllimport) UINT_PTR
    __stdcall SetCoalescableTimer(HWND hWnd, UINT_PTR nIDEvent, UINT uElapse, TIMERPROC lpTimerFunc, ULONG uToleranceDelay);

    __declspec(dllimport) BOOL __stdcall KillTimer(HWND hWnd, UINT_PTR uIDEvent);

    __declspec(dllimport) BOOL __stdcall IsWindowUnicode(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall EnableWindow(HWND hWnd, BOOL bEnable);

    __declspec(dllimport) BOOL __stdcall IsWindowEnabled(HWND hWnd);

    __declspec(dllimport) HACCEL __stdcall LoadAcceleratorsA(HINSTANCE hInstance, LPCSTR lpTableName);
    __declspec(dllimport) HACCEL __stdcall LoadAcceleratorsW(HINSTANCE hInstance, LPCWSTR lpTableName);

    __declspec(dllimport) HACCEL __stdcall CreateAcceleratorTableA(LPACCEL paccel, int cAccel);
    __declspec(dllimport) HACCEL __stdcall CreateAcceleratorTableW(LPACCEL paccel, int cAccel);

    __declspec(dllimport) BOOL __stdcall DestroyAcceleratorTable(HACCEL hAccel);

    __declspec(dllimport) int __stdcall CopyAcceleratorTableA(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries);
    __declspec(dllimport) int __stdcall CopyAcceleratorTableW(HACCEL hAccelSrc, LPACCEL lpAccelDst, int cAccelEntries);

    __declspec(dllimport) int __stdcall TranslateAcceleratorA(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);
    __declspec(dllimport) int __stdcall TranslateAcceleratorW(HWND hWnd, HACCEL hAccTable, LPMSG lpMsg);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall GetSystemMetrics(int nIndex);

    __declspec(dllimport) int __stdcall GetSystemMetricsForDpi(int nIndex, UINT dpi);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HMENU __stdcall LoadMenuA(HINSTANCE hInstance, LPCSTR lpMenuName);
    __declspec(dllimport) HMENU __stdcall LoadMenuW(HINSTANCE hInstance, LPCWSTR lpMenuName);

    __declspec(dllimport) HMENU __stdcall LoadMenuIndirectA(const MENUTEMPLATEA* lpMenuTemplate);
    __declspec(dllimport) HMENU __stdcall LoadMenuIndirectW(const MENUTEMPLATEW* lpMenuTemplate);

    __declspec(dllimport) HMENU __stdcall GetMenu(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall SetMenu(HWND hWnd, HMENU hMenu);

    __declspec(dllimport) BOOL __stdcall ChangeMenuA(HMENU hMenu, UINT cmd, LPCSTR lpszNewItem, UINT cmdInsert, UINT flags);
    __declspec(dllimport) BOOL __stdcall ChangeMenuW(HMENU hMenu, UINT cmd, LPCWSTR lpszNewItem, UINT cmdInsert, UINT flags);

    __declspec(dllimport) BOOL __stdcall HiliteMenuItem(HWND hWnd, HMENU hMenu, UINT uIDHiliteItem, UINT uHilite);

    __declspec(dllimport) int __stdcall GetMenuStringA(HMENU hMenu, UINT uIDItem, LPSTR lpString, int cchMax, UINT flags);
    __declspec(dllimport) int __stdcall GetMenuStringW(HMENU hMenu, UINT uIDItem, LPWSTR lpString, int cchMax, UINT flags);

    __declspec(dllimport) UINT __stdcall GetMenuState(HMENU hMenu, UINT uId, UINT uFlags);

    __declspec(dllimport) BOOL __stdcall DrawMenuBar(HWND hWnd);

    __declspec(dllimport) HMENU __stdcall GetSystemMenu(HWND hWnd, BOOL bRevert);

    __declspec(dllimport) HMENU __stdcall CreateMenu(void);

    __declspec(dllimport) HMENU __stdcall CreatePopupMenu(void);

    __declspec(dllimport) BOOL __stdcall DestroyMenu(HMENU hMenu);

    __declspec(dllimport) DWORD __stdcall CheckMenuItem(HMENU hMenu, UINT uIDCheckItem, UINT uCheck);

    __declspec(dllimport) BOOL __stdcall EnableMenuItem(HMENU hMenu, UINT uIDEnableItem, UINT uEnable);

    __declspec(dllimport) HMENU __stdcall GetSubMenu(HMENU hMenu, int nPos);

    __declspec(dllimport) UINT __stdcall GetMenuItemID(HMENU hMenu, int nPos);

    __declspec(dllimport) int __stdcall GetMenuItemCount(HMENU hMenu);

    __declspec(dllimport) BOOL
    __stdcall InsertMenuA(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
    __declspec(dllimport) BOOL
    __stdcall InsertMenuW(HMENU hMenu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);

    __declspec(dllimport) BOOL __stdcall AppendMenuA(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
    __declspec(dllimport) BOOL __stdcall AppendMenuW(HMENU hMenu, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);

    __declspec(dllimport) BOOL __stdcall ModifyMenuA(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCSTR lpNewItem);
    __declspec(dllimport) BOOL
    __stdcall ModifyMenuW(HMENU hMnu, UINT uPosition, UINT uFlags, UINT_PTR uIDNewItem, LPCWSTR lpNewItem);

    __declspec(dllimport) BOOL __stdcall RemoveMenu(HMENU hMenu, UINT uPosition, UINT uFlags);

    __declspec(dllimport) BOOL __stdcall DeleteMenu(HMENU hMenu, UINT uPosition, UINT uFlags);

    __declspec(dllimport) BOOL
    __stdcall SetMenuItemBitmaps(HMENU hMenu, UINT uPosition, UINT uFlags, HBITMAP hBitmapUnchecked, HBITMAP hBitmapChecked);

    __declspec(dllimport) LONG __stdcall GetMenuCheckMarkDimensions(void);

    __declspec(dllimport) BOOL
    __stdcall TrackPopupMenu(HMENU hMenu, UINT uFlags, int x, int y, int nReserved, HWND hWnd, const RECT* prcRect);

    typedef struct tagTPMPARAMS
    {
        UINT cbSize;
        RECT rcExclude;
    } TPMPARAMS;
    typedef TPMPARAMS* LPTPMPARAMS;

    __declspec(dllimport) BOOL __stdcall TrackPopupMenuEx(HMENU hMenu, UINT uFlags, int x, int y, HWND hwnd, LPTPMPARAMS lptpm);

    __declspec(dllimport) BOOL
    __stdcall CalculatePopupWindowPosition(const POINT* anchorPoint, const SIZE* windowSize, UINT flags, RECT* excludeRect, RECT* popupWindowPosition);

    typedef struct tagMENUINFO
    {
        DWORD cbSize;
        DWORD fMask;
        DWORD dwStyle;
        UINT cyMax;
        HBRUSH hbrBack;
        DWORD dwContextHelpID;
        ULONG_PTR dwMenuData;
    } MENUINFO, *LPMENUINFO;
    typedef MENUINFO const* LPCMENUINFO;

    __declspec(dllimport) BOOL __stdcall GetMenuInfo(HMENU, LPMENUINFO);

    __declspec(dllimport) BOOL __stdcall SetMenuInfo(HMENU, LPCMENUINFO);

    __declspec(dllimport) BOOL __stdcall EndMenu(void);

    typedef struct tagMENUGETOBJECTINFO
    {
        DWORD dwFlags;
        UINT uPos;
        HMENU hmenu;
        PVOID riid;
        PVOID pvObj;
    } MENUGETOBJECTINFO, *PMENUGETOBJECTINFO;

    typedef struct tagMENUITEMINFOA
    {
        UINT cbSize;
        UINT fMask;
        UINT fType;
        UINT fState;
        UINT wID;
        HMENU hSubMenu;
        HBITMAP hbmpChecked;
        HBITMAP hbmpUnchecked;
        ULONG_PTR dwItemData;
        LPSTR dwTypeData;
        UINT cch;

        HBITMAP hbmpItem;
    } MENUITEMINFOA, *LPMENUITEMINFOA;
    typedef struct tagMENUITEMINFOW
    {
        UINT cbSize;
        UINT fMask;
        UINT fType;
        UINT fState;
        UINT wID;
        HMENU hSubMenu;
        HBITMAP hbmpChecked;
        HBITMAP hbmpUnchecked;
        ULONG_PTR dwItemData;
        LPWSTR dwTypeData;
        UINT cch;

        HBITMAP hbmpItem;
    } MENUITEMINFOW, *LPMENUITEMINFOW;

    typedef MENUITEMINFOA MENUITEMINFO;
    typedef LPMENUITEMINFOA LPMENUITEMINFO;
    typedef MENUITEMINFOA const* LPCMENUITEMINFOA;
    typedef MENUITEMINFOW const* LPCMENUITEMINFOW;

    typedef LPCMENUITEMINFOA LPCMENUITEMINFO;

    __declspec(dllimport) BOOL __stdcall InsertMenuItemA(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOA lpmi);
    __declspec(dllimport) BOOL __stdcall InsertMenuItemW(HMENU hmenu, UINT item, BOOL fByPosition, LPCMENUITEMINFOW lpmi);

    __declspec(dllimport) BOOL __stdcall GetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOA lpmii);
    __declspec(dllimport) BOOL __stdcall GetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPosition, LPMENUITEMINFOW lpmii);

    __declspec(dllimport) BOOL __stdcall SetMenuItemInfoA(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOA lpmii);
    __declspec(dllimport) BOOL __stdcall SetMenuItemInfoW(HMENU hmenu, UINT item, BOOL fByPositon, LPCMENUITEMINFOW lpmii);

    __declspec(dllimport) UINT __stdcall GetMenuDefaultItem(HMENU hMenu, UINT fByPos, UINT gmdiFlags);

    __declspec(dllimport) BOOL __stdcall SetMenuDefaultItem(HMENU hMenu, UINT uItem, UINT fByPos);

    __declspec(dllimport) BOOL __stdcall GetMenuItemRect(HWND hWnd, HMENU hMenu, UINT uItem, LPRECT lprcItem);

    __declspec(dllimport) int __stdcall MenuItemFromPoint(HWND hWnd, HMENU hMenu, POINT ptScreen);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagDROPSTRUCT
    {
        HWND hwndSource;
        HWND hwndSink;
        DWORD wFmt;
        ULONG_PTR dwData;
        POINT ptDrop;
        DWORD dwControlData;
    } DROPSTRUCT, *PDROPSTRUCT, *LPDROPSTRUCT;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) DWORD __stdcall DragObject(HWND hwndParent, HWND hwndFrom, UINT fmt, ULONG_PTR data, HCURSOR hcur);

    __declspec(dllimport) BOOL __stdcall DragDetect(HWND hwnd, POINT pt);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall DrawIcon(HDC hDC, int X, int Y, HICON hIcon);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagDRAWTEXTPARAMS
    {
        UINT cbSize;
        int iTabLength;
        int iLeftMargin;
        int iRightMargin;
        UINT uiLengthDrawn;
    } DRAWTEXTPARAMS, *LPDRAWTEXTPARAMS;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport)

    int __stdcall DrawTextA(HDC hdc,

                            LPCSTR lpchText,
                            int cchText,
                            LPRECT lprc,
                            UINT format);
    __declspec(dllimport)

    int __stdcall DrawTextW(HDC hdc,

                            LPCWSTR lpchText,
                            int cchText,
                            LPRECT lprc,
                            UINT format);

    __inline int DrawText(HDC hdc, LPCTSTR lpchText, int cchText, LPRECT lprc, UINT format)
    {
        return DrawTextA(hdc, lpchText, cchText, lprc, format);
    }

    __declspec(dllimport)

    int __stdcall DrawTextExA(HDC hdc,

                              LPSTR lpchText,
                              int cchText,
                              LPRECT lprc,
                              UINT format,
                              LPDRAWTEXTPARAMS lpdtp);
    __declspec(dllimport)

    int __stdcall DrawTextExW(HDC hdc,

                              LPWSTR lpchText,
                              int cchText,
                              LPRECT lprc,
                              UINT format,
                              LPDRAWTEXTPARAMS lpdtp);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL
    __stdcall GrayStringA(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);
    __declspec(dllimport) BOOL
    __stdcall GrayStringW(HDC hDC, HBRUSH hBrush, GRAYSTRINGPROC lpOutputFunc, LPARAM lpData, int nCount, int X, int Y, int nWidth, int nHeight);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall DrawStateA(
    HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags);
    __declspec(dllimport) BOOL __stdcall DrawStateW(
    HDC hdc, HBRUSH hbrFore, DRAWSTATEPROC qfnCallBack, LPARAM lData, WPARAM wData, int x, int y, int cx, int cy, UINT uFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) LONG
    __stdcall TabbedTextOutA(HDC hdc, int x, int y, LPCSTR lpString, int chCount, int nTabPositions, const INT* lpnTabStopPositions, int nTabOrigin);
    __declspec(dllimport) LONG
    __stdcall TabbedTextOutW(HDC hdc, int x, int y, LPCWSTR lpString, int chCount, int nTabPositions, const INT* lpnTabStopPositions, int nTabOrigin);

    __declspec(dllimport) DWORD
    __stdcall GetTabbedTextExtentA(HDC hdc, LPCSTR lpString, int chCount, int nTabPositions, const INT* lpnTabStopPositions);
    __declspec(dllimport) DWORD
    __stdcall GetTabbedTextExtentW(HDC hdc, LPCWSTR lpString, int chCount, int nTabPositions, const INT* lpnTabStopPositions);

    __declspec(dllimport) BOOL __stdcall UpdateWindow(HWND hWnd);

    __declspec(dllimport) HWND __stdcall SetActiveWindow(HWND hWnd);

    __declspec(dllimport) HWND __stdcall GetForegroundWindow(void);

    __declspec(dllimport) BOOL __stdcall PaintDesktop(HDC hdc);

    __declspec(dllimport) void __stdcall SwitchToThisWindow(HWND hwnd, BOOL fUnknown);

    __declspec(dllimport) BOOL __stdcall SetForegroundWindow(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall AllowSetForegroundWindow(DWORD dwProcessId);

    __declspec(dllimport) BOOL __stdcall LockSetForegroundWindow(UINT uLockCode);

    __declspec(dllimport) HWND __stdcall WindowFromDC(HDC hDC);

    __declspec(dllimport) HDC __stdcall GetDC(HWND hWnd);

    __declspec(dllimport) HDC __stdcall GetDCEx(HWND hWnd, HRGN hrgnClip, DWORD flags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HDC __stdcall GetWindowDC(HWND hWnd);

    __declspec(dllimport) int __stdcall ReleaseDC(HWND hWnd, HDC hDC);

    __declspec(dllimport) HDC __stdcall BeginPaint(HWND hWnd, LPPAINTSTRUCT lpPaint);

    __declspec(dllimport) BOOL __stdcall EndPaint(HWND hWnd, const PAINTSTRUCT* lpPaint);

    __declspec(dllimport) BOOL __stdcall GetUpdateRect(HWND hWnd, LPRECT lpRect, BOOL bErase);

    __declspec(dllimport) int __stdcall GetUpdateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);

    __declspec(dllimport) int __stdcall SetWindowRgn(HWND hWnd, HRGN hRgn, BOOL bRedraw);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall GetWindowRgn(HWND hWnd, HRGN hRgn);

    __declspec(dllimport) int __stdcall GetWindowRgnBox(HWND hWnd, LPRECT lprc);

    __declspec(dllimport) int __stdcall ExcludeUpdateRgn(HDC hDC, HWND hWnd);

    __declspec(dllimport) BOOL __stdcall InvalidateRect(HWND hWnd, const RECT* lpRect, BOOL bErase);

    __declspec(dllimport) BOOL __stdcall ValidateRect(HWND hWnd, const RECT* lpRect);

    __declspec(dllimport) BOOL __stdcall InvalidateRgn(HWND hWnd, HRGN hRgn, BOOL bErase);

    __declspec(dllimport) BOOL __stdcall ValidateRgn(HWND hWnd, HRGN hRgn);

    __declspec(dllimport) BOOL __stdcall RedrawWindow(HWND hWnd, const RECT* lprcUpdate, HRGN hrgnUpdate, UINT flags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall LockWindowUpdate(HWND hWndLock);

    __declspec(dllimport) BOOL
    __stdcall ScrollWindow(HWND hWnd, int XAmount, int YAmount, const RECT* lpRect, const RECT* lpClipRect);

    __declspec(dllimport) BOOL
    __stdcall ScrollDC(HDC hDC, int dx, int dy, const RECT* lprcScroll, const RECT* lprcClip, HRGN hrgnUpdate, LPRECT lprcUpdate);

    __declspec(dllimport) int __stdcall ScrollWindowEx(
    HWND hWnd, int dx, int dy, const RECT* prcScroll, const RECT* prcClip, HRGN hrgnUpdate, LPRECT prcUpdate, UINT flags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall SetScrollPos(HWND hWnd, int nBar, int nPos, BOOL bRedraw);

    __declspec(dllimport) int __stdcall GetScrollPos(HWND hWnd, int nBar);

    __declspec(dllimport) BOOL __stdcall SetScrollRange(HWND hWnd, int nBar, int nMinPos, int nMaxPos, BOOL bRedraw);

    __declspec(dllimport) BOOL __stdcall GetScrollRange(HWND hWnd, int nBar, LPINT lpMinPos, LPINT lpMaxPos);

    __declspec(dllimport) BOOL __stdcall ShowScrollBar(HWND hWnd, int wBar, BOOL bShow);

    __declspec(dllimport) BOOL __stdcall EnableScrollBar(HWND hWnd, UINT wSBflags, UINT wArrows);

    __declspec(dllimport) BOOL __stdcall SetPropA(HWND hWnd, LPCSTR lpString, HANDLE hData);
    __declspec(dllimport) BOOL __stdcall SetPropW(HWND hWnd, LPCWSTR lpString, HANDLE hData);

    __declspec(dllimport) HANDLE __stdcall GetPropA(HWND hWnd, LPCSTR lpString);
    __declspec(dllimport) HANDLE __stdcall GetPropW(HWND hWnd, LPCWSTR lpString);

    __declspec(dllimport) HANDLE __stdcall RemovePropA(HWND hWnd, LPCSTR lpString);
    __declspec(dllimport) HANDLE __stdcall RemovePropW(HWND hWnd, LPCWSTR lpString);

    __declspec(dllimport) int __stdcall EnumPropsExA(HWND hWnd, PROPENUMPROCEXA lpEnumFunc, LPARAM lParam);
    __declspec(dllimport) int __stdcall EnumPropsExW(HWND hWnd, PROPENUMPROCEXW lpEnumFunc, LPARAM lParam);

    __declspec(dllimport) int __stdcall EnumPropsA(HWND hWnd, PROPENUMPROCA lpEnumFunc);
    __declspec(dllimport) int __stdcall EnumPropsW(HWND hWnd, PROPENUMPROCW lpEnumFunc);

    __declspec(dllimport) BOOL __stdcall SetWindowTextA(HWND hWnd, LPCSTR lpString);
    __declspec(dllimport) BOOL __stdcall SetWindowTextW(HWND hWnd, LPCWSTR lpString);

    __declspec(dllimport) int __stdcall GetWindowTextA(HWND hWnd, LPSTR lpString, int nMaxCount);

    __declspec(dllimport) int __stdcall GetWindowTextW(HWND hWnd, LPWSTR lpString, int nMaxCount);

    __declspec(dllimport) int __stdcall GetWindowTextLengthA(HWND hWnd);
    __declspec(dllimport) int __stdcall GetWindowTextLengthW(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall GetClientRect(HWND hWnd, LPRECT lpRect);

    __declspec(dllimport) BOOL __stdcall GetWindowRect(HWND hWnd, LPRECT lpRect);

    __declspec(dllimport) BOOL __stdcall AdjustWindowRect(LPRECT lpRect, DWORD dwStyle, BOOL bMenu);

    __declspec(dllimport) BOOL __stdcall AdjustWindowRectEx(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle);

    __declspec(dllimport) BOOL
    __stdcall AdjustWindowRectExForDpi(LPRECT lpRect, DWORD dwStyle, BOOL bMenu, DWORD dwExStyle, UINT dpi);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagHELPINFO
    {
        UINT cbSize;
        int iContextType;
        int iCtrlId;
        HANDLE hItemHandle;
        DWORD_PTR dwContextId;
        POINT MousePos;
    } HELPINFO, *LPHELPINFO;

    __declspec(dllimport) BOOL __stdcall SetWindowContextHelpId(HWND, DWORD);

    __declspec(dllimport) DWORD __stdcall GetWindowContextHelpId(HWND);

    __declspec(dllimport) BOOL __stdcall SetMenuContextHelpId(HMENU, DWORD);

    __declspec(dllimport) DWORD __stdcall GetMenuContextHelpId(HMENU);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall MessageBoxA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType);
    __declspec(dllimport) int __stdcall MessageBoxW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType);

    __inline int MessageBox(HWND hWnd, LPCTSTR lpText, LPCTSTR lpCaption, UINT uType)
    {
        return MessageBoxA(hWnd, lpText, lpCaption, uType);
    }

    __declspec(dllimport) int __stdcall MessageBoxExA(HWND hWnd, LPCSTR lpText, LPCSTR lpCaption, UINT uType, WORD wLanguageId);
    __declspec(dllimport) int __stdcall MessageBoxExW(HWND hWnd, LPCWSTR lpText, LPCWSTR lpCaption, UINT uType, WORD wLanguageId);

    typedef void(__stdcall* MSGBOXCALLBACK)(LPHELPINFO lpHelpInfo);

    typedef struct tagMSGBOXPARAMSA
    {
        UINT cbSize;
        HWND hwndOwner;
        HINSTANCE hInstance;
        LPCSTR lpszText;
        LPCSTR lpszCaption;
        DWORD dwStyle;
        LPCSTR lpszIcon;
        DWORD_PTR dwContextHelpId;
        MSGBOXCALLBACK lpfnMsgBoxCallback;
        DWORD dwLanguageId;
    } MSGBOXPARAMSA, *PMSGBOXPARAMSA, *LPMSGBOXPARAMSA;
    typedef struct tagMSGBOXPARAMSW
    {
        UINT cbSize;
        HWND hwndOwner;
        HINSTANCE hInstance;
        LPCWSTR lpszText;
        LPCWSTR lpszCaption;
        DWORD dwStyle;
        LPCWSTR lpszIcon;
        DWORD_PTR dwContextHelpId;
        MSGBOXCALLBACK lpfnMsgBoxCallback;
        DWORD dwLanguageId;
    } MSGBOXPARAMSW, *PMSGBOXPARAMSW, *LPMSGBOXPARAMSW;

    typedef MSGBOXPARAMSA MSGBOXPARAMS;
    typedef PMSGBOXPARAMSA PMSGBOXPARAMS;
    typedef LPMSGBOXPARAMSA LPMSGBOXPARAMS;

    __declspec(dllimport) int __stdcall MessageBoxIndirectA(const MSGBOXPARAMSA* lpmbp);
    __declspec(dllimport) int __stdcall MessageBoxIndirectW(const MSGBOXPARAMSW* lpmbp);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall MessageBeep(UINT uType);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall ShowCursor(BOOL bShow);

    __declspec(dllimport) BOOL __stdcall SetCursorPos(int X, int Y);

    __declspec(dllimport) BOOL __stdcall SetPhysicalCursorPos(int X, int Y);

    __declspec(dllimport) HCURSOR __stdcall SetCursor(HCURSOR hCursor);

    __declspec(dllimport) BOOL __stdcall GetCursorPos(LPPOINT lpPoint);

    __declspec(dllimport) BOOL __stdcall GetPhysicalCursorPos(LPPOINT lpPoint);

    __declspec(dllimport) BOOL __stdcall GetClipCursor(LPRECT lpRect);

    __declspec(dllimport) HCURSOR __stdcall GetCursor(void);

    __declspec(dllimport) BOOL __stdcall CreateCaret(HWND hWnd, HBITMAP hBitmap, int nWidth, int nHeight);

    __declspec(dllimport) UINT __stdcall GetCaretBlinkTime(void);

    __declspec(dllimport) BOOL __stdcall SetCaretBlinkTime(UINT uMSeconds);

    __declspec(dllimport) BOOL __stdcall DestroyCaret(void);

    __declspec(dllimport) BOOL __stdcall HideCaret(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall ShowCaret(HWND hWnd);

    __declspec(dllimport) BOOL __stdcall SetCaretPos(int X, int Y);

    __declspec(dllimport) BOOL __stdcall GetCaretPos(LPPOINT lpPoint);

    __declspec(dllimport) BOOL __stdcall ClientToScreen(HWND hWnd, LPPOINT lpPoint);

    __declspec(dllimport) BOOL __stdcall ScreenToClient(HWND hWnd, LPPOINT lpPoint);

    __declspec(dllimport) BOOL __stdcall LogicalToPhysicalPoint(HWND hWnd, LPPOINT lpPoint);

    __declspec(dllimport) BOOL __stdcall PhysicalToLogicalPoint(HWND hWnd, LPPOINT lpPoint);

    __declspec(dllimport) BOOL __stdcall LogicalToPhysicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint);

    __declspec(dllimport) BOOL __stdcall PhysicalToLogicalPointForPerMonitorDPI(HWND hWnd, LPPOINT lpPoint);

    __declspec(dllimport) int __stdcall MapWindowPoints(HWND hWndFrom, HWND hWndTo, LPPOINT lpPoints, UINT cPoints);

    __declspec(dllimport) HWND __stdcall WindowFromPoint(POINT Point);

    __declspec(dllimport) HWND __stdcall WindowFromPhysicalPoint(POINT Point);

    __declspec(dllimport) HWND __stdcall ChildWindowFromPoint(HWND hWndParent, POINT Point);

#pragma endregion

#pragma region Desktop or PC Family

    __declspec(dllimport) BOOL __stdcall ClipCursor(const RECT* lpRect);
#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HWND __stdcall ChildWindowFromPointEx(HWND hwnd, POINT pt, UINT flags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) DWORD __stdcall GetSysColor(int nIndex);

    __declspec(dllimport) HBRUSH __stdcall GetSysColorBrush(int nIndex);

    __declspec(dllimport) BOOL __stdcall SetSysColors(int cElements, const INT* lpaElements, const COLORREF* lpaRgbValues);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall DrawFocusRect(HDC hDC, const RECT* lprc);

    __declspec(dllimport) int __stdcall FillRect(HDC hDC, const RECT* lprc, HBRUSH hbr);

    __declspec(dllimport) int __stdcall FrameRect(HDC hDC, const RECT* lprc, HBRUSH hbr);

    __declspec(dllimport) BOOL __stdcall InvertRect(HDC hDC, const RECT* lprc);

    __declspec(dllimport) BOOL __stdcall SetRect(LPRECT lprc, int xLeft, int yTop, int xRight, int yBottom);

    __declspec(dllimport) BOOL __stdcall SetRectEmpty(LPRECT lprc);

    __declspec(dllimport) BOOL __stdcall CopyRect(LPRECT lprcDst, const RECT* lprcSrc);

    __declspec(dllimport) BOOL __stdcall InflateRect(LPRECT lprc, int dx, int dy);

    __declspec(dllimport) BOOL __stdcall IntersectRect(LPRECT lprcDst, const RECT* lprcSrc1, const RECT* lprcSrc2);

    __declspec(dllimport) BOOL __stdcall UnionRect(LPRECT lprcDst, const RECT* lprcSrc1, const RECT* lprcSrc2);

    __declspec(dllimport) BOOL __stdcall SubtractRect(LPRECT lprcDst, const RECT* lprcSrc1, const RECT* lprcSrc2);

    __declspec(dllimport) BOOL __stdcall OffsetRect(LPRECT lprc, int dx, int dy);

    __declspec(dllimport) BOOL __stdcall IsRectEmpty(const RECT* lprc);

    __declspec(dllimport) BOOL __stdcall EqualRect(const RECT* lprc1, const RECT* lprc2);

    __declspec(dllimport) BOOL __stdcall PtInRect(const RECT* lprc, POINT pt);

    __declspec(dllimport) WORD __stdcall GetWindowWord(HWND hWnd, int nIndex);

    __declspec(dllimport) WORD __stdcall SetWindowWord(HWND hWnd, int nIndex, WORD wNewWord);

    __declspec(dllimport) LONG __stdcall GetWindowLongA(HWND hWnd, int nIndex);
    __declspec(dllimport) LONG __stdcall GetWindowLongW(HWND hWnd, int nIndex);

    __declspec(dllimport) LONG __stdcall SetWindowLongA(HWND hWnd, int nIndex, LONG dwNewLong);
    __declspec(dllimport) LONG __stdcall SetWindowLongW(HWND hWnd, int nIndex, LONG dwNewLong);

    __declspec(dllimport) LONG_PTR __stdcall GetWindowLongPtrA(HWND hWnd, int nIndex);
    __declspec(dllimport) LONG_PTR __stdcall GetWindowLongPtrW(HWND hWnd, int nIndex);

    __declspec(dllimport) LONG_PTR __stdcall SetWindowLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
    __declspec(dllimport) LONG_PTR __stdcall SetWindowLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong);

    __declspec(dllimport) WORD __stdcall GetClassWord(HWND hWnd, int nIndex);

    __declspec(dllimport) WORD __stdcall SetClassWord(HWND hWnd, int nIndex, WORD wNewWord);

    __declspec(dllimport) DWORD __stdcall GetClassLongA(HWND hWnd, int nIndex);
    __declspec(dllimport) DWORD __stdcall GetClassLongW(HWND hWnd, int nIndex);

    __declspec(dllimport) DWORD __stdcall SetClassLongA(HWND hWnd, int nIndex, LONG dwNewLong);
    __declspec(dllimport) DWORD __stdcall SetClassLongW(HWND hWnd, int nIndex, LONG dwNewLong);

    __declspec(dllimport) ULONG_PTR __stdcall GetClassLongPtrA(HWND hWnd, int nIndex);
    __declspec(dllimport) ULONG_PTR __stdcall GetClassLongPtrW(HWND hWnd, int nIndex);

    __declspec(dllimport) ULONG_PTR __stdcall SetClassLongPtrA(HWND hWnd, int nIndex, LONG_PTR dwNewLong);
    __declspec(dllimport) ULONG_PTR __stdcall SetClassLongPtrW(HWND hWnd, int nIndex, LONG_PTR dwNewLong);

    __declspec(dllimport) BOOL __stdcall GetProcessDefaultLayout(DWORD* pdwDefaultLayout);

    __declspec(dllimport) BOOL __stdcall SetProcessDefaultLayout(DWORD dwDefaultLayout);

    __declspec(dllimport) HWND __stdcall GetDesktopWindow(void);

    __declspec(dllimport) HWND __stdcall GetParent(HWND hWnd);

    __declspec(dllimport) HWND __stdcall SetParent(HWND hWndChild, HWND hWndNewParent);

    __declspec(dllimport) BOOL __stdcall EnumChildWindows(HWND hWndParent, WNDENUMPROC lpEnumFunc, LPARAM lParam);

    __declspec(dllimport) HWND __stdcall FindWindowA(LPCSTR lpClassName, LPCSTR lpWindowName);
    __declspec(dllimport) HWND __stdcall FindWindowW(LPCWSTR lpClassName, LPCWSTR lpWindowName);

    __declspec(dllimport) HWND __stdcall FindWindowExA(HWND hWndParent, HWND hWndChildAfter, LPCSTR lpszClass, LPCSTR lpszWindow);
    __declspec(dllimport) HWND __stdcall FindWindowExW(HWND hWndParent, HWND hWndChildAfter, LPCWSTR lpszClass, LPCWSTR lpszWindow);

    __declspec(dllimport) HWND __stdcall GetShellWindow(void);

    __declspec(dllimport) BOOL __stdcall RegisterShellHookWindow(HWND hwnd);

    __declspec(dllimport) BOOL __stdcall DeregisterShellHookWindow(HWND hwnd);

    __declspec(dllimport) BOOL __stdcall EnumWindows(WNDENUMPROC lpEnumFunc, LPARAM lParam);

    __declspec(dllimport) BOOL __stdcall EnumThreadWindows(DWORD dwThreadId, WNDENUMPROC lpfn, LPARAM lParam);

    __declspec(dllimport) int __stdcall GetClassNameA(HWND hWnd, LPSTR lpClassName, int nMaxCount);
    __declspec(dllimport) int __stdcall GetClassNameW(HWND hWnd, LPWSTR lpClassName, int nMaxCount);

    __inline int GetClassName(HWND hWnd, LPTSTR lpClassName, int nMaxCount)
    {
        return GetClassNameA(hWnd, lpClassName, nMaxCount);
    }

    __declspec(dllimport) HWND __stdcall GetTopWindow(HWND hWnd);

    __declspec(dllimport) DWORD __stdcall GetWindowThreadProcessId(HWND hWnd, LPDWORD lpdwProcessId);

    __declspec(dllimport) BOOL __stdcall IsGUIThread(BOOL bConvert);

    __declspec(dllimport) HWND __stdcall GetLastActivePopup(HWND hWnd);

    __declspec(dllimport) HWND __stdcall GetWindow(HWND hWnd, UINT uCmd);

    __declspec(dllimport) HHOOK __stdcall SetWindowsHookA(int nFilterType, HOOKPROC pfnFilterProc);
    __declspec(dllimport) HHOOK __stdcall SetWindowsHookW(int nFilterType, HOOKPROC pfnFilterProc);

    __declspec(dllimport) BOOL __stdcall UnhookWindowsHook(int nCode, HOOKPROC pfnFilterProc);

    __declspec(dllimport) HHOOK __stdcall SetWindowsHookExA(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);
    __declspec(dllimport) HHOOK __stdcall SetWindowsHookExW(int idHook, HOOKPROC lpfn, HINSTANCE hmod, DWORD dwThreadId);

    __declspec(dllimport) BOOL __stdcall UnhookWindowsHookEx(HHOOK hhk);

    __declspec(dllimport) LRESULT __stdcall CallNextHookEx(HHOOK hhk, int nCode, WPARAM wParam, LPARAM lParam);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall CheckMenuRadioItem(HMENU hmenu, UINT first, UINT last, UINT check, UINT flags);

    typedef struct
    {
        WORD versionNumber;
        WORD offset;
    } MENUITEMTEMPLATEHEADER, *PMENUITEMTEMPLATEHEADER;

    typedef struct
    {
        WORD mtOption;
        WORD mtID;
        WCHAR mtString[1];
    } MENUITEMTEMPLATE, *PMENUITEMTEMPLATE;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HBITMAP __stdcall LoadBitmapA(HINSTANCE hInstance, LPCSTR lpBitmapName);
    __declspec(dllimport) HBITMAP __stdcall LoadBitmapW(HINSTANCE hInstance, LPCWSTR lpBitmapName);

    __declspec(dllimport) HCURSOR __stdcall LoadCursorA(HINSTANCE hInstance, LPCSTR lpCursorName);
    __declspec(dllimport) HCURSOR __stdcall LoadCursorW(HINSTANCE hInstance, LPCWSTR lpCursorName);

    __declspec(dllimport) HCURSOR __stdcall LoadCursorFromFileA(LPCSTR lpFileName);
    __declspec(dllimport) HCURSOR __stdcall LoadCursorFromFileW(LPCWSTR lpFileName);

    __declspec(dllimport) HCURSOR
    __stdcall CreateCursor(HINSTANCE hInst, int xHotSpot, int yHotSpot, int nWidth, int nHeight, const void* pvANDPlane, const void* pvXORPlane);

    __declspec(dllimport) BOOL __stdcall DestroyCursor(HCURSOR hCursor);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall SetSystemCursor(HCURSOR hcur, DWORD id);

    typedef struct _ICONINFO
    {
        BOOL fIcon;
        DWORD xHotspot;
        DWORD yHotspot;
        HBITMAP hbmMask;
        HBITMAP hbmColor;
    } ICONINFO;
    typedef ICONINFO* PICONINFO;

    __declspec(dllimport) HICON __stdcall LoadIconA(HINSTANCE hInstance, LPCSTR lpIconName);
    __declspec(dllimport) HICON __stdcall LoadIconW(HINSTANCE hInstance, LPCWSTR lpIconName);

    __declspec(dllimport) UINT __stdcall PrivateExtractIconsA(
    LPCSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON* phicon, UINT* piconid, UINT nIcons, UINT flags);
    __declspec(dllimport) UINT __stdcall PrivateExtractIconsW(
    LPCWSTR szFileName, int nIconIndex, int cxIcon, int cyIcon, HICON* phicon, UINT* piconid, UINT nIcons, UINT flags);

    __declspec(dllimport) HICON
    __stdcall CreateIcon(HINSTANCE hInstance, int nWidth, int nHeight, BYTE cPlanes, BYTE cBitsPixel, const BYTE* lpbANDbits, const BYTE* lpbXORbits);

    __declspec(dllimport) BOOL __stdcall DestroyIcon(HICON hIcon);

    __declspec(dllimport) int __stdcall LookupIconIdFromDirectory(PBYTE presbits, BOOL fIcon);

    __declspec(dllimport) int __stdcall LookupIconIdFromDirectoryEx(PBYTE presbits, BOOL fIcon, int cxDesired, int cyDesired, UINT Flags);

    __declspec(dllimport) HICON __stdcall CreateIconFromResource(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer);

    __declspec(dllimport) HICON
    __stdcall CreateIconFromResourceEx(PBYTE presbits, DWORD dwResSize, BOOL fIcon, DWORD dwVer, int cxDesired, int cyDesired, UINT Flags);

    typedef struct tagCURSORSHAPE
    {
        int xHotSpot;
        int yHotSpot;
        int cx;
        int cy;
        int cbWidth;
        BYTE Planes;
        BYTE BitsPixel;
    } CURSORSHAPE, *LPCURSORSHAPE;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HANDLE __stdcall LoadImageA(HINSTANCE hInst, LPCSTR name, UINT type, int cx, int cy, UINT fuLoad);
    __declspec(dllimport) HANDLE __stdcall LoadImageW(HINSTANCE hInst, LPCWSTR name, UINT type, int cx, int cy, UINT fuLoad);

    __declspec(dllimport) HANDLE __stdcall CopyImage(HANDLE h, UINT type, int cx, int cy, UINT flags);

    __declspec(dllimport) BOOL __stdcall DrawIconEx(
    HDC hdc, int xLeft, int yTop, HICON hIcon, int cxWidth, int cyWidth, UINT istepIfAniCur, HBRUSH hbrFlickerFreeDraw, UINT diFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HICON __stdcall CreateIconIndirect(PICONINFO piconinfo);

    __declspec(dllimport) HICON __stdcall CopyIcon(HICON hIcon);

    __declspec(dllimport) BOOL __stdcall GetIconInfo(HICON hIcon, PICONINFO piconinfo);

    typedef struct _ICONINFOEXA
    {
        DWORD cbSize;
        BOOL fIcon;
        DWORD xHotspot;
        DWORD yHotspot;
        HBITMAP hbmMask;
        HBITMAP hbmColor;
        WORD wResID;
        CHAR szModName[260];
        CHAR szResName[260];
    } ICONINFOEXA, *PICONINFOEXA;
    typedef struct _ICONINFOEXW
    {
        DWORD cbSize;
        BOOL fIcon;
        DWORD xHotspot;
        DWORD yHotspot;
        HBITMAP hbmMask;
        HBITMAP hbmColor;
        WORD wResID;
        WCHAR szModName[260];
        WCHAR szResName[260];
    } ICONINFOEXW, *PICONINFOEXW;

    typedef ICONINFOEXA ICONINFOEX;
    typedef PICONINFOEXA PICONINFOEX;

    __declspec(dllimport) BOOL __stdcall GetIconInfoExA(HICON hicon, PICONINFOEXA piconinfo);
    __declspec(dllimport) BOOL __stdcall GetIconInfoExW(HICON hicon, PICONINFOEXW piconinfo);

#pragma endregion

    typedef enum
    {
        EDIT_CONTROL_FEATURE_ENTERPRISE_DATA_PROTECTION_PASTE_SUPPORT = 0,
        EDIT_CONTROL_FEATURE_PASTE_NOTIFICATIONS = 1,
    } EDIT_CONTROL_FEATURE;

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall IsDialogMessageA(HWND hDlg, LPMSG lpMsg);
    __declspec(dllimport) BOOL __stdcall IsDialogMessageW(HWND hDlg, LPMSG lpMsg);

    __declspec(dllimport) BOOL __stdcall MapDialogRect(HWND hDlg, LPRECT lpRect);

    __declspec(dllimport) int __stdcall DlgDirListA(HWND hDlg, LPSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType);
    __declspec(dllimport) int __stdcall DlgDirListW(HWND hDlg, LPWSTR lpPathSpec, int nIDListBox, int nIDStaticPath, UINT uFileType);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall DlgDirSelectExA(HWND hwndDlg, LPSTR lpString, int chCount, int idListBox);
    __declspec(dllimport) BOOL __stdcall DlgDirSelectExW(HWND hwndDlg, LPWSTR lpString, int chCount, int idListBox);

    __declspec(dllimport) int __stdcall DlgDirListComboBoxA(HWND hDlg, LPSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype);
    __declspec(dllimport) int __stdcall DlgDirListComboBoxW(HWND hDlg, LPWSTR lpPathSpec, int nIDComboBox, int nIDStaticPath, UINT uFiletype);

    __declspec(dllimport) BOOL __stdcall DlgDirSelectComboBoxExA(HWND hwndDlg, LPSTR lpString, int cchOut, int idComboBox);
    __declspec(dllimport) BOOL __stdcall DlgDirSelectComboBoxExW(HWND hwndDlg, LPWSTR lpString, int cchOut, int idComboBox);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagSCROLLINFO
    {
        UINT cbSize;
        UINT fMask;
        int nMin;
        int nMax;
        UINT nPage;
        int nPos;
        int nTrackPos;
    } SCROLLINFO, *LPSCROLLINFO;
    typedef SCROLLINFO const* LPCSCROLLINFO;

    __declspec(dllimport) int __stdcall SetScrollInfo(HWND hwnd, int nBar, LPCSCROLLINFO lpsi, BOOL redraw);

    __declspec(dllimport) BOOL __stdcall GetScrollInfo(HWND hwnd, int nBar, LPSCROLLINFO lpsi);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagMDICREATESTRUCTA
    {
        LPCSTR szClass;
        LPCSTR szTitle;
        HANDLE hOwner;
        int x;
        int y;
        int cx;
        int cy;
        DWORD style;
        LPARAM lParam;
    } MDICREATESTRUCTA, *LPMDICREATESTRUCTA;
    typedef struct tagMDICREATESTRUCTW
    {
        LPCWSTR szClass;
        LPCWSTR szTitle;
        HANDLE hOwner;
        int x;
        int y;
        int cx;
        int cy;
        DWORD style;
        LPARAM lParam;
    } MDICREATESTRUCTW, *LPMDICREATESTRUCTW;

    typedef MDICREATESTRUCTA MDICREATESTRUCT;
    typedef LPMDICREATESTRUCTA LPMDICREATESTRUCT;

    typedef struct tagCLIENTCREATESTRUCT
    {
        HANDLE hWindowMenu;
        UINT idFirstChild;
    } CLIENTCREATESTRUCT, *LPCLIENTCREATESTRUCT;

    __declspec(dllimport) LRESULT __stdcall DefFrameProcA(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport) LRESULT __stdcall DefFrameProcW(HWND hWnd, HWND hWndMDIClient, UINT uMsg, WPARAM wParam, LPARAM lParam);

    __declspec(dllimport)

    LRESULT __stdcall

    DefMDIChildProcA(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);
    __declspec(dllimport)

    LRESULT __stdcall

    DefMDIChildProcW(HWND hWnd, UINT uMsg, WPARAM wParam, LPARAM lParam);

    __declspec(dllimport) BOOL __stdcall TranslateMDISysAccel(HWND hWndClient, LPMSG lpMsg);

    __declspec(dllimport) UINT __stdcall ArrangeIconicWindows(HWND hWnd);

    __declspec(dllimport) HWND __stdcall CreateMDIWindowA(
    LPCSTR lpClassName, LPCSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam);
    __declspec(dllimport) HWND __stdcall CreateMDIWindowW(
    LPCWSTR lpClassName, LPCWSTR lpWindowName, DWORD dwStyle, int X, int Y, int nWidth, int nHeight, HWND hWndParent, HINSTANCE hInstance, LPARAM lParam);

    __declspec(dllimport) WORD
    __stdcall TileWindows(HWND hwndParent, UINT wHow, const RECT* lpRect, UINT cKids, const HWND* lpKids);

    __declspec(dllimport) WORD
    __stdcall CascadeWindows(HWND hwndParent, UINT wHow, const RECT* lpRect, UINT cKids, const HWND* lpKids);

#pragma endregion

#pragma region Desktop Family

    typedef DWORD HELPPOLY;
    typedef struct tagMULTIKEYHELPA
    {
        DWORD mkSize;

        CHAR mkKeylist;
        CHAR szKeyphrase[1];
    } MULTIKEYHELPA, *PMULTIKEYHELPA, *LPMULTIKEYHELPA;
    typedef struct tagMULTIKEYHELPW
    {
        DWORD mkSize;

        WCHAR mkKeylist;
        WCHAR szKeyphrase[1];
    } MULTIKEYHELPW, *PMULTIKEYHELPW, *LPMULTIKEYHELPW;

    typedef MULTIKEYHELPA MULTIKEYHELP;
    typedef PMULTIKEYHELPA PMULTIKEYHELP;
    typedef LPMULTIKEYHELPA LPMULTIKEYHELP;

    typedef struct tagHELPWININFOA
    {
        int wStructSize;
        int x;
        int y;
        int dx;
        int dy;
        int wMax;
        CHAR rgchMember[2];
    } HELPWININFOA, *PHELPWININFOA, *LPHELPWININFOA;
    typedef struct tagHELPWININFOW
    {
        int wStructSize;
        int x;
        int y;
        int dx;
        int dy;
        int wMax;
        WCHAR rgchMember[2];
    } HELPWININFOW, *PHELPWININFOW, *LPHELPWININFOW;

    typedef HELPWININFOA HELPWININFO;
    typedef PHELPWININFOA PHELPWININFO;
    typedef LPHELPWININFOA LPHELPWININFO;

    __declspec(dllimport) BOOL __stdcall WinHelpA(HWND hWndMain, LPCSTR lpszHelp, UINT uCommand, ULONG_PTR dwData);
    __declspec(dllimport) BOOL __stdcall WinHelpW(HWND hWndMain, LPCWSTR lpszHelp, UINT uCommand, ULONG_PTR dwData);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) DWORD __stdcall GetGuiResources(HANDLE hProcess, DWORD uiFlags);

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma region Desktop Family

    typedef struct tagTouchPredictionParameters
    {
        UINT cbSize;
        UINT dwLatency;
        UINT dwSampleTime;
        UINT bUseHWTimeStamp;
    } TOUCHPREDICTIONPARAMETERS, *PTOUCHPREDICTIONPARAMETERS;

#pragma endregion

    typedef enum tagHANDEDNESS
    {
        HANDEDNESS_LEFT = 0,
        HANDEDNESS_RIGHT
    } HANDEDNESS,
    *PHANDEDNESS;

#pragma region Desktop Family

    typedef struct tagNONCLIENTMETRICSA
    {
        UINT cbSize;
        int iBorderWidth;
        int iScrollWidth;
        int iScrollHeight;
        int iCaptionWidth;
        int iCaptionHeight;
        LOGFONTA lfCaptionFont;
        int iSmCaptionWidth;
        int iSmCaptionHeight;
        LOGFONTA lfSmCaptionFont;
        int iMenuWidth;
        int iMenuHeight;
        LOGFONTA lfMenuFont;
        LOGFONTA lfStatusFont;
        LOGFONTA lfMessageFont;

        int iPaddedBorderWidth;
    } NONCLIENTMETRICSA, *PNONCLIENTMETRICSA, *LPNONCLIENTMETRICSA;
    typedef struct tagNONCLIENTMETRICSW
    {
        UINT cbSize;
        int iBorderWidth;
        int iScrollWidth;
        int iScrollHeight;
        int iCaptionWidth;
        int iCaptionHeight;
        LOGFONTW lfCaptionFont;
        int iSmCaptionWidth;
        int iSmCaptionHeight;
        LOGFONTW lfSmCaptionFont;
        int iMenuWidth;
        int iMenuHeight;
        LOGFONTW lfMenuFont;
        LOGFONTW lfStatusFont;
        LOGFONTW lfMessageFont;

        int iPaddedBorderWidth;
    } NONCLIENTMETRICSW, *PNONCLIENTMETRICSW, *LPNONCLIENTMETRICSW;

    typedef NONCLIENTMETRICSA NONCLIENTMETRICS;
    typedef PNONCLIENTMETRICSA PNONCLIENTMETRICS;
    typedef LPNONCLIENTMETRICSA LPNONCLIENTMETRICS;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagMINIMIZEDMETRICS
    {
        UINT cbSize;
        int iWidth;
        int iHorzGap;
        int iVertGap;
        int iArrange;
    } MINIMIZEDMETRICS, *PMINIMIZEDMETRICS, *LPMINIMIZEDMETRICS;

    typedef struct tagICONMETRICSA
    {
        UINT cbSize;
        int iHorzSpacing;
        int iVertSpacing;
        int iTitleWrap;
        LOGFONTA lfFont;
    } ICONMETRICSA, *PICONMETRICSA, *LPICONMETRICSA;
    typedef struct tagICONMETRICSW
    {
        UINT cbSize;
        int iHorzSpacing;
        int iVertSpacing;
        int iTitleWrap;
        LOGFONTW lfFont;
    } ICONMETRICSW, *PICONMETRICSW, *LPICONMETRICSW;

    typedef ICONMETRICSA ICONMETRICS;
    typedef PICONMETRICSA PICONMETRICS;
    typedef LPICONMETRICSA LPICONMETRICS;

    typedef struct tagANIMATIONINFO
    {
        UINT cbSize;
        int iMinAnimate;
    } ANIMATIONINFO, *LPANIMATIONINFO;

    typedef struct tagSERIALKEYSA
    {
        UINT cbSize;
        DWORD dwFlags;
        LPSTR lpszActivePort;
        LPSTR lpszPort;
        UINT iBaudRate;
        UINT iPortState;
        UINT iActive;
    } SERIALKEYSA, *LPSERIALKEYSA;
    typedef struct tagSERIALKEYSW
    {
        UINT cbSize;
        DWORD dwFlags;
        LPWSTR lpszActivePort;
        LPWSTR lpszPort;
        UINT iBaudRate;
        UINT iPortState;
        UINT iActive;
    } SERIALKEYSW, *LPSERIALKEYSW;

    typedef SERIALKEYSA SERIALKEYS;
    typedef LPSERIALKEYSA LPSERIALKEYS;

    typedef struct tagHIGHCONTRASTA
    {
        UINT cbSize;
        DWORD dwFlags;
        LPSTR lpszDefaultScheme;
    } HIGHCONTRASTA, *LPHIGHCONTRASTA;
    typedef struct tagHIGHCONTRASTW
    {
        UINT cbSize;
        DWORD dwFlags;
        LPWSTR lpszDefaultScheme;
    } HIGHCONTRASTW, *LPHIGHCONTRASTW;

    typedef HIGHCONTRASTA HIGHCONTRAST;
    typedef LPHIGHCONTRASTA LPHIGHCONTRAST;

#pragma endregion

#pragma once

#pragma region Desktop Family

    typedef struct _VIDEOPARAMETERS
    {
        GUID Guid;
        ULONG dwOffset;
        ULONG dwCommand;
        ULONG dwFlags;
        ULONG dwMode;
        ULONG dwTVStandard;
        ULONG dwAvailableModes;
        ULONG dwAvailableTVStandard;
        ULONG dwFlickerFilter;
        ULONG dwOverScanX;
        ULONG dwOverScanY;
        ULONG dwMaxUnscaledX;
        ULONG dwMaxUnscaledY;
        ULONG dwPositionX;
        ULONG dwPositionY;
        ULONG dwBrightness;
        ULONG dwContrast;
        ULONG dwCPType;
        ULONG dwCPCommand;
        ULONG dwCPStandard;
        ULONG dwCPKey;
        ULONG bCP_APSTriggerBits;
        UCHAR bOEMCopyProtection[256];
    } VIDEOPARAMETERS, *PVIDEOPARAMETERS, *LPVIDEOPARAMETERS;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) LONG __stdcall ChangeDisplaySettingsA(DEVMODEA* lpDevMode, DWORD dwFlags);
    __declspec(dllimport) LONG __stdcall ChangeDisplaySettingsW(DEVMODEW* lpDevMode, DWORD dwFlags);

    __declspec(dllimport) LONG
    __stdcall ChangeDisplaySettingsExA(LPCSTR lpszDeviceName, DEVMODEA* lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);
    __declspec(dllimport) LONG
    __stdcall ChangeDisplaySettingsExW(LPCWSTR lpszDeviceName, DEVMODEW* lpDevMode, HWND hwnd, DWORD dwflags, LPVOID lParam);

    __declspec(dllimport) BOOL __stdcall EnumDisplaySettingsA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA* lpDevMode);
    __declspec(dllimport) BOOL __stdcall EnumDisplaySettingsW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW* lpDevMode);

    __declspec(dllimport) BOOL
    __stdcall EnumDisplaySettingsExA(LPCSTR lpszDeviceName, DWORD iModeNum, DEVMODEA* lpDevMode, DWORD dwFlags);
    __declspec(dllimport) BOOL
    __stdcall EnumDisplaySettingsExW(LPCWSTR lpszDeviceName, DWORD iModeNum, DEVMODEW* lpDevMode, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall EnumDisplayDevicesA(LPCSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEA lpDisplayDevice, DWORD dwFlags);
    __declspec(dllimport) BOOL
    __stdcall EnumDisplayDevicesW(LPCWSTR lpDevice, DWORD iDevNum, PDISPLAY_DEVICEW lpDisplayDevice, DWORD dwFlags);

    __declspec(dllimport) LONG
    __stdcall GetDisplayConfigBufferSizes(UINT32 flags, UINT32* numPathArrayElements, UINT32* numModeInfoArrayElements);

    __declspec(dllimport) LONG __stdcall SetDisplayConfig(UINT32 numPathArrayElements,
                                                          DISPLAYCONFIG_PATH_INFO* pathArray,
                                                          UINT32 numModeInfoArrayElements,
                                                          DISPLAYCONFIG_MODE_INFO* modeInfoArray,
                                                          UINT32 flags);

    __declspec(dllimport) LONG __stdcall QueryDisplayConfig(UINT32 flags,
                                                            UINT32* numPathArrayElements,
                                                            DISPLAYCONFIG_PATH_INFO* pathArray,
                                                            UINT32* numModeInfoArrayElements,
                                                            DISPLAYCONFIG_MODE_INFO* modeInfoArray,

                                                            DISPLAYCONFIG_TOPOLOGY_ID* currentTopologyId);

    __declspec(dllimport) LONG __stdcall DisplayConfigGetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER* requestPacket);

    __declspec(dllimport) LONG __stdcall DisplayConfigSetDeviceInfo(DISPLAYCONFIG_DEVICE_INFO_HEADER* setPacket);

    __declspec(dllimport)

    BOOL __stdcall SystemParametersInfoA(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);
    __declspec(dllimport)

    BOOL __stdcall SystemParametersInfoW(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni);

    __declspec(dllimport)

    BOOL __stdcall SystemParametersInfoForDpi(UINT uiAction, UINT uiParam, PVOID pvParam, UINT fWinIni, UINT dpi);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagFILTERKEYS
    {
        UINT cbSize;
        DWORD dwFlags;
        DWORD iWaitMSec;
        DWORD iDelayMSec;
        DWORD iRepeatMSec;
        DWORD iBounceMSec;
    } FILTERKEYS, *LPFILTERKEYS;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagSTICKYKEYS
    {
        UINT cbSize;
        DWORD dwFlags;
    } STICKYKEYS, *LPSTICKYKEYS;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagMOUSEKEYS
    {
        UINT cbSize;
        DWORD dwFlags;
        DWORD iMaxSpeed;
        DWORD iTimeToMaxSpeed;
        DWORD iCtrlSpeed;
        DWORD dwReserved1;
        DWORD dwReserved2;
    } MOUSEKEYS, *LPMOUSEKEYS;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagACCESSTIMEOUT
    {
        UINT cbSize;
        DWORD dwFlags;
        DWORD iTimeOutMSec;
    } ACCESSTIMEOUT, *LPACCESSTIMEOUT;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagSOUNDSENTRYA
    {
        UINT cbSize;
        DWORD dwFlags;
        DWORD iFSTextEffect;
        DWORD iFSTextEffectMSec;
        DWORD iFSTextEffectColorBits;
        DWORD iFSGrafEffect;
        DWORD iFSGrafEffectMSec;
        DWORD iFSGrafEffectColor;
        DWORD iWindowsEffect;
        DWORD iWindowsEffectMSec;
        LPSTR lpszWindowsEffectDLL;
        DWORD iWindowsEffectOrdinal;
    } SOUNDSENTRYA, *LPSOUNDSENTRYA;
    typedef struct tagSOUNDSENTRYW
    {
        UINT cbSize;
        DWORD dwFlags;
        DWORD iFSTextEffect;
        DWORD iFSTextEffectMSec;
        DWORD iFSTextEffectColorBits;
        DWORD iFSGrafEffect;
        DWORD iFSGrafEffectMSec;
        DWORD iFSGrafEffectColor;
        DWORD iWindowsEffect;
        DWORD iWindowsEffectMSec;
        LPWSTR lpszWindowsEffectDLL;
        DWORD iWindowsEffectOrdinal;
    } SOUNDSENTRYW, *LPSOUNDSENTRYW;

    typedef SOUNDSENTRYA SOUNDSENTRY;
    typedef LPSOUNDSENTRYA LPSOUNDSENTRY;

#pragma endregion

#pragma region Desktop or PC Family

    __declspec(dllimport) BOOL __stdcall SoundSentry(void);
#pragma endregion

#pragma region Desktop Family

    typedef struct tagTOGGLEKEYS
    {
        UINT cbSize;
        DWORD dwFlags;
    } TOGGLEKEYS, *LPTOGGLEKEYS;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagAUDIODESCRIPTION
    {
        UINT cbSize;
        BOOL Enabled;
        LCID Locale;
    } AUDIODESCRIPTION, *LPAUDIODESCRIPTION;

    __declspec(dllimport) void __stdcall SetDebugErrorLevel(DWORD dwLevel);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) void __stdcall SetLastErrorEx(DWORD dwErrCode, DWORD dwType);

    __declspec(dllimport) int __stdcall InternalGetWindowText(HWND hWnd, LPWSTR pString, int cchMaxCount);

    __declspec(dllimport) BOOL __stdcall CancelShutdown(void);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HMONITOR __stdcall MonitorFromPoint(POINT pt, DWORD dwFlags);

    __declspec(dllimport) HMONITOR __stdcall MonitorFromRect(LPCRECT lprc, DWORD dwFlags);

    __declspec(dllimport) HMONITOR __stdcall MonitorFromWindow(HWND hwnd, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagMONITORINFO
    {
        DWORD cbSize;
        RECT rcMonitor;
        RECT rcWork;
        DWORD dwFlags;
    } MONITORINFO, *LPMONITORINFO;

    typedef struct tagMONITORINFOEXA : public tagMONITORINFO
    {
        CHAR szDevice[32];
    } MONITORINFOEXA, *LPMONITORINFOEXA;
    typedef struct tagMONITORINFOEXW : public tagMONITORINFO
    {
        WCHAR szDevice[32];
    } MONITORINFOEXW, *LPMONITORINFOEXW;

    typedef MONITORINFOEXA MONITORINFOEX;
    typedef LPMONITORINFOEXA LPMONITORINFOEX;

    __declspec(dllimport) BOOL __stdcall GetMonitorInfoA(HMONITOR hMonitor, LPMONITORINFO lpmi);
    __declspec(dllimport) BOOL __stdcall GetMonitorInfoW(HMONITOR hMonitor, LPMONITORINFO lpmi);

    typedef BOOL(__stdcall* MONITORENUMPROC)(HMONITOR, HDC, LPRECT, LPARAM);

    __declspec(dllimport) BOOL __stdcall EnumDisplayMonitors(HDC hdc, LPCRECT lprcClip, MONITORENUMPROC lpfnEnum, LPARAM dwData);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) void __stdcall NotifyWinEvent(DWORD event, HWND hwnd, LONG idObject, LONG idChild);

    typedef void(__stdcall* WINEVENTPROC)(
    HWINEVENTHOOK hWinEventHook, DWORD event, HWND hwnd, LONG idObject, LONG idChild, DWORD idEventThread, DWORD dwmsEventTime);

    __declspec(dllimport) HWINEVENTHOOK __stdcall SetWinEventHook(
    DWORD eventMin, DWORD eventMax, HMODULE hmodWinEventProc, WINEVENTPROC pfnWinEventProc, DWORD idProcess, DWORD idThread, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall IsWinEventHookInstalled(DWORD event);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall UnhookWinEvent(HWINEVENTHOOK hWinEventHook);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagGUITHREADINFO
    {
        DWORD cbSize;
        DWORD flags;
        HWND hwndActive;
        HWND hwndFocus;
        HWND hwndCapture;
        HWND hwndMenuOwner;
        HWND hwndMoveSize;
        HWND hwndCaret;
        RECT rcCaret;
    } GUITHREADINFO, *PGUITHREADINFO, *LPGUITHREADINFO;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall GetGUIThreadInfo(DWORD idThread, PGUITHREADINFO pgui);

    __declspec(dllimport) BOOL __stdcall BlockInput(BOOL fBlockIt);

    __declspec(dllimport) BOOL __stdcall SetProcessDPIAware(void);

    __declspec(dllimport) BOOL __stdcall IsProcessDPIAware(void);

    __declspec(dllimport) DPI_AWARENESS_CONTEXT __stdcall SetThreadDpiAwarenessContext(DPI_AWARENESS_CONTEXT dpiContext);

    __declspec(dllimport) DPI_AWARENESS_CONTEXT __stdcall GetThreadDpiAwarenessContext(void);

    __declspec(dllimport) DPI_AWARENESS_CONTEXT __stdcall GetWindowDpiAwarenessContext(HWND hwnd);

    __declspec(dllimport) DPI_AWARENESS __stdcall GetAwarenessFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value);

    __declspec(dllimport) UINT __stdcall GetDpiFromDpiAwarenessContext(DPI_AWARENESS_CONTEXT value);

    __declspec(dllimport) BOOL
    __stdcall AreDpiAwarenessContextsEqual(DPI_AWARENESS_CONTEXT dpiContextA, DPI_AWARENESS_CONTEXT dpiContextB);

    __declspec(dllimport) BOOL __stdcall IsValidDpiAwarenessContext(DPI_AWARENESS_CONTEXT value);

    __declspec(dllimport) UINT __stdcall GetDpiForWindow(HWND hwnd);

    __declspec(dllimport) UINT __stdcall GetDpiForSystem(void);

    __declspec(dllimport) UINT __stdcall GetSystemDpiForProcess(HANDLE hProcess);

    __declspec(dllimport) BOOL __stdcall EnableNonClientDpiScaling(HWND hwnd);

    __declspec(dllimport) BOOL __stdcall InheritWindowMonitor(HWND hwnd, HWND hwndInherit);

    __declspec(dllimport) BOOL __stdcall SetProcessDpiAwarenessContext(DPI_AWARENESS_CONTEXT value);

    __declspec(dllimport) DPI_HOSTING_BEHAVIOR __stdcall SetThreadDpiHostingBehavior(DPI_HOSTING_BEHAVIOR value);

    __declspec(dllimport) DPI_HOSTING_BEHAVIOR __stdcall GetThreadDpiHostingBehavior();

    __declspec(dllimport) DPI_HOSTING_BEHAVIOR __stdcall GetWindowDpiHostingBehavior(HWND hwnd);

    __declspec(dllimport) UINT __stdcall GetWindowModuleFileNameA(HWND hwnd, LPSTR pszFileName, UINT cchFileNameMax);
    __declspec(dllimport) UINT __stdcall GetWindowModuleFileNameW(HWND hwnd, LPWSTR pszFileName, UINT cchFileNameMax);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagCURSORINFO
    {
        DWORD cbSize;
        DWORD flags;
        HCURSOR hCursor;
        POINT ptScreenPos;
    } CURSORINFO, *PCURSORINFO, *LPCURSORINFO;

    __declspec(dllimport) BOOL __stdcall GetCursorInfo(PCURSORINFO pci);

    typedef struct tagWINDOWINFO
    {
        DWORD cbSize;
        RECT rcWindow;
        RECT rcClient;
        DWORD dwStyle;
        DWORD dwExStyle;
        DWORD dwWindowStatus;
        UINT cxWindowBorders;
        UINT cyWindowBorders;
        ATOM atomWindowType;
        WORD wCreatorVersion;
    } WINDOWINFO, *PWINDOWINFO, *LPWINDOWINFO;

    __declspec(dllimport) BOOL __stdcall GetWindowInfo(HWND hwnd, PWINDOWINFO pwi);

    typedef struct tagTITLEBARINFO
    {
        DWORD cbSize;
        RECT rcTitleBar;
        DWORD rgstate[5 + 1];
    } TITLEBARINFO, *PTITLEBARINFO, *LPTITLEBARINFO;

    __declspec(dllimport) BOOL __stdcall GetTitleBarInfo(HWND hwnd, PTITLEBARINFO pti);

    typedef struct tagTITLEBARINFOEX
    {
        DWORD cbSize;
        RECT rcTitleBar;
        DWORD rgstate[5 + 1];
        RECT rgrect[5 + 1];
    } TITLEBARINFOEX, *PTITLEBARINFOEX, *LPTITLEBARINFOEX;

    typedef struct tagMENUBARINFO
    {
        DWORD cbSize;
        RECT rcBar;
        HMENU hMenu;
        HWND hwndMenu;
        BOOL fBarFocused : 1;
        BOOL fFocused : 1;
    } MENUBARINFO, *PMENUBARINFO, *LPMENUBARINFO;

    __declspec(dllimport) BOOL __stdcall GetMenuBarInfo(HWND hwnd, LONG idObject, LONG idItem, PMENUBARINFO pmbi);

    typedef struct tagSCROLLBARINFO
    {
        DWORD cbSize;
        RECT rcScrollBar;
        int dxyLineButton;
        int xyThumbTop;
        int xyThumbBottom;
        int reserved;
        DWORD rgstate[5 + 1];
    } SCROLLBARINFO, *PSCROLLBARINFO, *LPSCROLLBARINFO;

    __declspec(dllimport) BOOL __stdcall GetScrollBarInfo(HWND hwnd, LONG idObject, PSCROLLBARINFO psbi);

    typedef struct tagCOMBOBOXINFO
    {
        DWORD cbSize;
        RECT rcItem;
        RECT rcButton;
        DWORD stateButton;
        HWND hwndCombo;
        HWND hwndItem;
        HWND hwndList;
    } COMBOBOXINFO, *PCOMBOBOXINFO, *LPCOMBOBOXINFO;

    __declspec(dllimport) BOOL __stdcall GetComboBoxInfo(HWND hwndCombo, PCOMBOBOXINFO pcbi);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) HWND __stdcall GetAncestor(HWND hwnd, UINT gaFlags);

    __declspec(dllimport) HWND __stdcall RealChildWindowFromPoint(HWND hwndParent, POINT ptParentClientCoords);

    __declspec(dllimport) UINT __stdcall RealGetWindowClassA(HWND hwnd, LPSTR ptszClassName, UINT cchClassNameMax);

    __declspec(dllimport) UINT __stdcall RealGetWindowClassW(HWND hwnd, LPWSTR ptszClassName, UINT cchClassNameMax);

    typedef struct tagALTTABINFO
    {
        DWORD cbSize;
        int cItems;
        int cColumns;
        int cRows;
        int iColFocus;
        int iRowFocus;
        int cxItem;
        int cyItem;
        POINT ptStart;
    } ALTTABINFO, *PALTTABINFO, *LPALTTABINFO;

    __declspec(dllimport) BOOL __stdcall GetAltTabInfoA(HWND hwnd, int iItem, PALTTABINFO pati, LPSTR pszItemText, UINT cchItemText);
    __declspec(dllimport) BOOL
    __stdcall GetAltTabInfoW(HWND hwnd, int iItem, PALTTABINFO pati, LPWSTR pszItemText, UINT cchItemText);

    __declspec(dllimport) DWORD __stdcall GetListBoxInfo(HWND hwnd);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall LockWorkStation(void);

    __declspec(dllimport) BOOL __stdcall UserHandleGrantAccess(HANDLE hUserHandle, HANDLE hJob, BOOL bGrant);

#pragma endregion

#pragma region Desktop Family

    struct HRAWINPUT__
    {
        int unused;
    };
    typedef struct HRAWINPUT__* HRAWINPUT;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagRAWINPUTHEADER
    {
        DWORD dwType;
        DWORD dwSize;
        HANDLE hDevice;
        WPARAM wParam;
    } RAWINPUTHEADER, *PRAWINPUTHEADER, *LPRAWINPUTHEADER;

#pragma endregion

#pragma region Desktop Family

#pragma warning(push)
#pragma warning(disable : 4201)

    typedef struct tagRAWMOUSE
    {
        USHORT usFlags;

        union
        {
            ULONG ulButtons;
            struct
            {
                USHORT usButtonFlags;
                USHORT usButtonData;
            };
        };

        ULONG ulRawButtons;

        LONG lLastX;

        LONG lLastY;

        ULONG ulExtraInformation;

    } RAWMOUSE, *PRAWMOUSE, *LPRAWMOUSE;

#pragma warning(pop)

#pragma endregion

#pragma region Desktop Family

    typedef struct tagRAWKEYBOARD
    {
        USHORT MakeCode;

        USHORT Flags;

        USHORT Reserved;

        USHORT VKey;
        UINT Message;

        ULONG ExtraInformation;

    } RAWKEYBOARD, *PRAWKEYBOARD, *LPRAWKEYBOARD;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagRAWHID
    {
        DWORD dwSizeHid;
        DWORD dwCount;
        BYTE bRawData[1];
    } RAWHID, *PRAWHID, *LPRAWHID;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagRAWINPUT
    {
        RAWINPUTHEADER header;
        union
        {
            RAWMOUSE mouse;
            RAWKEYBOARD keyboard;
            RAWHID hid;
        } data;
    } RAWINPUT, *PRAWINPUT, *LPRAWINPUT;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) UINT
    __stdcall GetRawInputData(HRAWINPUT hRawInput, UINT uiCommand, LPVOID pData, PUINT pcbSize, UINT cbSizeHeader);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagRID_DEVICE_INFO_MOUSE
    {
        DWORD dwId;
        DWORD dwNumberOfButtons;
        DWORD dwSampleRate;
        BOOL fHasHorizontalWheel;
    } RID_DEVICE_INFO_MOUSE, *PRID_DEVICE_INFO_MOUSE;

    typedef struct tagRID_DEVICE_INFO_KEYBOARD
    {
        DWORD dwType;
        DWORD dwSubType;
        DWORD dwKeyboardMode;
        DWORD dwNumberOfFunctionKeys;
        DWORD dwNumberOfIndicators;
        DWORD dwNumberOfKeysTotal;
    } RID_DEVICE_INFO_KEYBOARD, *PRID_DEVICE_INFO_KEYBOARD;

    typedef struct tagRID_DEVICE_INFO_HID
    {
        DWORD dwVendorId;
        DWORD dwProductId;
        DWORD dwVersionNumber;

        USHORT usUsagePage;
        USHORT usUsage;
    } RID_DEVICE_INFO_HID, *PRID_DEVICE_INFO_HID;

    typedef struct tagRID_DEVICE_INFO
    {
        DWORD cbSize;
        DWORD dwType;
        union
        {
            RID_DEVICE_INFO_MOUSE mouse;
            RID_DEVICE_INFO_KEYBOARD keyboard;
            RID_DEVICE_INFO_HID hid;
        };
    } RID_DEVICE_INFO, *PRID_DEVICE_INFO, *LPRID_DEVICE_INFO;

    __declspec(dllimport) UINT __stdcall GetRawInputDeviceInfoA(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize);
    __declspec(dllimport) UINT __stdcall GetRawInputDeviceInfoW(HANDLE hDevice, UINT uiCommand, LPVOID pData, PUINT pcbSize);

    __declspec(dllimport) UINT __stdcall GetRawInputBuffer(PRAWINPUT pData, PUINT pcbSize, UINT cbSizeHeader);

    typedef struct tagRAWINPUTDEVICE
    {
        USHORT usUsagePage;
        USHORT usUsage;
        DWORD dwFlags;
        HWND hwndTarget;
    } RAWINPUTDEVICE, *PRAWINPUTDEVICE, *LPRAWINPUTDEVICE;

    typedef const RAWINPUTDEVICE* PCRAWINPUTDEVICE;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall RegisterRawInputDevices(PCRAWINPUTDEVICE pRawInputDevices, UINT uiNumDevices, UINT cbSize);

    __declspec(dllimport) UINT
    __stdcall GetRegisteredRawInputDevices(PRAWINPUTDEVICE pRawInputDevices, PUINT puiNumDevices, UINT cbSize);

    typedef struct tagRAWINPUTDEVICELIST
    {
        HANDLE hDevice;
        DWORD dwType;
    } RAWINPUTDEVICELIST, *PRAWINPUTDEVICELIST;

    __declspec(dllimport) UINT
    __stdcall GetRawInputDeviceList(PRAWINPUTDEVICELIST pRawInputDeviceList, PUINT puiNumDevices, UINT cbSize);

    __declspec(dllimport) LRESULT __stdcall DefRawInputProc(PRAWINPUT* paRawInput, INT nInput, UINT cbSizeHeader);

#pragma endregion

#pragma region Desktop Family

    typedef enum tagPOINTER_DEVICE_TYPE
    {
        POINTER_DEVICE_TYPE_INTEGRATED_PEN = 0x00000001,
        POINTER_DEVICE_TYPE_EXTERNAL_PEN = 0x00000002,
        POINTER_DEVICE_TYPE_TOUCH = 0x00000003,

        POINTER_DEVICE_TYPE_TOUCH_PAD = 0x00000004,
        POINTER_DEVICE_TYPE_MAX = 0xFFFFFFFF
    } POINTER_DEVICE_TYPE;

    typedef struct tagPOINTER_DEVICE_INFO
    {
        DWORD displayOrientation;
        HANDLE device;
        POINTER_DEVICE_TYPE pointerDeviceType;
        HMONITOR monitor;
        ULONG startingCursorId;
        USHORT maxActiveContacts;
        WCHAR productString[520];
    } POINTER_DEVICE_INFO;

    typedef struct tagPOINTER_DEVICE_PROPERTY
    {
        INT32 logicalMin;
        INT32 logicalMax;
        INT32 physicalMin;
        INT32 physicalMax;
        UINT32 unit;
        UINT32 unitExponent;
        USHORT usagePageId;
        USHORT usageId;
    } POINTER_DEVICE_PROPERTY;

    typedef enum tagPOINTER_DEVICE_CURSOR_TYPE
    {
        POINTER_DEVICE_CURSOR_TYPE_UNKNOWN = 0x00000000,
        POINTER_DEVICE_CURSOR_TYPE_TIP = 0x00000001,
        POINTER_DEVICE_CURSOR_TYPE_ERASER = 0x00000002,
        POINTER_DEVICE_CURSOR_TYPE_MAX = 0xFFFFFFFF
    } POINTER_DEVICE_CURSOR_TYPE;

    typedef struct tagPOINTER_DEVICE_CURSOR_INFO
    {
        UINT32 cursorId;
        POINTER_DEVICE_CURSOR_TYPE cursor;
    } POINTER_DEVICE_CURSOR_INFO;

    __declspec(dllimport) BOOL __stdcall GetPointerDevices(UINT32* deviceCount, POINTER_DEVICE_INFO* pointerDevices);

    __declspec(dllimport) BOOL __stdcall GetPointerDevice(HANDLE device, POINTER_DEVICE_INFO* pointerDevice);

    __declspec(dllimport) BOOL
    __stdcall GetPointerDeviceProperties(HANDLE device, UINT32* propertyCount, POINTER_DEVICE_PROPERTY* pointerProperties);

    __declspec(dllimport) BOOL __stdcall RegisterPointerDeviceNotifications(HWND window, BOOL notifyRange);

    __declspec(dllimport) BOOL __stdcall GetPointerDeviceRects(HANDLE device, RECT* pointerDeviceRect, RECT* displayRect);

    __declspec(dllimport) BOOL
    __stdcall GetPointerDeviceCursors(HANDLE device, UINT32* cursorCount, POINTER_DEVICE_CURSOR_INFO* deviceCursors);

    __declspec(dllimport) BOOL __stdcall GetRawPointerDeviceData(
    UINT32 pointerId, UINT32 historyCount, UINT32 propertiesCount, POINTER_DEVICE_PROPERTY* pProperties, LONG* pValues);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall ChangeWindowMessageFilter(UINT message, DWORD dwFlag);

#pragma endregion

#pragma region Desktop Family

    typedef struct tagCHANGEFILTERSTRUCT
    {
        DWORD cbSize;
        DWORD ExtStatus;
    } CHANGEFILTERSTRUCT, *PCHANGEFILTERSTRUCT;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL
    __stdcall ChangeWindowMessageFilterEx(HWND hwnd, UINT message, DWORD action, PCHANGEFILTERSTRUCT pChangeFilterStruct);

#pragma endregion

#pragma region Desktop Family

    struct HGESTUREINFO__
    {
        int unused;
    };
    typedef struct HGESTUREINFO__* HGESTUREINFO;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagGESTUREINFO
    {
        UINT cbSize;
        DWORD dwFlags;
        DWORD dwID;
        HWND hwndTarget;
        POINTS ptsLocation;
        DWORD dwInstanceID;
        DWORD dwSequenceID;
        ULONGLONG ullArguments;
        UINT cbExtraArgs;
    } GESTUREINFO, *PGESTUREINFO;
    typedef GESTUREINFO const* PCGESTUREINFO;

    typedef struct tagGESTURENOTIFYSTRUCT
    {
        UINT cbSize;
        DWORD dwFlags;
        HWND hwndTarget;
        POINTS ptsLocation;
        DWORD dwInstanceID;
    } GESTURENOTIFYSTRUCT, *PGESTURENOTIFYSTRUCT;

    __declspec(dllimport) BOOL __stdcall GetGestureInfo(HGESTUREINFO hGestureInfo, PGESTUREINFO pGestureInfo);

    __declspec(dllimport) BOOL __stdcall GetGestureExtraArgs(HGESTUREINFO hGestureInfo, UINT cbExtraArgs, PBYTE pExtraArgs);

    __declspec(dllimport) BOOL __stdcall CloseGestureInfoHandle(HGESTUREINFO hGestureInfo);

    typedef struct tagGESTURECONFIG
    {
        DWORD dwID;
        DWORD dwWant;
        DWORD dwBlock;
    } GESTURECONFIG, *PGESTURECONFIG;

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall SetGestureConfig(HWND hwnd,
                                                          DWORD dwReserved,
                                                          UINT cIDs,
                                                          PGESTURECONFIG pGestureConfig,

                                                          UINT cbSize);

    __declspec(dllimport) BOOL __stdcall GetGestureConfig(HWND hwnd,
                                                          DWORD dwReserved,
                                                          DWORD dwFlags,
                                                          PUINT pcIDs,

                                                          PGESTURECONFIG pGestureConfig,

                                                          UINT cbSize);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall ShutdownBlockReasonCreate(HWND hWnd, LPCWSTR pwszReason);

    __declspec(dllimport) BOOL __stdcall ShutdownBlockReasonQuery(HWND hWnd, LPWSTR pwszBuff, DWORD* pcchBuff);

    __declspec(dllimport) BOOL __stdcall ShutdownBlockReasonDestroy(HWND hWnd);

#pragma endregion

#pragma region Desktop Family

    typedef enum tagINPUT_MESSAGE_DEVICE_TYPE
    {
        IMDT_UNAVAILABLE = 0x00000000,
        IMDT_KEYBOARD = 0x00000001,
        IMDT_MOUSE = 0x00000002,
        IMDT_TOUCH = 0x00000004,
        IMDT_PEN = 0x00000008,

        IMDT_TOUCHPAD = 0x00000010,
    } INPUT_MESSAGE_DEVICE_TYPE;

    typedef enum tagINPUT_MESSAGE_ORIGIN_ID
    {
        IMO_UNAVAILABLE = 0x00000000,
        IMO_HARDWARE = 0x00000001,
        IMO_INJECTED = 0x00000002,
        IMO_SYSTEM = 0x00000004,
    } INPUT_MESSAGE_ORIGIN_ID;

    typedef struct tagINPUT_MESSAGE_SOURCE
    {
        INPUT_MESSAGE_DEVICE_TYPE deviceType;
        INPUT_MESSAGE_ORIGIN_ID originId;
    } INPUT_MESSAGE_SOURCE;

    __declspec(dllimport) BOOL __stdcall GetCurrentInputMessageSource(INPUT_MESSAGE_SOURCE* inputMessageSource);

    __declspec(dllimport) BOOL __stdcall GetCIMSSM(INPUT_MESSAGE_SOURCE* inputMessageSource);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef enum tagAR_STATE
    {
        AR_ENABLED = 0x0,
        AR_DISABLED = 0x1,
        AR_SUPPRESSED = 0x2,
        AR_REMOTESESSION = 0x4,
        AR_MULTIMON = 0x8,
        AR_NOSENSOR = 0x10,
        AR_NOT_SUPPORTED = 0x20,
        AR_DOCKED = 0x40,
        AR_LAPTOP = 0x80
    } AR_STATE,
    *PAR_STATE;

#pragma endregion

    extern "C++"
    {
        inline constexpr AR_STATE operator|(AR_STATE a, AR_STATE b) throw()
        {
            return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) | ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b));
        }
        inline AR_STATE& operator|=(AR_STATE& a, AR_STATE b) throw()
        {
            return (AR_STATE&)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type&)a) |= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b));
        }
        inline constexpr AR_STATE operator&(AR_STATE a, AR_STATE b) throw()
        {
            return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) & ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b));
        }
        inline AR_STATE& operator&=(AR_STATE& a, AR_STATE b) throw()
        {
            return (AR_STATE&)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type&)a) &= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b));
        }
        inline constexpr AR_STATE operator~(AR_STATE a) throw()
        {
            return AR_STATE(~((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a));
        }
        inline constexpr AR_STATE operator^(AR_STATE a, AR_STATE b) throw()
        {
            return AR_STATE(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)a) ^ ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b));
        }
        inline AR_STATE& operator^=(AR_STATE& a, AR_STATE b) throw()
        {
            return (AR_STATE&)(((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type&)a) ^= ((_ENUM_FLAG_SIZED_INTEGER<AR_STATE>::type)b));
        }
    }

#pragma region Desktop Family

    typedef enum ORIENTATION_PREFERENCE
    {
        ORIENTATION_PREFERENCE_NONE = 0x0,
        ORIENTATION_PREFERENCE_LANDSCAPE = 0x1,
        ORIENTATION_PREFERENCE_PORTRAIT = 0x2,
        ORIENTATION_PREFERENCE_LANDSCAPE_FLIPPED = 0x4,
        ORIENTATION_PREFERENCE_PORTRAIT_FLIPPED = 0x8
    } ORIENTATION_PREFERENCE;

    extern "C++"
    {
        inline constexpr ORIENTATION_PREFERENCE operator|(ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) throw()
        {
            return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a)
                                          | ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b));
        }
        inline ORIENTATION_PREFERENCE& operator|=(ORIENTATION_PREFERENCE& a, ORIENTATION_PREFERENCE b) throw()
        {
            return (ORIENTATION_PREFERENCE&)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type&)a)
                                             |= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b));
        }
        inline constexpr ORIENTATION_PREFERENCE operator&(ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) throw()
        {
            return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a)
                                          & ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b));
        }
        inline ORIENTATION_PREFERENCE& operator&=(ORIENTATION_PREFERENCE& a, ORIENTATION_PREFERENCE b) throw()
        {
            return (ORIENTATION_PREFERENCE&)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type&)a)
                                             &= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b));
        }
        inline constexpr ORIENTATION_PREFERENCE operator~(ORIENTATION_PREFERENCE a) throw()
        {
            return ORIENTATION_PREFERENCE(~((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a));
        }
        inline constexpr ORIENTATION_PREFERENCE operator^(ORIENTATION_PREFERENCE a, ORIENTATION_PREFERENCE b) throw()
        {
            return ORIENTATION_PREFERENCE(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)a)
                                          ^ ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b));
        }
        inline ORIENTATION_PREFERENCE& operator^=(ORIENTATION_PREFERENCE& a, ORIENTATION_PREFERENCE b) throw()
        {
            return (ORIENTATION_PREFERENCE&)(((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type&)a)
                                             ^= ((_ENUM_FLAG_SIZED_INTEGER<ORIENTATION_PREFERENCE>::type)b));
        }
    }

    __declspec(dllimport) BOOL __stdcall GetAutoRotationState(PAR_STATE pState);

    __declspec(dllimport) BOOL __stdcall GetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE* pOrientation);

    __declspec(dllimport) BOOL
    __stdcall GetDisplayAutoRotationPreferencesByProcessId(DWORD dwProcessId, ORIENTATION_PREFERENCE* pOrientation, BOOL* fRotateScreen);

    __declspec(dllimport) BOOL __stdcall SetDisplayAutoRotationPreferences(ORIENTATION_PREFERENCE orientation);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall IsImmersiveProcess(HANDLE hProcess);

    __declspec(dllimport) BOOL __stdcall SetProcessRestrictionExemption(BOOL fEnableExemption);

#pragma endregion

#pragma region Desktop Family

#pragma warning(pop)
}

extern "C"
{
#pragma once

    extern "C"
    {
#pragma region Desktop Family or OneCore Family

        __declspec(dllimport) int __stdcall GetDateFormatA(
        LCID Locale, DWORD dwFlags, const SYSTEMTIME* lpDate, LPCSTR lpFormat, LPSTR lpDateStr, int cchDate);

        __declspec(dllimport) int __stdcall GetDateFormatW(
        LCID Locale, DWORD dwFlags, const SYSTEMTIME* lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate);

        __declspec(dllimport) int __stdcall GetTimeFormatA(
        LCID Locale, DWORD dwFlags, const SYSTEMTIME* lpTime, LPCSTR lpFormat, LPSTR lpTimeStr, int cchTime);

        __declspec(dllimport) int __stdcall GetTimeFormatW(
        LCID Locale, DWORD dwFlags, const SYSTEMTIME* lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport) int __stdcall GetTimeFormatEx(
        LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME* lpTime, LPCWSTR lpFormat, LPWSTR lpTimeStr, int cchTime);

        __declspec(dllimport) int __stdcall GetDateFormatEx(
        LPCWSTR lpLocaleName, DWORD dwFlags, const SYSTEMTIME* lpDate, LPCWSTR lpFormat, LPWSTR lpDateStr, int cchDate, LPCWSTR lpCalendar);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport) int __stdcall GetDurationFormatEx(LPCWSTR lpLocaleName,
                                                                DWORD dwFlags,
                                                                const SYSTEMTIME* lpDuration,
                                                                ULONGLONG ullDuration,
                                                                LPCWSTR lpFormat,
                                                                LPWSTR lpDurationStr,
                                                                int cchDuration);

#pragma endregion
    }

#pragma warning(push)
#pragma warning(disable : 4820)

#pragma region Application Family or OneCore Family

    typedef DWORD LGRPID;

    typedef DWORD LCTYPE;

    typedef DWORD CALTYPE;

    typedef DWORD CALID;

    typedef struct _cpinfo
    {
        UINT MaxCharSize;
        BYTE DefaultChar[2];
        BYTE LeadByte[12];
    } CPINFO, *LPCPINFO;

    typedef struct _cpinfoexA
    {
        UINT MaxCharSize;
        BYTE DefaultChar[2];
        BYTE LeadByte[12];
        WCHAR UnicodeDefaultChar;
        UINT CodePage;
        CHAR CodePageName[260];
    } CPINFOEXA, *LPCPINFOEXA;

    typedef struct _cpinfoexW
    {
        UINT MaxCharSize;
        BYTE DefaultChar[2];
        BYTE LeadByte[12];
        WCHAR UnicodeDefaultChar;
        UINT CodePage;
        WCHAR CodePageName[260];
    } CPINFOEXW, *LPCPINFOEXW;

    typedef CPINFOEXA CPINFOEX;
    typedef LPCPINFOEXA LPCPINFOEX;

    typedef struct _numberfmtA
    {
        UINT NumDigits;
        UINT LeadingZero;
        UINT Grouping;
        LPSTR lpDecimalSep;
        LPSTR lpThousandSep;
        UINT NegativeOrder;
    } NUMBERFMTA, *LPNUMBERFMTA;
    typedef struct _numberfmtW
    {
        UINT NumDigits;
        UINT LeadingZero;
        UINT Grouping;
        LPWSTR lpDecimalSep;
        LPWSTR lpThousandSep;
        UINT NegativeOrder;
    } NUMBERFMTW, *LPNUMBERFMTW;

    typedef NUMBERFMTA NUMBERFMT;
    typedef LPNUMBERFMTA LPNUMBERFMT;

    typedef struct _currencyfmtA
    {
        UINT NumDigits;
        UINT LeadingZero;
        UINT Grouping;
        LPSTR lpDecimalSep;
        LPSTR lpThousandSep;
        UINT NegativeOrder;
        UINT PositiveOrder;
        LPSTR lpCurrencySymbol;
    } CURRENCYFMTA, *LPCURRENCYFMTA;
    typedef struct _currencyfmtW
    {
        UINT NumDigits;
        UINT LeadingZero;
        UINT Grouping;
        LPWSTR lpDecimalSep;
        LPWSTR lpThousandSep;
        UINT NegativeOrder;
        UINT PositiveOrder;
        LPWSTR lpCurrencySymbol;
    } CURRENCYFMTW, *LPCURRENCYFMTW;

    typedef CURRENCYFMTA CURRENCYFMT;
    typedef LPCURRENCYFMTA LPCURRENCYFMT;

    enum SYSNLS_FUNCTION
    {
        COMPARE_STRING = 0x0001,
    };
    typedef DWORD NLS_FUNCTION;

    typedef struct _nlsversioninfo
    {
        DWORD dwNLSVersionInfoSize;
        DWORD dwNLSVersion;
        DWORD dwDefinedVersion;
        DWORD dwEffectiveId;
        GUID guidCustomVersion;
    } NLSVERSIONINFO, *LPNLSVERSIONINFO;

    typedef struct _nlsversioninfoex
    {
        DWORD dwNLSVersionInfoSize;
        DWORD dwNLSVersion;
        DWORD dwDefinedVersion;
        DWORD dwEffectiveId;
        GUID guidCustomVersion;
    } NLSVERSIONINFOEX, *LPNLSVERSIONINFOEX;

    typedef DWORD GEOTYPE;
    typedef DWORD GEOCLASS;

    typedef LONG GEOID;

    enum SYSGEOTYPE
    {
        GEO_NATION = 0x0001,
        GEO_LATITUDE = 0x0002,
        GEO_LONGITUDE = 0x0003,
        GEO_ISO2 = 0x0004,
        GEO_ISO3 = 0x0005,
        GEO_RFC1766 = 0x0006,
        GEO_LCID = 0x0007,
        GEO_FRIENDLYNAME = 0x0008,
        GEO_OFFICIALNAME = 0x0009,
        GEO_TIMEZONES = 0x000A,
        GEO_OFFICIALLANGUAGES = 0x000B,
        GEO_ISO_UN_NUMBER = 0x000C,
        GEO_PARENT = 0x000D,
        GEO_DIALINGCODE = 0x000E,
        GEO_CURRENCYCODE = 0x000F,
        GEO_CURRENCYSYMBOL = 0x0010,

        GEO_NAME = 0x0011,
        GEO_ID = 0x0012
    };

    enum SYSGEOCLASS
    {
        GEOCLASS_NATION = 16,
        GEOCLASS_REGION = 14,
        GEOCLASS_ALL = 0
    };

    typedef enum _NORM_FORM
    {
        NormalizationOther = 0,
        NormalizationC = 0x1,
        NormalizationD = 0x2,
        NormalizationKC = 0x5,

        NormalizationKD = 0x6

    } NORM_FORM;

    typedef BOOL(__stdcall* LANGUAGEGROUP_ENUMPROCA)(LGRPID, LPSTR, LPSTR, DWORD, LONG_PTR);

    typedef BOOL(__stdcall* LANGGROUPLOCALE_ENUMPROCA)(LGRPID, LCID, LPSTR, LONG_PTR);
    typedef BOOL(__stdcall* UILANGUAGE_ENUMPROCA)(LPSTR, LONG_PTR);
    typedef BOOL(__stdcall* CODEPAGE_ENUMPROCA)(LPSTR);
    typedef BOOL(__stdcall* DATEFMT_ENUMPROCA)(LPSTR);
    typedef BOOL(__stdcall* DATEFMT_ENUMPROCEXA)(LPSTR, CALID);
    typedef BOOL(__stdcall* TIMEFMT_ENUMPROCA)(LPSTR);
    typedef BOOL(__stdcall* CALINFO_ENUMPROCA)(LPSTR);
    typedef BOOL(__stdcall* CALINFO_ENUMPROCEXA)(LPSTR, CALID);
    typedef BOOL(__stdcall* LOCALE_ENUMPROCA)(LPSTR);
    typedef BOOL(__stdcall* LOCALE_ENUMPROCW)(LPWSTR);

    typedef BOOL(__stdcall* LANGUAGEGROUP_ENUMPROCW)(LGRPID, LPWSTR, LPWSTR, DWORD, LONG_PTR);

    typedef BOOL(__stdcall* LANGGROUPLOCALE_ENUMPROCW)(LGRPID, LCID, LPWSTR, LONG_PTR);
    typedef BOOL(__stdcall* UILANGUAGE_ENUMPROCW)(LPWSTR, LONG_PTR);
    typedef BOOL(__stdcall* CODEPAGE_ENUMPROCW)(LPWSTR);
    typedef BOOL(__stdcall* DATEFMT_ENUMPROCW)(LPWSTR);
    typedef BOOL(__stdcall* DATEFMT_ENUMPROCEXW)(LPWSTR, CALID);
    typedef BOOL(__stdcall* TIMEFMT_ENUMPROCW)(LPWSTR);
    typedef BOOL(__stdcall* CALINFO_ENUMPROCW)(LPWSTR);
    typedef BOOL(__stdcall* CALINFO_ENUMPROCEXW)(LPWSTR, CALID);
    typedef BOOL(__stdcall* GEO_ENUMPROC)(GEOID);

    typedef BOOL(__stdcall* GEO_ENUMNAMEPROC)(PWSTR, LPARAM);

    typedef struct _FILEMUIINFO
    {
        DWORD dwSize;
        DWORD dwVersion;
        DWORD dwFileType;
        BYTE pChecksum[16];
        BYTE pServiceChecksum[16];
        DWORD dwLanguageNameOffset;
        DWORD dwTypeIDMainSize;
        DWORD dwTypeIDMainOffset;
        DWORD dwTypeNameMainOffset;
        DWORD dwTypeIDMUISize;
        DWORD dwTypeIDMUIOffset;
        DWORD dwTypeNameMUIOffset;
        BYTE abBuffer[8];
    } FILEMUIINFO, *PFILEMUIINFO;

#pragma once

    extern "C"
    {
#pragma region Application or OneCore Family

        __declspec(dllimport) int __stdcall CompareStringEx(LPCWSTR lpLocaleName,
                                                            DWORD dwCmpFlags,
                                                            LPCWCH lpString1,
                                                            int cchCount1,
                                                            LPCWCH lpString2,
                                                            int cchCount2,
                                                            LPNLSVERSIONINFO lpVersionInformation,
                                                            LPVOID lpReserved,
                                                            LPARAM lParam);

        __declspec(dllimport) int __stdcall CompareStringOrdinal(LPCWCH lpString1, int cchCount1, LPCWCH lpString2, int cchCount2, BOOL bIgnoreCase);

#pragma endregion

#pragma region Desktop or OneCore Family

        __declspec(dllimport) int __stdcall CompareStringW(
        LCID Locale, DWORD dwCmpFlags, PCNZWCH lpString1, int cchCount1, PCNZWCH lpString2, int cchCount2);

        __declspec(dllimport) int __stdcall FoldStringW(DWORD dwMapFlags, LPCWCH lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);

#pragma endregion

#pragma region Application or OneCore Family

        __declspec(dllimport) BOOL
        __stdcall GetStringTypeExW(LCID Locale, DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType);

        __declspec(dllimport) BOOL __stdcall GetStringTypeW(DWORD dwInfoType, LPCWCH lpSrcStr, int cchSrc, LPWORD lpCharType);

        __declspec(dllimport)

        int __stdcall MultiByteToWideChar(UINT CodePage, DWORD dwFlags, LPCCH lpMultiByteStr, int cbMultiByte, LPWSTR lpWideCharStr, int cchWideChar);

        __declspec(dllimport)

        int __stdcall WideCharToMultiByte(UINT CodePage,
                                          DWORD dwFlags,
                                          LPCWCH lpWideCharStr,
                                          int cchWideChar,
                                          LPSTR lpMultiByteStr,
                                          int cbMultiByte,
                                          LPCCH lpDefaultChar,
                                          LPBOOL lpUsedDefaultChar);

#pragma endregion
    }

    __declspec(dllimport) BOOL __stdcall IsValidCodePage(UINT CodePage);

    __declspec(dllimport) UINT __stdcall GetACP(void);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) UINT __stdcall GetOEMCP(void);

#pragma endregion

#pragma region Desktop or Pc Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall GetCPInfo(UINT CodePage, LPCPINFO lpCPInfo);

    __declspec(dllimport) BOOL __stdcall GetCPInfoExA(UINT CodePage, DWORD dwFlags, LPCPINFOEXA lpCPInfoEx);

    __declspec(dllimport) BOOL __stdcall GetCPInfoExW(UINT CodePage, DWORD dwFlags, LPCPINFOEXW lpCPInfoEx);

#pragma endregion

#pragma region Desktop or OneCore Family

    __declspec(dllimport) int __stdcall CompareStringA(LCID Locale, DWORD dwCmpFlags, PCNZCH lpString1, int cchCount1, PCNZCH lpString2, int cchCount2);

    __inline int CompareString(LCID Locale, DWORD dwCmpFlags, LPCTSTR lpString1, int cchCount1, LPCTSTR lpString2, int cchCount2)
    {
        return CompareStringA(Locale, dwCmpFlags, lpString1, cchCount1, lpString2, cchCount2);
    }

    __declspec(dllimport) int __stdcall FindNLSString(
    LCID Locale, DWORD dwFindNLSStringFlags, LPCWSTR lpStringSource, int cchSource, LPCWSTR lpStringValue, int cchValue, LPINT pcchFound);

    __declspec(dllimport) int __stdcall LCMapStringW(LCID Locale, DWORD dwMapFlags, LPCWSTR lpSrcStr, int cchSrc, LPWSTR lpDestStr, int cchDest);

    __declspec(dllimport) int __stdcall LCMapStringA(LCID Locale, DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) int __stdcall GetLocaleInfoW(LCID Locale, LCTYPE LCType, LPWSTR lpLCData, int cchData);

    __declspec(dllimport) int __stdcall GetLocaleInfoA(LCID Locale, LCTYPE LCType, LPSTR lpLCData, int cchData);

#pragma endregion

#pragma region Desktop or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetLocaleInfoA(LCID Locale, LCTYPE LCType, LPCSTR lpLCData);
    __declspec(dllimport) BOOL __stdcall SetLocaleInfoW(LCID Locale, LCTYPE LCType, LPCWSTR lpLCData);

    __declspec(dllimport) int __stdcall GetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPSTR lpCalData, int cchData, LPDWORD lpValue);

    __declspec(dllimport) int __stdcall GetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue);

    __declspec(dllimport) BOOL __stdcall SetCalendarInfoA(LCID Locale, CALID Calendar, CALTYPE CalType, LPCSTR lpCalData);
    __declspec(dllimport) BOOL __stdcall SetCalendarInfoW(LCID Locale, CALID Calendar, CALTYPE CalType, LPCWSTR lpCalData);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall LoadStringByReference(
    DWORD Flags, PCWSTR Language, PCWSTR SourceString, PWSTR Buffer, ULONG cchBuffer, PCWSTR Directory, PULONG pcchBufferOut);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall IsDBCSLeadByte(BYTE TestChar);

    __declspec(dllimport) BOOL __stdcall IsDBCSLeadByteEx(UINT CodePage, BYTE TestChar);

    __declspec(dllimport) int __stdcall LCIDToLocaleName(LCID Locale, LPWSTR lpName, int cchName, DWORD dwFlags);

    __declspec(dllimport) LCID __stdcall LocaleNameToLCID(LPCWSTR lpName, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) int __stdcall GetDurationFormat(
    LCID Locale, DWORD dwFlags, const SYSTEMTIME* lpDuration, ULONGLONG ullDuration, LPCWSTR lpFormat, LPWSTR lpDurationStr, int cchDuration);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) int __stdcall GetNumberFormatA(
    LCID Locale, DWORD dwFlags, LPCSTR lpValue, const NUMBERFMTA* lpFormat, LPSTR lpNumberStr, int cchNumber);

    __declspec(dllimport) int __stdcall GetNumberFormatW(
    LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW* lpFormat, LPWSTR lpNumberStr, int cchNumber);

    __declspec(dllimport) int __stdcall GetCurrencyFormatA(
    LCID Locale, DWORD dwFlags, LPCSTR lpValue, const CURRENCYFMTA* lpFormat, LPSTR lpCurrencyStr, int cchCurrency);

    __declspec(dllimport) int __stdcall GetCurrencyFormatW(
    LCID Locale, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW* lpFormat, LPWSTR lpCurrencyStr, int cchCurrency);

    __declspec(dllimport) BOOL
    __stdcall EnumCalendarInfoA(CALINFO_ENUMPROCA lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType);

    __declspec(dllimport) BOOL
    __stdcall EnumCalendarInfoW(CALINFO_ENUMPROCW lpCalInfoEnumProc, LCID Locale, CALID Calendar, CALTYPE CalType);

    __declspec(dllimport) BOOL
    __stdcall EnumCalendarInfoExA(CALINFO_ENUMPROCEXA lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType);

    __declspec(dllimport) BOOL
    __stdcall EnumCalendarInfoExW(CALINFO_ENUMPROCEXW lpCalInfoEnumProcEx, LCID Locale, CALID Calendar, CALTYPE CalType);

    __declspec(dllimport) BOOL __stdcall EnumTimeFormatsA(TIMEFMT_ENUMPROCA lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall EnumTimeFormatsW(TIMEFMT_ENUMPROCW lpTimeFmtEnumProc, LCID Locale, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall EnumDateFormatsA(DATEFMT_ENUMPROCA lpDateFmtEnumProc, LCID Locale, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall EnumDateFormatsW(DATEFMT_ENUMPROCW lpDateFmtEnumProc, LCID Locale, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall EnumDateFormatsExA(DATEFMT_ENUMPROCEXA lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall EnumDateFormatsExW(DATEFMT_ENUMPROCEXW lpDateFmtEnumProcEx, LCID Locale, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall IsValidLanguageGroup(LGRPID LanguageGroup, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall GetNLSVersion(NLS_FUNCTION Function, LCID Locale, LPNLSVERSIONINFO lpVersionInformation);

    __declspec(dllimport) BOOL __stdcall IsValidLocale(LCID Locale, DWORD dwFlags);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) int __stdcall GetGeoInfoA(GEOID Location, GEOTYPE GeoType, LPSTR lpGeoData, int cchData, LANGID LangId);

    __declspec(dllimport) int __stdcall GetGeoInfoW(GEOID Location, GEOTYPE GeoType, LPWSTR lpGeoData, int cchData, LANGID LangId);

    __declspec(dllimport) int __stdcall GetGeoInfoEx(PWSTR location, GEOTYPE geoType, PWSTR geoData, int geoDataCount);

#pragma endregion

#pragma region Desktop or PC Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall EnumSystemGeoID(GEOCLASS GeoClass, GEOID ParentGeoId, GEO_ENUMPROC lpGeoEnumProc);

    __declspec(dllimport) BOOL __stdcall EnumSystemGeoNames(GEOCLASS geoClass, GEO_ENUMNAMEPROC geoEnumProc, LPARAM data);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) GEOID __stdcall GetUserGeoID(GEOCLASS GeoClass);

    __declspec(dllimport) int __stdcall GetUserDefaultGeoName(LPWSTR geoName, int geoNameCount);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall SetUserGeoID(GEOID GeoId);

    __declspec(dllimport) BOOL __stdcall SetUserGeoName(PWSTR geoName);

    __declspec(dllimport) LCID __stdcall ConvertDefaultLocale(LCID Locale);

    __declspec(dllimport) LCID __stdcall GetThreadLocale(void);

    __declspec(dllimport) BOOL __stdcall SetThreadLocale(LCID Locale);

    __declspec(dllimport) LANGID __stdcall GetSystemDefaultUILanguage(void);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) LANGID __stdcall GetUserDefaultUILanguage(void);

    __declspec(dllimport) LANGID __stdcall GetUserDefaultLangID(void);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) LANGID __stdcall GetSystemDefaultLangID(void);

    __declspec(dllimport) LCID __stdcall GetSystemDefaultLCID(void);

    __declspec(dllimport) LCID __stdcall GetUserDefaultLCID(void);

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) LANGID __stdcall SetThreadUILanguage(LANGID LangId);

    __declspec(dllimport) LANGID __stdcall GetThreadUILanguage(void);

    __declspec(dllimport) BOOL
    __stdcall GetProcessPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);

    __declspec(dllimport) BOOL
    __stdcall SetProcessPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages);

#pragma endregion

#pragma region Desktop Family or Phone Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetUserPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetSystemPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);

    __declspec(dllimport) BOOL
    __stdcall GetThreadPreferredUILanguages(DWORD dwFlags, PULONG pulNumLanguages, PZZWSTR pwszLanguagesBuffer, PULONG pcchLanguagesBuffer);

    __declspec(dllimport) BOOL
    __stdcall SetThreadPreferredUILanguages(DWORD dwFlags, PCZZWSTR pwszLanguagesBuffer, PULONG pulNumLanguages);

    __declspec(dllimport)

    BOOL __stdcall GetFileMUIInfo(DWORD dwFlags, PCWSTR pcwszFilePath, PFILEMUIINFO pFileMUIInfo, DWORD* pcbFileMUIInfo);

    __declspec(dllimport) BOOL __stdcall GetFileMUIPath(DWORD dwFlags,
                                                        PCWSTR pcwszFilePath,
                                                        PWSTR pwszLanguage,
                                                        PULONG pcchLanguage,
                                                        PWSTR pwszFileMUIPath,
                                                        PULONG pcchFileMUIPath,
                                                        PULONGLONG pululEnumerator);

    __declspec(dllimport) BOOL __stdcall GetUILanguageInfo(
    DWORD dwFlags, PCZZWSTR pwmszLanguage, PZZWSTR pwszFallbackLanguages, PDWORD pcchFallbackLanguages, PDWORD pAttributes);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL
    __stdcall NotifyUILanguageChange(DWORD dwFlags, PCWSTR pcwstrNewLanguage, PCWSTR pcwstrPreviousLanguage, DWORD dwReserved, PDWORD pdwStatusRtrn);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetStringTypeExA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall GetStringTypeA(LCID Locale, DWORD dwInfoType, LPCSTR lpSrcStr, int cchSrc, LPWORD lpCharType);

    __declspec(dllimport) int __stdcall FoldStringA(DWORD dwMapFlags, LPCSTR lpSrcStr, int cchSrc, LPSTR lpDestStr, int cchDest);

    __declspec(dllimport) BOOL __stdcall EnumSystemLocalesA(LOCALE_ENUMPROCA lpLocaleEnumProc, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall EnumSystemLocalesW(LOCALE_ENUMPROCW lpLocaleEnumProc, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall EnumSystemLanguageGroupsA(LANGUAGEGROUP_ENUMPROCA lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam);

    __declspec(dllimport) BOOL
    __stdcall EnumSystemLanguageGroupsW(LANGUAGEGROUP_ENUMPROCW lpLanguageGroupEnumProc, DWORD dwFlags, LONG_PTR lParam);

    __declspec(dllimport) BOOL __stdcall EnumLanguageGroupLocalesA(LANGGROUPLOCALE_ENUMPROCA lpLangGroupLocaleEnumProc,
                                                                   LGRPID LanguageGroup,
                                                                   DWORD dwFlags,
                                                                   LONG_PTR lParam);

    __declspec(dllimport) BOOL __stdcall EnumLanguageGroupLocalesW(LANGGROUPLOCALE_ENUMPROCW lpLangGroupLocaleEnumProc,
                                                                   LGRPID LanguageGroup,
                                                                   DWORD dwFlags,
                                                                   LONG_PTR lParam);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall EnumUILanguagesA(UILANGUAGE_ENUMPROCA lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam);

    __declspec(dllimport) BOOL
    __stdcall EnumUILanguagesW(UILANGUAGE_ENUMPROCW lpUILanguageEnumProc, DWORD dwFlags, LONG_PTR lParam);

#pragma endregion

#pragma region Desktop or PC Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall EnumSystemCodePagesA(CODEPAGE_ENUMPROCA lpCodePageEnumProc, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall EnumSystemCodePagesW(CODEPAGE_ENUMPROCW lpCodePageEnumProc, DWORD dwFlags);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) int __stdcall NormalizeString(NORM_FORM NormForm, LPCWSTR lpSrcString, int cwSrcLength, LPWSTR lpDstString, int cwDstLength);

    __declspec(dllimport) BOOL __stdcall IsNormalizedString(NORM_FORM NormForm, LPCWSTR lpString, int cwLength);

    __declspec(dllimport) int __stdcall IdnToAscii(DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpASCIICharStr, int cchASCIIChar);

    __declspec(dllimport) int __stdcall IdnToNameprepUnicode(
    DWORD dwFlags, LPCWSTR lpUnicodeCharStr, int cchUnicodeChar, LPWSTR lpNameprepCharStr, int cchNameprepChar);

    __declspec(dllimport) int __stdcall IdnToUnicode(DWORD dwFlags, LPCWSTR lpASCIICharStr, int cchASCIIChar, LPWSTR lpUnicodeCharStr, int cchUnicodeChar);

    __declspec(dllimport) BOOL
    __stdcall VerifyScripts(DWORD dwFlags, LPCWSTR lpLocaleScripts, int cchLocaleScripts, LPCWSTR lpTestScripts, int cchTestScripts);

    __declspec(dllimport) int __stdcall GetStringScripts(DWORD dwFlags, LPCWSTR lpString, int cchString, LPWSTR lpScripts, int cchScripts);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) int __stdcall GetLocaleInfoEx(LPCWSTR lpLocaleName, LCTYPE LCType, LPWSTR lpLCData, int cchData);

#pragma endregion

#pragma region Desktop or PC Family or OneCore Family

    __declspec(dllimport) int __stdcall GetCalendarInfoEx(
    LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPWSTR lpCalData, int cchData, LPDWORD lpValue);

#pragma endregion

#pragma region Application Family

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) int __stdcall GetNumberFormatEx(
    LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const NUMBERFMTW* lpFormat, LPWSTR lpNumberStr, int cchNumber);

    __declspec(dllimport) int __stdcall GetCurrencyFormatEx(
    LPCWSTR lpLocaleName, DWORD dwFlags, LPCWSTR lpValue, const CURRENCYFMTW* lpFormat, LPWSTR lpCurrencyStr, int cchCurrency);

    __declspec(dllimport) int __stdcall GetUserDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName);

#pragma endregion

#pragma region Desktop or PC Family or OneCore Family

    __declspec(dllimport) int __stdcall GetSystemDefaultLocaleName(LPWSTR lpLocaleName, int cchLocaleName);

    __declspec(dllimport) BOOL
    __stdcall IsNLSDefinedString(NLS_FUNCTION Function, DWORD dwFlags, LPNLSVERSIONINFO lpVersionInformation, LPCWSTR lpString, INT cchStr);

    __declspec(dllimport) BOOL
    __stdcall GetNLSVersionEx(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation);

    __declspec(dllimport) DWORD
    __stdcall IsValidNLSVersion(NLS_FUNCTION function, LPCWSTR lpLocaleName, LPNLSVERSIONINFOEX lpVersionInformation);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) int __stdcall FindNLSStringEx(LPCWSTR lpLocaleName,
                                                        DWORD dwFindNLSStringFlags,
                                                        LPCWSTR lpStringSource,
                                                        int cchSource,
                                                        LPCWSTR lpStringValue,
                                                        int cchValue,
                                                        LPINT pcchFound,
                                                        LPNLSVERSIONINFO lpVersionInformation,
                                                        LPVOID lpReserved,
                                                        LPARAM sortHandle);

    __declspec(dllimport) int __stdcall LCMapStringEx(LPCWSTR lpLocaleName,
                                                      DWORD dwMapFlags,
                                                      LPCWSTR lpSrcStr,
                                                      int cchSrc,
                                                      LPWSTR lpDestStr,
                                                      int cchDest,
                                                      LPNLSVERSIONINFO lpVersionInformation,
                                                      LPVOID lpReserved,
                                                      LPARAM sortHandle);

    __declspec(dllimport) BOOL __stdcall IsValidLocaleName(LPCWSTR lpLocaleName);
#pragma endregion

#pragma region Desktop or PC Family or OneCore Family

    typedef BOOL(__stdcall* CALINFO_ENUMPROCEXEX)(LPWSTR, CALID, LPWSTR, LPARAM);

    __declspec(dllimport) BOOL __stdcall EnumCalendarInfoExEx(
    CALINFO_ENUMPROCEXEX pCalInfoEnumProcExEx, LPCWSTR lpLocaleName, CALID Calendar, LPCWSTR lpReserved, CALTYPE CalType, LPARAM lParam);

    typedef BOOL(__stdcall* DATEFMT_ENUMPROCEXEX)(LPWSTR, CALID, LPARAM);

    __declspec(dllimport) BOOL
    __stdcall EnumDateFormatsExEx(DATEFMT_ENUMPROCEXEX lpDateFmtEnumProcExEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam);

    typedef BOOL(__stdcall* TIMEFMT_ENUMPROCEX)(LPWSTR, LPARAM);

    __declspec(dllimport) BOOL
    __stdcall EnumTimeFormatsEx(TIMEFMT_ENUMPROCEX lpTimeFmtEnumProcEx, LPCWSTR lpLocaleName, DWORD dwFlags, LPARAM lParam);

    typedef BOOL(__stdcall* LOCALE_ENUMPROCEX)(LPWSTR, DWORD, LPARAM);

    __declspec(dllimport) BOOL
    __stdcall EnumSystemLocalesEx(LOCALE_ENUMPROCEX lpLocaleEnumProcEx, DWORD dwFlags, LPARAM lParam, LPVOID lpReserved);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) int __stdcall ResolveLocaleName(LPCWSTR lpNameToResolve, LPWSTR lpLocaleName, int cchLocaleName);

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma warning(pop)
}

#pragma once

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

#pragma once

    extern "C"
    {
#pragma region Application Family

        typedef struct _COORD
        {
            SHORT X;
            SHORT Y;
        } COORD, *PCOORD;

        typedef struct _SMALL_RECT
        {
            SHORT Left;
            SHORT Top;
            SHORT Right;
            SHORT Bottom;
        } SMALL_RECT, *PSMALL_RECT;

        typedef struct _KEY_EVENT_RECORD
        {
            BOOL bKeyDown;
            WORD wRepeatCount;
            WORD wVirtualKeyCode;
            WORD wVirtualScanCode;
            union
            {
                WCHAR UnicodeChar;
                CHAR AsciiChar;
            } uChar;
            DWORD dwControlKeyState;
        } KEY_EVENT_RECORD, *PKEY_EVENT_RECORD;

        typedef struct _MOUSE_EVENT_RECORD
        {
            COORD dwMousePosition;
            DWORD dwButtonState;
            DWORD dwControlKeyState;
            DWORD dwEventFlags;
        } MOUSE_EVENT_RECORD, *PMOUSE_EVENT_RECORD;

        typedef struct _WINDOW_BUFFER_SIZE_RECORD
        {
            COORD dwSize;
        } WINDOW_BUFFER_SIZE_RECORD, *PWINDOW_BUFFER_SIZE_RECORD;

        typedef struct _MENU_EVENT_RECORD
        {
            UINT dwCommandId;
        } MENU_EVENT_RECORD, *PMENU_EVENT_RECORD;

        typedef struct _FOCUS_EVENT_RECORD
        {
            BOOL bSetFocus;
        } FOCUS_EVENT_RECORD, *PFOCUS_EVENT_RECORD;

        typedef struct _INPUT_RECORD
        {
            WORD EventType;
            union
            {
                KEY_EVENT_RECORD KeyEvent;
                MOUSE_EVENT_RECORD MouseEvent;
                WINDOW_BUFFER_SIZE_RECORD WindowBufferSizeEvent;
                MENU_EVENT_RECORD MenuEvent;
                FOCUS_EVENT_RECORD FocusEvent;
            } Event;
        } INPUT_RECORD, *PINPUT_RECORD;

        typedef struct _CHAR_INFO
        {
            union
            {
                WCHAR UnicodeChar;
                CHAR AsciiChar;
            } Char;
            WORD Attributes;
        } CHAR_INFO, *PCHAR_INFO;

        typedef struct _CONSOLE_FONT_INFO
        {
            DWORD nFont;
            COORD dwFontSize;
        } CONSOLE_FONT_INFO, *PCONSOLE_FONT_INFO;

        typedef void* HPCON;

#pragma endregion
    }

#pragma once

    extern "C"
    {
#pragma region Application Family or OneCore Family

        __declspec(dllimport) BOOL __stdcall AllocConsole(void);

        __declspec(dllimport) BOOL __stdcall FreeConsole(void);

        __declspec(dllimport) BOOL __stdcall AttachConsole(DWORD dwProcessId);

        __declspec(dllimport) UINT __stdcall GetConsoleCP(void);

        __declspec(dllimport) UINT __stdcall GetConsoleOutputCP(void);

        __declspec(dllimport) BOOL __stdcall GetConsoleMode(HANDLE hConsoleHandle, LPDWORD lpMode);

        __declspec(dllimport) BOOL __stdcall SetConsoleMode(HANDLE hConsoleHandle, DWORD dwMode);

        __declspec(dllimport) BOOL __stdcall GetNumberOfConsoleInputEvents(HANDLE hConsoleInput, LPDWORD lpNumberOfEvents);

        __declspec(dllimport)

        BOOL __stdcall ReadConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);

        __declspec(dllimport)

        BOOL __stdcall ReadConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);

        __declspec(dllimport) BOOL
        __stdcall PeekConsoleInputA(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);

        __declspec(dllimport) BOOL
        __stdcall PeekConsoleInputW(HANDLE hConsoleInput, PINPUT_RECORD lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsRead);

        typedef struct _CONSOLE_READCONSOLE_CONTROL
        {
            ULONG nLength;
            ULONG nInitialChars;
            ULONG dwCtrlWakeupMask;
            ULONG dwControlKeyState;
        } CONSOLE_READCONSOLE_CONTROL, *PCONSOLE_READCONSOLE_CONTROL;

        __declspec(dllimport)

        BOOL __stdcall ReadConsoleA(HANDLE hConsoleInput,
                                    LPVOID lpBuffer,
                                    DWORD nNumberOfCharsToRead,
                                    LPDWORD lpNumberOfCharsRead,
                                    PCONSOLE_READCONSOLE_CONTROL pInputControl);

        __declspec(dllimport)

        BOOL __stdcall ReadConsoleW(HANDLE hConsoleInput,
                                    LPVOID lpBuffer,
                                    DWORD nNumberOfCharsToRead,
                                    LPDWORD lpNumberOfCharsRead,
                                    PCONSOLE_READCONSOLE_CONTROL pInputControl);

        __declspec(dllimport) BOOL __stdcall WriteConsoleA(HANDLE hConsoleOutput,
                                                           const void* lpBuffer,
                                                           DWORD nNumberOfCharsToWrite,
                                                           LPDWORD lpNumberOfCharsWritten,
                                                           LPVOID lpReserved);

        __declspec(dllimport) BOOL __stdcall WriteConsoleW(HANDLE hConsoleOutput,
                                                           const void* lpBuffer,
                                                           DWORD nNumberOfCharsToWrite,
                                                           LPDWORD lpNumberOfCharsWritten,
                                                           LPVOID lpReserved);

        typedef BOOL(__stdcall* PHANDLER_ROUTINE)(DWORD CtrlType);

        __declspec(dllimport) BOOL __stdcall SetConsoleCtrlHandler(PHANDLER_ROUTINE HandlerRoutine, BOOL Add);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport) HRESULT
        __stdcall CreatePseudoConsole(COORD size, HANDLE hInput, HANDLE hOutput, DWORD dwFlags, HPCON* phPC);

        __declspec(dllimport) HRESULT __stdcall ResizePseudoConsole(HPCON hPC, COORD size);

        __declspec(dllimport) void __stdcall ClosePseudoConsole(HPCON hPC);

#pragma endregion
    }

#pragma once

    extern "C"
    {
#pragma region Application Family or OneCore Family

        __declspec(dllimport) BOOL
        __stdcall FillConsoleOutputCharacterA(HANDLE hConsoleOutput, CHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);

        __declspec(dllimport) BOOL
        __stdcall FillConsoleOutputCharacterW(HANDLE hConsoleOutput, WCHAR cCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);

        __declspec(dllimport) BOOL
        __stdcall FillConsoleOutputAttribute(HANDLE hConsoleOutput, WORD wAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);

        __declspec(dllimport) BOOL __stdcall GenerateConsoleCtrlEvent(DWORD dwCtrlEvent, DWORD dwProcessGroupId);

        __declspec(dllimport) HANDLE __stdcall CreateConsoleScreenBuffer(DWORD dwDesiredAccess,
                                                                         DWORD dwShareMode,
                                                                         const SECURITY_ATTRIBUTES* lpSecurityAttributes,
                                                                         DWORD dwFlags,
                                                                         LPVOID lpScreenBufferData);

        __declspec(dllimport) BOOL __stdcall SetConsoleActiveScreenBuffer(HANDLE hConsoleOutput);

        __declspec(dllimport) BOOL __stdcall FlushConsoleInputBuffer(HANDLE hConsoleInput);

        __declspec(dllimport) BOOL __stdcall SetConsoleCP(UINT wCodePageID);

        __declspec(dllimport) BOOL __stdcall SetConsoleOutputCP(UINT wCodePageID);

        typedef struct _CONSOLE_CURSOR_INFO
        {
            DWORD dwSize;
            BOOL bVisible;
        } CONSOLE_CURSOR_INFO, *PCONSOLE_CURSOR_INFO;

        __declspec(dllimport) BOOL __stdcall GetConsoleCursorInfo(HANDLE hConsoleOutput, PCONSOLE_CURSOR_INFO lpConsoleCursorInfo);

        __declspec(dllimport) BOOL
        __stdcall SetConsoleCursorInfo(HANDLE hConsoleOutput, const CONSOLE_CURSOR_INFO* lpConsoleCursorInfo);

        typedef struct _CONSOLE_SCREEN_BUFFER_INFO
        {
            COORD dwSize;
            COORD dwCursorPosition;
            WORD wAttributes;
            SMALL_RECT srWindow;
            COORD dwMaximumWindowSize;
        } CONSOLE_SCREEN_BUFFER_INFO, *PCONSOLE_SCREEN_BUFFER_INFO;

        __declspec(dllimport) BOOL
        __stdcall GetConsoleScreenBufferInfo(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFO lpConsoleScreenBufferInfo);

        typedef struct _CONSOLE_SCREEN_BUFFER_INFOEX
        {
            ULONG cbSize;
            COORD dwSize;
            COORD dwCursorPosition;
            WORD wAttributes;
            SMALL_RECT srWindow;
            COORD dwMaximumWindowSize;
            WORD wPopupAttributes;
            BOOL bFullscreenSupported;
            COLORREF ColorTable[16];
        } CONSOLE_SCREEN_BUFFER_INFOEX, *PCONSOLE_SCREEN_BUFFER_INFOEX;

        __declspec(dllimport) BOOL
        __stdcall GetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);

        __declspec(dllimport) BOOL
        __stdcall SetConsoleScreenBufferInfoEx(HANDLE hConsoleOutput, PCONSOLE_SCREEN_BUFFER_INFOEX lpConsoleScreenBufferInfoEx);

        __declspec(dllimport) BOOL __stdcall SetConsoleScreenBufferSize(HANDLE hConsoleOutput, COORD dwSize);

        __declspec(dllimport) BOOL __stdcall SetConsoleCursorPosition(HANDLE hConsoleOutput, COORD dwCursorPosition);

        __declspec(dllimport) COORD __stdcall GetLargestConsoleWindowSize(HANDLE hConsoleOutput);

        __declspec(dllimport) BOOL __stdcall SetConsoleTextAttribute(HANDLE hConsoleOutput, WORD wAttributes);

        __declspec(dllimport) BOOL
        __stdcall SetConsoleWindowInfo(HANDLE hConsoleOutput, BOOL bAbsolute, const SMALL_RECT* lpConsoleWindow);

        __declspec(dllimport) BOOL __stdcall WriteConsoleOutputCharacterA(
        HANDLE hConsoleOutput, LPCSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);

        __declspec(dllimport) BOOL __stdcall WriteConsoleOutputCharacterW(
        HANDLE hConsoleOutput, LPCWSTR lpCharacter, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfCharsWritten);

        __declspec(dllimport) BOOL __stdcall WriteConsoleOutputAttribute(
        HANDLE hConsoleOutput, const WORD* lpAttribute, DWORD nLength, COORD dwWriteCoord, LPDWORD lpNumberOfAttrsWritten);

        __declspec(dllimport) BOOL
        __stdcall ReadConsoleOutputCharacterA(HANDLE hConsoleOutput, LPSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);

        __declspec(dllimport) BOOL
        __stdcall ReadConsoleOutputCharacterW(HANDLE hConsoleOutput, LPWSTR lpCharacter, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfCharsRead);

        __declspec(dllimport) BOOL
        __stdcall ReadConsoleOutputAttribute(HANDLE hConsoleOutput, LPWORD lpAttribute, DWORD nLength, COORD dwReadCoord, LPDWORD lpNumberOfAttrsRead);

        __declspec(dllimport) BOOL
        __stdcall WriteConsoleInputA(HANDLE hConsoleInput, const INPUT_RECORD* lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);

        __declspec(dllimport) BOOL
        __stdcall WriteConsoleInputW(HANDLE hConsoleInput, const INPUT_RECORD* lpBuffer, DWORD nLength, LPDWORD lpNumberOfEventsWritten);

        __declspec(dllimport) BOOL __stdcall ScrollConsoleScreenBufferA(HANDLE hConsoleOutput,
                                                                        const SMALL_RECT* lpScrollRectangle,
                                                                        const SMALL_RECT* lpClipRectangle,
                                                                        COORD dwDestinationOrigin,
                                                                        const CHAR_INFO* lpFill);

        __declspec(dllimport) BOOL __stdcall ScrollConsoleScreenBufferW(HANDLE hConsoleOutput,
                                                                        const SMALL_RECT* lpScrollRectangle,
                                                                        const SMALL_RECT* lpClipRectangle,
                                                                        COORD dwDestinationOrigin,
                                                                        const CHAR_INFO* lpFill);

        __declspec(dllimport) BOOL __stdcall WriteConsoleOutputA(
        HANDLE hConsoleOutput, const CHAR_INFO* lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion);

        __declspec(dllimport) BOOL __stdcall WriteConsoleOutputW(
        HANDLE hConsoleOutput, const CHAR_INFO* lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpWriteRegion);

        __declspec(dllimport) BOOL
        __stdcall ReadConsoleOutputA(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion);

        __declspec(dllimport) BOOL
        __stdcall ReadConsoleOutputW(HANDLE hConsoleOutput, PCHAR_INFO lpBuffer, COORD dwBufferSize, COORD dwBufferCoord, PSMALL_RECT lpReadRegion);

        __declspec(dllimport) DWORD __stdcall GetConsoleTitleA(LPSTR lpConsoleTitle, DWORD nSize);

        __declspec(dllimport) DWORD __stdcall GetConsoleTitleW(LPWSTR lpConsoleTitle, DWORD nSize);

        __declspec(dllimport) DWORD __stdcall GetConsoleOriginalTitleA(LPSTR lpConsoleTitle, DWORD nSize);

        __declspec(dllimport) DWORD __stdcall GetConsoleOriginalTitleW(LPWSTR lpConsoleTitle, DWORD nSize);

        __declspec(dllimport) BOOL __stdcall SetConsoleTitleA(LPCSTR lpConsoleTitle);

        __declspec(dllimport) BOOL __stdcall SetConsoleTitleW(LPCWSTR lpConsoleTitle);

#pragma endregion
    }

#pragma once

    extern "C"
    {
#pragma region Application Family or OneCore Family

        __declspec(dllimport) BOOL __stdcall GetNumberOfConsoleMouseButtons(LPDWORD lpNumberOfMouseButtons);

        __declspec(dllimport) COORD __stdcall GetConsoleFontSize(HANDLE hConsoleOutput, DWORD nFont);

        __declspec(dllimport) BOOL
        __stdcall GetCurrentConsoleFont(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFO lpConsoleCurrentFont);

        typedef struct _CONSOLE_FONT_INFOEX
        {
            ULONG cbSize;
            DWORD nFont;
            COORD dwFontSize;
            UINT FontFamily;
            UINT FontWeight;
            WCHAR FaceName[32];
        } CONSOLE_FONT_INFOEX, *PCONSOLE_FONT_INFOEX;

        __declspec(dllimport) BOOL
        __stdcall GetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);

        __declspec(dllimport) BOOL
        __stdcall SetCurrentConsoleFontEx(HANDLE hConsoleOutput, BOOL bMaximumWindow, PCONSOLE_FONT_INFOEX lpConsoleCurrentFontEx);

        typedef struct _CONSOLE_SELECTION_INFO
        {
            DWORD dwFlags;
            COORD dwSelectionAnchor;
            SMALL_RECT srSelection;
        } CONSOLE_SELECTION_INFO, *PCONSOLE_SELECTION_INFO;

        __declspec(dllimport) BOOL __stdcall GetConsoleSelectionInfo(PCONSOLE_SELECTION_INFO lpConsoleSelectionInfo);

        typedef struct _CONSOLE_HISTORY_INFO
        {
            UINT cbSize;
            UINT HistoryBufferSize;
            UINT NumberOfHistoryBuffers;
            DWORD dwFlags;
        } CONSOLE_HISTORY_INFO, *PCONSOLE_HISTORY_INFO;

        __declspec(dllimport) BOOL __stdcall GetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);

        __declspec(dllimport) BOOL __stdcall SetConsoleHistoryInfo(PCONSOLE_HISTORY_INFO lpConsoleHistoryInfo);

        __declspec(dllimport) BOOL __stdcall GetConsoleDisplayMode(LPDWORD lpModeFlags);

        __declspec(dllimport) BOOL
        __stdcall SetConsoleDisplayMode(HANDLE hConsoleOutput, DWORD dwFlags, PCOORD lpNewScreenBufferDimensions);

        __declspec(dllimport) HWND __stdcall GetConsoleWindow(void);

        __declspec(dllimport) BOOL __stdcall AddConsoleAliasA(LPSTR Source, LPSTR Target, LPSTR ExeName);

        __declspec(dllimport) BOOL __stdcall AddConsoleAliasW(LPWSTR Source, LPWSTR Target, LPWSTR ExeName);

        __declspec(dllimport) DWORD
        __stdcall GetConsoleAliasA(LPSTR Source, LPSTR TargetBuffer, DWORD TargetBufferLength, LPSTR ExeName);

        __declspec(dllimport) DWORD
        __stdcall GetConsoleAliasW(LPWSTR Source, LPWSTR TargetBuffer, DWORD TargetBufferLength, LPWSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleAliasesLengthA(LPSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleAliasesLengthW(LPWSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleAliasExesLengthA(void);

        __declspec(dllimport) DWORD __stdcall GetConsoleAliasExesLengthW(void);

        __declspec(dllimport) DWORD __stdcall GetConsoleAliasesA(LPSTR AliasBuffer, DWORD AliasBufferLength, LPSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleAliasesW(LPWSTR AliasBuffer, DWORD AliasBufferLength, LPWSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleAliasExesA(LPSTR ExeNameBuffer, DWORD ExeNameBufferLength);

        __declspec(dllimport) DWORD __stdcall GetConsoleAliasExesW(LPWSTR ExeNameBuffer, DWORD ExeNameBufferLength);

        __declspec(dllimport) void __stdcall ExpungeConsoleCommandHistoryA(LPSTR ExeName);

        __declspec(dllimport) void __stdcall ExpungeConsoleCommandHistoryW(LPWSTR ExeName);

        __declspec(dllimport) BOOL __stdcall SetConsoleNumberOfCommandsA(DWORD Number, LPSTR ExeName);

        __declspec(dllimport) BOOL __stdcall SetConsoleNumberOfCommandsW(DWORD Number, LPWSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleCommandHistoryLengthA(LPSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleCommandHistoryLengthW(LPWSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleCommandHistoryA(LPSTR Commands, DWORD CommandBufferLength, LPSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleCommandHistoryW(LPWSTR Commands, DWORD CommandBufferLength, LPWSTR ExeName);

        __declspec(dllimport) DWORD __stdcall GetConsoleProcessList(LPDWORD lpdwProcessList, DWORD dwProcessCount);

#pragma endregion
    }

#pragma warning(pop)
}

#pragma region Application Family or OneCore Family

#pragma endregion

#pragma region Desktop Family

extern "C"
{
    typedef struct tagVS_FIXEDFILEINFO
    {
        DWORD dwSignature;
        DWORD dwStrucVersion;
        DWORD dwFileVersionMS;
        DWORD dwFileVersionLS;
        DWORD dwProductVersionMS;
        DWORD dwProductVersionLS;
        DWORD dwFileFlagsMask;
        DWORD dwFileFlags;
        DWORD dwFileOS;
        DWORD dwFileType;
        DWORD dwFileSubtype;
        DWORD dwFileDateMS;
        DWORD dwFileDateLS;
    } VS_FIXEDFILEINFO;
}

#pragma endregion

extern "C"
{
#pragma region Desktop Family or OneCore Family

    DWORD
    __stdcall VerFindFileA(
    DWORD uFlags, LPCSTR szFileName, LPCSTR szWinDir, LPCSTR szAppDir, LPSTR szCurDir, PUINT puCurDirLen, LPSTR szDestDir, PUINT puDestDirLen);
    DWORD
    __stdcall VerFindFileW(
    DWORD uFlags, LPCWSTR szFileName, LPCWSTR szWinDir, LPCWSTR szAppDir, LPWSTR szCurDir, PUINT puCurDirLen, LPWSTR szDestDir, PUINT puDestDirLen);

#pragma endregion

#pragma region Desktop Family

    DWORD
    __stdcall VerInstallFileA(
    DWORD uFlags, LPCSTR szSrcFileName, LPCSTR szDestFileName, LPCSTR szSrcDir, LPCSTR szDestDir, LPCSTR szCurDir, LPSTR szTmpFile, PUINT puTmpFileLen);
    DWORD
    __stdcall VerInstallFileW(DWORD uFlags,
                              LPCWSTR szSrcFileName,
                              LPCWSTR szDestFileName,
                              LPCWSTR szSrcDir,
                              LPCWSTR szDestDir,
                              LPCWSTR szCurDir,
                              LPWSTR szTmpFile,
                              PUINT puTmpFileLen);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    DWORD
    __stdcall GetFileVersionInfoSizeA(LPCSTR lptstrFilename, LPDWORD lpdwHandle);

    DWORD
    __stdcall GetFileVersionInfoSizeW(LPCWSTR lptstrFilename, LPDWORD lpdwHandle);

    BOOL __stdcall GetFileVersionInfoA(LPCSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);

    BOOL __stdcall GetFileVersionInfoW(LPCWSTR lptstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);

#pragma endregion

#pragma region Application or OneCore Family

    DWORD __stdcall GetFileVersionInfoSizeExA(DWORD dwFlags, LPCSTR lpwstrFilename, LPDWORD lpdwHandle);
    DWORD __stdcall GetFileVersionInfoSizeExW(DWORD dwFlags, LPCWSTR lpwstrFilename, LPDWORD lpdwHandle);

    BOOL __stdcall GetFileVersionInfoExA(DWORD dwFlags, LPCSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);
    BOOL __stdcall GetFileVersionInfoExW(DWORD dwFlags, LPCWSTR lpwstrFilename, DWORD dwHandle, DWORD dwLen, LPVOID lpData);

#pragma endregion

#pragma region Desktop Family

#pragma endregion

#pragma region Application Family or OneCore Family

    DWORD
    __stdcall VerLanguageNameA(DWORD wLang, LPSTR szLang, DWORD cchLang);
    DWORD
    __stdcall VerLanguageNameW(DWORD wLang, LPWSTR szLang, DWORD cchLang);

    BOOL __stdcall VerQueryValueA(LPCVOID pBlock, LPCSTR lpSubBlock, LPVOID* lplpBuffer, PUINT puLen);
    BOOL __stdcall VerQueryValueW(LPCVOID pBlock, LPCWSTR lpSubBlock, LPVOID* lplpBuffer, PUINT puLen);

#pragma endregion
}

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

#pragma region Application Family or Desktop Family or OneCore Family

    typedef LONG LSTATUS;

    typedef ACCESS_MASK REGSAM;

    struct val_context
    {
        int valuelen;
        LPVOID value_context;
        LPVOID val_buff_ptr;
    };

    typedef struct val_context* PVALCONTEXT;

    typedef struct pvalueA
    {
        LPSTR pv_valuename;
        int pv_valuelen;
        LPVOID pv_value_context;
        DWORD pv_type;
    } PVALUEA, *PPVALUEA;
    typedef struct pvalueW
    {
        LPWSTR pv_valuename;
        int pv_valuelen;
        LPVOID pv_value_context;
        DWORD pv_type;
    } PVALUEW, *PPVALUEW;

    typedef PVALUEA PVALUE;
    typedef PPVALUEA PPVALUE;

    typedef DWORD __cdecl QUERYHANDLER(
    LPVOID keycontext, PVALCONTEXT val_list, DWORD num_vals, LPVOID outputbuffer, DWORD* total_outlen, DWORD input_blen);

    typedef QUERYHANDLER* PQUERYHANDLER;

    typedef struct provider_info
    {
        PQUERYHANDLER pi_R0_1val;
        PQUERYHANDLER pi_R0_allvals;
        PQUERYHANDLER pi_R3_1val;
        PQUERYHANDLER pi_R3_allvals;
        DWORD pi_flags;
        LPVOID pi_key_context;
    } REG_PROVIDER;

    typedef struct provider_info* PPROVIDER;

    typedef struct value_entA
    {
        LPSTR ve_valuename;
        DWORD ve_valuelen;
        DWORD_PTR ve_valueptr;
        DWORD ve_type;
    } VALENTA, *PVALENTA;
    typedef struct value_entW
    {
        LPWSTR ve_valuename;
        DWORD ve_valuelen;
        DWORD_PTR ve_valueptr;
        DWORD ve_type;
    } VALENTW, *PVALENTW;

    typedef VALENTA VALENT;
    typedef PVALENTA PVALENT;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) LSTATUS __stdcall RegCloseKey(HKEY hKey);

    __declspec(dllimport) LSTATUS __stdcall RegOverridePredefKey(HKEY hKey, HKEY hNewHKey);

    __declspec(dllimport) LSTATUS
    __stdcall RegOpenUserClassesRoot(HANDLE hToken, DWORD dwOptions, REGSAM samDesired, PHKEY phkResult);

    __declspec(dllimport) LSTATUS __stdcall RegOpenCurrentUser(REGSAM samDesired, PHKEY phkResult);

    __declspec(dllimport) LSTATUS __stdcall RegDisablePredefinedCache(void);

    __declspec(dllimport) LSTATUS __stdcall RegDisablePredefinedCacheEx(void);

    __declspec(dllimport) LSTATUS __stdcall RegConnectRegistryA(LPCSTR lpMachineName, HKEY hKey, PHKEY phkResult);
    __declspec(dllimport) LSTATUS __stdcall RegConnectRegistryW(LPCWSTR lpMachineName, HKEY hKey, PHKEY phkResult);

    __declspec(dllimport) LSTATUS __stdcall RegConnectRegistryExA(LPCSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult);
    __declspec(dllimport) LSTATUS __stdcall RegConnectRegistryExW(LPCWSTR lpMachineName, HKEY hKey, ULONG Flags, PHKEY phkResult);

    __declspec(dllimport) LSTATUS __stdcall RegCreateKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
    __declspec(dllimport) LSTATUS __stdcall RegCreateKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);

    __declspec(dllimport) LSTATUS __stdcall RegCreateKeyExA(HKEY hKey,
                                                            LPCSTR lpSubKey,
                                                            DWORD Reserved,
                                                            LPSTR lpClass,
                                                            DWORD dwOptions,
                                                            REGSAM samDesired,
                                                            const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                            PHKEY phkResult,
                                                            LPDWORD lpdwDisposition);

    __declspec(dllimport) LSTATUS __stdcall RegCreateKeyExW(HKEY hKey,
                                                            LPCWSTR lpSubKey,
                                                            DWORD Reserved,
                                                            LPWSTR lpClass,
                                                            DWORD dwOptions,
                                                            REGSAM samDesired,
                                                            const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                            PHKEY phkResult,
                                                            LPDWORD lpdwDisposition);

    __declspec(dllimport) LSTATUS __stdcall RegCreateKeyTransactedA(HKEY hKey,
                                                                    LPCSTR lpSubKey,
                                                                    DWORD Reserved,
                                                                    LPSTR lpClass,
                                                                    DWORD dwOptions,
                                                                    REGSAM samDesired,
                                                                    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                                    PHKEY phkResult,
                                                                    LPDWORD lpdwDisposition,
                                                                    HANDLE hTransaction,
                                                                    PVOID pExtendedParemeter);
    __declspec(dllimport) LSTATUS __stdcall RegCreateKeyTransactedW(HKEY hKey,
                                                                    LPCWSTR lpSubKey,
                                                                    DWORD Reserved,
                                                                    LPWSTR lpClass,
                                                                    DWORD dwOptions,
                                                                    REGSAM samDesired,
                                                                    const LPSECURITY_ATTRIBUTES lpSecurityAttributes,
                                                                    PHKEY phkResult,
                                                                    LPDWORD lpdwDisposition,
                                                                    HANDLE hTransaction,
                                                                    PVOID pExtendedParemeter);

    __declspec(dllimport) LSTATUS __stdcall RegDeleteKeyA(HKEY hKey, LPCSTR lpSubKey);
    __declspec(dllimport) LSTATUS __stdcall RegDeleteKeyW(HKEY hKey, LPCWSTR lpSubKey);

    __declspec(dllimport) LSTATUS __stdcall RegDeleteKeyExA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved);

    __declspec(dllimport) LSTATUS __stdcall RegDeleteKeyExW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved);

    __declspec(dllimport) LSTATUS
    __stdcall RegDeleteKeyTransactedA(HKEY hKey, LPCSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter);
    __declspec(dllimport) LSTATUS
    __stdcall RegDeleteKeyTransactedW(HKEY hKey, LPCWSTR lpSubKey, REGSAM samDesired, DWORD Reserved, HANDLE hTransaction, PVOID pExtendedParameter);

    __declspec(dllimport) LONG __stdcall RegDisableReflectionKey(HKEY hBase);

    __declspec(dllimport) LONG __stdcall RegEnableReflectionKey(HKEY hBase);

    __declspec(dllimport) LONG __stdcall RegQueryReflectionKey(HKEY hBase, BOOL* bIsReflectionDisabled);

    __declspec(dllimport) LSTATUS __stdcall RegDeleteValueA(HKEY hKey, LPCSTR lpValueName);

    __declspec(dllimport) LSTATUS __stdcall RegDeleteValueW(HKEY hKey, LPCWSTR lpValueName);

    __declspec(dllimport) LSTATUS __stdcall RegEnumKeyA(HKEY hKey, DWORD dwIndex, LPSTR lpName, DWORD cchName);
    __declspec(dllimport) LSTATUS __stdcall RegEnumKeyW(HKEY hKey, DWORD dwIndex, LPWSTR lpName, DWORD cchName);

    __declspec(dllimport) LSTATUS __stdcall RegEnumKeyExA(
    HKEY hKey, DWORD dwIndex, LPSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);

    __declspec(dllimport) LSTATUS __stdcall RegEnumKeyExW(
    HKEY hKey, DWORD dwIndex, LPWSTR lpName, LPDWORD lpcchName, LPDWORD lpReserved, LPWSTR lpClass, LPDWORD lpcchClass, PFILETIME lpftLastWriteTime);

    __declspec(dllimport) LSTATUS __stdcall RegEnumValueA(
    HKEY hKey, DWORD dwIndex, LPSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);

    __declspec(dllimport) LSTATUS __stdcall RegEnumValueW(
    HKEY hKey, DWORD dwIndex, LPWSTR lpValueName, LPDWORD lpcchValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);

    __declspec(dllimport) LSTATUS __stdcall RegFlushKey(HKEY hKey);

    __declspec(dllimport) LSTATUS __stdcall RegGetKeySecurity(HKEY hKey,
                                                              SECURITY_INFORMATION SecurityInformation,
                                                              PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                              LPDWORD lpcbSecurityDescriptor);

    __declspec(dllimport) LSTATUS __stdcall RegLoadKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpFile);

    __declspec(dllimport) LSTATUS __stdcall RegLoadKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpFile);

    __declspec(dllimport) LSTATUS
    __stdcall RegNotifyChangeKeyValue(HKEY hKey, BOOL bWatchSubtree, DWORD dwNotifyFilter, HANDLE hEvent, BOOL fAsynchronous);

    __declspec(dllimport) LSTATUS __stdcall RegOpenKeyA(HKEY hKey, LPCSTR lpSubKey, PHKEY phkResult);
    __declspec(dllimport) LSTATUS __stdcall RegOpenKeyW(HKEY hKey, LPCWSTR lpSubKey, PHKEY phkResult);

    __declspec(dllimport) LSTATUS
    __stdcall RegOpenKeyExA(HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);

    __declspec(dllimport) LSTATUS
    __stdcall RegOpenKeyExW(HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult);

    __declspec(dllimport) LSTATUS __stdcall RegOpenKeyTransactedA(
    HKEY hKey, LPCSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter);
    __declspec(dllimport) LSTATUS __stdcall RegOpenKeyTransactedW(
    HKEY hKey, LPCWSTR lpSubKey, DWORD ulOptions, REGSAM samDesired, PHKEY phkResult, HANDLE hTransaction, PVOID pExtendedParemeter);

    __declspec(dllimport) LSTATUS __stdcall RegQueryInfoKeyA(HKEY hKey,
                                                             LPSTR lpClass,
                                                             LPDWORD lpcchClass,
                                                             LPDWORD lpReserved,
                                                             LPDWORD lpcSubKeys,
                                                             LPDWORD lpcbMaxSubKeyLen,
                                                             LPDWORD lpcbMaxClassLen,
                                                             LPDWORD lpcValues,
                                                             LPDWORD lpcbMaxValueNameLen,
                                                             LPDWORD lpcbMaxValueLen,
                                                             LPDWORD lpcbSecurityDescriptor,
                                                             PFILETIME lpftLastWriteTime);

    __declspec(dllimport) LSTATUS __stdcall RegQueryInfoKeyW(HKEY hKey,
                                                             LPWSTR lpClass,
                                                             LPDWORD lpcchClass,
                                                             LPDWORD lpReserved,
                                                             LPDWORD lpcSubKeys,
                                                             LPDWORD lpcbMaxSubKeyLen,
                                                             LPDWORD lpcbMaxClassLen,
                                                             LPDWORD lpcValues,
                                                             LPDWORD lpcbMaxValueNameLen,
                                                             LPDWORD lpcbMaxValueLen,
                                                             LPDWORD lpcbSecurityDescriptor,
                                                             PFILETIME lpftLastWriteTime);

    __declspec(dllimport) LSTATUS __stdcall RegQueryValueA(HKEY hKey, LPCSTR lpSubKey, LPSTR lpData, PLONG lpcbData);
    __declspec(dllimport) LSTATUS __stdcall RegQueryValueW(HKEY hKey, LPCWSTR lpSubKey, LPWSTR lpData, PLONG lpcbData);

    __declspec(dllimport) LSTATUS
    __stdcall RegQueryMultipleValuesA(HKEY hKey, PVALENTA val_list, DWORD num_vals, LPSTR lpValueBuf, LPDWORD ldwTotsize);

    __declspec(dllimport) LSTATUS
    __stdcall RegQueryMultipleValuesW(HKEY hKey, PVALENTW val_list, DWORD num_vals, LPWSTR lpValueBuf, LPDWORD ldwTotsize);

    __declspec(dllimport) LSTATUS
    __stdcall RegQueryValueExA(HKEY hKey, LPCSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);

    __declspec(dllimport) LSTATUS
    __stdcall RegQueryValueExW(HKEY hKey, LPCWSTR lpValueName, LPDWORD lpReserved, LPDWORD lpType, LPBYTE lpData, LPDWORD lpcbData);

    __declspec(dllimport) LSTATUS __stdcall RegReplaceKeyA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpNewFile, LPCSTR lpOldFile);
    __declspec(dllimport) LSTATUS __stdcall RegReplaceKeyW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpNewFile, LPCWSTR lpOldFile);

    __declspec(dllimport) LSTATUS __stdcall RegRestoreKeyA(HKEY hKey, LPCSTR lpFile, DWORD dwFlags);

    __declspec(dllimport) LSTATUS __stdcall RegRestoreKeyW(HKEY hKey, LPCWSTR lpFile, DWORD dwFlags);

    __declspec(dllimport) LSTATUS __stdcall RegRenameKey(HKEY hKey, LPCWSTR lpSubKeyName, LPCWSTR lpNewKeyName);

    __declspec(dllimport) LSTATUS __stdcall RegSaveKeyA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes);
    __declspec(dllimport) LSTATUS __stdcall RegSaveKeyW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes);

    __declspec(dllimport) LSTATUS
    __stdcall RegSetKeySecurity(HKEY hKey, SECURITY_INFORMATION SecurityInformation, PSECURITY_DESCRIPTOR pSecurityDescriptor);

    __declspec(dllimport) LSTATUS __stdcall RegSetValueA(HKEY hKey, LPCSTR lpSubKey, DWORD dwType, LPCSTR lpData, DWORD cbData);
    __declspec(dllimport) LSTATUS __stdcall RegSetValueW(HKEY hKey, LPCWSTR lpSubKey, DWORD dwType, LPCWSTR lpData, DWORD cbData);

    __declspec(dllimport) LSTATUS
    __stdcall RegSetValueExA(HKEY hKey, LPCSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE* lpData, DWORD cbData);

    __declspec(dllimport) LSTATUS
    __stdcall RegSetValueExW(HKEY hKey, LPCWSTR lpValueName, DWORD Reserved, DWORD dwType, const BYTE* lpData, DWORD cbData);

    __declspec(dllimport) LSTATUS __stdcall RegUnLoadKeyA(HKEY hKey, LPCSTR lpSubKey);

    __declspec(dllimport) LSTATUS __stdcall RegUnLoadKeyW(HKEY hKey, LPCWSTR lpSubKey);

    __declspec(dllimport) LSTATUS __stdcall RegDeleteKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName);

    __declspec(dllimport) LSTATUS __stdcall RegDeleteKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName);

    __declspec(dllimport) LSTATUS
    __stdcall RegSetKeyValueA(HKEY hKey, LPCSTR lpSubKey, LPCSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData);

    __declspec(dllimport) LSTATUS
    __stdcall RegSetKeyValueW(HKEY hKey, LPCWSTR lpSubKey, LPCWSTR lpValueName, DWORD dwType, LPCVOID lpData, DWORD cbData);

    __declspec(dllimport) LSTATUS __stdcall RegDeleteTreeA(HKEY hKey, LPCSTR lpSubKey);

    __declspec(dllimport) LSTATUS __stdcall RegDeleteTreeW(HKEY hKey, LPCWSTR lpSubKey);

    __declspec(dllimport) LSTATUS __stdcall RegCopyTreeA(HKEY hKeySrc, LPCSTR lpSubKey, HKEY hKeyDest);

    __declspec(dllimport) LSTATUS __stdcall RegGetValueA(HKEY hkey,
                                                         LPCSTR lpSubKey,
                                                         LPCSTR lpValue,
                                                         DWORD dwFlags,
                                                         LPDWORD pdwType,

                                                         PVOID pvData,
                                                         LPDWORD pcbData);

    __declspec(dllimport) LSTATUS __stdcall RegGetValueW(HKEY hkey,
                                                         LPCWSTR lpSubKey,
                                                         LPCWSTR lpValue,
                                                         DWORD dwFlags,
                                                         LPDWORD pdwType,

                                                         PVOID pvData,
                                                         LPDWORD pcbData);

    __declspec(dllimport) LSTATUS __stdcall RegCopyTreeW(HKEY hKeySrc, LPCWSTR lpSubKey, HKEY hKeyDest);

    __declspec(dllimport) LSTATUS
    __stdcall RegLoadMUIStringA(HKEY hKey, LPCSTR pszValue, LPSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCSTR pszDirectory);

    __declspec(dllimport) LSTATUS
    __stdcall RegLoadMUIStringW(HKEY hKey, LPCWSTR pszValue, LPWSTR pszOutBuf, DWORD cbOutBuf, LPDWORD pcbData, DWORD Flags, LPCWSTR pszDirectory);

    __declspec(dllimport) LSTATUS
    __stdcall RegLoadAppKeyA(LPCSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved);

    __declspec(dllimport) LSTATUS
    __stdcall RegLoadAppKeyW(LPCWSTR lpFile, PHKEY phkResult, REGSAM samDesired, DWORD dwOptions, DWORD Reserved);

    __declspec(dllimport) BOOL
    __stdcall InitiateSystemShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown);

    __declspec(dllimport) BOOL
    __stdcall InitiateSystemShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown);

    __declspec(dllimport) BOOL __stdcall AbortSystemShutdownA(LPSTR lpMachineName);
    __declspec(dllimport) BOOL __stdcall AbortSystemShutdownW(LPWSTR lpMachineName);

#pragma once

#pragma region Desktop Family

#pragma endregion

    __declspec(dllimport) BOOL __stdcall InitiateSystemShutdownExA(
    LPSTR lpMachineName, LPSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason);

    __declspec(dllimport) BOOL __stdcall InitiateSystemShutdownExW(
    LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwTimeout, BOOL bForceAppsClosed, BOOL bRebootAfterShutdown, DWORD dwReason);

    __declspec(dllimport) DWORD
    __stdcall InitiateShutdownA(LPSTR lpMachineName, LPSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason);
    __declspec(dllimport) DWORD
    __stdcall InitiateShutdownW(LPWSTR lpMachineName, LPWSTR lpMessage, DWORD dwGracePeriod, DWORD dwShutdownFlags, DWORD dwReason);

    __declspec(dllimport) DWORD __stdcall CheckForHiberboot(PBOOLEAN pHiberboot, BOOLEAN bClearFlag);

    __declspec(dllimport) LSTATUS
    __stdcall RegSaveKeyExA(HKEY hKey, LPCSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);

    __declspec(dllimport) LSTATUS
    __stdcall RegSaveKeyExW(HKEY hKey, LPCWSTR lpFile, const LPSECURITY_ATTRIBUTES lpSecurityAttributes, DWORD Flags);

#pragma endregion

#pragma warning(pop)
}

#pragma once

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

#pragma region Desktop Family or System Family

#pragma region Desktop Family or OneCore Family

#pragma endregion

    typedef struct _NETRESOURCEA
    {
        DWORD dwScope;
        DWORD dwType;
        DWORD dwDisplayType;
        DWORD dwUsage;
        LPSTR lpLocalName;
        LPSTR lpRemoteName;
        LPSTR lpComment;
        LPSTR lpProvider;
    } NETRESOURCEA, *LPNETRESOURCEA;
    typedef struct _NETRESOURCEW
    {
        DWORD dwScope;
        DWORD dwType;
        DWORD dwDisplayType;
        DWORD dwUsage;
        LPWSTR lpLocalName;
        LPWSTR lpRemoteName;
        LPWSTR lpComment;
        LPWSTR lpProvider;
    } NETRESOURCEW, *LPNETRESOURCEW;

    typedef NETRESOURCEA NETRESOURCE;
    typedef LPNETRESOURCEA LPNETRESOURCE;

    DWORD __stdcall WNetAddConnectionA(LPCSTR lpRemoteName, LPCSTR lpPassword, LPCSTR lpLocalName);

    DWORD __stdcall WNetAddConnectionW(LPCWSTR lpRemoteName, LPCWSTR lpPassword, LPCWSTR lpLocalName);

    DWORD __stdcall WNetAddConnection2A(LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags);

    DWORD __stdcall WNetAddConnection2W(LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags);

    DWORD __stdcall WNetAddConnection3A(HWND hwndOwner, LPNETRESOURCEA lpNetResource, LPCSTR lpPassword, LPCSTR lpUserName, DWORD dwFlags);

    DWORD __stdcall WNetAddConnection3W(HWND hwndOwner, LPNETRESOURCEW lpNetResource, LPCWSTR lpPassword, LPCWSTR lpUserName, DWORD dwFlags);

    DWORD __stdcall WNetCancelConnectionA(LPCSTR lpName, BOOL fForce);

    DWORD __stdcall WNetCancelConnectionW(LPCWSTR lpName, BOOL fForce);

    DWORD __stdcall WNetCancelConnection2A(LPCSTR lpName, DWORD dwFlags, BOOL fForce);

    DWORD __stdcall WNetCancelConnection2W(LPCWSTR lpName, DWORD dwFlags, BOOL fForce);

    DWORD __stdcall WNetGetConnectionA(LPCSTR lpLocalName, LPSTR lpRemoteName, LPDWORD lpnLength);

    DWORD __stdcall WNetGetConnectionW(LPCWSTR lpLocalName, LPWSTR lpRemoteName, LPDWORD lpnLength);

#pragma endregion

#pragma region Desktop Family

    DWORD __stdcall WNetRestoreSingleConnectionW(HWND hwndParent, LPCWSTR lpDevice, BOOL fUseUI);

#pragma endregion

#pragma region Desktop Family or System Family

    DWORD __stdcall WNetUseConnectionA(HWND hwndOwner,
                                       LPNETRESOURCEA lpNetResource,
                                       LPCSTR lpPassword,
                                       LPCSTR lpUserId,
                                       DWORD dwFlags,
                                       LPSTR lpAccessName,
                                       LPDWORD lpBufferSize,
                                       LPDWORD lpResult);

    DWORD __stdcall WNetUseConnectionW(HWND hwndOwner,
                                       LPNETRESOURCEW lpNetResource,
                                       LPCWSTR lpPassword,
                                       LPCWSTR lpUserId,
                                       DWORD dwFlags,
                                       LPWSTR lpAccessName,
                                       LPDWORD lpBufferSize,
                                       LPDWORD lpResult);

    DWORD __stdcall WNetConnectionDialog(HWND hwnd, DWORD dwType);

    DWORD __stdcall WNetDisconnectDialog(HWND hwnd, DWORD dwType);

    typedef struct _CONNECTDLGSTRUCTA
    {
        DWORD cbStructure;
        HWND hwndOwner;
        LPNETRESOURCEA lpConnRes;
        DWORD dwFlags;
        DWORD dwDevNum;
    } CONNECTDLGSTRUCTA, *LPCONNECTDLGSTRUCTA;
    typedef struct _CONNECTDLGSTRUCTW
    {
        DWORD cbStructure;
        HWND hwndOwner;
        LPNETRESOURCEW lpConnRes;
        DWORD dwFlags;
        DWORD dwDevNum;
    } CONNECTDLGSTRUCTW, *LPCONNECTDLGSTRUCTW;

    typedef CONNECTDLGSTRUCTA CONNECTDLGSTRUCT;
    typedef LPCONNECTDLGSTRUCTA LPCONNECTDLGSTRUCT;

    DWORD __stdcall WNetConnectionDialog1A(LPCONNECTDLGSTRUCTA lpConnDlgStruct);

    DWORD __stdcall WNetConnectionDialog1W(LPCONNECTDLGSTRUCTW lpConnDlgStruct);

    typedef struct _DISCDLGSTRUCTA
    {
        DWORD cbStructure;
        HWND hwndOwner;
        LPSTR lpLocalName;
        LPSTR lpRemoteName;
        DWORD dwFlags;
    } DISCDLGSTRUCTA, *LPDISCDLGSTRUCTA;
    typedef struct _DISCDLGSTRUCTW
    {
        DWORD cbStructure;
        HWND hwndOwner;
        LPWSTR lpLocalName;
        LPWSTR lpRemoteName;
        DWORD dwFlags;
    } DISCDLGSTRUCTW, *LPDISCDLGSTRUCTW;

    typedef DISCDLGSTRUCTA DISCDLGSTRUCT;
    typedef LPDISCDLGSTRUCTA LPDISCDLGSTRUCT;

    DWORD __stdcall WNetDisconnectDialog1A(LPDISCDLGSTRUCTA lpConnDlgStruct);

    DWORD __stdcall WNetDisconnectDialog1W(LPDISCDLGSTRUCTW lpConnDlgStruct);

    DWORD __stdcall WNetOpenEnumA(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEA lpNetResource, LPHANDLE lphEnum);

    DWORD __stdcall WNetOpenEnumW(DWORD dwScope, DWORD dwType, DWORD dwUsage, LPNETRESOURCEW lpNetResource, LPHANDLE lphEnum);

    DWORD __stdcall WNetEnumResourceA(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);

    DWORD __stdcall WNetEnumResourceW(HANDLE hEnum, LPDWORD lpcCount, LPVOID lpBuffer, LPDWORD lpBufferSize);

    DWORD __stdcall WNetCloseEnum(HANDLE hEnum);

    DWORD __stdcall WNetGetResourceParentA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer);

    DWORD __stdcall WNetGetResourceParentW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer);

    DWORD __stdcall WNetGetResourceInformationA(LPNETRESOURCEA lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPSTR* lplpSystem);

    DWORD __stdcall WNetGetResourceInformationW(LPNETRESOURCEW lpNetResource, LPVOID lpBuffer, LPDWORD lpcbBuffer, LPWSTR* lplpSystem);

    typedef struct _UNIVERSAL_NAME_INFOA
    {
        LPSTR lpUniversalName;
    } UNIVERSAL_NAME_INFOA, *LPUNIVERSAL_NAME_INFOA;
    typedef struct _UNIVERSAL_NAME_INFOW
    {
        LPWSTR lpUniversalName;
    } UNIVERSAL_NAME_INFOW, *LPUNIVERSAL_NAME_INFOW;

    typedef UNIVERSAL_NAME_INFOA UNIVERSAL_NAME_INFO;
    typedef LPUNIVERSAL_NAME_INFOA LPUNIVERSAL_NAME_INFO;

    typedef struct _REMOTE_NAME_INFOA
    {
        LPSTR lpUniversalName;
        LPSTR lpConnectionName;
        LPSTR lpRemainingPath;
    } REMOTE_NAME_INFOA, *LPREMOTE_NAME_INFOA;
    typedef struct _REMOTE_NAME_INFOW
    {
        LPWSTR lpUniversalName;
        LPWSTR lpConnectionName;
        LPWSTR lpRemainingPath;
    } REMOTE_NAME_INFOW, *LPREMOTE_NAME_INFOW;

    typedef REMOTE_NAME_INFOA REMOTE_NAME_INFO;
    typedef LPREMOTE_NAME_INFOA LPREMOTE_NAME_INFO;

    DWORD __stdcall WNetGetUniversalNameA(LPCSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize);

    DWORD __stdcall WNetGetUniversalNameW(LPCWSTR lpLocalPath, DWORD dwInfoLevel, LPVOID lpBuffer, LPDWORD lpBufferSize);

    DWORD __stdcall WNetGetUserA(LPCSTR lpName, LPSTR lpUserName, LPDWORD lpnLength);

    DWORD __stdcall WNetGetUserW(LPCWSTR lpName, LPWSTR lpUserName, LPDWORD lpnLength);

    DWORD __stdcall WNetGetProviderNameA(DWORD dwNetType, LPSTR lpProviderName, LPDWORD lpBufferSize);

    DWORD __stdcall WNetGetProviderNameW(DWORD dwNetType, LPWSTR lpProviderName, LPDWORD lpBufferSize);

    typedef struct _NETINFOSTRUCT
    {
        DWORD cbStructure;
        DWORD dwProviderVersion;
        DWORD dwStatus;
        DWORD dwCharacteristics;
        ULONG_PTR dwHandle;
        WORD wNetType;
        DWORD dwPrinters;
        DWORD dwDrives;
    } NETINFOSTRUCT, *LPNETINFOSTRUCT;

    DWORD __stdcall WNetGetNetworkInformationA(LPCSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct);

    DWORD __stdcall WNetGetNetworkInformationW(LPCWSTR lpProvider, LPNETINFOSTRUCT lpNetInfoStruct);

    DWORD __stdcall WNetGetLastErrorA(LPDWORD lpError, LPSTR lpErrorBuf, DWORD nErrorBufSize, LPSTR lpNameBuf, DWORD nNameBufSize);

    DWORD __stdcall WNetGetLastErrorW(LPDWORD lpError, LPWSTR lpErrorBuf, DWORD nErrorBufSize, LPWSTR lpNameBuf, DWORD nNameBufSize);

    typedef struct _NETCONNECTINFOSTRUCT
    {
        DWORD cbStructure;
        DWORD dwFlags;
        DWORD dwSpeed;
        DWORD dwDelay;
        DWORD dwOptDataSize;
    } NETCONNECTINFOSTRUCT, *LPNETCONNECTINFOSTRUCT;

    DWORD __stdcall MultinetGetConnectionPerformanceA(LPNETRESOURCEA lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct);

    DWORD __stdcall MultinetGetConnectionPerformanceW(LPNETRESOURCEW lpNetResource, LPNETCONNECTINFOSTRUCT lpNetConnectInfoStruct);

#pragma endregion

#pragma warning(pop)
}

#pragma once

#pragma once

#pragma warning(push)
#pragma warning(disable : 4820)

extern "C"
{
#pragma region Desktop Family

    typedef struct
    {
        unsigned short bAppReturnCode : 8, reserved : 6, fBusy : 1, fAck : 1;

    } DDEACK;

    typedef struct
    {
        unsigned short reserved : 14, fDeferUpd : 1, fAckReq : 1;

        short cfFormat;
    } DDEADVISE;

    typedef struct
    {
        unsigned short unused : 12, fResponse : 1, fRelease : 1, reserved : 1, fAckReq : 1;

        short cfFormat;
        BYTE Value[1];
    } DDEDATA;

    typedef struct
    {
        unsigned short unused : 13,

        fRelease : 1, fReserved : 2;

        short cfFormat;
        BYTE Value[1];

    } DDEPOKE;

    typedef struct
    {
        unsigned short unused : 13, fRelease : 1, fDeferUpd : 1, fAckReq : 1;

        short cfFormat;
    } DDELN;

    typedef struct
    {
        unsigned short unused : 12, fAck : 1, fRelease : 1, fReserved : 1, fAckReq : 1;

        short cfFormat;
        BYTE rgb[1];
    } DDEUP;

    BOOL __stdcall DdeSetQualityOfService(HWND hwndClient, const SECURITY_QUALITY_OF_SERVICE* pqosNew, PSECURITY_QUALITY_OF_SERVICE pqosPrev);

    BOOL __stdcall ImpersonateDdeClientWindow(HWND hWndClient, HWND hWndServer);

    LPARAM __stdcall PackDDElParam(UINT msg, UINT_PTR uiLo, UINT_PTR uiHi);
    BOOL __stdcall UnpackDDElParam(UINT msg, LPARAM lParam, PUINT_PTR puiLo, PUINT_PTR puiHi);
    BOOL __stdcall FreeDDElParam(UINT msg, LPARAM lParam);
    LPARAM __stdcall ReuseDDElParam(LPARAM lParam, UINT msgIn, UINT msgOut, UINT_PTR uiLo, UINT_PTR uiHi);

#pragma endregion
}

#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4820)

extern "C"
{
#pragma region Desktop Family

    struct HCONVLIST__
    {
        int unused;
    };
    typedef struct HCONVLIST__* HCONVLIST;
    struct HCONV__
    {
        int unused;
    };
    typedef struct HCONV__* HCONV;
    struct HSZ__
    {
        int unused;
    };
    typedef struct HSZ__* HSZ;
    struct HDDEDATA__
    {
        int unused;
    };
    typedef struct HDDEDATA__* HDDEDATA;

    typedef struct tagHSZPAIR
    {
        HSZ hszSvc;
        HSZ hszTopic;
    } HSZPAIR, *PHSZPAIR;

    typedef struct tagCONVCONTEXT
    {
        UINT cb;
        UINT wFlags;
        UINT wCountryID;
        int iCodePage;
        DWORD dwLangID;
        DWORD dwSecurity;
        SECURITY_QUALITY_OF_SERVICE qos;
    } CONVCONTEXT, *PCONVCONTEXT;

    typedef struct tagCONVINFO
    {
        DWORD cb;
        DWORD_PTR hUser;
        HCONV hConvPartner;
        HSZ hszSvcPartner;
        HSZ hszServiceReq;
        HSZ hszTopic;
        HSZ hszItem;
        UINT wFmt;
        UINT wType;
        UINT wStatus;
        UINT wConvst;
        UINT wLastError;
        HCONVLIST hConvList;
        CONVCONTEXT ConvCtxt;
        HWND hwnd;
        HWND hwndPartner;
    } CONVINFO, *PCONVINFO;

    typedef HDDEDATA __stdcall FNCALLBACK(UINT wType, UINT wFmt, HCONV hConv, HSZ hsz1, HSZ hsz2, HDDEDATA hData, ULONG_PTR dwData1, ULONG_PTR dwData2);
    typedef HDDEDATA(__stdcall* PFNCALLBACK)(
    UINT wType, UINT wFmt, HCONV hConv, HSZ hsz1, HSZ hsz2, HDDEDATA hData, ULONG_PTR dwData1, ULONG_PTR dwData2);

    UINT __stdcall DdeInitializeA(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes);
    UINT __stdcall DdeInitializeW(LPDWORD pidInst, PFNCALLBACK pfnCallback, DWORD afCmd, DWORD ulRes);

    BOOL __stdcall DdeUninitialize(DWORD idInst);

    HCONVLIST
    __stdcall DdeConnectList(DWORD idInst, HSZ hszService, HSZ hszTopic, HCONVLIST hConvList, PCONVCONTEXT pCC);

    HCONV
    __stdcall DdeQueryNextServer(HCONVLIST hConvList, HCONV hConvPrev);
    BOOL __stdcall DdeDisconnectList(HCONVLIST hConvList);

    HCONV
    __stdcall DdeConnect(DWORD idInst, HSZ hszService, HSZ hszTopic, PCONVCONTEXT pCC);

    BOOL __stdcall DdeDisconnect(HCONV hConv);

    HCONV
    __stdcall DdeReconnect(HCONV hConv);

    UINT __stdcall DdeQueryConvInfo(HCONV hConv, DWORD idTransaction, PCONVINFO pConvInfo);

    BOOL __stdcall DdeSetUserHandle(HCONV hConv, DWORD id, DWORD_PTR hUser);

    BOOL __stdcall DdeAbandonTransaction(DWORD idInst, HCONV hConv, DWORD idTransaction);

    BOOL __stdcall DdePostAdvise(DWORD idInst, HSZ hszTopic, HSZ hszItem);

    BOOL __stdcall DdeEnableCallback(DWORD idInst, HCONV hConv, UINT wCmd);

    BOOL __stdcall DdeImpersonateClient(HCONV hConv);

    HDDEDATA
    __stdcall DdeNameService(DWORD idInst, HSZ hsz1, HSZ hsz2, UINT afCmd);

    HDDEDATA
    __stdcall DdeClientTransaction(LPBYTE pData, DWORD cbData, HCONV hConv, HSZ hszItem, UINT wFmt, UINT wType, DWORD dwTimeout, LPDWORD pdwResult);

    HDDEDATA
    __stdcall DdeCreateDataHandle(DWORD idInst, LPBYTE pSrc, DWORD cb, DWORD cbOff, HSZ hszItem, UINT wFmt, UINT afCmd);

    HDDEDATA
    __stdcall DdeAddData(HDDEDATA hData, LPBYTE pSrc, DWORD cb, DWORD cbOff);

    DWORD
    __stdcall DdeGetData(HDDEDATA hData, LPBYTE pDst, DWORD cbMax, DWORD cbOff);

    LPBYTE
    __stdcall DdeAccessData(HDDEDATA hData, LPDWORD pcbDataSize);

    BOOL __stdcall DdeUnaccessData(HDDEDATA hData);

    BOOL __stdcall DdeFreeDataHandle(HDDEDATA hData);

    UINT __stdcall DdeGetLastError(DWORD idInst);

    HSZ __stdcall DdeCreateStringHandleA(DWORD idInst, LPCSTR psz, int iCodePage);
    HSZ __stdcall DdeCreateStringHandleW(DWORD idInst, LPCWSTR psz, int iCodePage);

    DWORD
    __stdcall DdeQueryStringA(DWORD idInst, HSZ hsz, LPSTR psz, DWORD cchMax, int iCodePage);
    DWORD
    __stdcall DdeQueryStringW(DWORD idInst, HSZ hsz, LPWSTR psz, DWORD cchMax, int iCodePage);

    BOOL __stdcall DdeFreeStringHandle(DWORD idInst, HSZ hsz);

    BOOL __stdcall DdeKeepStringHandle(DWORD idInst, HSZ hsz);

    int __stdcall DdeCmpStringHandles(HSZ hsz1, HSZ hsz2);

    typedef struct tagDDEML_MSG_HOOK_DATA
    {
        UINT_PTR uiLo;
        UINT_PTR uiHi;
        DWORD cbData;
        DWORD Data[8];
    } DDEML_MSG_HOOK_DATA, *PDDEML_MSG_HOOK_DATA;

    typedef struct tagMONMSGSTRUCT
    {
        UINT cb;
        HWND hwndTo;
        DWORD dwTime;
        HANDLE hTask;
        UINT wMsg;
        WPARAM wParam;
        LPARAM lParam;
        DDEML_MSG_HOOK_DATA dmhd;
    } MONMSGSTRUCT, *PMONMSGSTRUCT;

    typedef struct tagMONCBSTRUCT
    {
        UINT cb;
        DWORD dwTime;
        HANDLE hTask;
        DWORD dwRet;
        UINT wType;
        UINT wFmt;
        HCONV hConv;
        HSZ hsz1;
        HSZ hsz2;
        HDDEDATA hData;
        ULONG_PTR dwData1;
        ULONG_PTR dwData2;
        CONVCONTEXT cc;
        DWORD cbData;
        DWORD Data[8];
    } MONCBSTRUCT, *PMONCBSTRUCT;

    typedef struct tagMONHSZSTRUCTA
    {
        UINT cb;
        BOOL fsAction;
        DWORD dwTime;
        HSZ hsz;
        HANDLE hTask;
        CHAR str[1];
    } MONHSZSTRUCTA, *PMONHSZSTRUCTA;
    typedef struct tagMONHSZSTRUCTW
    {
        UINT cb;
        BOOL fsAction;
        DWORD dwTime;
        HSZ hsz;
        HANDLE hTask;
        WCHAR str[1];
    } MONHSZSTRUCTW, *PMONHSZSTRUCTW;

    typedef MONHSZSTRUCTA MONHSZSTRUCT;
    typedef PMONHSZSTRUCTA PMONHSZSTRUCT;

    typedef struct tagMONERRSTRUCT
    {
        UINT cb;
        UINT wLastError;
        DWORD dwTime;
        HANDLE hTask;
    } MONERRSTRUCT, *PMONERRSTRUCT;

    typedef struct tagMONLINKSTRUCT
    {
        UINT cb;
        DWORD dwTime;
        HANDLE hTask;
        BOOL fEstablished;
        BOOL fNoData;
        HSZ hszSvc;
        HSZ hszTopic;
        HSZ hszItem;
        UINT wFmt;
        BOOL fServer;
        HCONV hConvServer;
        HCONV hConvClient;
    } MONLINKSTRUCT, *PMONLINKSTRUCT;

    typedef struct tagMONCONVSTRUCT
    {
        UINT cb;
        BOOL fConnect;
        DWORD dwTime;
        HANDLE hTask;
        HSZ hszSvc;
        HSZ hszTopic;
        HCONV hConvClient;
        HCONV hConvServer;
    } MONCONVSTRUCT, *PMONCONVSTRUCT;

#pragma endregion
}

#pragma warning(pop)

#pragma once

#pragma region Desktop Family

typedef struct tagCRGB
{
    BYTE bRed;
    BYTE bGreen;
    BYTE bBlue;
    BYTE bExtra;
} CRGB;

#pragma endregion

extern "C"
{
#pragma region Desktop Family

    INT __stdcall LZStart(void);

    void __stdcall LZDone(void);

    LONG __stdcall CopyLZFile(INT hfSource, INT hfDest);

    LONG __stdcall LZCopy(INT hfSource, INT hfDest);

    INT __stdcall LZInit(INT hfSource);

    INT __stdcall GetExpandedNameA(LPSTR lpszSource, LPSTR lpszBuffer);

    INT __stdcall GetExpandedNameW(LPWSTR lpszSource, LPWSTR lpszBuffer);

    INT __stdcall LZOpenFileA(LPSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle);

    INT __stdcall LZOpenFileW(LPWSTR lpFileName, LPOFSTRUCT lpReOpenBuf, WORD wStyle);

    LONG __stdcall LZSeek(INT hFile, LONG lOffset, INT iOrigin);

    INT __stdcall LZRead(INT hFile, CHAR* lpBuffer, INT cbRead);

    void __stdcall LZClose(INT hFile);

#pragma endregion
}

#pragma warning(disable : 4201)

#pragma warning(disable : 4103)

#pragma pack(push, 1)

extern "C"
{
#pragma region Desktop Family or OneCore Family

    typedef UINT MMVERSION;

    typedef UINT MMRESULT;

    typedef UINT* LPUINT;

    typedef struct mmtime_tag
    {
        UINT wType;
        union
        {
            DWORD ms;
            DWORD sample;
            DWORD cb;
            DWORD ticks;

            struct
            {
                BYTE hour;
                BYTE min;
                BYTE sec;
                BYTE frame;
                BYTE fps;
                BYTE dummy;

                BYTE pad[2];
            } smpte;

            struct
            {
                DWORD songptrpos;
            } midi;
        } u;
    } MMTIME, *PMMTIME, *NPMMTIME, *LPMMTIME;

    struct HDRVR__
    {
        int unused;
    };
    typedef struct HDRVR__* HDRVR;

    typedef void(__stdcall DRVCALLBACK)(HDRVR hdrvr, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);

    typedef DRVCALLBACK* LPDRVCALLBACK;

    typedef DRVCALLBACK* PDRVCALLBACK;

#pragma endregion
}

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(disable : 4103)

#pragma pack(push, 1)

extern "C"
{
#pragma region Desktop Family

#pragma once

    extern "C"
    {
#pragma region Desktop Family

        typedef DWORD MCIERROR;

        typedef UINT MCIDEVICEID;

        typedef UINT(__stdcall* YIELDPROC)(MCIDEVICEID mciId, DWORD dwYieldData);

        __declspec(dllimport) MCIERROR
        __stdcall mciSendCommandA(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

        __declspec(dllimport) MCIERROR
        __stdcall mciSendCommandW(MCIDEVICEID mciId, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

        __declspec(dllimport) MCIERROR
        __stdcall mciSendStringA(LPCSTR lpstrCommand, LPSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);

        __declspec(dllimport) MCIERROR
        __stdcall mciSendStringW(LPCWSTR lpstrCommand, LPWSTR lpstrReturnString, UINT uReturnLength, HWND hwndCallback);

        __declspec(dllimport) MCIDEVICEID __stdcall mciGetDeviceIDA(LPCSTR pszDevice);

        __declspec(dllimport) MCIDEVICEID __stdcall mciGetDeviceIDW(LPCWSTR pszDevice);

        __declspec(dllimport) MCIDEVICEID __stdcall mciGetDeviceIDFromElementIDA(DWORD dwElementID, LPCSTR lpstrType);

        __declspec(dllimport) MCIDEVICEID __stdcall mciGetDeviceIDFromElementIDW(DWORD dwElementID, LPCWSTR lpstrType);

        __declspec(dllimport) BOOL __stdcall mciGetErrorStringA(MCIERROR mcierr, LPSTR pszText, UINT cchText);

        __declspec(dllimport) BOOL __stdcall mciGetErrorStringW(MCIERROR mcierr, LPWSTR pszText, UINT cchText);

        __declspec(dllimport) BOOL __stdcall mciSetYieldProc(MCIDEVICEID mciId, YIELDPROC fpYieldProc, DWORD dwYieldData);

        __declspec(dllimport) HTASK __stdcall mciGetCreatorTask(MCIDEVICEID mciId);

        __declspec(dllimport) YIELDPROC __stdcall mciGetYieldProc(MCIDEVICEID mciId, LPDWORD pdwYieldData);

        typedef struct tagMCI_GENERIC_PARMS
        {
            DWORD_PTR dwCallback;
        } MCI_GENERIC_PARMS, *PMCI_GENERIC_PARMS, *LPMCI_GENERIC_PARMS;

        typedef struct tagMCI_OPEN_PARMSA
        {
            DWORD_PTR dwCallback;
            MCIDEVICEID wDeviceID;
            LPCSTR lpstrDeviceType;
            LPCSTR lpstrElementName;
            LPCSTR lpstrAlias;
        } MCI_OPEN_PARMSA, *PMCI_OPEN_PARMSA, *LPMCI_OPEN_PARMSA;
        typedef struct tagMCI_OPEN_PARMSW
        {
            DWORD_PTR dwCallback;
            MCIDEVICEID wDeviceID;
            LPCWSTR lpstrDeviceType;
            LPCWSTR lpstrElementName;
            LPCWSTR lpstrAlias;
        } MCI_OPEN_PARMSW, *PMCI_OPEN_PARMSW, *LPMCI_OPEN_PARMSW;

        typedef MCI_OPEN_PARMSA MCI_OPEN_PARMS;
        typedef PMCI_OPEN_PARMSA PMCI_OPEN_PARMS;
        typedef LPMCI_OPEN_PARMSA LPMCI_OPEN_PARMS;

        typedef struct tagMCI_PLAY_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwFrom;
            DWORD dwTo;
        } MCI_PLAY_PARMS, *PMCI_PLAY_PARMS, *LPMCI_PLAY_PARMS;

        typedef struct tagMCI_SEEK_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwTo;
        } MCI_SEEK_PARMS, *PMCI_SEEK_PARMS, *LPMCI_SEEK_PARMS;

        typedef struct tagMCI_STATUS_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD_PTR dwReturn;
            DWORD dwItem;
            DWORD dwTrack;
        } MCI_STATUS_PARMS, *PMCI_STATUS_PARMS, *LPMCI_STATUS_PARMS;

        typedef struct tagMCI_INFO_PARMSA
        {
            DWORD_PTR dwCallback;
            LPSTR lpstrReturn;
            DWORD dwRetSize;
        } MCI_INFO_PARMSA, *LPMCI_INFO_PARMSA;
        typedef struct tagMCI_INFO_PARMSW
        {
            DWORD_PTR dwCallback;
            LPWSTR lpstrReturn;
            DWORD dwRetSize;
        } MCI_INFO_PARMSW, *LPMCI_INFO_PARMSW;

        typedef MCI_INFO_PARMSA MCI_INFO_PARMS;
        typedef LPMCI_INFO_PARMSA LPMCI_INFO_PARMS;

        typedef struct tagMCI_GETDEVCAPS_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwReturn;
            DWORD dwItem;
        } MCI_GETDEVCAPS_PARMS, *PMCI_GETDEVCAPS_PARMS, *LPMCI_GETDEVCAPS_PARMS;

        typedef struct tagMCI_SYSINFO_PARMSA
        {
            DWORD_PTR dwCallback;
            LPSTR lpstrReturn;
            DWORD dwRetSize;
            DWORD dwNumber;
            UINT wDeviceType;
        } MCI_SYSINFO_PARMSA, *PMCI_SYSINFO_PARMSA, *LPMCI_SYSINFO_PARMSA;
        typedef struct tagMCI_SYSINFO_PARMSW
        {
            DWORD_PTR dwCallback;
            LPWSTR lpstrReturn;
            DWORD dwRetSize;
            DWORD dwNumber;
            UINT wDeviceType;
        } MCI_SYSINFO_PARMSW, *PMCI_SYSINFO_PARMSW, *LPMCI_SYSINFO_PARMSW;

        typedef MCI_SYSINFO_PARMSA MCI_SYSINFO_PARMS;
        typedef PMCI_SYSINFO_PARMSA PMCI_SYSINFO_PARMS;
        typedef LPMCI_SYSINFO_PARMSA LPMCI_SYSINFO_PARMS;

        typedef struct tagMCI_SET_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwTimeFormat;
            DWORD dwAudio;
        } MCI_SET_PARMS, *PMCI_SET_PARMS, *LPMCI_SET_PARMS;

        typedef struct tagMCI_BREAK_PARMS
        {
            DWORD_PTR dwCallback;

            int nVirtKey;
            HWND hwndBreak;

        } MCI_BREAK_PARMS, *PMCI_BREAK_PARMS, *LPMCI_BREAK_PARMS;

        typedef struct tagMCI_SAVE_PARMSA
        {
            DWORD_PTR dwCallback;
            LPCSTR lpfilename;
        } MCI_SAVE_PARMSA, *PMCI_SAVE_PARMSA, *LPMCI_SAVE_PARMSA;
        typedef struct tagMCI_SAVE_PARMSW
        {
            DWORD_PTR dwCallback;
            LPCWSTR lpfilename;
        } MCI_SAVE_PARMSW, *PMCI_SAVE_PARMSW, *LPMCI_SAVE_PARMSW;

        typedef MCI_SAVE_PARMSA MCI_SAVE_PARMS;
        typedef PMCI_SAVE_PARMSA PMCI_SAVE_PARMS;
        typedef LPMCI_SAVE_PARMSA LPMCI_SAVE_PARMS;

        typedef struct tagMCI_LOAD_PARMSA
        {
            DWORD_PTR dwCallback;
            LPCSTR lpfilename;
        } MCI_LOAD_PARMSA, *PMCI_LOAD_PARMSA, *LPMCI_LOAD_PARMSA;
        typedef struct tagMCI_LOAD_PARMSW
        {
            DWORD_PTR dwCallback;
            LPCWSTR lpfilename;
        } MCI_LOAD_PARMSW, *PMCI_LOAD_PARMSW, *LPMCI_LOAD_PARMSW;

        typedef MCI_LOAD_PARMSA MCI_LOAD_PARMS;
        typedef PMCI_LOAD_PARMSA PMCI_LOAD_PARMS;
        typedef LPMCI_LOAD_PARMSA LPMCI_LOAD_PARMS;

        typedef struct tagMCI_RECORD_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwFrom;
            DWORD dwTo;
        } MCI_RECORD_PARMS, *LPMCI_RECORD_PARMS;

        typedef struct tagMCI_VD_PLAY_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwFrom;
            DWORD dwTo;
            DWORD dwSpeed;
        } MCI_VD_PLAY_PARMS, *PMCI_VD_PLAY_PARMS, *LPMCI_VD_PLAY_PARMS;

        typedef struct tagMCI_VD_STEP_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwFrames;
        } MCI_VD_STEP_PARMS, *PMCI_VD_STEP_PARMS, *LPMCI_VD_STEP_PARMS;

        typedef struct tagMCI_VD_ESCAPE_PARMSA
        {
            DWORD_PTR dwCallback;
            LPCSTR lpstrCommand;
        } MCI_VD_ESCAPE_PARMSA, *PMCI_VD_ESCAPE_PARMSA, *LPMCI_VD_ESCAPE_PARMSA;
        typedef struct tagMCI_VD_ESCAPE_PARMSW
        {
            DWORD_PTR dwCallback;
            LPCWSTR lpstrCommand;
        } MCI_VD_ESCAPE_PARMSW, *PMCI_VD_ESCAPE_PARMSW, *LPMCI_VD_ESCAPE_PARMSW;

        typedef MCI_VD_ESCAPE_PARMSA MCI_VD_ESCAPE_PARMS;
        typedef PMCI_VD_ESCAPE_PARMSA PMCI_VD_ESCAPE_PARMS;
        typedef LPMCI_VD_ESCAPE_PARMSA LPMCI_VD_ESCAPE_PARMS;

        typedef struct tagMCI_WAVE_OPEN_PARMSA
        {
            DWORD_PTR dwCallback;
            MCIDEVICEID wDeviceID;
            LPCSTR lpstrDeviceType;
            LPCSTR lpstrElementName;
            LPCSTR lpstrAlias;
            DWORD dwBufferSeconds;
        } MCI_WAVE_OPEN_PARMSA, *PMCI_WAVE_OPEN_PARMSA, *LPMCI_WAVE_OPEN_PARMSA;
        typedef struct tagMCI_WAVE_OPEN_PARMSW
        {
            DWORD_PTR dwCallback;
            MCIDEVICEID wDeviceID;
            LPCWSTR lpstrDeviceType;
            LPCWSTR lpstrElementName;
            LPCWSTR lpstrAlias;
            DWORD dwBufferSeconds;
        } MCI_WAVE_OPEN_PARMSW, *PMCI_WAVE_OPEN_PARMSW, *LPMCI_WAVE_OPEN_PARMSW;

        typedef MCI_WAVE_OPEN_PARMSA MCI_WAVE_OPEN_PARMS;
        typedef PMCI_WAVE_OPEN_PARMSA PMCI_WAVE_OPEN_PARMS;
        typedef LPMCI_WAVE_OPEN_PARMSA LPMCI_WAVE_OPEN_PARMS;

        typedef struct tagMCI_WAVE_DELETE_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwFrom;
            DWORD dwTo;
        } MCI_WAVE_DELETE_PARMS, *PMCI_WAVE_DELETE_PARMS, *LPMCI_WAVE_DELETE_PARMS;

        typedef struct tagMCI_WAVE_SET_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwTimeFormat;
            DWORD dwAudio;

            UINT wInput;
            UINT wOutput;

            WORD wFormatTag;
            WORD wReserved2;
            WORD nChannels;
            WORD wReserved3;
            DWORD nSamplesPerSec;
            DWORD nAvgBytesPerSec;
            WORD nBlockAlign;
            WORD wReserved4;
            WORD wBitsPerSample;
            WORD wReserved5;
        } MCI_WAVE_SET_PARMS, *PMCI_WAVE_SET_PARMS, *LPMCI_WAVE_SET_PARMS;

        typedef struct tagMCI_SEQ_SET_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwTimeFormat;
            DWORD dwAudio;
            DWORD dwTempo;
            DWORD dwPort;
            DWORD dwSlave;
            DWORD dwMaster;
            DWORD dwOffset;
        } MCI_SEQ_SET_PARMS, *PMCI_SEQ_SET_PARMS, *LPMCI_SEQ_SET_PARMS;

        typedef struct tagMCI_ANIM_OPEN_PARMSA
        {
            DWORD_PTR dwCallback;
            MCIDEVICEID wDeviceID;
            LPCSTR lpstrDeviceType;
            LPCSTR lpstrElementName;
            LPCSTR lpstrAlias;
            DWORD dwStyle;
            HWND hWndParent;
        } MCI_ANIM_OPEN_PARMSA, *PMCI_ANIM_OPEN_PARMSA, *LPMCI_ANIM_OPEN_PARMSA;
        typedef struct tagMCI_ANIM_OPEN_PARMSW
        {
            DWORD_PTR dwCallback;
            MCIDEVICEID wDeviceID;
            LPCWSTR lpstrDeviceType;
            LPCWSTR lpstrElementName;
            LPCWSTR lpstrAlias;
            DWORD dwStyle;
            HWND hWndParent;
        } MCI_ANIM_OPEN_PARMSW, *PMCI_ANIM_OPEN_PARMSW, *LPMCI_ANIM_OPEN_PARMSW;

        typedef MCI_ANIM_OPEN_PARMSA MCI_ANIM_OPEN_PARMS;
        typedef PMCI_ANIM_OPEN_PARMSA PMCI_ANIM_OPEN_PARMS;
        typedef LPMCI_ANIM_OPEN_PARMSA LPMCI_ANIM_OPEN_PARMS;

        typedef struct tagMCI_ANIM_PLAY_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwFrom;
            DWORD dwTo;
            DWORD dwSpeed;
        } MCI_ANIM_PLAY_PARMS, *PMCI_ANIM_PLAY_PARMS, *LPMCI_ANIM_PLAY_PARMS;

        typedef struct tagMCI_ANIM_STEP_PARMS
        {
            DWORD_PTR dwCallback;
            DWORD dwFrames;
        } MCI_ANIM_STEP_PARMS, *PMCI_ANIM_STEP_PARMS, *LPMCI_ANIM_STEP_PARMS;

        typedef struct tagMCI_ANIM_WINDOW_PARMSA
        {
            DWORD_PTR dwCallback;
            HWND hWnd;
            UINT nCmdShow;
            LPCSTR lpstrText;
        } MCI_ANIM_WINDOW_PARMSA, *PMCI_ANIM_WINDOW_PARMSA, *LPMCI_ANIM_WINDOW_PARMSA;
        typedef struct tagMCI_ANIM_WINDOW_PARMSW
        {
            DWORD_PTR dwCallback;
            HWND hWnd;
            UINT nCmdShow;
            LPCWSTR lpstrText;
        } MCI_ANIM_WINDOW_PARMSW, *PMCI_ANIM_WINDOW_PARMSW, *LPMCI_ANIM_WINDOW_PARMSW;

        typedef MCI_ANIM_WINDOW_PARMSA MCI_ANIM_WINDOW_PARMS;
        typedef PMCI_ANIM_WINDOW_PARMSA PMCI_ANIM_WINDOW_PARMS;
        typedef LPMCI_ANIM_WINDOW_PARMSA LPMCI_ANIM_WINDOW_PARMS;

        typedef struct tagMCI_ANIM_RECT_PARMS
        {
            DWORD_PTR dwCallback;

            RECT rc;
        } MCI_ANIM_RECT_PARMS;
        typedef MCI_ANIM_RECT_PARMS* PMCI_ANIM_RECT_PARMS;
        typedef MCI_ANIM_RECT_PARMS* LPMCI_ANIM_RECT_PARMS;

        typedef struct tagMCI_ANIM_UPDATE_PARMS
        {
            DWORD_PTR dwCallback;
            RECT rc;
            HDC hDC;
        } MCI_ANIM_UPDATE_PARMS, *PMCI_ANIM_UPDATE_PARMS, *LPMCI_ANIM_UPDATE_PARMS;

        typedef struct tagMCI_OVLY_OPEN_PARMSA
        {
            DWORD_PTR dwCallback;
            MCIDEVICEID wDeviceID;
            LPCSTR lpstrDeviceType;
            LPCSTR lpstrElementName;
            LPCSTR lpstrAlias;
            DWORD dwStyle;
            HWND hWndParent;
        } MCI_OVLY_OPEN_PARMSA, *PMCI_OVLY_OPEN_PARMSA, *LPMCI_OVLY_OPEN_PARMSA;
        typedef struct tagMCI_OVLY_OPEN_PARMSW
        {
            DWORD_PTR dwCallback;
            MCIDEVICEID wDeviceID;
            LPCWSTR lpstrDeviceType;
            LPCWSTR lpstrElementName;
            LPCWSTR lpstrAlias;
            DWORD dwStyle;
            HWND hWndParent;
        } MCI_OVLY_OPEN_PARMSW, *PMCI_OVLY_OPEN_PARMSW, *LPMCI_OVLY_OPEN_PARMSW;

        typedef MCI_OVLY_OPEN_PARMSA MCI_OVLY_OPEN_PARMS;
        typedef PMCI_OVLY_OPEN_PARMSA PMCI_OVLY_OPEN_PARMS;
        typedef LPMCI_OVLY_OPEN_PARMSA LPMCI_OVLY_OPEN_PARMS;

        typedef struct tagMCI_OVLY_WINDOW_PARMSA
        {
            DWORD_PTR dwCallback;
            HWND hWnd;
            UINT nCmdShow;
            LPCSTR lpstrText;
        } MCI_OVLY_WINDOW_PARMSA, *PMCI_OVLY_WINDOW_PARMSA, *LPMCI_OVLY_WINDOW_PARMSA;
        typedef struct tagMCI_OVLY_WINDOW_PARMSW
        {
            DWORD_PTR dwCallback;
            HWND hWnd;
            UINT nCmdShow;
            LPCWSTR lpstrText;
        } MCI_OVLY_WINDOW_PARMSW, *PMCI_OVLY_WINDOW_PARMSW, *LPMCI_OVLY_WINDOW_PARMSW;

        typedef MCI_OVLY_WINDOW_PARMSA MCI_OVLY_WINDOW_PARMS;
        typedef PMCI_OVLY_WINDOW_PARMSA PMCI_OVLY_WINDOW_PARMS;
        typedef LPMCI_OVLY_WINDOW_PARMSA LPMCI_OVLY_WINDOW_PARMS;

        typedef struct tagMCI_OVLY_RECT_PARMS
        {
            DWORD_PTR dwCallback;

            RECT rc;
        } MCI_OVLY_RECT_PARMS, *PMCI_OVLY_RECT_PARMS, *LPMCI_OVLY_RECT_PARMS;

        typedef struct tagMCI_OVLY_SAVE_PARMSA
        {
            DWORD_PTR dwCallback;
            LPCSTR lpfilename;
            RECT rc;
        } MCI_OVLY_SAVE_PARMSA, *PMCI_OVLY_SAVE_PARMSA, *LPMCI_OVLY_SAVE_PARMSA;
        typedef struct tagMCI_OVLY_SAVE_PARMSW
        {
            DWORD_PTR dwCallback;
            LPCWSTR lpfilename;
            RECT rc;
        } MCI_OVLY_SAVE_PARMSW, *PMCI_OVLY_SAVE_PARMSW, *LPMCI_OVLY_SAVE_PARMSW;

        typedef MCI_OVLY_SAVE_PARMSA MCI_OVLY_SAVE_PARMS;
        typedef PMCI_OVLY_SAVE_PARMSA PMCI_OVLY_SAVE_PARMS;
        typedef LPMCI_OVLY_SAVE_PARMSA LPMCI_OVLY_SAVE_PARMS;

        typedef struct tagMCI_OVLY_LOAD_PARMSA
        {
            DWORD_PTR dwCallback;
            LPCSTR lpfilename;
            RECT rc;
        } MCI_OVLY_LOAD_PARMSA, *PMCI_OVLY_LOAD_PARMSA, *LPMCI_OVLY_LOAD_PARMSA;
        typedef struct tagMCI_OVLY_LOAD_PARMSW
        {
            DWORD_PTR dwCallback;
            LPCWSTR lpfilename;
            RECT rc;
        } MCI_OVLY_LOAD_PARMSW, *PMCI_OVLY_LOAD_PARMSW, *LPMCI_OVLY_LOAD_PARMSW;

        typedef MCI_OVLY_LOAD_PARMSA MCI_OVLY_LOAD_PARMS;
        typedef PMCI_OVLY_LOAD_PARMSA PMCI_OVLY_LOAD_PARMS;
        typedef LPMCI_OVLY_LOAD_PARMSA LPMCI_OVLY_LOAD_PARMS;

        DWORD_PTR
        __stdcall mciGetDriverData(MCIDEVICEID wDeviceID);

        UINT __stdcall mciLoadCommandResource(HANDLE hInstance, LPCWSTR lpResName, UINT wType);

        BOOL __stdcall mciSetDriverData(MCIDEVICEID wDeviceID, DWORD_PTR dwData);

        UINT __stdcall mciDriverYield(MCIDEVICEID wDeviceID);

        BOOL __stdcall mciDriverNotify(HANDLE hwndCallback, MCIDEVICEID wDeviceID, UINT uStatus);

        BOOL __stdcall mciFreeCommandResource(UINT wTable);

#pragma endregion
    }

#pragma once

    extern "C"
    {
#pragma region Desktop Family

        typedef struct DRVCONFIGINFOEX
        {
            DWORD dwDCISize;
            LPCWSTR lpszDCISectionName;
            LPCWSTR lpszDCIAliasName;
            DWORD dnDevNode;
        } DRVCONFIGINFOEX, *PDRVCONFIGINFOEX, *NPDRVCONFIGINFOEX, *LPDRVCONFIGINFOEX;

        typedef struct tagDRVCONFIGINFO
        {
            DWORD dwDCISize;
            LPCWSTR lpszDCISectionName;
            LPCWSTR lpszDCIAliasName;
        } DRVCONFIGINFO, *PDRVCONFIGINFO, *NPDRVCONFIGINFO, *LPDRVCONFIGINFO;

        typedef LRESULT(__stdcall* DRIVERPROC)(DWORD_PTR, HDRVR, UINT, LPARAM, LPARAM);

        __declspec(dllimport) LRESULT __stdcall CloseDriver(HDRVR hDriver, LPARAM lParam1, LPARAM lParam2);

        __declspec(dllimport) HDRVR __stdcall OpenDriver(LPCWSTR szDriverName, LPCWSTR szSectionName, LPARAM lParam2);

        __declspec(dllimport) LRESULT __stdcall SendDriverMessage(HDRVR hDriver, UINT message, LPARAM lParam1, LPARAM lParam2);

        __declspec(dllimport) HMODULE __stdcall DrvGetModuleHandle(HDRVR hDriver);

        __declspec(dllimport) HMODULE __stdcall GetDriverModuleHandle(HDRVR hDriver);

        __declspec(dllimport) LRESULT
        __stdcall DefDriverProc(DWORD_PTR dwDriverIdentifier, HDRVR hdrvr, UINT uMsg, LPARAM lParam1, LPARAM lParam2);

        BOOL __stdcall DriverCallback(
        DWORD_PTR dwCallback, DWORD dwFlags, HDRVR hDevice, DWORD dwMsg, DWORD_PTR dwUser, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

        LONG __stdcall sndOpenSound(LPCWSTR EventName, LPCWSTR AppName, INT32 Flags, PHANDLE FileHandle);

        typedef DWORD(__stdcall* DRIVERMSGPROC)(DWORD, DWORD, DWORD_PTR, DWORD_PTR, DWORD_PTR);

        UINT __stdcall mmDrvInstall(HDRVR hDriver, LPCWSTR wszDrvEntry, DRIVERMSGPROC drvMessage, UINT wFlags);

        typedef DWORD FOURCC;
        typedef char* HPSTR;
        struct HMMIO__
        {
            int unused;
        };
        typedef struct HMMIO__* HMMIO;
        typedef LRESULT(__stdcall MMIOPROC)(LPSTR lpmmioinfo, UINT uMsg, LPARAM lParam1, LPARAM lParam2);
        typedef MMIOPROC* LPMMIOPROC;

        typedef struct _MMIOINFO
        {
            DWORD dwFlags;
            FOURCC fccIOProc;
            LPMMIOPROC pIOProc;
            UINT wErrorRet;
            HTASK htask;

            LONG cchBuffer;
            HPSTR pchBuffer;
            HPSTR pchNext;
            HPSTR pchEndRead;
            HPSTR pchEndWrite;
            LONG lBufOffset;

            LONG lDiskOffset;
            DWORD adwInfo[3];

            DWORD dwReserved1;
            DWORD dwReserved2;
            HMMIO hmmio;
        } MMIOINFO, *PMMIOINFO, *NPMMIOINFO, *LPMMIOINFO;
        typedef const MMIOINFO* LPCMMIOINFO;

        typedef struct _MMCKINFO
        {
            FOURCC ckid;
            DWORD cksize;
            FOURCC fccType;
            DWORD dwDataOffset;
            DWORD dwFlags;
        } MMCKINFO, *PMMCKINFO, *NPMMCKINFO, *LPMMCKINFO;
        typedef const MMCKINFO* LPCMMCKINFO;

        __declspec(dllimport) FOURCC __stdcall mmioStringToFOURCCA(LPCSTR sz, UINT uFlags);

        __declspec(dllimport) FOURCC __stdcall mmioStringToFOURCCW(LPCWSTR sz, UINT uFlags);

        __declspec(dllimport) LPMMIOPROC __stdcall mmioInstallIOProcA(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);

        __declspec(dllimport) LPMMIOPROC __stdcall mmioInstallIOProcW(FOURCC fccIOProc, LPMMIOPROC pIOProc, DWORD dwFlags);

        __declspec(dllimport) HMMIO __stdcall mmioOpenA(LPSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);

        __declspec(dllimport) HMMIO __stdcall mmioOpenW(LPWSTR pszFileName, LPMMIOINFO pmmioinfo, DWORD fdwOpen);

        __declspec(dllimport) MMRESULT
        __stdcall mmioRenameA(LPCSTR pszFileName, LPCSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);

        __declspec(dllimport) MMRESULT
        __stdcall mmioRenameW(LPCWSTR pszFileName, LPCWSTR pszNewFileName, LPCMMIOINFO pmmioinfo, DWORD fdwRename);

        __declspec(dllimport) MMRESULT __stdcall mmioClose(HMMIO hmmio, UINT fuClose);

        __declspec(dllimport) LONG __stdcall mmioRead(HMMIO hmmio, HPSTR pch, LONG cch);

        __declspec(dllimport) LONG __stdcall mmioWrite(HMMIO hmmio, const char* pch, LONG cch);

        __declspec(dllimport) LONG __stdcall mmioSeek(HMMIO hmmio, LONG lOffset, int iOrigin);

        __declspec(dllimport) MMRESULT __stdcall mmioGetInfo(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuInfo);

        __declspec(dllimport) MMRESULT __stdcall mmioSetInfo(HMMIO hmmio, LPCMMIOINFO pmmioinfo, UINT fuInfo);

        __declspec(dllimport) MMRESULT __stdcall mmioSetBuffer(HMMIO hmmio, LPSTR pchBuffer, LONG cchBuffer, UINT fuBuffer);

        __declspec(dllimport) MMRESULT __stdcall mmioFlush(HMMIO hmmio, UINT fuFlush);

        __declspec(dllimport) MMRESULT __stdcall mmioAdvance(HMMIO hmmio, LPMMIOINFO pmmioinfo, UINT fuAdvance);

        __declspec(dllimport) LRESULT __stdcall mmioSendMessage(HMMIO hmmio, UINT uMsg, LPARAM lParam1, LPARAM lParam2);

        __declspec(dllimport) MMRESULT
        __stdcall mmioDescend(HMMIO hmmio, LPMMCKINFO pmmcki, const MMCKINFO* pmmckiParent, UINT fuDescend);

        __declspec(dllimport) MMRESULT __stdcall mmioAscend(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuAscend);

        __declspec(dllimport) MMRESULT __stdcall mmioCreateChunk(HMMIO hmmio, LPMMCKINFO pmmcki, UINT fuCreate);

#pragma endregion
    }

#pragma once

    extern "C"
    {
#pragma region Desktop Family

        typedef void(__stdcall TIMECALLBACK)(UINT uTimerID, UINT uMsg, DWORD_PTR dwUser, DWORD_PTR dw1, DWORD_PTR dw2);
        typedef TIMECALLBACK* LPTIMECALLBACK;

        __declspec(dllimport) MMRESULT
        __stdcall timeSetEvent(UINT uDelay, UINT uResolution, LPTIMECALLBACK fptc, DWORD_PTR dwUser, UINT fuEvent);

        __declspec(dllimport) MMRESULT __stdcall timeKillEvent(UINT uTimerID);

#pragma endregion
    }

#pragma once

    extern "C"
    {
#pragma region Desktop Family

        __declspec(dllimport) BOOL __stdcall sndPlaySoundA(LPCSTR pszSound, UINT fuSound);

        __declspec(dllimport) BOOL __stdcall sndPlaySoundW(LPCWSTR pszSound, UINT fuSound);

        __declspec(dllimport) BOOL __stdcall PlaySoundA(LPCSTR pszSound, HMODULE hmod, DWORD fdwSound);

        __declspec(dllimport) BOOL __stdcall PlaySoundW(LPCWSTR pszSound, HMODULE hmod, DWORD fdwSound);

#pragma endregion
    }

#pragma once

    extern "C"
    {
#pragma region Desktop Family

        struct HWAVE__
        {
            int unused;
        };
        typedef struct HWAVE__* HWAVE;
        struct HWAVEIN__
        {
            int unused;
        };
        typedef struct HWAVEIN__* HWAVEIN;
        struct HWAVEOUT__
        {
            int unused;
        };
        typedef struct HWAVEOUT__* HWAVEOUT;
        typedef HWAVEIN* LPHWAVEIN;
        typedef HWAVEOUT* LPHWAVEOUT;
        typedef DRVCALLBACK WAVECALLBACK;
        typedef WAVECALLBACK* LPWAVECALLBACK;

        typedef struct wavehdr_tag
        {
            LPSTR lpData;
            DWORD dwBufferLength;
            DWORD dwBytesRecorded;
            DWORD_PTR dwUser;
            DWORD dwFlags;
            DWORD dwLoops;
            struct wavehdr_tag* lpNext;
            DWORD_PTR reserved;
        } WAVEHDR, *PWAVEHDR, *NPWAVEHDR, *LPWAVEHDR;

        typedef struct tagWAVEOUTCAPSA
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            DWORD dwFormats;
            WORD wChannels;
            WORD wReserved1;
            DWORD dwSupport;
        } WAVEOUTCAPSA, *PWAVEOUTCAPSA, *NPWAVEOUTCAPSA, *LPWAVEOUTCAPSA;
        typedef struct tagWAVEOUTCAPSW
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            DWORD dwFormats;
            WORD wChannels;
            WORD wReserved1;
            DWORD dwSupport;
        } WAVEOUTCAPSW, *PWAVEOUTCAPSW, *NPWAVEOUTCAPSW, *LPWAVEOUTCAPSW;

        typedef WAVEOUTCAPSA WAVEOUTCAPS;
        typedef PWAVEOUTCAPSA PWAVEOUTCAPS;
        typedef NPWAVEOUTCAPSA NPWAVEOUTCAPS;
        typedef LPWAVEOUTCAPSA LPWAVEOUTCAPS;
        typedef struct tagWAVEOUTCAPS2A
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            DWORD dwFormats;
            WORD wChannels;
            WORD wReserved1;
            DWORD dwSupport;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } WAVEOUTCAPS2A, *PWAVEOUTCAPS2A, *NPWAVEOUTCAPS2A, *LPWAVEOUTCAPS2A;
        typedef struct tagWAVEOUTCAPS2W
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            DWORD dwFormats;
            WORD wChannels;
            WORD wReserved1;
            DWORD dwSupport;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } WAVEOUTCAPS2W, *PWAVEOUTCAPS2W, *NPWAVEOUTCAPS2W, *LPWAVEOUTCAPS2W;

        typedef WAVEOUTCAPS2A WAVEOUTCAPS2;
        typedef PWAVEOUTCAPS2A PWAVEOUTCAPS2;
        typedef NPWAVEOUTCAPS2A NPWAVEOUTCAPS2;
        typedef LPWAVEOUTCAPS2A LPWAVEOUTCAPS2;

        typedef struct tagWAVEINCAPSA
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            DWORD dwFormats;
            WORD wChannels;
            WORD wReserved1;
        } WAVEINCAPSA, *PWAVEINCAPSA, *NPWAVEINCAPSA, *LPWAVEINCAPSA;
        typedef struct tagWAVEINCAPSW
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            DWORD dwFormats;
            WORD wChannels;
            WORD wReserved1;
        } WAVEINCAPSW, *PWAVEINCAPSW, *NPWAVEINCAPSW, *LPWAVEINCAPSW;

        typedef WAVEINCAPSA WAVEINCAPS;
        typedef PWAVEINCAPSA PWAVEINCAPS;
        typedef NPWAVEINCAPSA NPWAVEINCAPS;
        typedef LPWAVEINCAPSA LPWAVEINCAPS;
        typedef struct tagWAVEINCAPS2A
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            DWORD dwFormats;
            WORD wChannels;
            WORD wReserved1;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } WAVEINCAPS2A, *PWAVEINCAPS2A, *NPWAVEINCAPS2A, *LPWAVEINCAPS2A;
        typedef struct tagWAVEINCAPS2W
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            DWORD dwFormats;
            WORD wChannels;
            WORD wReserved1;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } WAVEINCAPS2W, *PWAVEINCAPS2W, *NPWAVEINCAPS2W, *LPWAVEINCAPS2W;

        typedef WAVEINCAPS2A WAVEINCAPS2;
        typedef PWAVEINCAPS2A PWAVEINCAPS2;
        typedef NPWAVEINCAPS2A NPWAVEINCAPS2;
        typedef LPWAVEINCAPS2A LPWAVEINCAPS2;

        typedef struct waveformat_tag
        {
            WORD wFormatTag;
            WORD nChannels;
            DWORD nSamplesPerSec;
            DWORD nAvgBytesPerSec;
            WORD nBlockAlign;
        } WAVEFORMAT, *PWAVEFORMAT, *NPWAVEFORMAT, *LPWAVEFORMAT;

        typedef struct pcmwaveformat_tag
        {
            WAVEFORMAT wf;
            WORD wBitsPerSample;
        } PCMWAVEFORMAT, *PPCMWAVEFORMAT, *NPPCMWAVEFORMAT, *LPPCMWAVEFORMAT;

        typedef struct tWAVEFORMATEX
        {
            WORD wFormatTag;
            WORD nChannels;
            DWORD nSamplesPerSec;
            DWORD nAvgBytesPerSec;
            WORD nBlockAlign;
            WORD wBitsPerSample;
            WORD cbSize;

        } WAVEFORMATEX, *PWAVEFORMATEX, *NPWAVEFORMATEX, *LPWAVEFORMATEX;

        typedef const WAVEFORMATEX* LPCWAVEFORMATEX;

        __declspec(dllimport) UINT __stdcall waveOutGetNumDevs(void);

        __declspec(dllimport) MMRESULT __stdcall waveOutGetDevCapsA(UINT_PTR uDeviceID, LPWAVEOUTCAPSA pwoc, UINT cbwoc);

        __declspec(dllimport) MMRESULT __stdcall waveOutGetDevCapsW(UINT_PTR uDeviceID, LPWAVEOUTCAPSW pwoc, UINT cbwoc);

        __declspec(dllimport) MMRESULT __stdcall waveOutGetVolume(HWAVEOUT hwo, LPDWORD pdwVolume);

        __declspec(dllimport) MMRESULT __stdcall waveOutSetVolume(HWAVEOUT hwo, DWORD dwVolume);

        __declspec(dllimport) MMRESULT __stdcall waveOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);

        __declspec(dllimport) MMRESULT __stdcall waveOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);

        __declspec(dllimport) MMRESULT
        __stdcall waveOutOpen(LPHWAVEOUT phwo, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);

        __declspec(dllimport) MMRESULT __stdcall waveOutClose(HWAVEOUT hwo);

        __declspec(dllimport) MMRESULT __stdcall waveOutPrepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);

        __declspec(dllimport) MMRESULT __stdcall waveOutUnprepareHeader(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);

        __declspec(dllimport) MMRESULT __stdcall waveOutWrite(HWAVEOUT hwo, LPWAVEHDR pwh, UINT cbwh);

        __declspec(dllimport) MMRESULT __stdcall waveOutPause(HWAVEOUT hwo);

        __declspec(dllimport) MMRESULT __stdcall waveOutRestart(HWAVEOUT hwo);

        __declspec(dllimport) MMRESULT __stdcall waveOutReset(HWAVEOUT hwo);

        __declspec(dllimport) MMRESULT __stdcall waveOutBreakLoop(HWAVEOUT hwo);

        __declspec(dllimport) MMRESULT __stdcall waveOutGetPosition(HWAVEOUT hwo, LPMMTIME pmmt, UINT cbmmt);

        __declspec(dllimport) MMRESULT __stdcall waveOutGetPitch(HWAVEOUT hwo, LPDWORD pdwPitch);

        __declspec(dllimport) MMRESULT __stdcall waveOutSetPitch(HWAVEOUT hwo, DWORD dwPitch);

        __declspec(dllimport) MMRESULT __stdcall waveOutGetPlaybackRate(HWAVEOUT hwo, LPDWORD pdwRate);

        __declspec(dllimport) MMRESULT __stdcall waveOutSetPlaybackRate(HWAVEOUT hwo, DWORD dwRate);

        __declspec(dllimport) MMRESULT __stdcall waveOutGetID(HWAVEOUT hwo, LPUINT puDeviceID);

        __declspec(dllimport) MMRESULT __stdcall waveOutMessage(HWAVEOUT hwo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2);

        __declspec(dllimport) UINT __stdcall waveInGetNumDevs(void);

        __declspec(dllimport) MMRESULT __stdcall waveInGetDevCapsA(UINT_PTR uDeviceID, LPWAVEINCAPSA pwic, UINT cbwic);

        __declspec(dllimport) MMRESULT __stdcall waveInGetDevCapsW(UINT_PTR uDeviceID, LPWAVEINCAPSW pwic, UINT cbwic);

        __declspec(dllimport) MMRESULT __stdcall waveInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);

        __declspec(dllimport) MMRESULT __stdcall waveInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);

        __declspec(dllimport) MMRESULT
        __stdcall waveInOpen(LPHWAVEIN phwi, UINT uDeviceID, LPCWAVEFORMATEX pwfx, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);

        __declspec(dllimport) MMRESULT __stdcall waveInClose(HWAVEIN hwi);

        __declspec(dllimport) MMRESULT __stdcall waveInPrepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);

        __declspec(dllimport) MMRESULT __stdcall waveInUnprepareHeader(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);

        __declspec(dllimport) MMRESULT __stdcall waveInAddBuffer(HWAVEIN hwi, LPWAVEHDR pwh, UINT cbwh);

        __declspec(dllimport) MMRESULT __stdcall waveInStart(HWAVEIN hwi);

        __declspec(dllimport) MMRESULT __stdcall waveInStop(HWAVEIN hwi);

        __declspec(dllimport) MMRESULT __stdcall waveInReset(HWAVEIN hwi);

        __declspec(dllimport) MMRESULT __stdcall waveInGetPosition(HWAVEIN hwi, LPMMTIME pmmt, UINT cbmmt);

        __declspec(dllimport) MMRESULT __stdcall waveInGetID(HWAVEIN hwi, LPUINT puDeviceID);

        __declspec(dllimport) MMRESULT __stdcall waveInMessage(HWAVEIN hwi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2);

        struct HMIDI__
        {
            int unused;
        };
        typedef struct HMIDI__* HMIDI;
        struct HMIDIIN__
        {
            int unused;
        };
        typedef struct HMIDIIN__* HMIDIIN;
        struct HMIDIOUT__
        {
            int unused;
        };
        typedef struct HMIDIOUT__* HMIDIOUT;
        struct HMIDISTRM__
        {
            int unused;
        };
        typedef struct HMIDISTRM__* HMIDISTRM;
        typedef HMIDI* LPHMIDI;
        typedef HMIDIIN* LPHMIDIIN;
        typedef HMIDIOUT* LPHMIDIOUT;
        typedef HMIDISTRM* LPHMIDISTRM;
        typedef DRVCALLBACK MIDICALLBACK;
        typedef MIDICALLBACK* LPMIDICALLBACK;

        typedef WORD PATCHARRAY[128];
        typedef WORD* LPPATCHARRAY;
        typedef WORD KEYARRAY[128];
        typedef WORD* LPKEYARRAY;

        typedef struct tagMIDIOUTCAPSA
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            WORD wTechnology;
            WORD wVoices;
            WORD wNotes;
            WORD wChannelMask;
            DWORD dwSupport;
        } MIDIOUTCAPSA, *PMIDIOUTCAPSA, *NPMIDIOUTCAPSA, *LPMIDIOUTCAPSA;
        typedef struct tagMIDIOUTCAPSW
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            WORD wTechnology;
            WORD wVoices;
            WORD wNotes;
            WORD wChannelMask;
            DWORD dwSupport;
        } MIDIOUTCAPSW, *PMIDIOUTCAPSW, *NPMIDIOUTCAPSW, *LPMIDIOUTCAPSW;

        typedef MIDIOUTCAPSA MIDIOUTCAPS;
        typedef PMIDIOUTCAPSA PMIDIOUTCAPS;
        typedef NPMIDIOUTCAPSA NPMIDIOUTCAPS;
        typedef LPMIDIOUTCAPSA LPMIDIOUTCAPS;
        typedef struct tagMIDIOUTCAPS2A
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            WORD wTechnology;
            WORD wVoices;
            WORD wNotes;
            WORD wChannelMask;
            DWORD dwSupport;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } MIDIOUTCAPS2A, *PMIDIOUTCAPS2A, *NPMIDIOUTCAPS2A, *LPMIDIOUTCAPS2A;
        typedef struct tagMIDIOUTCAPS2W
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            WORD wTechnology;
            WORD wVoices;
            WORD wNotes;
            WORD wChannelMask;
            DWORD dwSupport;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } MIDIOUTCAPS2W, *PMIDIOUTCAPS2W, *NPMIDIOUTCAPS2W, *LPMIDIOUTCAPS2W;

        typedef MIDIOUTCAPS2A MIDIOUTCAPS2;
        typedef PMIDIOUTCAPS2A PMIDIOUTCAPS2;
        typedef NPMIDIOUTCAPS2A NPMIDIOUTCAPS2;
        typedef LPMIDIOUTCAPS2A LPMIDIOUTCAPS2;

        typedef struct tagMIDIINCAPSA
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];

            DWORD dwSupport;
        } MIDIINCAPSA, *PMIDIINCAPSA, *NPMIDIINCAPSA, *LPMIDIINCAPSA;
        typedef struct tagMIDIINCAPSW
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];

            DWORD dwSupport;
        } MIDIINCAPSW, *PMIDIINCAPSW, *NPMIDIINCAPSW, *LPMIDIINCAPSW;

        typedef MIDIINCAPSA MIDIINCAPS;
        typedef PMIDIINCAPSA PMIDIINCAPS;
        typedef NPMIDIINCAPSA NPMIDIINCAPS;
        typedef LPMIDIINCAPSA LPMIDIINCAPS;
        typedef struct tagMIDIINCAPS2A
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];

            DWORD dwSupport;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } MIDIINCAPS2A, *PMIDIINCAPS2A, *NPMIDIINCAPS2A, *LPMIDIINCAPS2A;
        typedef struct tagMIDIINCAPS2W
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];

            DWORD dwSupport;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } MIDIINCAPS2W, *PMIDIINCAPS2W, *NPMIDIINCAPS2W, *LPMIDIINCAPS2W;

        typedef MIDIINCAPS2A MIDIINCAPS2;
        typedef PMIDIINCAPS2A PMIDIINCAPS2;
        typedef NPMIDIINCAPS2A NPMIDIINCAPS2;
        typedef LPMIDIINCAPS2A LPMIDIINCAPS2;

        typedef struct midihdr_tag
        {
            LPSTR lpData;
            DWORD dwBufferLength;
            DWORD dwBytesRecorded;
            DWORD_PTR dwUser;
            DWORD dwFlags;
            struct midihdr_tag* lpNext;
            DWORD_PTR reserved;

            DWORD dwOffset;
            DWORD_PTR dwReserved[8];
        } MIDIHDR, *PMIDIHDR, *NPMIDIHDR, *LPMIDIHDR;

        typedef struct midievent_tag
        {
            DWORD dwDeltaTime;
            DWORD dwStreamID;
            DWORD dwEvent;
            DWORD dwParms[1];
        } MIDIEVENT;

        typedef struct midistrmbuffver_tag
        {
            DWORD dwVersion;
            DWORD dwMid;
            DWORD dwOEMVersion;
        } MIDISTRMBUFFVER;

        typedef struct midiproptimediv_tag
        {
            DWORD cbStruct;
            DWORD dwTimeDiv;
        } MIDIPROPTIMEDIV, *LPMIDIPROPTIMEDIV;

        typedef struct midiproptempo_tag
        {
            DWORD cbStruct;
            DWORD dwTempo;
        } MIDIPROPTEMPO, *LPMIDIPROPTEMPO;

        __declspec(dllimport) UINT __stdcall midiOutGetNumDevs(void);

        __declspec(dllimport) MMRESULT
        __stdcall midiStreamOpen(LPHMIDISTRM phms, LPUINT puDeviceID, DWORD cMidi, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);

        __declspec(dllimport) MMRESULT __stdcall midiStreamClose(HMIDISTRM hms);

        __declspec(dllimport) MMRESULT __stdcall midiStreamProperty(HMIDISTRM hms, LPBYTE lppropdata, DWORD dwProperty);

        __declspec(dllimport) MMRESULT __stdcall midiStreamPosition(HMIDISTRM hms, LPMMTIME lpmmt, UINT cbmmt);

        __declspec(dllimport) MMRESULT __stdcall midiStreamOut(HMIDISTRM hms, LPMIDIHDR pmh, UINT cbmh);

        __declspec(dllimport) MMRESULT __stdcall midiStreamPause(HMIDISTRM hms);

        __declspec(dllimport) MMRESULT __stdcall midiStreamRestart(HMIDISTRM hms);

        __declspec(dllimport) MMRESULT __stdcall midiStreamStop(HMIDISTRM hms);

        __declspec(dllimport) MMRESULT __stdcall midiConnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);

        __declspec(dllimport) MMRESULT __stdcall midiDisconnect(HMIDI hmi, HMIDIOUT hmo, LPVOID pReserved);

        __declspec(dllimport) MMRESULT __stdcall midiOutGetDevCapsA(UINT_PTR uDeviceID, LPMIDIOUTCAPSA pmoc, UINT cbmoc);

        __declspec(dllimport) MMRESULT __stdcall midiOutGetDevCapsW(UINT_PTR uDeviceID, LPMIDIOUTCAPSW pmoc, UINT cbmoc);

        __declspec(dllimport) MMRESULT __stdcall midiOutGetVolume(HMIDIOUT hmo, LPDWORD pdwVolume);

        __declspec(dllimport) MMRESULT __stdcall midiOutSetVolume(HMIDIOUT hmo, DWORD dwVolume);

        __declspec(dllimport) MMRESULT __stdcall midiOutGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);

        __declspec(dllimport) MMRESULT __stdcall midiOutGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);

        __declspec(dllimport) MMRESULT
        __stdcall midiOutOpen(LPHMIDIOUT phmo, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);

        __declspec(dllimport) MMRESULT __stdcall midiOutClose(HMIDIOUT hmo);

        __declspec(dllimport) MMRESULT __stdcall midiOutPrepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);

        __declspec(dllimport) MMRESULT __stdcall midiOutUnprepareHeader(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);

        __declspec(dllimport) MMRESULT __stdcall midiOutShortMsg(HMIDIOUT hmo, DWORD dwMsg);

        __declspec(dllimport) MMRESULT __stdcall midiOutLongMsg(HMIDIOUT hmo, LPMIDIHDR pmh, UINT cbmh);

        __declspec(dllimport) MMRESULT __stdcall midiOutReset(HMIDIOUT hmo);

        __declspec(dllimport) MMRESULT __stdcall midiOutCachePatches(HMIDIOUT hmo, UINT uBank, LPWORD pwpa, UINT fuCache);

        __declspec(dllimport) MMRESULT __stdcall midiOutCacheDrumPatches(HMIDIOUT hmo, UINT uPatch, LPWORD pwkya, UINT fuCache);

        __declspec(dllimport) MMRESULT __stdcall midiOutGetID(HMIDIOUT hmo, LPUINT puDeviceID);

        __declspec(dllimport) MMRESULT __stdcall midiOutMessage(HMIDIOUT hmo, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2);

        __declspec(dllimport) UINT __stdcall midiInGetNumDevs(void);

        __declspec(dllimport) MMRESULT __stdcall midiInGetDevCapsA(UINT_PTR uDeviceID, LPMIDIINCAPSA pmic, UINT cbmic);

        __declspec(dllimport) MMRESULT __stdcall midiInGetDevCapsW(UINT_PTR uDeviceID, LPMIDIINCAPSW pmic, UINT cbmic);

        __declspec(dllimport) MMRESULT __stdcall midiInGetErrorTextA(MMRESULT mmrError, LPSTR pszText, UINT cchText);

        __declspec(dllimport) MMRESULT __stdcall midiInGetErrorTextW(MMRESULT mmrError, LPWSTR pszText, UINT cchText);

        __declspec(dllimport) MMRESULT
        __stdcall midiInOpen(LPHMIDIIN phmi, UINT uDeviceID, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);

        __declspec(dllimport) MMRESULT __stdcall midiInClose(HMIDIIN hmi);

        __declspec(dllimport) MMRESULT __stdcall midiInPrepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);

        __declspec(dllimport) MMRESULT __stdcall midiInUnprepareHeader(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);

        __declspec(dllimport) MMRESULT __stdcall midiInAddBuffer(HMIDIIN hmi, LPMIDIHDR pmh, UINT cbmh);

        __declspec(dllimport) MMRESULT __stdcall midiInStart(HMIDIIN hmi);

        __declspec(dllimport) MMRESULT __stdcall midiInStop(HMIDIIN hmi);

        __declspec(dllimport) MMRESULT __stdcall midiInReset(HMIDIIN hmi);

        __declspec(dllimport) MMRESULT __stdcall midiInGetID(HMIDIIN hmi, LPUINT puDeviceID);

        __declspec(dllimport) MMRESULT __stdcall midiInMessage(HMIDIIN hmi, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2);

        typedef struct tagAUXCAPSA
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            WORD wTechnology;
            WORD wReserved1;
            DWORD dwSupport;
        } AUXCAPSA, *PAUXCAPSA, *NPAUXCAPSA, *LPAUXCAPSA;
        typedef struct tagAUXCAPSW
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            WORD wTechnology;
            WORD wReserved1;
            DWORD dwSupport;
        } AUXCAPSW, *PAUXCAPSW, *NPAUXCAPSW, *LPAUXCAPSW;

        typedef AUXCAPSA AUXCAPS;
        typedef PAUXCAPSA PAUXCAPS;
        typedef NPAUXCAPSA NPAUXCAPS;
        typedef LPAUXCAPSA LPAUXCAPS;
        typedef struct tagAUXCAPS2A
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            WORD wTechnology;
            WORD wReserved1;
            DWORD dwSupport;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } AUXCAPS2A, *PAUXCAPS2A, *NPAUXCAPS2A, *LPAUXCAPS2A;
        typedef struct tagAUXCAPS2W
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            WORD wTechnology;
            WORD wReserved1;
            DWORD dwSupport;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } AUXCAPS2W, *PAUXCAPS2W, *NPAUXCAPS2W, *LPAUXCAPS2W;

        typedef AUXCAPS2A AUXCAPS2;
        typedef PAUXCAPS2A PAUXCAPS2;
        typedef NPAUXCAPS2A NPAUXCAPS2;
        typedef LPAUXCAPS2A LPAUXCAPS2;

        __declspec(dllimport) UINT __stdcall auxGetNumDevs(void);

        __declspec(dllimport) MMRESULT __stdcall auxGetDevCapsA(UINT_PTR uDeviceID, LPAUXCAPSA pac, UINT cbac);

        __declspec(dllimport) MMRESULT __stdcall auxGetDevCapsW(UINT_PTR uDeviceID, LPAUXCAPSW pac, UINT cbac);

        __declspec(dllimport) MMRESULT __stdcall auxSetVolume(UINT uDeviceID, DWORD dwVolume);

        __declspec(dllimport) MMRESULT __stdcall auxGetVolume(UINT uDeviceID, LPDWORD pdwVolume);

        __declspec(dllimport) MMRESULT __stdcall auxOutMessage(UINT uDeviceID, UINT uMsg, DWORD_PTR dw1, DWORD_PTR dw2);

        struct HMIXEROBJ__
        {
            int unused;
        };
        typedef struct HMIXEROBJ__* HMIXEROBJ;
        typedef HMIXEROBJ* LPHMIXEROBJ;

        struct HMIXER__
        {
            int unused;
        };
        typedef struct HMIXER__* HMIXER;
        typedef HMIXER* LPHMIXER;

        __declspec(dllimport) UINT __stdcall mixerGetNumDevs(void);

        typedef struct tagMIXERCAPSA
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            DWORD fdwSupport;
            DWORD cDestinations;
        } MIXERCAPSA, *PMIXERCAPSA, *LPMIXERCAPSA;
        typedef struct tagMIXERCAPSW
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            DWORD fdwSupport;
            DWORD cDestinations;
        } MIXERCAPSW, *PMIXERCAPSW, *LPMIXERCAPSW;

        typedef MIXERCAPSA MIXERCAPS;
        typedef PMIXERCAPSA PMIXERCAPS;
        typedef LPMIXERCAPSA LPMIXERCAPS;
        typedef struct tagMIXERCAPS2A
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            CHAR szPname[32];
            DWORD fdwSupport;
            DWORD cDestinations;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } MIXERCAPS2A, *PMIXERCAPS2A, *LPMIXERCAPS2A;
        typedef struct tagMIXERCAPS2W
        {
            WORD wMid;
            WORD wPid;
            MMVERSION vDriverVersion;
            WCHAR szPname[32];
            DWORD fdwSupport;
            DWORD cDestinations;
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } MIXERCAPS2W, *PMIXERCAPS2W, *LPMIXERCAPS2W;

        typedef MIXERCAPS2A MIXERCAPS2;
        typedef PMIXERCAPS2A PMIXERCAPS2;
        typedef LPMIXERCAPS2A LPMIXERCAPS2;

        __declspec(dllimport) MMRESULT __stdcall mixerGetDevCapsA(UINT_PTR uMxId, LPMIXERCAPSA pmxcaps, UINT cbmxcaps);

        __declspec(dllimport) MMRESULT __stdcall mixerGetDevCapsW(UINT_PTR uMxId, LPMIXERCAPSW pmxcaps, UINT cbmxcaps);

        __declspec(dllimport) MMRESULT
        __stdcall mixerOpen(LPHMIXER phmx, UINT uMxId, DWORD_PTR dwCallback, DWORD_PTR dwInstance, DWORD fdwOpen);

        __declspec(dllimport) MMRESULT __stdcall mixerClose(HMIXER hmx);

        __declspec(dllimport) DWORD __stdcall mixerMessage(HMIXER hmx, UINT uMsg, DWORD_PTR dwParam1, DWORD_PTR dwParam2);

        typedef struct tagMIXERLINEA
        {
            DWORD cbStruct;
            DWORD dwDestination;
            DWORD dwSource;
            DWORD dwLineID;
            DWORD fdwLine;
            DWORD_PTR dwUser;
            DWORD dwComponentType;
            DWORD cChannels;
            DWORD cConnections;
            DWORD cControls;
            CHAR szShortName[16];
            CHAR szName[64];
            struct
            {
                DWORD dwType;
                DWORD dwDeviceID;
                WORD wMid;
                WORD wPid;
                MMVERSION vDriverVersion;
                CHAR szPname[32];
            } Target;
        } MIXERLINEA, *PMIXERLINEA, *LPMIXERLINEA;
        typedef struct tagMIXERLINEW
        {
            DWORD cbStruct;
            DWORD dwDestination;
            DWORD dwSource;
            DWORD dwLineID;
            DWORD fdwLine;
            DWORD_PTR dwUser;
            DWORD dwComponentType;
            DWORD cChannels;
            DWORD cConnections;
            DWORD cControls;
            WCHAR szShortName[16];
            WCHAR szName[64];
            struct
            {
                DWORD dwType;
                DWORD dwDeviceID;
                WORD wMid;
                WORD wPid;
                MMVERSION vDriverVersion;
                WCHAR szPname[32];
            } Target;
        } MIXERLINEW, *PMIXERLINEW, *LPMIXERLINEW;

        typedef MIXERLINEA MIXERLINE;
        typedef PMIXERLINEA PMIXERLINE;
        typedef LPMIXERLINEA LPMIXERLINE;

        __declspec(dllimport) MMRESULT __stdcall mixerGetLineInfoA(HMIXEROBJ hmxobj, LPMIXERLINEA pmxl, DWORD fdwInfo);

        __declspec(dllimport) MMRESULT __stdcall mixerGetLineInfoW(HMIXEROBJ hmxobj, LPMIXERLINEW pmxl, DWORD fdwInfo);

        __declspec(dllimport) MMRESULT __stdcall mixerGetID(HMIXEROBJ hmxobj, UINT* puMxId, DWORD fdwId);

        typedef struct tagMIXERCONTROLA
        {
            DWORD cbStruct;
            DWORD dwControlID;
            DWORD dwControlType;
            DWORD fdwControl;
            DWORD cMultipleItems;
            CHAR szShortName[16];
            CHAR szName[64];
            union
            {
                struct
                {
                    LONG lMinimum;
                    LONG lMaximum;
                };
                struct
                {
                    DWORD dwMinimum;
                    DWORD dwMaximum;
                };
                DWORD dwReserved[6];
            } Bounds;
            union
            {
                DWORD cSteps;
                DWORD cbCustomData;
                DWORD dwReserved[6];
            } Metrics;
        } MIXERCONTROLA, *PMIXERCONTROLA, *LPMIXERCONTROLA;
        typedef struct tagMIXERCONTROLW
        {
            DWORD cbStruct;
            DWORD dwControlID;
            DWORD dwControlType;
            DWORD fdwControl;
            DWORD cMultipleItems;
            WCHAR szShortName[16];
            WCHAR szName[64];
            union
            {
                struct
                {
                    LONG lMinimum;
                    LONG lMaximum;
                };
                struct
                {
                    DWORD dwMinimum;
                    DWORD dwMaximum;
                };
                DWORD dwReserved[6];
            } Bounds;
            union
            {
                DWORD cSteps;
                DWORD cbCustomData;
                DWORD dwReserved[6];
            } Metrics;
        } MIXERCONTROLW, *PMIXERCONTROLW, *LPMIXERCONTROLW;

        typedef MIXERCONTROLA MIXERCONTROL;
        typedef PMIXERCONTROLA PMIXERCONTROL;
        typedef LPMIXERCONTROLA LPMIXERCONTROL;

        typedef struct tagMIXERLINECONTROLSA
        {
            DWORD cbStruct;
            DWORD dwLineID;
            union
            {
                DWORD dwControlID;
                DWORD dwControlType;
            };
            DWORD cControls;
            DWORD cbmxctrl;
            LPMIXERCONTROLA pamxctrl;
        } MIXERLINECONTROLSA, *PMIXERLINECONTROLSA, *LPMIXERLINECONTROLSA;
        typedef struct tagMIXERLINECONTROLSW
        {
            DWORD cbStruct;
            DWORD dwLineID;
            union
            {
                DWORD dwControlID;
                DWORD dwControlType;
            };
            DWORD cControls;
            DWORD cbmxctrl;
            LPMIXERCONTROLW pamxctrl;
        } MIXERLINECONTROLSW, *PMIXERLINECONTROLSW, *LPMIXERLINECONTROLSW;

        typedef MIXERLINECONTROLSA MIXERLINECONTROLS;
        typedef PMIXERLINECONTROLSA PMIXERLINECONTROLS;
        typedef LPMIXERLINECONTROLSA LPMIXERLINECONTROLS;

        __declspec(dllimport) MMRESULT
        __stdcall mixerGetLineControlsA(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSA pmxlc, DWORD fdwControls);

        __declspec(dllimport) MMRESULT
        __stdcall mixerGetLineControlsW(HMIXEROBJ hmxobj, LPMIXERLINECONTROLSW pmxlc, DWORD fdwControls);

        typedef struct tMIXERCONTROLDETAILS
        {
            DWORD cbStruct;
            DWORD dwControlID;
            DWORD cChannels;
            union
            {
                HWND hwndOwner;
                DWORD cMultipleItems;
            };
            DWORD cbDetails;
            LPVOID paDetails;
        } MIXERCONTROLDETAILS, *PMIXERCONTROLDETAILS, *LPMIXERCONTROLDETAILS;

        typedef struct tagMIXERCONTROLDETAILS_LISTTEXTA
        {
            DWORD dwParam1;
            DWORD dwParam2;
            CHAR szName[64];
        } MIXERCONTROLDETAILS_LISTTEXTA, *PMIXERCONTROLDETAILS_LISTTEXTA, *LPMIXERCONTROLDETAILS_LISTTEXTA;
        typedef struct tagMIXERCONTROLDETAILS_LISTTEXTW
        {
            DWORD dwParam1;
            DWORD dwParam2;
            WCHAR szName[64];
        } MIXERCONTROLDETAILS_LISTTEXTW, *PMIXERCONTROLDETAILS_LISTTEXTW, *LPMIXERCONTROLDETAILS_LISTTEXTW;

        typedef MIXERCONTROLDETAILS_LISTTEXTA MIXERCONTROLDETAILS_LISTTEXT;
        typedef PMIXERCONTROLDETAILS_LISTTEXTA PMIXERCONTROLDETAILS_LISTTEXT;
        typedef LPMIXERCONTROLDETAILS_LISTTEXTA LPMIXERCONTROLDETAILS_LISTTEXT;

        typedef struct tMIXERCONTROLDETAILS_BOOLEAN
        {
            LONG fValue;
        } MIXERCONTROLDETAILS_BOOLEAN, *PMIXERCONTROLDETAILS_BOOLEAN, *LPMIXERCONTROLDETAILS_BOOLEAN;

        typedef struct tMIXERCONTROLDETAILS_SIGNED
        {
            LONG lValue;
        } MIXERCONTROLDETAILS_SIGNED, *PMIXERCONTROLDETAILS_SIGNED, *LPMIXERCONTROLDETAILS_SIGNED;

        typedef struct tMIXERCONTROLDETAILS_UNSIGNED
        {
            DWORD dwValue;
        } MIXERCONTROLDETAILS_UNSIGNED, *PMIXERCONTROLDETAILS_UNSIGNED, *LPMIXERCONTROLDETAILS_UNSIGNED;

        __declspec(dllimport) MMRESULT
        __stdcall mixerGetControlDetailsA(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);

        __declspec(dllimport) MMRESULT
        __stdcall mixerGetControlDetailsW(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);

        __declspec(dllimport) MMRESULT
        __stdcall mixerSetControlDetails(HMIXEROBJ hmxobj, LPMIXERCONTROLDETAILS pmxcd, DWORD fdwDetails);

#pragma endregion
    }

#pragma endregion

#pragma region Desktop Family or OneCore Family

#pragma once

    extern "C"
    {
#pragma region Desktop Family or OneCore Family

        typedef struct timecaps_tag
        {
            UINT wPeriodMin;
            UINT wPeriodMax;
        } TIMECAPS, *PTIMECAPS, *NPTIMECAPS, *LPTIMECAPS;

        __declspec(dllimport) MMRESULT __stdcall timeGetSystemTime(LPMMTIME pmmt, UINT cbmmt);

        __declspec(dllimport) DWORD __stdcall timeGetTime(void);

        __declspec(dllimport) MMRESULT __stdcall timeGetDevCaps(LPTIMECAPS ptc, UINT cbtc);

        __declspec(dllimport) MMRESULT __stdcall timeBeginPeriod(UINT uPeriod);

        __declspec(dllimport) MMRESULT __stdcall timeEndPeriod(UINT uPeriod);

#pragma endregion
    }

#pragma endregion

#pragma region Desktop Family

#pragma once

    extern "C"
    {
#pragma region Desktop Family

        typedef struct tagJOYCAPSA
        {
            WORD wMid;
            WORD wPid;
            CHAR szPname[32];
            UINT wXmin;
            UINT wXmax;
            UINT wYmin;
            UINT wYmax;
            UINT wZmin;
            UINT wZmax;
            UINT wNumButtons;
            UINT wPeriodMin;
            UINT wPeriodMax;

            UINT wRmin;
            UINT wRmax;
            UINT wUmin;
            UINT wUmax;
            UINT wVmin;
            UINT wVmax;
            UINT wCaps;
            UINT wMaxAxes;
            UINT wNumAxes;
            UINT wMaxButtons;
            CHAR szRegKey[32];
            CHAR szOEMVxD[260];
        } JOYCAPSA, *PJOYCAPSA, *NPJOYCAPSA, *LPJOYCAPSA;
        typedef struct tagJOYCAPSW
        {
            WORD wMid;
            WORD wPid;
            WCHAR szPname[32];
            UINT wXmin;
            UINT wXmax;
            UINT wYmin;
            UINT wYmax;
            UINT wZmin;
            UINT wZmax;
            UINT wNumButtons;
            UINT wPeriodMin;
            UINT wPeriodMax;

            UINT wRmin;
            UINT wRmax;
            UINT wUmin;
            UINT wUmax;
            UINT wVmin;
            UINT wVmax;
            UINT wCaps;
            UINT wMaxAxes;
            UINT wNumAxes;
            UINT wMaxButtons;
            WCHAR szRegKey[32];
            WCHAR szOEMVxD[260];
        } JOYCAPSW, *PJOYCAPSW, *NPJOYCAPSW, *LPJOYCAPSW;

        typedef JOYCAPSA JOYCAPS;
        typedef PJOYCAPSA PJOYCAPS;
        typedef NPJOYCAPSA NPJOYCAPS;
        typedef LPJOYCAPSA LPJOYCAPS;
        typedef struct tagJOYCAPS2A
        {
            WORD wMid;
            WORD wPid;
            CHAR szPname[32];
            UINT wXmin;
            UINT wXmax;
            UINT wYmin;
            UINT wYmax;
            UINT wZmin;
            UINT wZmax;
            UINT wNumButtons;
            UINT wPeriodMin;
            UINT wPeriodMax;
            UINT wRmin;
            UINT wRmax;
            UINT wUmin;
            UINT wUmax;
            UINT wVmin;
            UINT wVmax;
            UINT wCaps;
            UINT wMaxAxes;
            UINT wNumAxes;
            UINT wMaxButtons;
            CHAR szRegKey[32];
            CHAR szOEMVxD[260];
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } JOYCAPS2A, *PJOYCAPS2A, *NPJOYCAPS2A, *LPJOYCAPS2A;
        typedef struct tagJOYCAPS2W
        {
            WORD wMid;
            WORD wPid;
            WCHAR szPname[32];
            UINT wXmin;
            UINT wXmax;
            UINT wYmin;
            UINT wYmax;
            UINT wZmin;
            UINT wZmax;
            UINT wNumButtons;
            UINT wPeriodMin;
            UINT wPeriodMax;
            UINT wRmin;
            UINT wRmax;
            UINT wUmin;
            UINT wUmax;
            UINT wVmin;
            UINT wVmax;
            UINT wCaps;
            UINT wMaxAxes;
            UINT wNumAxes;
            UINT wMaxButtons;
            WCHAR szRegKey[32];
            WCHAR szOEMVxD[260];
            GUID ManufacturerGuid;
            GUID ProductGuid;
            GUID NameGuid;
        } JOYCAPS2W, *PJOYCAPS2W, *NPJOYCAPS2W, *LPJOYCAPS2W;

        typedef JOYCAPS2A JOYCAPS2;
        typedef PJOYCAPS2A PJOYCAPS2;
        typedef NPJOYCAPS2A NPJOYCAPS2;
        typedef LPJOYCAPS2A LPJOYCAPS2;

        typedef struct joyinfo_tag
        {
            UINT wXpos;
            UINT wYpos;
            UINT wZpos;
            UINT wButtons;
        } JOYINFO, *PJOYINFO, *NPJOYINFO, *LPJOYINFO;

        typedef struct joyinfoex_tag
        {
            DWORD dwSize;
            DWORD dwFlags;
            DWORD dwXpos;
            DWORD dwYpos;
            DWORD dwZpos;
            DWORD dwRpos;
            DWORD dwUpos;
            DWORD dwVpos;
            DWORD dwButtons;
            DWORD dwButtonNumber;
            DWORD dwPOV;
            DWORD dwReserved1;
            DWORD dwReserved2;
        } JOYINFOEX, *PJOYINFOEX, *NPJOYINFOEX, *LPJOYINFOEX;

        __declspec(dllimport) MMRESULT __stdcall joyGetPosEx(UINT uJoyID, LPJOYINFOEX pji);

        __declspec(dllimport) UINT __stdcall joyGetNumDevs(void);

        __declspec(dllimport) MMRESULT __stdcall joyGetDevCapsA(UINT_PTR uJoyID, LPJOYCAPSA pjc, UINT cbjc);

        __declspec(dllimport) MMRESULT __stdcall joyGetDevCapsW(UINT_PTR uJoyID, LPJOYCAPSW pjc, UINT cbjc);

        __declspec(dllimport) MMRESULT __stdcall joyGetPos(UINT uJoyID, LPJOYINFO pji);

        __declspec(dllimport) MMRESULT __stdcall joyGetThreshold(UINT uJoyID, LPUINT puThreshold);

        __declspec(dllimport) MMRESULT __stdcall joyReleaseCapture(UINT uJoyID);

        __declspec(dllimport) MMRESULT __stdcall joySetCapture(HWND hwnd, UINT uJoyID, UINT uPeriod, BOOL fChanged);

        __declspec(dllimport) MMRESULT __stdcall joySetThreshold(UINT uJoyID, UINT uThreshold);

        __declspec(dllimport) MMRESULT __stdcall joyConfigChanged(DWORD dwFlags);

#pragma endregion
    }

#pragma endregion
}

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma once

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

#pragma region Desktop Family

    typedef struct _NCB
    {
        UCHAR ncb_command;
        UCHAR ncb_retcode;
        UCHAR ncb_lsn;
        UCHAR ncb_num;
        PUCHAR ncb_buffer;
        WORD ncb_length;
        UCHAR ncb_callname[16];
        UCHAR ncb_name[16];
        UCHAR ncb_rto;
        UCHAR ncb_sto;
        void(__stdcall* ncb_post)(struct _NCB*);
        UCHAR ncb_lana_num;
        UCHAR ncb_cmd_cplt;

        UCHAR ncb_reserve[18];

        HANDLE ncb_event;

    } NCB, *PNCB;

    typedef struct _ADAPTER_STATUS
    {
        UCHAR adapter_address[6];
        UCHAR rev_major;
        UCHAR reserved0;
        UCHAR adapter_type;
        UCHAR rev_minor;
        WORD duration;
        WORD frmr_recv;
        WORD frmr_xmit;

        WORD iframe_recv_err;

        WORD xmit_aborts;
        DWORD xmit_success;
        DWORD recv_success;

        WORD iframe_xmit_err;

        WORD recv_buff_unavail;
        WORD t1_timeouts;
        WORD ti_timeouts;
        DWORD reserved1;
        WORD free_ncbs;
        WORD max_cfg_ncbs;
        WORD max_ncbs;
        WORD xmit_buf_unavail;
        WORD max_dgram_size;
        WORD pending_sess;
        WORD max_cfg_sess;
        WORD max_sess;
        WORD max_sess_pkt_size;
        WORD name_count;
    } ADAPTER_STATUS, *PADAPTER_STATUS;

    typedef struct _NAME_BUFFER
    {
        UCHAR name[16];
        UCHAR name_num;
        UCHAR name_flags;
    } NAME_BUFFER, *PNAME_BUFFER;

    typedef struct _SESSION_HEADER
    {
        UCHAR sess_name;
        UCHAR num_sess;
        UCHAR rcv_dg_outstanding;
        UCHAR rcv_any_outstanding;
    } SESSION_HEADER, *PSESSION_HEADER;

    typedef struct _SESSION_BUFFER
    {
        UCHAR lsn;
        UCHAR state;
        UCHAR local_name[16];
        UCHAR remote_name[16];
        UCHAR rcvs_outstanding;
        UCHAR sends_outstanding;
    } SESSION_BUFFER, *PSESSION_BUFFER;

    typedef struct _LANA_ENUM
    {
        UCHAR length;
        UCHAR lana[254 + 1];
    } LANA_ENUM, *PLANA_ENUM;

    typedef struct _FIND_NAME_HEADER
    {
        WORD node_count;
        UCHAR reserved;
        UCHAR unique_group;
    } FIND_NAME_HEADER, *PFIND_NAME_HEADER;

    typedef struct _FIND_NAME_BUFFER
    {
        UCHAR length;
        UCHAR access_control;
        UCHAR frame_control;
        UCHAR destination_addr[6];
        UCHAR source_addr[6];
        UCHAR routing_info[18];
    } FIND_NAME_BUFFER, *PFIND_NAME_BUFFER;

    typedef struct _ACTION_HEADER
    {
        ULONG transport_id;
        USHORT action_code;
        USHORT reserved;
    } ACTION_HEADER, *PACTION_HEADER;

    UCHAR
    __stdcall Netbios(PNCB pncb);

#pragma endregion

#pragma warning(pop)
}

#pragma once

extern "C"
{
#pragma warning(disable : 4103)

#pragma pack(push, 8)

    typedef void* I_RPC_HANDLE;

    typedef long RPC_STATUS;

#pragma once

    extern "C"
    {
#pragma warning(push)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)

#pragma region Application Family or OneCore Family

        typedef unsigned char* RPC_CSTR;

        typedef unsigned short* RPC_WSTR;
        typedef const unsigned short* RPC_CWSTR;

        typedef I_RPC_HANDLE RPC_BINDING_HANDLE;
        typedef RPC_BINDING_HANDLE handle_t;

        typedef GUID UUID;

#pragma endregion

#pragma region Desktop Family or OneCore Family

        typedef struct _RPC_BINDING_VECTOR
        {
            unsigned long Count;
            RPC_BINDING_HANDLE BindingH[1];
        } RPC_BINDING_VECTOR;

        typedef struct _UUID_VECTOR
        {
            unsigned long Count;
            UUID* Uuid[1];
        } UUID_VECTOR;

#pragma endregion

#pragma region Application Family or OneCore Family

        typedef void* RPC_IF_HANDLE;

        typedef struct _RPC_IF_ID
        {
            UUID Uuid;
            unsigned short VersMajor;
            unsigned short VersMinor;
        } RPC_IF_ID;

#pragma endregion

#pragma region Desktop Family or OneCore Family

        typedef struct _RPC_PROTSEQ_VECTORA
        {
            unsigned int Count;
            unsigned char* Protseq[1];
        } RPC_PROTSEQ_VECTORA;

        typedef struct _RPC_PROTSEQ_VECTORW
        {
            unsigned int Count;
            unsigned short* Protseq[1];
        } RPC_PROTSEQ_VECTORW;

        typedef struct _RPC_POLICY
        {
            unsigned int Length;
            unsigned long EndpointFlags;
            unsigned long NICFlags;
        } RPC_POLICY, *PRPC_POLICY;

        typedef void __stdcall RPC_OBJECT_INQ_FN(UUID* ObjectUuid, UUID* TypeUuid, RPC_STATUS* Status);

        typedef RPC_STATUS __stdcall RPC_IF_CALLBACK_FN(RPC_IF_HANDLE InterfaceUuid, void* Context);

        typedef void __stdcall RPC_SECURITY_CALLBACK_FN(void* Context);

#pragma endregion

#pragma region Application Family or OneCore Family

        typedef struct
        {
            unsigned int Count;
            unsigned long Stats[1];
        } RPC_STATS_VECTOR;

        typedef struct
        {
            unsigned long Count;
            RPC_IF_ID* IfId[1];
        } RPC_IF_ID_VECTOR;

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingCopy(RPC_BINDING_HANDLE SourceBinding, RPC_BINDING_HANDLE* DestinationBinding);

        __declspec(dllimport) RPC_STATUS __stdcall RpcBindingFree(RPC_BINDING_HANDLE* Binding);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingSetOption(RPC_BINDING_HANDLE hBinding, unsigned long option, ULONG_PTR optionValue);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingInqOption(RPC_BINDING_HANDLE hBinding, unsigned long option, ULONG_PTR* pOptionValue);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingFromStringBindingA(RPC_CSTR StringBinding, RPC_BINDING_HANDLE* Binding);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingFromStringBindingW(RPC_WSTR StringBinding, RPC_BINDING_HANDLE* Binding);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport) RPC_STATUS __stdcall RpcSsGetContextBinding(void* ContextHandle, RPC_BINDING_HANDLE* Binding);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingInqObject(RPC_BINDING_HANDLE Binding, UUID* ObjectUuid);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingReset(RPC_BINDING_HANDLE Binding);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingSetObject(RPC_BINDING_HANDLE Binding, UUID* ObjectUuid);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtInqDefaultProtectLevel(unsigned long AuthnSvc, unsigned long* AuthnLevel);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingToStringBindingA(RPC_BINDING_HANDLE Binding, RPC_CSTR* StringBinding);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingToStringBindingW(RPC_BINDING_HANDLE Binding, RPC_WSTR* StringBinding);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport) RPC_STATUS __stdcall RpcBindingVectorFree(RPC_BINDING_VECTOR** BindingVector);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcStringBindingComposeA(
        RPC_CSTR ObjUuid, RPC_CSTR ProtSeq, RPC_CSTR NetworkAddr, RPC_CSTR Endpoint, RPC_CSTR Options, RPC_CSTR* StringBinding);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcStringBindingComposeW(
        RPC_WSTR ObjUuid, RPC_WSTR ProtSeq, RPC_WSTR NetworkAddr, RPC_WSTR Endpoint, RPC_WSTR Options, RPC_WSTR* StringBinding);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcStringBindingParseA(
        RPC_CSTR StringBinding, RPC_CSTR* ObjUuid, RPC_CSTR* Protseq, RPC_CSTR* NetworkAddr, RPC_CSTR* Endpoint, RPC_CSTR* NetworkOptions);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcStringBindingParseW(
        RPC_WSTR StringBinding, RPC_WSTR* ObjUuid, RPC_WSTR* Protseq, RPC_WSTR* NetworkAddr, RPC_WSTR* Endpoint, RPC_WSTR* NetworkOptions);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport) RPC_STATUS __stdcall RpcStringFreeA(RPC_CSTR* String);

        __declspec(dllimport) RPC_STATUS __stdcall RpcStringFreeW(RPC_WSTR* String);

#pragma endregion

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcIfInqId(RPC_IF_HANDLE RpcIfHandle, RPC_IF_ID* RpcIfId);

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcNetworkIsProtseqValidA(RPC_CSTR Protseq);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcNetworkIsProtseqValidW(RPC_WSTR Protseq);

#pragma endregion

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtInqComTimeout(RPC_BINDING_HANDLE Binding, unsigned int* Timeout);

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtSetComTimeout(RPC_BINDING_HANDLE Binding, unsigned int Timeout);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtSetCancelTimeout(long Timeout);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcNetworkInqProtseqsA(RPC_PROTSEQ_VECTORA** ProtseqVector);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcNetworkInqProtseqsW(RPC_PROTSEQ_VECTORW** ProtseqVector);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcObjectInqType(UUID* ObjUuid, UUID* TypeUuid);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcObjectSetInqFn(RPC_OBJECT_INQ_FN* InquiryFn);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcObjectSetType(UUID* ObjUuid, UUID* TypeUuid);

        __declspec(dllimport) RPC_STATUS __stdcall RpcProtseqVectorFreeA(RPC_PROTSEQ_VECTORA** ProtseqVector);

        __declspec(dllimport) RPC_STATUS __stdcall RpcProtseqVectorFreeW(RPC_PROTSEQ_VECTORW** ProtseqVector);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerInqBindings(RPC_BINDING_VECTOR** BindingVector);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerInqBindingsEx(void* SecurityDescriptor, RPC_BINDING_VECTOR** BindingVector);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerInqIf(RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, void** MgrEpv);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerListen(unsigned int MinimumCallThreads, unsigned int MaxCalls, unsigned int DontWait);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerRegisterIf(RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, void* MgrEpv);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerRegisterIfEx(
        RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, void* MgrEpv, unsigned int Flags, unsigned int MaxCalls, RPC_IF_CALLBACK_FN* IfCallback);

        __declspec(dllimport) RPC_STATUS __stdcall RpcServerRegisterIf2(RPC_IF_HANDLE IfSpec,
                                                                        UUID* MgrTypeUuid,
                                                                        void* MgrEpv,
                                                                        unsigned int Flags,
                                                                        unsigned int MaxCalls,
                                                                        unsigned int MaxRpcSize,
                                                                        RPC_IF_CALLBACK_FN* IfCallbackFn);

        __declspec(dllimport) RPC_STATUS __stdcall RpcServerRegisterIf3(RPC_IF_HANDLE IfSpec,
                                                                        UUID* MgrTypeUuid,
                                                                        void* MgrEpv,
                                                                        unsigned int Flags,
                                                                        unsigned int MaxCalls,
                                                                        unsigned int MaxRpcSize,
                                                                        RPC_IF_CALLBACK_FN* IfCallback,
                                                                        void* SecurityDescriptor);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUnregisterIf(RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, unsigned int WaitForCallsToComplete);

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcServerUnregisterIfEx(RPC_IF_HANDLE IfSpec, UUID* MgrTypeUuid, int RundownContextHandles);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerUseAllProtseqs(unsigned int MaxCalls, void* SecurityDescriptor);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerUseAllProtseqsEx(unsigned int MaxCalls, void* SecurityDescriptor, PRPC_POLICY Policy);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerUseAllProtseqsIf(unsigned int MaxCalls, RPC_IF_HANDLE IfSpec, void* SecurityDescriptor);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUseAllProtseqsIfEx(unsigned int MaxCalls, RPC_IF_HANDLE IfSpec, void* SecurityDescriptor, PRPC_POLICY Policy);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerUseProtseqA(RPC_CSTR Protseq, unsigned int MaxCalls, void* SecurityDescriptor);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUseProtseqExA(RPC_CSTR Protseq, unsigned int MaxCalls, void* SecurityDescriptor, PRPC_POLICY Policy);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerUseProtseqW(RPC_WSTR Protseq, unsigned int MaxCalls, void* SecurityDescriptor);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUseProtseqExW(RPC_WSTR Protseq, unsigned int MaxCalls, void* SecurityDescriptor, PRPC_POLICY Policy);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUseProtseqEpA(RPC_CSTR Protseq, unsigned int MaxCalls, RPC_CSTR Endpoint, void* SecurityDescriptor);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUseProtseqEpExA(RPC_CSTR Protseq, unsigned int MaxCalls, RPC_CSTR Endpoint, void* SecurityDescriptor, PRPC_POLICY Policy);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUseProtseqEpW(RPC_WSTR Protseq, unsigned int MaxCalls, RPC_WSTR Endpoint, void* SecurityDescriptor);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUseProtseqEpExW(RPC_WSTR Protseq, unsigned int MaxCalls, RPC_WSTR Endpoint, void* SecurityDescriptor, PRPC_POLICY Policy);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUseProtseqIfA(RPC_CSTR Protseq, unsigned int MaxCalls, RPC_IF_HANDLE IfSpec, void* SecurityDescriptor);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerUseProtseqIfExA(
        RPC_CSTR Protseq, unsigned int MaxCalls, RPC_IF_HANDLE IfSpec, void* SecurityDescriptor, PRPC_POLICY Policy);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerUseProtseqIfW(RPC_WSTR Protseq, unsigned int MaxCalls, RPC_IF_HANDLE IfSpec, void* SecurityDescriptor);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerUseProtseqIfExW(
        RPC_WSTR Protseq, unsigned int MaxCalls, RPC_IF_HANDLE IfSpec, void* SecurityDescriptor, PRPC_POLICY Policy);

        __declspec(dllimport) void __stdcall RpcServerYield(void);

        __declspec(dllimport) RPC_STATUS __stdcall RpcMgmtStatsVectorFree(RPC_STATS_VECTOR** StatsVector);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtInqStats(RPC_BINDING_HANDLE Binding, RPC_STATS_VECTOR** Statistics);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtIsServerListening(RPC_BINDING_HANDLE Binding);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtStopServerListening(RPC_BINDING_HANDLE Binding);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtWaitServerListen(void);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtSetServerStackSize(unsigned long ThreadStackSize);

        __declspec(dllimport) void __stdcall RpcSsDontSerializeContext(void);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtEnableIdleCleanup(void);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtInqIfIds(RPC_BINDING_HANDLE Binding, RPC_IF_ID_VECTOR** IfIdVector);

        __declspec(dllimport) RPC_STATUS __stdcall RpcIfIdVectorFree(RPC_IF_ID_VECTOR** IfIdVector);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcMgmtInqServerPrincNameA(RPC_BINDING_HANDLE Binding, unsigned long AuthnSvc, RPC_CSTR* ServerPrincName);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcMgmtInqServerPrincNameW(RPC_BINDING_HANDLE Binding, unsigned long AuthnSvc, RPC_WSTR* ServerPrincName);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerInqDefaultPrincNameA(unsigned long AuthnSvc, RPC_CSTR* PrincName);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerInqDefaultPrincNameW(unsigned long AuthnSvc, RPC_WSTR* PrincName);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcEpResolveBinding(RPC_BINDING_HANDLE Binding, RPC_IF_HANDLE IfSpec);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcNsBindingInqEntryNameA(RPC_BINDING_HANDLE Binding, unsigned long EntryNameSyntax, RPC_CSTR* EntryName);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcNsBindingInqEntryNameW(RPC_BINDING_HANDLE Binding, unsigned long EntryNameSyntax, RPC_WSTR* EntryName);

#pragma endregion

#pragma region Application Family or OneCore Family

        typedef void* RPC_AUTH_IDENTITY_HANDLE;
        typedef void* RPC_AUTHZ_HANDLE;

        typedef struct _RPC_SECURITY_QOS
        {
            unsigned long Version;
            unsigned long Capabilities;
            unsigned long IdentityTracking;
            unsigned long ImpersonationType;
        } RPC_SECURITY_QOS, *PRPC_SECURITY_QOS;

        typedef struct _SEC_WINNT_AUTH_IDENTITY_W
        {
            unsigned short* User;
            unsigned long UserLength;
            unsigned short* Domain;
            unsigned long DomainLength;
            unsigned short* Password;
            unsigned long PasswordLength;
            unsigned long Flags;
        } SEC_WINNT_AUTH_IDENTITY_W, *PSEC_WINNT_AUTH_IDENTITY_W;

        typedef struct _SEC_WINNT_AUTH_IDENTITY_A
        {
            unsigned char* User;
            unsigned long UserLength;
            unsigned char* Domain;
            unsigned long DomainLength;
            unsigned char* Password;
            unsigned long PasswordLength;
            unsigned long Flags;
        } SEC_WINNT_AUTH_IDENTITY_A, *PSEC_WINNT_AUTH_IDENTITY_A;

        typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_W
        {
            SEC_WINNT_AUTH_IDENTITY_W* TransportCredentials;
            unsigned long Flags;
            unsigned long AuthenticationTarget;
            unsigned long NumberOfAuthnSchemes;
            unsigned long* AuthnSchemes;
            unsigned short* ServerCertificateSubject;
        } RPC_HTTP_TRANSPORT_CREDENTIALS_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_W;

        typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_A
        {
            SEC_WINNT_AUTH_IDENTITY_A* TransportCredentials;
            unsigned long Flags;
            unsigned long AuthenticationTarget;
            unsigned long NumberOfAuthnSchemes;
            unsigned long* AuthnSchemes;
            unsigned char* ServerCertificateSubject;
        } RPC_HTTP_TRANSPORT_CREDENTIALS_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_A;

        typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W
        {
            SEC_WINNT_AUTH_IDENTITY_W* TransportCredentials;
            unsigned long Flags;
            unsigned long AuthenticationTarget;
            unsigned long NumberOfAuthnSchemes;
            unsigned long* AuthnSchemes;
            unsigned short* ServerCertificateSubject;
            SEC_WINNT_AUTH_IDENTITY_W* ProxyCredentials;
            unsigned long NumberOfProxyAuthnSchemes;
            unsigned long* ProxyAuthnSchemes;
        } RPC_HTTP_TRANSPORT_CREDENTIALS_V2_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_W;

        typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A
        {
            SEC_WINNT_AUTH_IDENTITY_A* TransportCredentials;
            unsigned long Flags;
            unsigned long AuthenticationTarget;
            unsigned long NumberOfAuthnSchemes;
            unsigned long* AuthnSchemes;
            unsigned char* ServerCertificateSubject;
            SEC_WINNT_AUTH_IDENTITY_A* ProxyCredentials;
            unsigned long NumberOfProxyAuthnSchemes;
            unsigned long* ProxyAuthnSchemes;
        } RPC_HTTP_TRANSPORT_CREDENTIALS_V2_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V2_A;

        typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W
        {
            RPC_AUTH_IDENTITY_HANDLE TransportCredentials;
            unsigned long Flags;
            unsigned long AuthenticationTarget;
            unsigned long NumberOfAuthnSchemes;
            unsigned long* AuthnSchemes;
            unsigned short* ServerCertificateSubject;
            RPC_AUTH_IDENTITY_HANDLE ProxyCredentials;
            unsigned long NumberOfProxyAuthnSchemes;
            unsigned long* ProxyAuthnSchemes;
        } RPC_HTTP_TRANSPORT_CREDENTIALS_V3_W, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_W;

        typedef struct _RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A
        {
            RPC_AUTH_IDENTITY_HANDLE TransportCredentials;
            unsigned long Flags;
            unsigned long AuthenticationTarget;
            unsigned long NumberOfAuthnSchemes;
            unsigned long* AuthnSchemes;
            unsigned char* ServerCertificateSubject;
            RPC_AUTH_IDENTITY_HANDLE ProxyCredentials;
            unsigned long NumberOfProxyAuthnSchemes;
            unsigned long* ProxyAuthnSchemes;
        } RPC_HTTP_TRANSPORT_CREDENTIALS_V3_A, *PRPC_HTTP_TRANSPORT_CREDENTIALS_V3_A;

        typedef struct _RPC_SECURITY_QOS_V2_W
        {
            unsigned long Version;
            unsigned long Capabilities;
            unsigned long IdentityTracking;
            unsigned long ImpersonationType;
            unsigned long AdditionalSecurityInfoType;
            union
            {
                RPC_HTTP_TRANSPORT_CREDENTIALS_W* HttpCredentials;
            } u;
        } RPC_SECURITY_QOS_V2_W, *PRPC_SECURITY_QOS_V2_W;

        typedef struct _RPC_SECURITY_QOS_V2_A
        {
            unsigned long Version;
            unsigned long Capabilities;
            unsigned long IdentityTracking;
            unsigned long ImpersonationType;
            unsigned long AdditionalSecurityInfoType;
            union
            {
                RPC_HTTP_TRANSPORT_CREDENTIALS_A* HttpCredentials;
            } u;
        } RPC_SECURITY_QOS_V2_A, *PRPC_SECURITY_QOS_V2_A;

        typedef struct _RPC_SECURITY_QOS_V3_W
        {
            unsigned long Version;
            unsigned long Capabilities;
            unsigned long IdentityTracking;
            unsigned long ImpersonationType;
            unsigned long AdditionalSecurityInfoType;
            union
            {
                RPC_HTTP_TRANSPORT_CREDENTIALS_W* HttpCredentials;
            } u;
            void* Sid;
        } RPC_SECURITY_QOS_V3_W, *PRPC_SECURITY_QOS_V3_W;

        typedef struct _RPC_SECURITY_QOS_V3_A
        {
            unsigned long Version;
            unsigned long Capabilities;
            unsigned long IdentityTracking;
            unsigned long ImpersonationType;
            unsigned long AdditionalSecurityInfoType;
            union
            {
                RPC_HTTP_TRANSPORT_CREDENTIALS_A* HttpCredentials;
            } u;
            void* Sid;
        } RPC_SECURITY_QOS_V3_A, *PRPC_SECURITY_QOS_V3_A;

        typedef struct _RPC_SECURITY_QOS_V4_W
        {
            unsigned long Version;
            unsigned long Capabilities;
            unsigned long IdentityTracking;
            unsigned long ImpersonationType;
            unsigned long AdditionalSecurityInfoType;
            union
            {
                RPC_HTTP_TRANSPORT_CREDENTIALS_W* HttpCredentials;
            } u;
            void* Sid;
            unsigned int EffectiveOnly;
        } RPC_SECURITY_QOS_V4_W, *PRPC_SECURITY_QOS_V4_W;

        typedef struct _RPC_SECURITY_QOS_V4_A
        {
            unsigned long Version;
            unsigned long Capabilities;
            unsigned long IdentityTracking;
            unsigned long ImpersonationType;
            unsigned long AdditionalSecurityInfoType;
            union
            {
                RPC_HTTP_TRANSPORT_CREDENTIALS_A* HttpCredentials;
            } u;
            void* Sid;
            unsigned int EffectiveOnly;
        } RPC_SECURITY_QOS_V4_A, *PRPC_SECURITY_QOS_V4_A;

        typedef struct _RPC_SECURITY_QOS_V5_W
        {
            unsigned long Version;
            unsigned long Capabilities;
            unsigned long IdentityTracking;
            unsigned long ImpersonationType;
            unsigned long AdditionalSecurityInfoType;
            union
            {
                RPC_HTTP_TRANSPORT_CREDENTIALS_W* HttpCredentials;
            } u;
            void* Sid;
            unsigned int EffectiveOnly;
            void* ServerSecurityDescriptor;
        } RPC_SECURITY_QOS_V5_W, *PRPC_SECURITY_QOS_V5_W;

        typedef struct _RPC_SECURITY_QOS_V5_A
        {
            unsigned long Version;
            unsigned long Capabilities;
            unsigned long IdentityTracking;
            unsigned long ImpersonationType;
            unsigned long AdditionalSecurityInfoType;
            union
            {
                RPC_HTTP_TRANSPORT_CREDENTIALS_A* HttpCredentials;
            } u;
            void* Sid;
            unsigned int EffectiveOnly;
            void* ServerSecurityDescriptor;
        } RPC_SECURITY_QOS_V5_A, *PRPC_SECURITY_QOS_V5_A;

#pragma endregion

#pragma region Desktop Family or OneCore Family

#pragma endregion

#pragma region Application Family or OneCore Family

        typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_W
        {
            unsigned long Version;
            unsigned long Flags;
            unsigned long ProtocolSequence;
            unsigned short* NetworkAddress;
            unsigned short* StringEndpoint;
            union
            {
                unsigned short* Reserved;
            } u1;
            UUID ObjectUuid;
        } RPC_BINDING_HANDLE_TEMPLATE_V1_W, *PRPC_BINDING_HANDLE_TEMPLATE_V1_W;

        typedef struct _RPC_BINDING_HANDLE_TEMPLATE_V1_A
        {
            unsigned long Version;
            unsigned long Flags;
            unsigned long ProtocolSequence;
            unsigned char* NetworkAddress;
            unsigned char* StringEndpoint;
            union
            {
                unsigned char* Reserved;
            } u1;
            UUID ObjectUuid;
        } RPC_BINDING_HANDLE_TEMPLATE_V1_A, *PRPC_BINDING_HANDLE_TEMPLATE_V1_A;

        typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_W
        {
            unsigned long Version;
            unsigned short* ServerPrincName;
            unsigned long AuthnLevel;
            unsigned long AuthnSvc;
            SEC_WINNT_AUTH_IDENTITY_W* AuthIdentity;
            RPC_SECURITY_QOS* SecurityQos;
        } RPC_BINDING_HANDLE_SECURITY_V1_W, *PRPC_BINDING_HANDLE_SECURITY_V1_W;

        typedef struct _RPC_BINDING_HANDLE_SECURITY_V1_A
        {
            unsigned long Version;
            unsigned char* ServerPrincName;
            unsigned long AuthnLevel;
            unsigned long AuthnSvc;
            SEC_WINNT_AUTH_IDENTITY_A* AuthIdentity;
            RPC_SECURITY_QOS* SecurityQos;
        } RPC_BINDING_HANDLE_SECURITY_V1_A, *PRPC_BINDING_HANDLE_SECURITY_V1_A;

        typedef struct _RPC_BINDING_HANDLE_OPTIONS_V1
        {
            unsigned long Version;
            unsigned long Flags;
            unsigned long ComTimeout;
            unsigned long CallTimeout;
        } RPC_BINDING_HANDLE_OPTIONS_V1, *PRPC_BINDING_HANDLE_OPTIONS_V1;

        __declspec(dllimport) RPC_STATUS __stdcall RpcBindingCreateA(RPC_BINDING_HANDLE_TEMPLATE_V1_A* Template,
                                                                     RPC_BINDING_HANDLE_SECURITY_V1_A* Security,
                                                                     RPC_BINDING_HANDLE_OPTIONS_V1* Options,
                                                                     RPC_BINDING_HANDLE* Binding);

        __declspec(dllimport) RPC_STATUS __stdcall RpcBindingCreateW(RPC_BINDING_HANDLE_TEMPLATE_V1_W* Template,
                                                                     RPC_BINDING_HANDLE_SECURITY_V1_W* Security,
                                                                     RPC_BINDING_HANDLE_OPTIONS_V1* Options,
                                                                     RPC_BINDING_HANDLE* Binding);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcBindingGetTrainingContextHandle(RPC_BINDING_HANDLE Binding, void** ContextHandle);

        __declspec(dllimport) RPC_STATUS __stdcall RpcServerInqBindingHandle(RPC_BINDING_HANDLE* Binding);

#pragma endregion

#pragma region Application Family or OneCore Family

        typedef enum _RPC_HTTP_REDIRECTOR_STAGE
        {
            RPCHTTP_RS_REDIRECT = 1,
            RPCHTTP_RS_ACCESS_1,
            RPCHTTP_RS_SESSION,
            RPCHTTP_RS_ACCESS_2,
            RPCHTTP_RS_INTERFACE
        } RPC_HTTP_REDIRECTOR_STAGE;

#pragma endregion

#pragma region Desktop Family or OneCore Family

        typedef RPC_STATUS(__stdcall* RPC_NEW_HTTP_PROXY_CHANNEL)(RPC_HTTP_REDIRECTOR_STAGE RedirectorStage,
                                                                  RPC_WSTR ServerName,
                                                                  RPC_WSTR ServerPort,
                                                                  RPC_WSTR RemoteUser,
                                                                  RPC_WSTR AuthType,
                                                                  void* ResourceUuid,
                                                                  void* SessionId,
                                                                  void* Interface,
                                                                  void* Reserved,
                                                                  unsigned long Flags,
                                                                  RPC_WSTR* NewServerName,
                                                                  RPC_WSTR* NewServerPort);

        typedef void(__stdcall* RPC_HTTP_PROXY_FREE_STRING)(RPC_WSTR String);

#pragma endregion

#pragma region Application Family or OneCore Family

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcImpersonateClient(RPC_BINDING_HANDLE BindingHandle);

        __declspec(dllimport) RPC_STATUS __stdcall RpcImpersonateClient2(RPC_BINDING_HANDLE BindingHandle);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcRevertToSelfEx(RPC_BINDING_HANDLE BindingHandle);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcRevertToSelf(void);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcImpersonateClientContainer(RPC_BINDING_HANDLE BindingHandle);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcRevertContainerImpersonation(void);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingInqAuthClientA(RPC_BINDING_HANDLE ClientBinding,
                                                      RPC_AUTHZ_HANDLE* Privs,
                                                      RPC_CSTR* ServerPrincName,
                                                      unsigned long* AuthnLevel,
                                                      unsigned long* AuthnSvc,
                                                      unsigned long* AuthzSvc);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingInqAuthClientW(RPC_BINDING_HANDLE ClientBinding,
                                                      RPC_AUTHZ_HANDLE* Privs,
                                                      RPC_WSTR* ServerPrincName,
                                                      unsigned long* AuthnLevel,
                                                      unsigned long* AuthnSvc,
                                                      unsigned long* AuthzSvc);

        __declspec(dllimport) RPC_STATUS __stdcall RpcBindingInqAuthClientExA(RPC_BINDING_HANDLE ClientBinding,
                                                                              RPC_AUTHZ_HANDLE* Privs,
                                                                              RPC_CSTR* ServerPrincName,
                                                                              unsigned long* AuthnLevel,
                                                                              unsigned long* AuthnSvc,
                                                                              unsigned long* AuthzSvc,
                                                                              unsigned long Flags);

        __declspec(dllimport) RPC_STATUS __stdcall RpcBindingInqAuthClientExW(RPC_BINDING_HANDLE ClientBinding,
                                                                              RPC_AUTHZ_HANDLE* Privs,
                                                                              RPC_WSTR* ServerPrincName,
                                                                              unsigned long* AuthnLevel,
                                                                              unsigned long* AuthnSvc,
                                                                              unsigned long* AuthzSvc,
                                                                              unsigned long Flags);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingInqAuthInfoA(RPC_BINDING_HANDLE Binding,
                                                    RPC_CSTR* ServerPrincName,
                                                    unsigned long* AuthnLevel,
                                                    unsigned long* AuthnSvc,
                                                    RPC_AUTH_IDENTITY_HANDLE* AuthIdentity,
                                                    unsigned long* AuthzSvc);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingInqAuthInfoW(RPC_BINDING_HANDLE Binding,
                                                    RPC_WSTR* ServerPrincName,
                                                    unsigned long* AuthnLevel,
                                                    unsigned long* AuthnSvc,
                                                    RPC_AUTH_IDENTITY_HANDLE* AuthIdentity,
                                                    unsigned long* AuthzSvc);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingSetAuthInfoA(RPC_BINDING_HANDLE Binding,
                                                    RPC_CSTR ServerPrincName,
                                                    unsigned long AuthnLevel,
                                                    unsigned long AuthnSvc,
                                                    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
                                                    unsigned long AuthzSvc);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingSetAuthInfoExA(RPC_BINDING_HANDLE Binding,
                                                      RPC_CSTR ServerPrincName,
                                                      unsigned long AuthnLevel,
                                                      unsigned long AuthnSvc,
                                                      RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
                                                      unsigned long AuthzSvc,
                                                      RPC_SECURITY_QOS* SecurityQos);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingSetAuthInfoW(RPC_BINDING_HANDLE Binding,
                                                    RPC_WSTR ServerPrincName,
                                                    unsigned long AuthnLevel,
                                                    unsigned long AuthnSvc,
                                                    RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
                                                    unsigned long AuthzSvc);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingSetAuthInfoExW(RPC_BINDING_HANDLE Binding,
                                                      RPC_WSTR ServerPrincName,
                                                      unsigned long AuthnLevel,
                                                      unsigned long AuthnSvc,
                                                      RPC_AUTH_IDENTITY_HANDLE AuthIdentity,
                                                      unsigned long AuthzSvc,
                                                      RPC_SECURITY_QOS* SecurityQOS);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingInqAuthInfoExA(RPC_BINDING_HANDLE Binding,
                                                      RPC_CSTR* ServerPrincName,
                                                      unsigned long* AuthnLevel,
                                                      unsigned long* AuthnSvc,
                                                      RPC_AUTH_IDENTITY_HANDLE* AuthIdentity,
                                                      unsigned long* AuthzSvc,
                                                      unsigned long RpcQosVersion,
                                                      RPC_SECURITY_QOS* SecurityQOS);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingInqAuthInfoExW(RPC_BINDING_HANDLE Binding,
                                                      RPC_WSTR* ServerPrincName,
                                                      unsigned long* AuthnLevel,
                                                      unsigned long* AuthnSvc,
                                                      RPC_AUTH_IDENTITY_HANDLE* AuthIdentity,
                                                      unsigned long* AuthzSvc,
                                                      unsigned long RpcQosVersion,
                                                      RPC_SECURITY_QOS* SecurityQOS);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        typedef void(__stdcall* RPC_AUTH_KEY_RETRIEVAL_FN)(void* Arg, RPC_WSTR ServerPrincName, unsigned long KeyVer, void** Key, RPC_STATUS* Status);

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcServerCompleteSecurityCallback(RPC_BINDING_HANDLE BindingHandle, RPC_STATUS Status);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerRegisterAuthInfoA(RPC_CSTR ServerPrincName, unsigned long AuthnSvc, RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn, void* Arg);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcServerRegisterAuthInfoW(RPC_WSTR ServerPrincName, unsigned long AuthnSvc, RPC_AUTH_KEY_RETRIEVAL_FN GetKeyFn, void* Arg);

#pragma endregion

#pragma region Application Family or OneCore Family

#pragma endregion

#pragma region Desktop Family or OneCore Family

        typedef struct
        {
            unsigned char* UserName;
            unsigned char* ComputerName;
            unsigned short Privilege;
            unsigned long AuthFlags;
        } RPC_CLIENT_INFORMATION1, *PRPC_CLIENT_INFORMATION1;

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcBindingServerFromClient(RPC_BINDING_HANDLE ClientBinding, RPC_BINDING_HANDLE* ServerBinding);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport) __declspec(noreturn) void __stdcall RpcRaiseException(RPC_STATUS exception);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcTestCancel(void);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcServerTestCancel(RPC_BINDING_HANDLE BindingHandle);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcCancelThread(void* Thread);

        __declspec(dllimport) RPC_STATUS __stdcall RpcCancelThreadEx(void* Thread, long Timeout);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall UuidCreate(UUID* Uuid);

        __declspec(dllimport) RPC_STATUS __stdcall UuidCreateSequential(UUID* Uuid);

        __declspec(dllimport)

        RPC_STATUS __stdcall UuidToStringA(const UUID* Uuid, RPC_CSTR* StringUuid);

        __declspec(dllimport)

        RPC_STATUS __stdcall UuidFromStringA(RPC_CSTR StringUuid, UUID* Uuid);

        __declspec(dllimport)

        RPC_STATUS __stdcall UuidToStringW(const UUID* Uuid, RPC_WSTR* StringUuid);

        __declspec(dllimport)

        RPC_STATUS __stdcall UuidFromStringW(RPC_WSTR StringUuid, UUID* Uuid);

        __declspec(dllimport) signed int __stdcall UuidCompare(UUID* Uuid1, UUID* Uuid2, RPC_STATUS* Status);

        __declspec(dllimport)

        RPC_STATUS __stdcall UuidCreateNil(UUID* NilUuid);

        __declspec(dllimport) int __stdcall UuidEqual(UUID* Uuid1, UUID* Uuid2, RPC_STATUS* Status);

        __declspec(dllimport) unsigned short __stdcall UuidHash(UUID* Uuid, RPC_STATUS* Status);

        __declspec(dllimport) int __stdcall UuidIsNil(UUID* Uuid, RPC_STATUS* Status);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcEpRegisterNoReplaceA(RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR* BindingVector, UUID_VECTOR* UuidVector, RPC_CSTR Annotation);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcEpRegisterNoReplaceW(RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR* BindingVector, UUID_VECTOR* UuidVector, RPC_WSTR Annotation);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcEpRegisterA(RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR* BindingVector, UUID_VECTOR* UuidVector, RPC_CSTR Annotation);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcEpRegisterW(RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR* BindingVector, UUID_VECTOR* UuidVector, RPC_WSTR Annotation);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcEpUnregister(RPC_IF_HANDLE IfSpec, RPC_BINDING_VECTOR* BindingVector, UUID_VECTOR* UuidVector);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport)

        RPC_STATUS __stdcall DceErrorInqTextA(RPC_STATUS RpcStatus, RPC_CSTR ErrorText);

        __declspec(dllimport)

        RPC_STATUS __stdcall DceErrorInqTextW(RPC_STATUS RpcStatus, RPC_WSTR ErrorText);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        typedef I_RPC_HANDLE* RPC_EP_INQ_HANDLE;

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtEpEltInqBegin(RPC_BINDING_HANDLE EpBinding,
                                                  unsigned long InquiryType,
                                                  RPC_IF_ID* IfId,
                                                  unsigned long VersOption,
                                                  UUID* ObjectUuid,
                                                  RPC_EP_INQ_HANDLE* InquiryContext);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtEpEltInqDone(RPC_EP_INQ_HANDLE* InquiryContext);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtEpEltInqNextA(
        RPC_EP_INQ_HANDLE InquiryContext, RPC_IF_ID* IfId, RPC_BINDING_HANDLE* Binding, UUID* ObjectUuid, RPC_CSTR* Annotation);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtEpEltInqNextW(
        RPC_EP_INQ_HANDLE InquiryContext, RPC_IF_ID* IfId, RPC_BINDING_HANDLE* Binding, UUID* ObjectUuid, RPC_WSTR* Annotation);

        __declspec(dllimport)

        RPC_STATUS
        __stdcall RpcMgmtEpUnregister(RPC_BINDING_HANDLE EpBinding, RPC_IF_ID* IfId, RPC_BINDING_HANDLE Binding, UUID* ObjectUuid);

        typedef int(__stdcall* RPC_MGMT_AUTHORIZATION_FN)(RPC_BINDING_HANDLE ClientBinding,
                                                          unsigned long RequestedMgmtOperation,
                                                          RPC_STATUS* Status);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcMgmtSetAuthorizationFn(RPC_MGMT_AUTHORIZATION_FN AuthorizationFn);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport) int __stdcall RpcExceptionFilter(unsigned long ExceptionCode);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        typedef void *RPC_INTERFACE_GROUP, **PRPC_INTERFACE_GROUP;

        typedef struct
        {
            unsigned long Version;
            RPC_WSTR ProtSeq;
            RPC_WSTR Endpoint;
            void* SecurityDescriptor;
            unsigned long Backlog;
        } RPC_ENDPOINT_TEMPLATEW, *PRPC_ENDPOINT_TEMPLATEW;

        typedef struct
        {
            unsigned long Version;
            RPC_CSTR ProtSeq;
            RPC_CSTR Endpoint;
            void* SecurityDescriptor;
            unsigned long Backlog;
        } RPC_ENDPOINT_TEMPLATEA, *PRPC_ENDPOINT_TEMPLATEA;

        typedef struct
        {
            unsigned long Version;
            RPC_IF_HANDLE IfSpec;
            UUID* MgrTypeUuid;
            void* MgrEpv;
            unsigned int Flags;
            unsigned int MaxCalls;
            unsigned int MaxRpcSize;
            RPC_IF_CALLBACK_FN* IfCallback;
            UUID_VECTOR* UuidVector;
            RPC_CSTR Annotation;
            void* SecurityDescriptor;
        } RPC_INTERFACE_TEMPLATEA, *PRPC_INTERFACE_TEMPLATEA;

        typedef struct
        {
            unsigned long Version;
            RPC_IF_HANDLE IfSpec;
            UUID* MgrTypeUuid;
            void* MgrEpv;
            unsigned int Flags;
            unsigned int MaxCalls;
            unsigned int MaxRpcSize;
            RPC_IF_CALLBACK_FN* IfCallback;
            UUID_VECTOR* UuidVector;
            RPC_WSTR Annotation;
            void* SecurityDescriptor;
        } RPC_INTERFACE_TEMPLATEW, *PRPC_INTERFACE_TEMPLATEW;

        typedef void __stdcall RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN(RPC_INTERFACE_GROUP IfGroup,
                                                                    void* IdleCallbackContext,
                                                                    unsigned long IsGroupIdle);

        __declspec(dllimport) RPC_STATUS __stdcall RpcServerInterfaceGroupCreateW(RPC_INTERFACE_TEMPLATEW* Interfaces,
                                                                                  unsigned long NumIfs,
                                                                                  RPC_ENDPOINT_TEMPLATEW* Endpoints,
                                                                                  unsigned long NumEndpoints,
                                                                                  unsigned long IdlePeriod,
                                                                                  RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN IdleCallbackFn,
                                                                                  void* IdleCallbackContext,
                                                                                  PRPC_INTERFACE_GROUP IfGroup);

        __declspec(dllimport) RPC_STATUS __stdcall RpcServerInterfaceGroupCreateA(RPC_INTERFACE_TEMPLATEA* Interfaces,
                                                                                  unsigned long NumIfs,
                                                                                  RPC_ENDPOINT_TEMPLATEA* Endpoints,
                                                                                  unsigned long NumEndpoints,
                                                                                  unsigned long IdlePeriod,
                                                                                  RPC_INTERFACE_GROUP_IDLE_CALLBACK_FN IdleCallbackFn,
                                                                                  void* IdleCallbackContext,
                                                                                  PRPC_INTERFACE_GROUP IfGroup);

        __declspec(dllimport) RPC_STATUS __stdcall RpcServerInterfaceGroupClose(RPC_INTERFACE_GROUP IfGroup);

        __declspec(dllimport) RPC_STATUS __stdcall RpcServerInterfaceGroupActivate(RPC_INTERFACE_GROUP IfGroup);

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcServerInterfaceGroupDeactivate(RPC_INTERFACE_GROUP IfGroup, unsigned long ForceDeactivation);

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcServerInterfaceGroupInqBindings(RPC_INTERFACE_GROUP IfGroup, RPC_BINDING_VECTOR** BindingVector);

#pragma endregion

#pragma warning(pop)

#pragma once

        extern "C"
        {
#pragma warning(push)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)

#pragma region Application Family or OneCore Family

            typedef struct _RPC_VERSION
            {
                unsigned short MajorVersion;
                unsigned short MinorVersion;
            } RPC_VERSION;

            typedef struct _RPC_SYNTAX_IDENTIFIER
            {
                GUID SyntaxGUID;
                RPC_VERSION SyntaxVersion;
            } RPC_SYNTAX_IDENTIFIER, *PRPC_SYNTAX_IDENTIFIER;

            typedef struct _RPC_MESSAGE
            {
                RPC_BINDING_HANDLE Handle;
                unsigned long DataRepresentation;
                void* Buffer;
                unsigned int BufferLength;
                unsigned int ProcNum;
                PRPC_SYNTAX_IDENTIFIER TransferSyntax;
                void* RpcInterfaceInformation;
                void* ReservedForRuntime;
                void* ManagerEpv;
                void* ImportContext;
                unsigned long RpcFlags;
            } RPC_MESSAGE, *PRPC_MESSAGE;

#pragma endregion

#pragma region Desktop Family or OneCore Family

            typedef RPC_STATUS __stdcall RPC_FORWARD_FUNCTION(
            UUID* InterfaceId, RPC_VERSION* InterfaceVersion, UUID* ObjectId, unsigned char* Rpcpro, void** ppDestEndpoint);

            enum RPC_ADDRESS_CHANGE_TYPE
            {
                PROTOCOL_NOT_LOADED = 1,
                PROTOCOL_LOADED,
                PROTOCOL_ADDRESS_CHANGE
            };

            typedef void __stdcall RPC_ADDRESS_CHANGE_FN(void* arg);

#pragma endregion

#pragma region Application Family or OneCore Family

            typedef void(__stdcall* RPC_DISPATCH_FUNCTION)(PRPC_MESSAGE Message);

            typedef struct
            {
                unsigned int DispatchTableCount;
                RPC_DISPATCH_FUNCTION* DispatchTable;
                LONG_PTR Reserved;
            } RPC_DISPATCH_TABLE, *PRPC_DISPATCH_TABLE;

            typedef struct _RPC_PROTSEQ_ENDPOINT
            {
                unsigned char* RpcProtocolSequence;
                unsigned char* Endpoint;
            } RPC_PROTSEQ_ENDPOINT, *PRPC_PROTSEQ_ENDPOINT;

            typedef struct _RPC_SERVER_INTERFACE
            {
                unsigned int Length;
                RPC_SYNTAX_IDENTIFIER InterfaceId;
                RPC_SYNTAX_IDENTIFIER TransferSyntax;
                PRPC_DISPATCH_TABLE DispatchTable;
                unsigned int RpcProtseqEndpointCount;
                PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
                void* DefaultManagerEpv;
                void const* InterpreterInfo;
                unsigned int Flags;
            } RPC_SERVER_INTERFACE, *PRPC_SERVER_INTERFACE;

            typedef struct _RPC_CLIENT_INTERFACE
            {
                unsigned int Length;
                RPC_SYNTAX_IDENTIFIER InterfaceId;
                RPC_SYNTAX_IDENTIFIER TransferSyntax;
                PRPC_DISPATCH_TABLE DispatchTable;
                unsigned int RpcProtseqEndpointCount;
                PRPC_PROTSEQ_ENDPOINT RpcProtseqEndpoint;
                ULONG_PTR Reserved;
                void const* InterpreterInfo;
                unsigned int Flags;
            } RPC_CLIENT_INTERFACE, *PRPC_CLIENT_INTERFACE;

#pragma endregion

#pragma region Desktop Family or OneCore Family

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcNegotiateTransferSyntax(RPC_MESSAGE* Message);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcGetBuffer(RPC_MESSAGE* Message);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcGetBufferWithObject(RPC_MESSAGE* Message, UUID* ObjectUuid);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcSendReceive(RPC_MESSAGE* Message);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcFreeBuffer(RPC_MESSAGE* Message);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcSend(PRPC_MESSAGE Message);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcReceive(PRPC_MESSAGE Message, unsigned int Size);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcFreePipeBuffer(RPC_MESSAGE* Message);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcReallocPipeBuffer(PRPC_MESSAGE Message, unsigned int NewSize);

            typedef void* I_RPC_MUTEX;

            __declspec(dllimport) void __stdcall I_RpcRequestMutex(I_RPC_MUTEX* Mutex);

            __declspec(dllimport) void __stdcall I_RpcClearMutex(I_RPC_MUTEX Mutex);

            __declspec(dllimport) void __stdcall I_RpcDeleteMutex(I_RPC_MUTEX Mutex);

            __declspec(dllimport) void* __stdcall I_RpcAllocate(unsigned int Size);

            __declspec(dllimport) void __stdcall I_RpcFree(void* Object);

            __declspec(dllimport) unsigned long __stdcall I_RpcFreeSystemHandleCollection(void* CallObj, unsigned long FreeFlags);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcSetSystemHandle(void* Handle, unsigned char Type, unsigned long AccessMask, void* CallObj, unsigned long* HandleIndex);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcGetSystemHandle(
            unsigned char* pMemory, unsigned char Type, unsigned long AccessMask, unsigned long HandleIndex, void* CallObj);

            __declspec(dllimport) void __stdcall I_RpcFreeSystemHandle(unsigned char Type, void* Handle);

            __declspec(dllimport) void __stdcall I_RpcPauseExecution(unsigned long Milliseconds);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcGetExtendedError(void);

            typedef enum _LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION
            {
                MarshalDirectionMarshal,
                MarshalDirectionUnmarshal
            } LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION;

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcSystemHandleTypeSpecificWork(void* Handle,
                                                        unsigned char ActualType,
                                                        unsigned char IdlType,
                                                        LRPC_SYSTEM_HANDLE_MARSHAL_DIRECTION MarshalDirection);

            typedef void(__stdcall* PRPC_RUNDOWN)(void* AssociationContext);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcMonitorAssociation(RPC_BINDING_HANDLE Handle, PRPC_RUNDOWN RundownRoutine, void* Context);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcStopMonitorAssociation(RPC_BINDING_HANDLE Handle);

            __declspec(dllimport) RPC_BINDING_HANDLE __stdcall I_RpcGetCurrentCallHandle(void);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcGetAssociationContext(RPC_BINDING_HANDLE BindingHandle, void** AssociationContext);

            __declspec(dllimport) void* __stdcall I_RpcGetServerContextList(RPC_BINDING_HANDLE BindingHandle);

            __declspec(dllimport) void __stdcall I_RpcSetServerContextList(RPC_BINDING_HANDLE BindingHandle, void* ServerContextList);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcNsInterfaceExported(unsigned long EntryNameSyntax,
                                                                                unsigned short* EntryName,
                                                                                RPC_SERVER_INTERFACE* RpcInterfaceInformation);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcNsInterfaceUnexported(unsigned long EntryNameSyntax,
                                                                                  unsigned short* EntryName,
                                                                                  RPC_SERVER_INTERFACE* RpcInterfaceInformation);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingToStaticStringBindingW(RPC_BINDING_HANDLE Binding, unsigned short** StringBinding);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingInqSecurityContext(RPC_BINDING_HANDLE Binding, void** SecurityContextHandle);

            typedef struct _RPC_SEC_CONTEXT_KEY_INFO
            {
                unsigned long EncryptAlgorithm;
                unsigned long KeySize;
                unsigned long SignatureAlgorithm;
            } RPC_SEC_CONTEXT_KEY_INFO, *PRPC_SEC_CONTEXT_KEY_INFO;

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingInqSecurityContextKeyInfo(RPC_BINDING_HANDLE Binding, void* KeyInfo);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingInqWireIdForSnego(RPC_BINDING_HANDLE Binding, unsigned char* WireId);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcBindingInqMarshalledTargetInfo(RPC_BINDING_HANDLE Binding,
                                                                                           unsigned long* MarshalledTargetInfoSize,
                                                                                           RPC_CSTR* MarshalledTargetInfo);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingInqLocalClientPID(RPC_BINDING_HANDLE Binding, unsigned long* Pid);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingHandleToAsyncHandle(RPC_BINDING_HANDLE Binding, void** AsyncHandle);

            __declspec(dllimport)

            RPC_STATUS
            __stdcall I_RpcNsBindingSetEntryNameW(RPC_BINDING_HANDLE Binding, unsigned long EntryNameSyntax, RPC_WSTR EntryName);

            __declspec(dllimport)

            RPC_STATUS
            __stdcall I_RpcNsBindingSetEntryNameA(RPC_BINDING_HANDLE Binding, unsigned long EntryNameSyntax, RPC_CSTR EntryName);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcServerUseProtseqEp2A(RPC_CSTR NetworkAddress,
                                                                                 RPC_CSTR Protseq,
                                                                                 unsigned int MaxCalls,
                                                                                 RPC_CSTR Endpoint,
                                                                                 void* SecurityDescriptor,
                                                                                 void* Policy);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcServerUseProtseqEp2W(RPC_WSTR NetworkAddress,
                                                                                 RPC_WSTR Protseq,
                                                                                 unsigned int MaxCalls,
                                                                                 RPC_WSTR Endpoint,
                                                                                 void* SecurityDescriptor,
                                                                                 void* Policy);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcServerUseProtseq2W(
            RPC_WSTR NetworkAddress, RPC_WSTR Protseq, unsigned int MaxCalls, void* SecurityDescriptor, void* Policy);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcServerUseProtseq2A(
            RPC_CSTR NetworkAddress, RPC_CSTR Protseq, unsigned int MaxCalls, void* SecurityDescriptor, void* Policy);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcServerStartService(RPC_WSTR Protseq, RPC_WSTR Endpoint, RPC_IF_HANDLE IfSpec);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcBindingInqDynamicEndpointW(RPC_BINDING_HANDLE Binding, RPC_WSTR* DynamicEndpoint);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcBindingInqDynamicEndpointA(RPC_BINDING_HANDLE Binding, RPC_CSTR* DynamicEndpoint);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcServerCheckClientRestriction(RPC_BINDING_HANDLE Context);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcBindingInqTransportType(RPC_BINDING_HANDLE Binding, unsigned int* Type);

            typedef struct _RPC_TRANSFER_SYNTAX
            {
                UUID Uuid;
                unsigned short VersMajor;
                unsigned short VersMinor;
            } RPC_TRANSFER_SYNTAX;

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcIfInqTransferSyntaxes(RPC_IF_HANDLE RpcIfHandle,
                                                            RPC_TRANSFER_SYNTAX* TransferSyntaxes,
                                                            unsigned int TransferSyntaxSize,
                                                            unsigned int* TransferSyntaxCount);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_UuidCreate(UUID* Uuid);

            __declspec(dllimport) void __stdcall I_RpcUninitializeNdrOle(void);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcBindingCopy(RPC_BINDING_HANDLE SourceBinding, RPC_BINDING_HANDLE* DestinationBinding);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingIsClientLocal(RPC_BINDING_HANDLE BindingHandle, unsigned int* ClientLocalFlag);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingInqConnId(RPC_BINDING_HANDLE Binding, void** ConnId, int* pfFirstCall);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingCreateNP(RPC_WSTR ServerName, RPC_WSTR ServiceName, RPC_WSTR NetworkOptions, RPC_BINDING_HANDLE* Binding);

            __declspec(dllimport) void __stdcall I_RpcSsDontSerializeContext(void);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcLaunchDatagramReceiveThread(void* pAddress);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcServerRegisterForwardFunction(RPC_FORWARD_FUNCTION* pForwardFunction);

            RPC_ADDRESS_CHANGE_FN* __stdcall I_RpcServerInqAddressChangeFn(void);

            RPC_STATUS __stdcall I_RpcServerSetAddressChangeFn(RPC_ADDRESS_CHANGE_FN* pAddressChangeFn);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcServerInqLocalConnAddress(RPC_BINDING_HANDLE Binding,
                                                                                      void* Buffer,
                                                                                      unsigned long* BufferSize,
                                                                                      unsigned long* AddressFormat);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcServerInqRemoteConnAddress(RPC_BINDING_HANDLE Binding,
                                                                                       void* Buffer,
                                                                                       unsigned long* BufferSize,
                                                                                       unsigned long* AddressFormat);

            __declspec(dllimport) void __stdcall I_RpcSessionStrictContextHandle(void);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcTurnOnEEInfoPropagation(void);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcConnectionInqSockBuffSize(unsigned long* RecvBuffSize, unsigned long* SendBuffSize);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcConnectionSetSockBuffSize(unsigned long RecvBuffSize, unsigned long SendBuffSize);

            typedef void (*RPCLT_PDU_FILTER_FUNC)(void* Buffer, unsigned int BufferLength, int fDatagram);

            typedef void(__cdecl* RPC_SETFILTER_FUNC)(RPCLT_PDU_FILTER_FUNC pfnFilter);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcServerStartListening(void* hWnd);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcServerStopListening(void);

            typedef RPC_STATUS (*RPC_BLOCKING_FN)(void* hWnd, void* Context, void* hSyncEvent);

            __declspec(dllimport)

            RPC_STATUS
            __stdcall I_RpcBindingSetAsync(RPC_BINDING_HANDLE Binding, RPC_BLOCKING_FN BlockingFn, unsigned long ServerTid);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcSetThreadParams(int fClientFree, void* Context, void* hWndClient);

            __declspec(dllimport) unsigned int __stdcall I_RpcWindowProc(void* hWnd, unsigned int Message, unsigned int wParam, unsigned long lParam);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcServerUnregisterEndpointA(RPC_CSTR Protseq, RPC_CSTR Endpoint);

            __declspec(dllimport)

            RPC_STATUS __stdcall I_RpcServerUnregisterEndpointW(RPC_WSTR Protseq, RPC_WSTR Endpoint);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcServerInqTransportType(unsigned int* Type);

            __declspec(dllimport) long __stdcall I_RpcMapWin32Status(RPC_STATUS Status);

            typedef struct _RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR
            {
                unsigned long BufferSize;
                char* Buffer;
            } RPC_C_OPT_COOKIE_AUTH_DESCRIPTOR;

            typedef struct _RDR_CALLOUT_STATE
            {
                RPC_STATUS LastError;
                void* LastEEInfo;

                RPC_HTTP_REDIRECTOR_STAGE LastCalledStage;

                unsigned short* ServerName;
                unsigned short* ServerPort;
                unsigned short* RemoteUser;
                unsigned short* AuthType;
                unsigned char ResourceTypePresent;
                unsigned char SessionIdPresent;
                unsigned char InterfacePresent;
                UUID ResourceType;
                UUID SessionId;
                RPC_SYNTAX_IDENTIFIER Interface;
                void* CertContext;

            } RDR_CALLOUT_STATE;

            typedef RPC_STATUS(__stdcall* I_RpcProxyIsValidMachineFn)(RPC_WSTR Machine, RPC_WSTR DotMachine, unsigned long PortNumber);

            typedef RPC_STATUS(__stdcall* I_RpcProxyGetClientAddressFn)(void* Context, char* Buffer, unsigned long* BufferLength);

            typedef RPC_STATUS(__stdcall* I_RpcProxyGetConnectionTimeoutFn)(unsigned long* ConnectionTimeout);

            typedef RPC_STATUS(__stdcall* I_RpcPerformCalloutFn)(void* Context, RDR_CALLOUT_STATE* CallOutState, RPC_HTTP_REDIRECTOR_STAGE Stage);

            typedef void(__stdcall* I_RpcFreeCalloutStateFn)(RDR_CALLOUT_STATE* CallOutState);

            typedef RPC_STATUS(__stdcall* I_RpcProxyGetClientSessionAndResourceUUID)(
            void* Context, int* SessionIdPresent, UUID* SessionId, int* ResourceIdPresent, UUID* ResourceId);

            typedef RPC_STATUS(__stdcall* I_RpcProxyFilterIfFn)(void* Context, UUID* IfUuid, unsigned short IfMajorVersion, int* fAllow);

            typedef enum RpcProxyPerfCounters
            {
                RpcCurrentUniqueUser = 1,
                RpcBackEndConnectionAttempts,
                RpcBackEndConnectionFailed,
                RpcRequestsPerSecond,
                RpcIncomingConnections,
                RpcIncomingBandwidth,
                RpcOutgoingBandwidth,
                RpcAttemptedLbsDecisions,
                RpcFailedLbsDecisions,
                RpcAttemptedLbsMessages,
                RpcFailedLbsMessages,
                RpcLastCounter
            } RpcPerfCounters;

            typedef void(__stdcall* I_RpcProxyUpdatePerfCounterFn)(RpcPerfCounters Counter, int ModifyTrend, unsigned long Size);

            typedef void(__stdcall* I_RpcProxyUpdatePerfCounterBackendServerFn)(unsigned short* MachineName, int IsConnectEvent);

            typedef struct tagI_RpcProxyCallbackInterface
            {
                I_RpcProxyIsValidMachineFn IsValidMachineFn;
                I_RpcProxyGetClientAddressFn GetClientAddressFn;
                I_RpcProxyGetConnectionTimeoutFn GetConnectionTimeoutFn;
                I_RpcPerformCalloutFn PerformCalloutFn;
                I_RpcFreeCalloutStateFn FreeCalloutStateFn;
                I_RpcProxyGetClientSessionAndResourceUUID GetClientSessionAndResourceUUIDFn;

                I_RpcProxyFilterIfFn ProxyFilterIfFn;
                I_RpcProxyUpdatePerfCounterFn RpcProxyUpdatePerfCounterFn;
                I_RpcProxyUpdatePerfCounterBackendServerFn RpcProxyUpdatePerfCounterBackendServerFn;
            } I_RpcProxyCallbackInterface;

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcProxyNewConnection(unsigned long ConnectionType,
                                                                               unsigned short* ServerAddress,
                                                                               unsigned short* ServerPort,
                                                                               unsigned short* MinConnTimeout,
                                                                               void* ConnectionParameter,
                                                                               RDR_CALLOUT_STATE* CallOutState,
                                                                               I_RpcProxyCallbackInterface* ProxyCallbackInterface);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcReplyToClientWithStatus(void* ConnectionParameter, RPC_STATUS RpcStatus);

            __declspec(dllimport) void __stdcall I_RpcRecordCalloutFailure(RPC_STATUS RpcStatus,
                                                                           RDR_CALLOUT_STATE* CallOutState,
                                                                           unsigned short* DllName);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcMgmtEnableDedicatedThreadPool(void);

            __declspec(dllimport) RPC_STATUS __stdcall I_RpcGetDefaultSD(void** ppSecurityDescriptor);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcOpenClientProcess(RPC_BINDING_HANDLE Binding, unsigned long DesiredAccess, void** ClientProcess);

            __declspec(dllimport) RPC_STATUS
            __stdcall I_RpcBindingIsServerLocal(RPC_BINDING_HANDLE Binding, unsigned int* ServerLocalFlag);

            RPC_STATUS __stdcall I_RpcBindingSetPrivateOption(RPC_BINDING_HANDLE hBinding, unsigned long option, ULONG_PTR optionValue);

            RPC_STATUS
            __stdcall I_RpcServerSubscribeForDisconnectNotification(RPC_BINDING_HANDLE Binding, void* hEvent);

            RPC_STATUS
            __stdcall I_RpcServerGetAssociationID(RPC_BINDING_HANDLE Binding, unsigned long* AssociationID);

            __declspec(dllimport) long __stdcall I_RpcServerDisableExceptionFilter(void);

#pragma endregion

#pragma warning(pop)
        }
    }

#pragma once

#pragma region Desktop Family

    typedef void* RPC_NS_HANDLE;

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingExportA(unsigned long EntryNameSyntax,
                                                                   RPC_CSTR EntryName,
                                                                   RPC_IF_HANDLE IfSpec,
                                                                   RPC_BINDING_VECTOR* BindingVec,
                                                                   UUID_VECTOR* ObjectUuidVec);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsBindingUnexportA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_HANDLE IfSpec, UUID_VECTOR* ObjectUuidVec);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingExportW(unsigned long EntryNameSyntax,
                                                                   RPC_WSTR EntryName,
                                                                   RPC_IF_HANDLE IfSpec,
                                                                   RPC_BINDING_VECTOR* BindingVec,
                                                                   UUID_VECTOR* ObjectUuidVec);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsBindingUnexportW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_HANDLE IfSpec, UUID_VECTOR* ObjectUuidVec);

    RPC_STATUS __stdcall RpcNsBindingExportPnPA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_HANDLE IfSpec, UUID_VECTOR* ObjectVector);

    RPC_STATUS __stdcall RpcNsBindingUnexportPnPA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_HANDLE IfSpec, UUID_VECTOR* ObjectVector);

    RPC_STATUS __stdcall RpcNsBindingExportPnPW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_HANDLE IfSpec, UUID_VECTOR* ObjectVector);

    RPC_STATUS __stdcall RpcNsBindingUnexportPnPW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_HANDLE IfSpec, UUID_VECTOR* ObjectVector);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingLookupBeginA(unsigned long EntryNameSyntax,
                                                                        RPC_CSTR EntryName,
                                                                        RPC_IF_HANDLE IfSpec,
                                                                        UUID* ObjUuid,
                                                                        unsigned long BindingMaxCount,
                                                                        RPC_NS_HANDLE* LookupContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingLookupBeginW(unsigned long EntryNameSyntax,
                                                                        RPC_WSTR EntryName,
                                                                        RPC_IF_HANDLE IfSpec,
                                                                        UUID* ObjUuid,
                                                                        unsigned long BindingMaxCount,
                                                                        RPC_NS_HANDLE* LookupContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingLookupNext(RPC_NS_HANDLE LookupContext, RPC_BINDING_VECTOR** BindingVec);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingLookupDone(RPC_NS_HANDLE* LookupContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupDeleteA(unsigned long GroupNameSyntax, RPC_CSTR GroupName);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsGroupMbrAddA(unsigned long GroupNameSyntax, RPC_CSTR GroupName, unsigned long MemberNameSyntax, RPC_CSTR MemberName);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsGroupMbrRemoveA(unsigned long GroupNameSyntax, RPC_CSTR GroupName, unsigned long MemberNameSyntax, RPC_CSTR MemberName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqBeginA(unsigned long GroupNameSyntax,
                                                                      RPC_CSTR GroupName,
                                                                      unsigned long MemberNameSyntax,
                                                                      RPC_NS_HANDLE* InquiryContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqNextA(RPC_NS_HANDLE InquiryContext, RPC_CSTR* MemberName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupDeleteW(unsigned long GroupNameSyntax, RPC_WSTR GroupName);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsGroupMbrAddW(unsigned long GroupNameSyntax, RPC_WSTR GroupName, unsigned long MemberNameSyntax, RPC_WSTR MemberName);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsGroupMbrRemoveW(unsigned long GroupNameSyntax, RPC_WSTR GroupName, unsigned long MemberNameSyntax, RPC_WSTR MemberName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqBeginW(unsigned long GroupNameSyntax,
                                                                      RPC_WSTR GroupName,
                                                                      unsigned long MemberNameSyntax,
                                                                      RPC_NS_HANDLE* InquiryContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqNextW(RPC_NS_HANDLE InquiryContext, RPC_WSTR* MemberName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsGroupMbrInqDone(RPC_NS_HANDLE* InquiryContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileDeleteA(unsigned long ProfileNameSyntax, RPC_CSTR ProfileName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltAddA(unsigned long ProfileNameSyntax,
                                                                   RPC_CSTR ProfileName,
                                                                   RPC_IF_ID* IfId,
                                                                   unsigned long MemberNameSyntax,
                                                                   RPC_CSTR MemberName,
                                                                   unsigned long Priority,
                                                                   RPC_CSTR Annotation);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltRemoveA(
    unsigned long ProfileNameSyntax, RPC_CSTR ProfileName, RPC_IF_ID* IfId, unsigned long MemberNameSyntax, RPC_CSTR MemberName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqBeginA(unsigned long ProfileNameSyntax,
                                                                        RPC_CSTR ProfileName,
                                                                        unsigned long InquiryType,
                                                                        RPC_IF_ID* IfId,
                                                                        unsigned long VersOption,
                                                                        unsigned long MemberNameSyntax,
                                                                        RPC_CSTR MemberName,
                                                                        RPC_NS_HANDLE* InquiryContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqNextA(
    RPC_NS_HANDLE InquiryContext, RPC_IF_ID* IfId, RPC_CSTR* MemberName, unsigned long* Priority, RPC_CSTR* Annotation);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileDeleteW(unsigned long ProfileNameSyntax, RPC_WSTR ProfileName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltAddW(unsigned long ProfileNameSyntax,
                                                                   RPC_WSTR ProfileName,
                                                                   RPC_IF_ID* IfId,
                                                                   unsigned long MemberNameSyntax,
                                                                   RPC_WSTR MemberName,
                                                                   unsigned long Priority,
                                                                   RPC_WSTR Annotation);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltRemoveW(
    unsigned long ProfileNameSyntax, RPC_WSTR ProfileName, RPC_IF_ID* IfId, unsigned long MemberNameSyntax, RPC_WSTR MemberName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqBeginW(unsigned long ProfileNameSyntax,
                                                                        RPC_WSTR ProfileName,
                                                                        unsigned long InquiryType,
                                                                        RPC_IF_ID* IfId,
                                                                        unsigned long VersOption,
                                                                        unsigned long MemberNameSyntax,
                                                                        RPC_WSTR MemberName,
                                                                        RPC_NS_HANDLE* InquiryContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqNextW(
    RPC_NS_HANDLE InquiryContext, RPC_IF_ID* IfId, RPC_WSTR* MemberName, unsigned long* Priority, RPC_WSTR* Annotation);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsProfileEltInqDone(RPC_NS_HANDLE* InquiryContext);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsEntryObjectInqBeginA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_NS_HANDLE* InquiryContext);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsEntryObjectInqBeginW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_NS_HANDLE* InquiryContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsEntryObjectInqNext(RPC_NS_HANDLE InquiryContext, UUID* ObjUuid);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsEntryObjectInqDone(RPC_NS_HANDLE* InquiryContext);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsEntryExpandNameA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_CSTR* ExpandedName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtBindingUnexportA(
    unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_ID* IfId, unsigned long VersOption, UUID_VECTOR* ObjectUuidVec);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryCreateA(unsigned long EntryNameSyntax, RPC_CSTR EntryName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryDeleteA(unsigned long EntryNameSyntax, RPC_CSTR EntryName);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsMgmtEntryInqIfIdsA(unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_ID_VECTOR** IfIdVec);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtHandleSetExpAge(RPC_NS_HANDLE NsHandle, unsigned long ExpirationAge);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtInqExpAge(unsigned long* ExpirationAge);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtSetExpAge(unsigned long ExpirationAge);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsEntryExpandNameW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_WSTR* ExpandedName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtBindingUnexportW(
    unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_ID* IfId, unsigned long VersOption, UUID_VECTOR* ObjectUuidVec);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryCreateW(unsigned long EntryNameSyntax, RPC_WSTR EntryName);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsMgmtEntryDeleteW(unsigned long EntryNameSyntax, RPC_WSTR EntryName);

    __declspec(dllimport) RPC_STATUS
    __stdcall RpcNsMgmtEntryInqIfIdsW(unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_ID_VECTOR** IfIdVec);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingImportBeginA(
    unsigned long EntryNameSyntax, RPC_CSTR EntryName, RPC_IF_HANDLE IfSpec, UUID* ObjUuid, RPC_NS_HANDLE* ImportContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingImportBeginW(
    unsigned long EntryNameSyntax, RPC_WSTR EntryName, RPC_IF_HANDLE IfSpec, UUID* ObjUuid, RPC_NS_HANDLE* ImportContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingImportNext(RPC_NS_HANDLE ImportContext, RPC_BINDING_HANDLE* Binding);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingImportDone(RPC_NS_HANDLE* ImportContext);

    __declspec(dllimport) RPC_STATUS __stdcall RpcNsBindingSelect(RPC_BINDING_VECTOR* BindingVec, RPC_BINDING_HANDLE* Binding);

#pragma endregion

#pragma once

#pragma warning(push)
#pragma warning(disable : 4668)

#pragma region Desktop Family or OneCore Family

#pragma endregion

#pragma warning(pop)

#pragma region Application Family or OneCore Family

#pragma endregion

#pragma once

#pragma warning(disable : 4103)

#pragma pack(push, 8)

    extern "C"
    {
#pragma region Application Family or OneCore Family

#pragma warning(push)
#pragma warning(disable : 4820)

        typedef enum _RPC_NOTIFICATION_TYPES
        {
            RpcNotificationTypeNone,
            RpcNotificationTypeEvent,

            RpcNotificationTypeApc,
            RpcNotificationTypeIoc,
            RpcNotificationTypeHwnd,
            RpcNotificationTypeCallback
        } RPC_NOTIFICATION_TYPES;

        typedef enum _RPC_ASYNC_EVENT
        {
            RpcCallComplete,
            RpcSendComplete,
            RpcReceiveComplete,
            RpcClientDisconnect,
            RpcClientCancel
        } RPC_ASYNC_EVENT;

        struct _RPC_ASYNC_STATE;

        typedef void __stdcall RPCNOTIFICATION_ROUTINE(struct _RPC_ASYNC_STATE* pAsync, void* Context, RPC_ASYNC_EVENT Event);
        typedef RPCNOTIFICATION_ROUTINE* PFN_RPCNOTIFICATION_ROUTINE;

        typedef union _RPC_ASYNC_NOTIFICATION_INFO
        {
            struct
            {
                PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
                HANDLE hThread;
            } APC;

            struct
            {
                HANDLE hIOPort;
                DWORD dwNumberOfBytesTransferred;
                DWORD_PTR dwCompletionKey;
                LPOVERLAPPED lpOverlapped;
            } IOC;

            struct
            {
                HWND hWnd;
                UINT Msg;
            } HWND;

            HANDLE hEvent;

            PFN_RPCNOTIFICATION_ROUTINE NotificationRoutine;
        } RPC_ASYNC_NOTIFICATION_INFO, *PRPC_ASYNC_NOTIFICATION_INFO;

        typedef struct _RPC_ASYNC_STATE
        {
            unsigned int Size;
            unsigned long Signature;
            long Lock;
            unsigned long Flags;
            void* StubInfo;
            void* UserInfo;
            void* RuntimeInfo;
            RPC_ASYNC_EVENT Event;

            RPC_NOTIFICATION_TYPES NotificationType;
            RPC_ASYNC_NOTIFICATION_INFO u;

            LONG_PTR Reserved[4];
        } RPC_ASYNC_STATE, *PRPC_ASYNC_STATE;

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcAsyncRegisterInfo(PRPC_ASYNC_STATE pAsync);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcAsyncInitializeHandle(PRPC_ASYNC_STATE pAsync, unsigned int Size);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcAsyncGetCallStatus(PRPC_ASYNC_STATE pAsync);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcAsyncCompleteCall(PRPC_ASYNC_STATE pAsync, void* Reply);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcAsyncAbortCall(PRPC_ASYNC_STATE pAsync, unsigned long ExceptionCode);

        __declspec(dllimport)

        RPC_STATUS __stdcall RpcAsyncCancelCall(PRPC_ASYNC_STATE pAsync, BOOL fAbort);

        typedef enum tagExtendedErrorParamTypes
        {
            eeptAnsiString = 1,
            eeptUnicodeString,
            eeptLongVal,
            eeptShortVal,
            eeptPointerVal,
            eeptNone,
            eeptBinary
        } ExtendedErrorParamTypes;

        typedef struct tagBinaryParam
        {
            void* Buffer;
            short Size;
        } BinaryParam;

        typedef struct tagRPC_EE_INFO_PARAM
        {
            ExtendedErrorParamTypes ParameterType;
            union
            {
                LPSTR AnsiString;
                LPWSTR UnicodeString;
                long LVal;
                short SVal;
                ULONGLONG PVal;
                BinaryParam BVal;
            } u;
        } RPC_EE_INFO_PARAM;

        typedef struct tagRPC_EXTENDED_ERROR_INFO
        {
            ULONG Version;
            LPWSTR ComputerName;
            ULONG ProcessID;
            union
            {
                SYSTEMTIME SystemTime;
                FILETIME FileTime;

            } u;
            ULONG GeneratingComponent;
            ULONG Status;
            USHORT DetectionLocation;
            USHORT Flags;
            int NumberOfParameters;
            RPC_EE_INFO_PARAM Parameters[4];
        } RPC_EXTENDED_ERROR_INFO;

        typedef struct tagRPC_ERROR_ENUM_HANDLE
        {
            ULONG Signature;
            void* CurrentPos;
            void* Head;
        } RPC_ERROR_ENUM_HANDLE;

        __declspec(dllimport) RPC_STATUS __stdcall RpcErrorStartEnumeration(RPC_ERROR_ENUM_HANDLE* EnumHandle);

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcErrorGetNextRecord(RPC_ERROR_ENUM_HANDLE* EnumHandle, BOOL CopyStrings, RPC_EXTENDED_ERROR_INFO* ErrorInfo);

        __declspec(dllimport) RPC_STATUS __stdcall RpcErrorEndEnumeration(RPC_ERROR_ENUM_HANDLE* EnumHandle);

        __declspec(dllimport) RPC_STATUS __stdcall RpcErrorResetEnumeration(RPC_ERROR_ENUM_HANDLE* EnumHandle);

        __declspec(dllimport) RPC_STATUS __stdcall RpcErrorGetNumberOfRecords(RPC_ERROR_ENUM_HANDLE* EnumHandle, int* Records);

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcErrorSaveErrorInfo(RPC_ERROR_ENUM_HANDLE* EnumHandle, PVOID* ErrorBlob, size_t* BlobSize);

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcErrorLoadErrorInfo(PVOID ErrorBlob, size_t BlobSize, RPC_ERROR_ENUM_HANDLE* EnumHandle);

        __declspec(dllimport) RPC_STATUS __stdcall RpcErrorAddRecord(RPC_EXTENDED_ERROR_INFO* ErrorInfo);

        __declspec(dllimport) void __stdcall RpcErrorClearInformation(void);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        __declspec(dllimport) RPC_STATUS __stdcall RpcAsyncCleanupThread(DWORD dwTimeout);

        __declspec(dllimport) RPC_STATUS __stdcall RpcGetAuthorizationContextForClient(RPC_BINDING_HANDLE ClientBinding,
                                                                                       BOOL ImpersonateOnReturn,
                                                                                       PVOID Reserved1,
                                                                                       PLARGE_INTEGER pExpirationTime,
                                                                                       LUID Reserved2,
                                                                                       DWORD Reserved3,
                                                                                       PVOID Reserved4,
                                                                                       PVOID* pAuthzClientContext);

        __declspec(dllimport) RPC_STATUS __stdcall RpcFreeAuthorizationContext(PVOID* pAuthzClientContext);

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcSsContextLockExclusive(RPC_BINDING_HANDLE ServerBindingHandle, PVOID UserContext);

        __declspec(dllimport) RPC_STATUS __stdcall RpcSsContextLockShared(RPC_BINDING_HANDLE ServerBindingHandle, PVOID UserContext);

        typedef enum tagRpcLocalAddressFormat
        {
            rlafInvalid = 0,
            rlafIPv4,
            rlafIPv6
        } RpcLocalAddressFormat;

        typedef struct _RPC_CALL_LOCAL_ADDRESS_V1
        {
            unsigned int Version;
            void* Buffer;
            unsigned long BufferSize;
            RpcLocalAddressFormat AddressFormat;
        } RPC_CALL_LOCAL_ADDRESS_V1, *PRPC_CALL_LOCAL_ADDRESS_V1;

        typedef struct tagRPC_CALL_ATTRIBUTES_V1_W
        {
            unsigned int Version;
            unsigned long Flags;
            unsigned long ServerPrincipalNameBufferLength;
            unsigned short* ServerPrincipalName;
            unsigned long ClientPrincipalNameBufferLength;
            unsigned short* ClientPrincipalName;
            unsigned long AuthenticationLevel;
            unsigned long AuthenticationService;
            BOOL NullSession;
        } RPC_CALL_ATTRIBUTES_V1_W;

        typedef struct tagRPC_CALL_ATTRIBUTES_V1_A
        {
            unsigned int Version;
            unsigned long Flags;
            unsigned long ServerPrincipalNameBufferLength;
            unsigned char* ServerPrincipalName;
            unsigned long ClientPrincipalNameBufferLength;
            unsigned char* ClientPrincipalName;
            unsigned long AuthenticationLevel;
            unsigned long AuthenticationService;
            BOOL NullSession;
        } RPC_CALL_ATTRIBUTES_V1_A;

        typedef enum tagRpcCallType
        {
            rctInvalid = 0,
            rctNormal,
            rctTraining,
            rctGuaranteed
        } RpcCallType;

        typedef enum tagRpcCallClientLocality
        {
            rcclInvalid = 0,
            rcclLocal,
            rcclRemote,
            rcclClientUnknownLocality
        } RpcCallClientLocality;

        typedef struct tagRPC_CALL_ATTRIBUTES_V2_W
        {
            unsigned int Version;
            unsigned long Flags;
            unsigned long ServerPrincipalNameBufferLength;
            unsigned short* ServerPrincipalName;
            unsigned long ClientPrincipalNameBufferLength;
            unsigned short* ClientPrincipalName;
            unsigned long AuthenticationLevel;
            unsigned long AuthenticationService;
            BOOL NullSession;
            BOOL KernelModeCaller;
            unsigned long ProtocolSequence;
            RpcCallClientLocality IsClientLocal;
            HANDLE ClientPID;
            unsigned long CallStatus;
            RpcCallType CallType;
            RPC_CALL_LOCAL_ADDRESS_V1* CallLocalAddress;
            unsigned short OpNum;
            UUID InterfaceUuid;
        } RPC_CALL_ATTRIBUTES_V2_W;

        typedef struct tagRPC_CALL_ATTRIBUTES_V2_A
        {
            unsigned int Version;
            unsigned long Flags;
            unsigned long ServerPrincipalNameBufferLength;
            unsigned char* ServerPrincipalName;
            unsigned long ClientPrincipalNameBufferLength;
            unsigned char* ClientPrincipalName;
            unsigned long AuthenticationLevel;
            unsigned long AuthenticationService;
            BOOL NullSession;
            BOOL KernelModeCaller;
            unsigned long ProtocolSequence;
            unsigned long IsClientLocal;
            HANDLE ClientPID;
            unsigned long CallStatus;
            RpcCallType CallType;
            RPC_CALL_LOCAL_ADDRESS_V1* CallLocalAddress;
            unsigned short OpNum;
            UUID InterfaceUuid;
        } RPC_CALL_ATTRIBUTES_V2_A;

        typedef struct tagRPC_CALL_ATTRIBUTES_V3_W
        {
            unsigned int Version;
            unsigned long Flags;
            unsigned long ServerPrincipalNameBufferLength;
            unsigned short* ServerPrincipalName;
            unsigned long ClientPrincipalNameBufferLength;
            unsigned short* ClientPrincipalName;
            unsigned long AuthenticationLevel;
            unsigned long AuthenticationService;
            BOOL NullSession;
            BOOL KernelModeCaller;
            unsigned long ProtocolSequence;
            RpcCallClientLocality IsClientLocal;
            HANDLE ClientPID;
            unsigned long CallStatus;
            RpcCallType CallType;
            RPC_CALL_LOCAL_ADDRESS_V1* CallLocalAddress;
            unsigned short OpNum;
            UUID InterfaceUuid;
            unsigned long ClientIdentifierBufferLength;
            unsigned char* ClientIdentifier;
        } RPC_CALL_ATTRIBUTES_V3_W;

        typedef struct tagRPC_CALL_ATTRIBUTES_V3_A
        {
            unsigned int Version;
            unsigned long Flags;
            unsigned long ServerPrincipalNameBufferLength;
            unsigned char* ServerPrincipalName;
            unsigned long ClientPrincipalNameBufferLength;
            unsigned char* ClientPrincipalName;
            unsigned long AuthenticationLevel;
            unsigned long AuthenticationService;
            BOOL NullSession;
            BOOL KernelModeCaller;
            unsigned long ProtocolSequence;
            unsigned long IsClientLocal;
            HANDLE ClientPID;
            unsigned long CallStatus;
            RpcCallType CallType;
            RPC_CALL_LOCAL_ADDRESS_V1* CallLocalAddress;
            unsigned short OpNum;
            UUID InterfaceUuid;
            unsigned long ClientIdentifierBufferLength;
            unsigned char* ClientIdentifier;
        } RPC_CALL_ATTRIBUTES_V3_A;

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcServerInqCallAttributesW(RPC_BINDING_HANDLE ClientBinding, void* RpcCallAttributes);

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcServerInqCallAttributesA(RPC_BINDING_HANDLE ClientBinding, void* RpcCallAttributes);

        typedef RPC_CALL_ATTRIBUTES_V3_A RPC_CALL_ATTRIBUTES;

        typedef enum _RPC_NOTIFICATIONS
        {
            RpcNotificationCallNone = 0,
            RpcNotificationClientDisconnect = 1,
            RpcNotificationCallCancel = 2
        } RPC_NOTIFICATIONS;

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcServerSubscribeForNotification(RPC_BINDING_HANDLE Binding,
                                                    RPC_NOTIFICATIONS Notification,
                                                    RPC_NOTIFICATION_TYPES NotificationType,
                                                    RPC_ASYNC_NOTIFICATION_INFO* NotificationInfo);

        __declspec(dllimport) RPC_STATUS __stdcall RpcServerUnsubscribeForNotification(RPC_BINDING_HANDLE Binding,
                                                                                       RPC_NOTIFICATIONS Notification,
                                                                                       unsigned long* NotificationsQueued);

#pragma endregion

#pragma region Application Family or OneCore Family

        __declspec(dllimport) RPC_STATUS
        __stdcall RpcBindingBind(PRPC_ASYNC_STATE pAsync, RPC_BINDING_HANDLE Binding, RPC_IF_HANDLE IfSpec);

        __declspec(dllimport) RPC_STATUS __stdcall RpcBindingUnbind(RPC_BINDING_HANDLE Binding);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        RPC_STATUS __stdcall I_RpcAsyncSetHandle(PRPC_MESSAGE Message, PRPC_ASYNC_STATE pAsync);

        RPC_STATUS __stdcall I_RpcAsyncAbortCall(PRPC_ASYNC_STATE pAsync, unsigned long ExceptionCode);

        int __stdcall I_RpcExceptionFilter(unsigned long ExceptionCode);

        __declspec(dllimport) RPC_STATUS
        __stdcall I_RpcBindingInqClientTokenAttributes(RPC_BINDING_HANDLE Binding, LUID* TokenId, LUID* AuthenticationId, LUID* ModifiedId);

#pragma warning(pop)

#pragma endregion
    }

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(disable : 4103)

#pragma pack(pop)
}

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4820)
#pragma once

extern "C"
{
#pragma region Desktop Family

    struct HDROP__
    {
        int unused;
    };
    typedef struct HDROP__* HDROP;

    extern "C" __declspec(dllimport) UINT __stdcall DragQueryFileA(HDROP hDrop, UINT iFile, LPSTR lpszFile, UINT cch);

    extern "C" __declspec(dllimport) UINT __stdcall DragQueryFileW(HDROP hDrop, UINT iFile, LPWSTR lpszFile, UINT cch);

    extern "C" __declspec(dllimport) BOOL __stdcall DragQueryPoint(HDROP hDrop, POINT* ppt);
    extern "C" __declspec(dllimport) void __stdcall DragFinish(HDROP hDrop);
    extern "C" __declspec(dllimport) void __stdcall DragAcceptFiles(HWND hWnd, BOOL fAccept);

    extern "C" __declspec(dllimport) HINSTANCE
    __stdcall ShellExecuteA(HWND hwnd, LPCSTR lpOperation, LPCSTR lpFile, LPCSTR lpParameters, LPCSTR lpDirectory, INT nShowCmd);
    extern "C" __declspec(dllimport) HINSTANCE
    __stdcall ShellExecuteW(HWND hwnd, LPCWSTR lpOperation, LPCWSTR lpFile, LPCWSTR lpParameters, LPCWSTR lpDirectory, INT nShowCmd);

    extern "C" __declspec(dllimport) HINSTANCE __stdcall FindExecutableA(LPCSTR lpFile, LPCSTR lpDirectory, LPSTR lpResult);

    extern "C" __declspec(dllimport) HINSTANCE __stdcall FindExecutableW(LPCWSTR lpFile, LPCWSTR lpDirectory, LPWSTR lpResult);

    extern "C" __declspec(dllimport) LPWSTR* __stdcall CommandLineToArgvW(LPCWSTR lpCmdLine, int* pNumArgs);

    extern "C" __declspec(dllimport) INT __stdcall ShellAboutA(HWND hWnd, LPCSTR szApp, LPCSTR szOtherStuff, HICON hIcon);
    extern "C" __declspec(dllimport) INT __stdcall ShellAboutW(HWND hWnd, LPCWSTR szApp, LPCWSTR szOtherStuff, HICON hIcon);

    extern "C" __declspec(dllimport) HICON __stdcall DuplicateIcon(HINSTANCE hInst, HICON hIcon);
    extern "C" __declspec(dllimport) HICON __stdcall ExtractAssociatedIconA(HINSTANCE hInst, LPSTR pszIconPath, WORD* piIcon);
    extern "C" __declspec(dllimport) HICON __stdcall ExtractAssociatedIconW(HINSTANCE hInst, LPWSTR pszIconPath, WORD* piIcon);

    extern "C" __declspec(dllimport) HICON
    __stdcall ExtractAssociatedIconExA(HINSTANCE hInst, LPSTR pszIconPath, WORD* piIconIndex, WORD* piIconId);
    extern "C" __declspec(dllimport) HICON
    __stdcall ExtractAssociatedIconExW(HINSTANCE hInst, LPWSTR pszIconPath, WORD* piIconIndex, WORD* piIconId);

    extern "C" __declspec(dllimport) HICON __stdcall ExtractIconA(HINSTANCE hInst, LPCSTR pszExeFileName, UINT nIconIndex);
    extern "C" __declspec(dllimport) HICON __stdcall ExtractIconW(HINSTANCE hInst, LPCWSTR pszExeFileName, UINT nIconIndex);

    typedef struct _DRAGINFOA
    {
        UINT uSize;
        POINT pt;
        BOOL fNC;
        PZZSTR lpFileList;
        DWORD grfKeyState;
    } DRAGINFOA, *LPDRAGINFOA;
    typedef struct _DRAGINFOW
    {
        UINT uSize;
        POINT pt;
        BOOL fNC;
        PZZWSTR lpFileList;
        DWORD grfKeyState;
    } DRAGINFOW, *LPDRAGINFOW;

    typedef DRAGINFOA DRAGINFO;
    typedef LPDRAGINFOA LPDRAGINFO;

    typedef struct _AppBarData
    {
        DWORD cbSize;
        HWND hWnd;
        UINT uCallbackMessage;
        UINT uEdge;
        RECT rc;
        LPARAM lParam;
    } APPBARDATA, *PAPPBARDATA;

    extern "C" __declspec(dllimport) UINT_PTR __stdcall SHAppBarMessage(DWORD dwMessage, PAPPBARDATA pData);

    extern "C" __declspec(dllimport) DWORD __stdcall DoEnvironmentSubstA(LPSTR pszSrc, UINT cchSrc);
    extern "C" __declspec(dllimport) DWORD __stdcall DoEnvironmentSubstW(LPWSTR pszSrc, UINT cchSrc);

    extern "C" __declspec(dllimport) UINT
    __stdcall ExtractIconExA(LPCSTR lpszFile, int nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIcons);
    extern "C" __declspec(dllimport) UINT
    __stdcall ExtractIconExW(LPCWSTR lpszFile, int nIconIndex, HICON* phiconLarge, HICON* phiconSmall, UINT nIcons);

    typedef WORD FILEOP_FLAGS;

    typedef WORD PRINTEROP_FLAGS;

    typedef struct _SHFILEOPSTRUCTA
    {
        HWND hwnd;
        UINT wFunc;
        PCZZSTR pFrom;
        PCZZSTR pTo;
        FILEOP_FLAGS fFlags;
        BOOL fAnyOperationsAborted;
        LPVOID hNameMappings;
        PCSTR lpszProgressTitle;
    } SHFILEOPSTRUCTA, *LPSHFILEOPSTRUCTA;
    typedef struct _SHFILEOPSTRUCTW
    {
        HWND hwnd;
        UINT wFunc;
        PCZZWSTR pFrom;
        PCZZWSTR pTo;
        FILEOP_FLAGS fFlags;
        BOOL fAnyOperationsAborted;
        LPVOID hNameMappings;
        PCWSTR lpszProgressTitle;
    } SHFILEOPSTRUCTW, *LPSHFILEOPSTRUCTW;

    typedef SHFILEOPSTRUCTA SHFILEOPSTRUCT;
    typedef LPSHFILEOPSTRUCTA LPSHFILEOPSTRUCT;

    extern "C" __declspec(dllimport) int __stdcall SHFileOperationA(LPSHFILEOPSTRUCTA lpFileOp);
    extern "C" __declspec(dllimport) int __stdcall SHFileOperationW(LPSHFILEOPSTRUCTW lpFileOp);

    extern "C" __declspec(dllimport) void __stdcall SHFreeNameMappings(HANDLE hNameMappings);

    typedef struct _SHNAMEMAPPINGA
    {
        LPSTR pszOldPath;
        LPSTR pszNewPath;
        int cchOldPath;
        int cchNewPath;
    } SHNAMEMAPPINGA, *LPSHNAMEMAPPINGA;
    typedef struct _SHNAMEMAPPINGW
    {
        LPWSTR pszOldPath;
        LPWSTR pszNewPath;
        int cchOldPath;
        int cchNewPath;
    } SHNAMEMAPPINGW, *LPSHNAMEMAPPINGW;

    typedef SHNAMEMAPPINGA SHNAMEMAPPING;
    typedef LPSHNAMEMAPPINGA LPSHNAMEMAPPING;

    typedef struct _SHELLEXECUTEINFOA
    {
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCSTR lpVerb;
        LPCSTR lpFile;
        LPCSTR lpParameters;
        LPCSTR lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        void* lpIDList;
        LPCSTR lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union
        {
            HANDLE hIcon;

            HANDLE hMonitor;
        };
        HANDLE hProcess;
    } SHELLEXECUTEINFOA, *LPSHELLEXECUTEINFOA;
    typedef struct _SHELLEXECUTEINFOW
    {
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR lpVerb;
        LPCWSTR lpFile;
        LPCWSTR lpParameters;
        LPCWSTR lpDirectory;
        int nShow;
        HINSTANCE hInstApp;
        void* lpIDList;
        LPCWSTR lpClass;
        HKEY hkeyClass;
        DWORD dwHotKey;
        union
        {
            HANDLE hIcon;

            HANDLE hMonitor;
        };
        HANDLE hProcess;
    } SHELLEXECUTEINFOW, *LPSHELLEXECUTEINFOW;

    typedef SHELLEXECUTEINFOA SHELLEXECUTEINFO;
    typedef LPSHELLEXECUTEINFOA LPSHELLEXECUTEINFO;

    extern "C" __declspec(dllimport) BOOL __stdcall ShellExecuteExA(SHELLEXECUTEINFOA* pExecInfo);
    extern "C" __declspec(dllimport) BOOL __stdcall ShellExecuteExW(SHELLEXECUTEINFOW* pExecInfo);

    typedef struct _SHCREATEPROCESSINFOW
    {
        DWORD cbSize;
        ULONG fMask;
        HWND hwnd;
        LPCWSTR pszFile;
        LPCWSTR pszParameters;
        LPCWSTR pszCurrentDirectory;
        HANDLE hUserToken;
        LPSECURITY_ATTRIBUTES lpProcessAttributes;
        LPSECURITY_ATTRIBUTES lpThreadAttributes;
        BOOL bInheritHandles;
        DWORD dwCreationFlags;
        LPSTARTUPINFOW lpStartupInfo;
        LPPROCESS_INFORMATION lpProcessInformation;
    } SHCREATEPROCESSINFOW, *PSHCREATEPROCESSINFOW;

    extern "C" __declspec(dllimport) BOOL __stdcall SHCreateProcessAsUserW(PSHCREATEPROCESSINFOW pscpi);

    extern "C" __declspec(dllimport) HRESULT
    __stdcall SHEvaluateSystemCommandTemplate(PCWSTR pszCmdTemplate, PWSTR* ppszApplication, PWSTR* ppszCommandLine, PWSTR* ppszParameters);

    typedef enum ASSOCCLASS
    {
        ASSOCCLASS_SHELL_KEY = 0,
        ASSOCCLASS_PROGID_KEY,
        ASSOCCLASS_PROGID_STR,
        ASSOCCLASS_CLSID_KEY,
        ASSOCCLASS_CLSID_STR,
        ASSOCCLASS_APP_KEY,
        ASSOCCLASS_APP_STR,
        ASSOCCLASS_SYSTEM_STR,
        ASSOCCLASS_FOLDER,
        ASSOCCLASS_STAR,

        ASSOCCLASS_FIXED_PROGID_STR,
        ASSOCCLASS_PROTOCOL_STR,
    } ASSOCCLASS;

    typedef struct ASSOCIATIONELEMENT
    {
        ASSOCCLASS ac;
        HKEY hkClass;
        PCWSTR pszClass;
    } ASSOCIATIONELEMENT;

    extern "C" __declspec(dllimport) HRESULT
    __stdcall AssocCreateForClasses(const ASSOCIATIONELEMENT* rgClasses, ULONG cClasses, const IID& riid, void** ppv);

    typedef struct _SHQUERYRBINFO
    {
        DWORD cbSize;

        __int64 i64Size;
        __int64 i64NumItems;

    } SHQUERYRBINFO, *LPSHQUERYRBINFO;

    extern "C" __declspec(dllimport) HRESULT __stdcall SHQueryRecycleBinA(LPCSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo);
    extern "C" __declspec(dllimport) HRESULT __stdcall SHQueryRecycleBinW(LPCWSTR pszRootPath, LPSHQUERYRBINFO pSHQueryRBInfo);

    extern "C" __declspec(dllimport) HRESULT __stdcall SHEmptyRecycleBinA(HWND hwnd, LPCSTR pszRootPath, DWORD dwFlags);
    extern "C" __declspec(dllimport) HRESULT __stdcall SHEmptyRecycleBinW(HWND hwnd, LPCWSTR pszRootPath, DWORD dwFlags);

    typedef enum
    {
        QUNS_NOT_PRESENT = 1,
        QUNS_BUSY = 2,
        QUNS_RUNNING_D3D_FULL_SCREEN = 3,
        QUNS_PRESENTATION_MODE = 4,
        QUNS_ACCEPTS_NOTIFICATIONS = 5,

        QUNS_QUIET_TIME = 6,

        QUNS_APP = 7,
    } QUERY_USER_NOTIFICATION_STATE;

    extern "C" __declspec(dllimport) HRESULT __stdcall SHQueryUserNotificationState(QUERY_USER_NOTIFICATION_STATE* pquns);

    extern "C" __declspec(dllimport) HRESULT __stdcall SHGetPropertyStoreForWindow(HWND hwnd, const IID& riid, void** ppv);

    typedef struct _NOTIFYICONDATAA
    {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;

        CHAR szTip[128];
        DWORD dwState;
        DWORD dwStateMask;
        CHAR szInfo[256];

        union
        {
            UINT uTimeout;
            UINT uVersion;
        };
        CHAR szInfoTitle[64];
        DWORD dwInfoFlags;

        GUID guidItem;

        HICON hBalloonIcon;
    } NOTIFYICONDATAA, *PNOTIFYICONDATAA;
    typedef struct _NOTIFYICONDATAW
    {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        UINT uFlags;
        UINT uCallbackMessage;
        HICON hIcon;

        WCHAR szTip[128];
        DWORD dwState;
        DWORD dwStateMask;
        WCHAR szInfo[256];

        union
        {
            UINT uTimeout;
            UINT uVersion;
        };
        WCHAR szInfoTitle[64];
        DWORD dwInfoFlags;

        GUID guidItem;

        HICON hBalloonIcon;
    } NOTIFYICONDATAW, *PNOTIFYICONDATAW;

    typedef NOTIFYICONDATAA NOTIFYICONDATA;
    typedef PNOTIFYICONDATAA PNOTIFYICONDATA;

    typedef struct _NOTIFYICONIDENTIFIER
    {
        DWORD cbSize;
        HWND hWnd;
        UINT uID;
        GUID guidItem;
    } NOTIFYICONIDENTIFIER, *PNOTIFYICONIDENTIFIER;

    extern "C" __declspec(dllimport) BOOL __stdcall Shell_NotifyIconA(DWORD dwMessage, PNOTIFYICONDATAA lpData);
    extern "C" __declspec(dllimport) BOOL __stdcall Shell_NotifyIconW(DWORD dwMessage, PNOTIFYICONDATAW lpData);

    extern "C" __declspec(dllimport) HRESULT
    __stdcall Shell_NotifyIconGetRect(const NOTIFYICONIDENTIFIER* identifier, RECT* iconLocation);

    typedef struct _SHFILEINFOA
    {
        HICON hIcon;
        int iIcon;
        DWORD dwAttributes;
        CHAR szDisplayName[260];
        CHAR szTypeName[80];
    } SHFILEINFOA;
    typedef struct _SHFILEINFOW
    {
        HICON hIcon;
        int iIcon;
        DWORD dwAttributes;
        WCHAR szDisplayName[260];
        WCHAR szTypeName[80];
    } SHFILEINFOW;

    typedef SHFILEINFOA SHFILEINFO;

    extern "C" __declspec(dllimport) DWORD_PTR
    __stdcall SHGetFileInfoA(LPCSTR pszPath, DWORD dwFileAttributes, SHFILEINFOA* psfi, UINT cbFileInfo, UINT uFlags);
    extern "C" __declspec(dllimport) DWORD_PTR
    __stdcall SHGetFileInfoW(LPCWSTR pszPath, DWORD dwFileAttributes, SHFILEINFOW* psfi, UINT cbFileInfo, UINT uFlags);

    typedef struct _SHSTOCKICONINFO
    {
        DWORD cbSize;
        HICON hIcon;
        int iSysImageIndex;
        int iIcon;
        WCHAR szPath[260];
    } SHSTOCKICONINFO;

    typedef enum SHSTOCKICONID
    {
        SIID_DOCNOASSOC = 0,
        SIID_DOCASSOC = 1,
        SIID_APPLICATION = 2,
        SIID_FOLDER = 3,
        SIID_FOLDEROPEN = 4,
        SIID_DRIVE525 = 5,
        SIID_DRIVE35 = 6,
        SIID_DRIVEREMOVE = 7,
        SIID_DRIVEFIXED = 8,
        SIID_DRIVENET = 9,
        SIID_DRIVENETDISABLED = 10,
        SIID_DRIVECD = 11,
        SIID_DRIVERAM = 12,
        SIID_WORLD = 13,
        SIID_SERVER = 15,
        SIID_PRINTER = 16,
        SIID_MYNETWORK = 17,
        SIID_FIND = 22,
        SIID_HELP = 23,
        SIID_SHARE = 28,
        SIID_LINK = 29,
        SIID_SLOWFILE = 30,
        SIID_RECYCLER = 31,
        SIID_RECYCLERFULL = 32,
        SIID_MEDIACDAUDIO = 40,
        SIID_LOCK = 47,
        SIID_AUTOLIST = 49,
        SIID_PRINTERNET = 50,
        SIID_SERVERSHARE = 51,
        SIID_PRINTERFAX = 52,
        SIID_PRINTERFAXNET = 53,
        SIID_PRINTERFILE = 54,
        SIID_STACK = 55,
        SIID_MEDIASVCD = 56,
        SIID_STUFFEDFOLDER = 57,
        SIID_DRIVEUNKNOWN = 58,
        SIID_DRIVEDVD = 59,
        SIID_MEDIADVD = 60,
        SIID_MEDIADVDRAM = 61,
        SIID_MEDIADVDRW = 62,
        SIID_MEDIADVDR = 63,
        SIID_MEDIADVDROM = 64,
        SIID_MEDIACDAUDIOPLUS = 65,
        SIID_MEDIACDRW = 66,
        SIID_MEDIACDR = 67,
        SIID_MEDIACDBURN = 68,
        SIID_MEDIABLANKCD = 69,
        SIID_MEDIACDROM = 70,
        SIID_AUDIOFILES = 71,
        SIID_IMAGEFILES = 72,
        SIID_VIDEOFILES = 73,
        SIID_MIXEDFILES = 74,
        SIID_FOLDERBACK = 75,
        SIID_FOLDERFRONT = 76,
        SIID_SHIELD = 77,
        SIID_WARNING = 78,
        SIID_INFO = 79,
        SIID_ERROR = 80,
        SIID_KEY = 81,
        SIID_SOFTWARE = 82,
        SIID_RENAME = 83,
        SIID_DELETE = 84,
        SIID_MEDIAAUDIODVD = 85,
        SIID_MEDIAMOVIEDVD = 86,
        SIID_MEDIAENHANCEDCD = 87,
        SIID_MEDIAENHANCEDDVD = 88,
        SIID_MEDIAHDDVD = 89,
        SIID_MEDIABLURAY = 90,
        SIID_MEDIAVCD = 91,
        SIID_MEDIADVDPLUSR = 92,
        SIID_MEDIADVDPLUSRW = 93,
        SIID_DESKTOPPC = 94,
        SIID_MOBILEPC = 95,
        SIID_USERS = 96,
        SIID_MEDIASMARTMEDIA = 97,
        SIID_MEDIACOMPACTFLASH = 98,
        SIID_DEVICECELLPHONE = 99,
        SIID_DEVICECAMERA = 100,
        SIID_DEVICEVIDEOCAMERA = 101,
        SIID_DEVICEAUDIOPLAYER = 102,
        SIID_NETWORKCONNECT = 103,
        SIID_INTERNET = 104,
        SIID_ZIPFILE = 105,
        SIID_SETTINGS = 106,

        SIID_DRIVEHDDVD = 132,
        SIID_DRIVEBD = 133,
        SIID_MEDIAHDDVDROM = 134,
        SIID_MEDIAHDDVDR = 135,
        SIID_MEDIAHDDVDRAM = 136,
        SIID_MEDIABDROM = 137,
        SIID_MEDIABDR = 138,
        SIID_MEDIABDRE = 139,
        SIID_CLUSTEREDDRIVE = 140,

        SIID_MAX_ICONS = 181,
    } SHSTOCKICONID;

    extern "C" __declspec(dllimport) HRESULT __stdcall SHGetStockIconInfo(SHSTOCKICONID siid, UINT uFlags, SHSTOCKICONINFO* psii);

    extern "C" __declspec(dllimport) BOOL __stdcall SHGetDiskFreeSpaceExA(LPCSTR pszDirectoryName,
                                                                          ULARGE_INTEGER* pulFreeBytesAvailableToCaller,
                                                                          ULARGE_INTEGER* pulTotalNumberOfBytes,
                                                                          ULARGE_INTEGER* pulTotalNumberOfFreeBytes);
    extern "C" __declspec(dllimport) BOOL __stdcall SHGetDiskFreeSpaceExW(LPCWSTR pszDirectoryName,
                                                                          ULARGE_INTEGER* pulFreeBytesAvailableToCaller,
                                                                          ULARGE_INTEGER* pulTotalNumberOfBytes,
                                                                          ULARGE_INTEGER* pulTotalNumberOfFreeBytes);

    extern "C" __declspec(dllimport) BOOL
    __stdcall SHGetNewLinkInfoA(LPCSTR pszLinkTo, LPCSTR pszDir, LPSTR pszName, BOOL* pfMustCopy, UINT uFlags);

    extern "C" __declspec(dllimport) BOOL
    __stdcall SHGetNewLinkInfoW(LPCWSTR pszLinkTo, LPCWSTR pszDir, LPWSTR pszName, BOOL* pfMustCopy, UINT uFlags);

    extern "C" __declspec(dllimport) BOOL
    __stdcall SHInvokePrinterCommandA(HWND hwnd, UINT uAction, LPCSTR lpBuf1, LPCSTR lpBuf2, BOOL fModal);
    extern "C" __declspec(dllimport) BOOL
    __stdcall SHInvokePrinterCommandW(HWND hwnd, UINT uAction, LPCWSTR lpBuf1, LPCWSTR lpBuf2, BOOL fModal);

    typedef struct _OPEN_PRINTER_PROPS_INFOA
    {
        DWORD dwSize;
        LPSTR pszSheetName;
        UINT uSheetIndex;
        DWORD dwFlags;
        BOOL bModal;
    } OPEN_PRINTER_PROPS_INFOA, *POPEN_PRINTER_PROPS_INFOA;
    typedef struct _OPEN_PRINTER_PROPS_INFOW
    {
        DWORD dwSize;
        LPWSTR pszSheetName;
        UINT uSheetIndex;
        DWORD dwFlags;
        BOOL bModal;
    } OPEN_PRINTER_PROPS_INFOW, *POPEN_PRINTER_PROPS_INFOW;

    typedef OPEN_PRINTER_PROPS_INFOA OPEN_PRINTER_PROPS_INFO;
    typedef POPEN_PRINTER_PROPS_INFOA POPEN_PRINTER_PROPS_INFO;

    extern "C" __declspec(dllimport) HRESULT __stdcall SHLoadNonloadedIconOverlayIdentifiers(void);

    extern "C" __declspec(dllimport) HRESULT __stdcall SHIsFileAvailableOffline(PCWSTR pwszPath, DWORD* pdwStatus);

    extern "C" __declspec(dllimport) HRESULT __stdcall SHSetLocalizedName(PCWSTR pszPath, PCWSTR pszResModule, int idsRes);

    extern "C" __declspec(dllimport) HRESULT __stdcall SHRemoveLocalizedName(PCWSTR pszPath);

    extern "C" __declspec(dllimport) HRESULT
    __stdcall SHGetLocalizedName(PCWSTR pszPath, PWSTR pszResModule, UINT cch, int* pidsRes);

    extern "C" __declspec(dllimport) int __cdecl ShellMessageBoxA(
    HINSTANCE hAppInst, HWND hWnd, LPCSTR lpcText, LPCSTR lpcTitle, UINT fuStyle, ...);
    extern "C" __declspec(dllimport) int __cdecl ShellMessageBoxW(
    HINSTANCE hAppInst, HWND hWnd, LPCWSTR lpcText, LPCWSTR lpcTitle, UINT fuStyle, ...);

    extern "C" __declspec(dllimport) BOOL __stdcall IsLFNDriveA(LPCSTR pszPath);
    extern "C" __declspec(dllimport) BOOL __stdcall IsLFNDriveW(LPCWSTR pszPath);

    extern "C" HRESULT __stdcall SHEnumerateUnreadMailAccountsA(HKEY hKeyUser, DWORD dwIndex, LPSTR pszMailAddress, int cchMailAddress);
    extern "C" HRESULT __stdcall SHEnumerateUnreadMailAccountsW(HKEY hKeyUser, DWORD dwIndex, LPWSTR pszMailAddress, int cchMailAddress);

    extern "C" HRESULT __stdcall SHGetUnreadMailCountA(
    HKEY hKeyUser, LPCSTR pszMailAddress, DWORD* pdwCount, FILETIME* pFileTime, LPSTR pszShellExecuteCommand, int cchShellExecuteCommand);
    extern "C" HRESULT __stdcall SHGetUnreadMailCountW(
    HKEY hKeyUser, LPCWSTR pszMailAddress, DWORD* pdwCount, FILETIME* pFileTime, LPWSTR pszShellExecuteCommand, int cchShellExecuteCommand);

    extern "C" HRESULT __stdcall SHSetUnreadMailCountA(LPCSTR pszMailAddress, DWORD dwCount, LPCSTR pszShellExecuteCommand);
    extern "C" HRESULT __stdcall SHSetUnreadMailCountW(LPCWSTR pszMailAddress, DWORD dwCount, LPCWSTR pszShellExecuteCommand);

    extern "C" BOOL __stdcall SHTestTokenMembership(HANDLE hToken, ULONG ulRID);

    extern "C" __declspec(dllimport) HRESULT __stdcall SHGetImageList(int iImageList, const IID& riid, void** ppvObj);

    typedef HRESULT(__stdcall* PFNCANSHAREFOLDERW)(PCWSTR pszPath);
    typedef HRESULT(__stdcall* PFNSHOWSHAREFOLDERUIW)(HWND hwndParent, PCWSTR pszPath);

#pragma endregion
}

#pragma region Desktop Family

extern "C" __declspec(dllimport) BOOL __stdcall InitNetworkAddressControl(void);

typedef struct tagNC_ADDRESS
{
    struct NET_ADDRESS_INFO_* pAddrInfo;
    USHORT PortNumber;
    BYTE PrefixLength;
} NC_ADDRESS, *PNC_ADDRESS;

extern "C" HRESULT __stdcall SHGetDriveMedia(PCWSTR pszDrive, DWORD* pdwMediaContent);

#pragma endregion

#pragma warning(pop)

#pragma once

#pragma warning(push)
#pragma warning(disable : 4820)

#pragma region Desktop Family

#pragma warning(disable : 4103)

#pragma pack(push, 8)

typedef struct _PERF_DATA_BLOCK
{
    WCHAR Signature[4];
    DWORD LittleEndian;
    DWORD Version;

    DWORD Revision;

    DWORD TotalByteLength;
    DWORD HeaderLength;
    DWORD NumObjectTypes;

    LONG DefaultObject;

    SYSTEMTIME SystemTime;

    LARGE_INTEGER PerfTime;

    LARGE_INTEGER PerfFreq;

    LARGE_INTEGER PerfTime100nSec;

    DWORD SystemNameLength;
    DWORD SystemNameOffset;

} PERF_DATA_BLOCK, *PPERF_DATA_BLOCK;

typedef struct _PERF_OBJECT_TYPE
{
    DWORD TotalByteLength;

    DWORD DefinitionLength;

    DWORD HeaderLength;

    DWORD ObjectNameTitleIndex;

    DWORD ObjectNameTitle;

    DWORD ObjectHelpTitleIndex;

    DWORD ObjectHelpTitle;

    DWORD DetailLevel;

    DWORD NumCounters;

    LONG DefaultCounter;

    LONG NumInstances;

    DWORD CodePage;

    LARGE_INTEGER PerfTime;

    LARGE_INTEGER PerfFreq;

} PERF_OBJECT_TYPE, *PPERF_OBJECT_TYPE;

typedef struct _PERF_COUNTER_DEFINITION
{
    DWORD ByteLength;
    DWORD CounterNameTitleIndex;

    DWORD CounterNameTitle;

    DWORD CounterHelpTitleIndex;

    DWORD CounterHelpTitle;

    LONG DefaultScale;

    DWORD DetailLevel;

    DWORD CounterType;
    DWORD CounterSize;
    DWORD CounterOffset;

} PERF_COUNTER_DEFINITION, *PPERF_COUNTER_DEFINITION;

typedef struct _PERF_INSTANCE_DEFINITION
{
    DWORD ByteLength;

    DWORD ParentObjectTitleIndex;

    DWORD ParentObjectInstance;

    LONG UniqueID;

    DWORD NameOffset;

    DWORD NameLength;

} PERF_INSTANCE_DEFINITION, *PPERF_INSTANCE_DEFINITION;

typedef struct _PERF_COUNTER_BLOCK
{
    DWORD ByteLength;

} PERF_COUNTER_BLOCK, *PPERF_COUNTER_BLOCK;

typedef DWORD(__stdcall PM_OPEN_PROC)(LPWSTR);
typedef DWORD(__stdcall PM_COLLECT_PROC)(LPWSTR lpValueName,

                                         LPVOID* lppData,
                                         LPDWORD lpcbTotalBytes,
                                         LPDWORD lpNumObjectTypes);
typedef DWORD(__stdcall PM_CLOSE_PROC)(void);
typedef DWORD(__stdcall PM_QUERY_PROC)(LPDWORD, LPVOID*, LPDWORD, LPDWORD);

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma endregion

#pragma warning(pop)

#pragma once

#pragma region Desktop Family

#pragma warning(push)
#pragma warning(disable : 4820)

typedef unsigned char u_char;
typedef unsigned short u_short;
typedef unsigned int u_int;
typedef unsigned long u_long;

typedef UINT_PTR SOCKET;

typedef struct fd_set
{
    u_int fd_count;
    SOCKET fd_array[64];
} fd_set;

extern "C"
{
    extern int __stdcall __WSAFDIsSet(SOCKET, fd_set*);
}

struct timeval
{
    long tv_sec;
    long tv_usec;
};

struct hostent
{
    char* h_name;
    char** h_aliases;
    short h_addrtype;
    short h_length;
    char** h_addr_list;
};

struct netent
{
    char* n_name;
    char** n_aliases;
    short n_addrtype;
    u_long n_net;
};

struct servent
{
    char* s_name;
    char** s_aliases;

    char* s_proto;
    short s_port;
};

struct protoent
{
    char* p_name;
    char** p_aliases;
    short p_proto;
};

#pragma once

#pragma region Desktop Family or OneCore Family

typedef struct in_addr
{
    union
    {
        struct
        {
            UCHAR s_b1, s_b2, s_b3, s_b4;
        } S_un_b;
        struct
        {
            USHORT s_w1, s_w2;
        } S_un_w;
        ULONG S_addr;
    } S_un;

} IN_ADDR, *PIN_ADDR, *LPIN_ADDR;

#pragma endregion

struct sockaddr_in
{
    short sin_family;
    u_short sin_port;
    struct in_addr sin_addr;
    char sin_zero[8];
};

typedef struct WSAData
{
    WORD wVersion;
    WORD wHighVersion;

    unsigned short iMaxSockets;
    unsigned short iMaxUdpDg;
    char* lpVendorInfo;
    char szDescription[256 + 1];
    char szSystemStatus[128 + 1];

} WSADATA;

typedef WSADATA* LPWSADATA;

struct ip_mreq
{
    struct in_addr imr_multiaddr;
    struct in_addr imr_interface;
};

struct sockaddr
{
    u_short sa_family;
    char sa_data[14];
};

struct sockproto
{
    u_short sp_family;
    u_short sp_protocol;
};

struct linger
{
    u_short l_onoff;
    u_short l_linger;
};

extern "C"
{
    SOCKET __stdcall accept(SOCKET s, struct sockaddr* addr, int* addrlen);

    int __stdcall bind(SOCKET s, const struct sockaddr* addr, int namelen);

    int __stdcall closesocket(SOCKET s);

    int __stdcall connect(SOCKET s, const struct sockaddr* name, int namelen);

    int __stdcall ioctlsocket(SOCKET s, long cmd, u_long* argp);

    int __stdcall getpeername(SOCKET s, struct sockaddr* name, int* namelen);

    int __stdcall getsockname(SOCKET s, struct sockaddr* name, int* namelen);

    int __stdcall getsockopt(SOCKET s, int level, int optname, char* optval, int* optlen);

    u_long __stdcall htonl(u_long hostlong);

    u_short __stdcall htons(u_short hostshort);

    unsigned long __stdcall inet_addr(const char* cp);

    char* __stdcall inet_ntoa(struct in_addr in);

    int __stdcall listen(SOCKET s, int backlog);

    u_long __stdcall ntohl(u_long netlong);

    u_short __stdcall ntohs(u_short netshort);

    int __stdcall recv(SOCKET s, char* buf, int len, int flags);

    int __stdcall recvfrom(SOCKET s, char* buf, int len, int flags, struct sockaddr* from, int* fromlen);

    int __stdcall select(int nfds, fd_set* readfds, fd_set* writefds, fd_set* exceptfds, const struct timeval* timeout);

    int __stdcall send(SOCKET s, const char* buf, int len, int flags);

    int __stdcall sendto(SOCKET s, const char* buf, int len, int flags, const struct sockaddr* to, int tolen);

    int __stdcall setsockopt(SOCKET s, int level, int optname, const char* optval, int optlen);

    int __stdcall shutdown(SOCKET s, int how);

    SOCKET __stdcall socket(int af, int type, int protocol);

    struct hostent* __stdcall gethostbyaddr(const char* addr, int len, int type);

    struct hostent* __stdcall gethostbyname(const char* name);

    int __stdcall gethostname(char* name, int namelen);

    struct servent* __stdcall getservbyport(int port, const char* proto);

    struct servent* __stdcall getservbyname(const char* name, const char* proto);

    struct protoent* __stdcall getprotobynumber(int proto);

    struct protoent* __stdcall getprotobyname(const char* name);

    int __stdcall WSAStartup(WORD wVersionRequired, LPWSADATA lpWSAData);

    int __stdcall WSACleanup(void);

    void __stdcall WSASetLastError(int iError);

    int __stdcall WSAGetLastError(void);

    BOOL __stdcall WSAIsBlocking(void);

    int __stdcall WSAUnhookBlockingHook(void);

    FARPROC __stdcall WSASetBlockingHook(FARPROC lpBlockFunc);

    int __stdcall WSACancelBlockingCall(void);

    HANDLE __stdcall WSAAsyncGetServByName(HWND hWnd, u_int wMsg, const char* name, const char* proto, char* buf, int buflen);

    HANDLE __stdcall WSAAsyncGetServByPort(HWND hWnd, u_int wMsg, int port, const char* proto, char* buf, int buflen);

    HANDLE __stdcall WSAAsyncGetProtoByName(HWND hWnd, u_int wMsg, const char* name, char* buf, int buflen);

    HANDLE __stdcall WSAAsyncGetProtoByNumber(HWND hWnd, u_int wMsg, int number, char* buf, int buflen);

    HANDLE __stdcall WSAAsyncGetHostByName(HWND hWnd, u_int wMsg, const char* name, char* buf, int buflen);

    HANDLE __stdcall WSAAsyncGetHostByAddr(HWND hWnd, u_int wMsg, const char* addr, int len, int type, char* buf, int buflen);

    int __stdcall WSACancelAsyncRequest(HANDLE hAsyncTaskHandle);

    int __stdcall WSAAsyncSelect(SOCKET s, HWND hWnd, u_int wMsg, long lEvent);

    int __stdcall WSARecvEx(SOCKET s, char* buf, int len, int* flags);

    typedef struct _TRANSMIT_FILE_BUFFERS
    {
        PVOID Head;
        DWORD HeadLength;
        PVOID Tail;
        DWORD TailLength;
    } TRANSMIT_FILE_BUFFERS, *PTRANSMIT_FILE_BUFFERS, *LPTRANSMIT_FILE_BUFFERS;

    BOOL __stdcall TransmitFile(SOCKET hSocket,
                                HANDLE hFile,
                                DWORD nNumberOfBytesToWrite,
                                DWORD nNumberOfBytesPerSend,
                                LPOVERLAPPED lpOverlapped,
                                LPTRANSMIT_FILE_BUFFERS lpTransmitBuffers,
                                DWORD dwReserved);

    BOOL __stdcall AcceptEx(SOCKET sListenSocket,
                            SOCKET sAcceptSocket,
                            PVOID lpOutputBuffer,
                            DWORD dwReceiveDataLength,
                            DWORD dwLocalAddressLength,
                            DWORD dwRemoteAddressLength,
                            LPDWORD lpdwBytesReceived,
                            LPOVERLAPPED lpOverlapped);

    void __stdcall GetAcceptExSockaddrs(PVOID lpOutputBuffer,
                                        DWORD dwReceiveDataLength,
                                        DWORD dwLocalAddressLength,
                                        DWORD dwRemoteAddressLength,
                                        struct sockaddr** LocalSockaddr,
                                        LPINT LocalSockaddrLength,
                                        struct sockaddr** RemoteSockaddr,
                                        LPINT RemoteSockaddrLength);
}

typedef struct sockaddr SOCKADDR;
typedef struct sockaddr* PSOCKADDR;
typedef struct sockaddr* LPSOCKADDR;

typedef struct sockaddr_in SOCKADDR_IN;
typedef struct sockaddr_in* PSOCKADDR_IN;
typedef struct sockaddr_in* LPSOCKADDR_IN;

typedef struct linger LINGER;
typedef struct linger* PLINGER;
typedef struct linger* LPLINGER;

typedef struct fd_set FD_SET;
typedef struct fd_set* PFD_SET;
typedef struct fd_set* LPFD_SET;

typedef struct hostent HOSTENT;
typedef struct hostent* PHOSTENT;
typedef struct hostent* LPHOSTENT;

typedef struct servent SERVENT;
typedef struct servent* PSERVENT;
typedef struct servent* LPSERVENT;

typedef struct protoent PROTOENT;
typedef struct protoent* PPROTOENT;
typedef struct protoent* LPPROTOENT;

typedef struct timeval TIMEVAL;
typedef struct timeval* PTIMEVAL;
typedef struct timeval* LPTIMEVAL;

#pragma warning(pop)

#pragma endregion

#pragma warning(push)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)

#pragma once

extern "C"
{
#pragma region Application Family or OneCore Family

    typedef unsigned int ALG_ID;

    typedef ULONG_PTR HCRYPTPROV;
    typedef ULONG_PTR HCRYPTKEY;
    typedef ULONG_PTR HCRYPTHASH;

    typedef struct _CMS_KEY_INFO
    {
        DWORD dwVersion;
        ALG_ID Algid;
        BYTE* pbOID;
        DWORD cbOID;
    } CMS_KEY_INFO, *PCMS_KEY_INFO;

    typedef struct _HMAC_Info
    {
        ALG_ID HashAlgid;
        BYTE* pbInnerString;
        DWORD cbInnerString;
        BYTE* pbOuterString;
        DWORD cbOuterString;
    } HMAC_INFO, *PHMAC_INFO;

    typedef struct _SCHANNEL_ALG
    {
        DWORD dwUse;
        ALG_ID Algid;
        DWORD cBits;
        DWORD dwFlags;
        DWORD dwReserved;
    } SCHANNEL_ALG, *PSCHANNEL_ALG;

    typedef struct _PROV_ENUMALGS
    {
        ALG_ID aiAlgid;
        DWORD dwBitLen;
        DWORD dwNameLen;
        CHAR szName[20];
    } PROV_ENUMALGS;

    typedef struct _PROV_ENUMALGS_EX
    {
        ALG_ID aiAlgid;
        DWORD dwDefaultLen;
        DWORD dwMinLen;
        DWORD dwMaxLen;
        DWORD dwProtocols;
        DWORD dwNameLen;
        CHAR szName[20];
        DWORD dwLongNameLen;
        CHAR szLongName[40];
    } PROV_ENUMALGS_EX;

    typedef struct _PUBLICKEYSTRUC
    {
        BYTE bType;
        BYTE bVersion;
        WORD reserved;
        ALG_ID aiKeyAlg;
    } BLOBHEADER, PUBLICKEYSTRUC;

    typedef struct _RSAPUBKEY
    {
        DWORD magic;
        DWORD bitlen;
        DWORD pubexp;

    } RSAPUBKEY;

    typedef struct _PUBKEY
    {
        DWORD magic;
        DWORD bitlen;
    } DHPUBKEY, DSSPUBKEY, KEAPUBKEY, TEKPUBKEY;

    typedef struct _DSSSEED
    {
        DWORD counter;
        BYTE seed[20];
    } DSSSEED;

    typedef struct _PUBKEYVER3
    {
        DWORD magic;
        DWORD bitlenP;
        DWORD bitlenQ;
        DWORD bitlenJ;
        DSSSEED DSSSeed;
    } DHPUBKEY_VER3, DSSPUBKEY_VER3;

    typedef struct _PRIVKEYVER3
    {
        DWORD magic;
        DWORD bitlenP;
        DWORD bitlenQ;
        DWORD bitlenJ;
        DWORD bitlenX;
        DSSSEED DSSSeed;
    } DHPRIVKEY_VER3, DSSPRIVKEY_VER3;

    typedef struct _KEY_TYPE_SUBTYPE
    {
        DWORD dwKeySpec;
        GUID Type;
        GUID Subtype;
    } KEY_TYPE_SUBTYPE, *PKEY_TYPE_SUBTYPE;

    typedef struct _CERT_FORTEZZA_DATA_PROP
    {
        unsigned char SerialNumber[8];
        int CertIndex;
        unsigned char CertLabel[36];
    } CERT_FORTEZZA_DATA_PROP;

    typedef struct _CRYPT_RC4_KEY_STATE
    {
        unsigned char Key[16];
        unsigned char SBox[256];
        unsigned char i;
        unsigned char j;
    } CRYPT_RC4_KEY_STATE, *PCRYPT_RC4_KEY_STATE;

    typedef struct _CRYPT_DES_KEY_STATE
    {
        unsigned char Key[8];
        unsigned char IV[8];
        unsigned char Feedback[8];
    } CRYPT_DES_KEY_STATE, *PCRYPT_DES_KEY_STATE;

    typedef struct _CRYPT_3DES_KEY_STATE
    {
        unsigned char Key[24];
        unsigned char IV[8];
        unsigned char Feedback[8];
    } CRYPT_3DES_KEY_STATE, *PCRYPT_3DES_KEY_STATE;

    typedef struct _CRYPT_AES_128_KEY_STATE
    {
        unsigned char Key[16];
        unsigned char IV[16];
        unsigned char EncryptionState[11][16];
        unsigned char DecryptionState[11][16];
        unsigned char Feedback[16];
    } CRYPT_AES_128_KEY_STATE, *PCRYPT_AES_128_KEY_STATE;

    typedef struct _CRYPT_AES_256_KEY_STATE
    {
        unsigned char Key[32];
        unsigned char IV[16];
        unsigned char EncryptionState[15][16];
        unsigned char DecryptionState[15][16];
        unsigned char Feedback[16];
    } CRYPT_AES_256_KEY_STATE, *PCRYPT_AES_256_KEY_STATE;

    typedef struct _CRYPTOAPI_BLOB
    {
        DWORD cbData;
        BYTE* pbData;
    } CRYPT_INTEGER_BLOB, *PCRYPT_INTEGER_BLOB, CRYPT_UINT_BLOB, *PCRYPT_UINT_BLOB, CRYPT_OBJID_BLOB, *PCRYPT_OBJID_BLOB,
    CERT_NAME_BLOB, *PCERT_NAME_BLOB, CERT_RDN_VALUE_BLOB, *PCERT_RDN_VALUE_BLOB, CERT_BLOB, *PCERT_BLOB, CRL_BLOB,
    *PCRL_BLOB, DATA_BLOB, *PDATA_BLOB, CRYPT_DATA_BLOB, *PCRYPT_DATA_BLOB, CRYPT_HASH_BLOB, *PCRYPT_HASH_BLOB,
    CRYPT_DIGEST_BLOB, *PCRYPT_DIGEST_BLOB, CRYPT_DER_BLOB, *PCRYPT_DER_BLOB, CRYPT_ATTR_BLOB, *PCRYPT_ATTR_BLOB;

    typedef struct _CMS_DH_KEY_INFO
    {
        DWORD dwVersion;
        ALG_ID Algid;
        LPSTR pszContentEncObjId;
        CRYPT_DATA_BLOB PubInfo;
        void* pReserved;
    } CMS_DH_KEY_INFO, *PCMS_DH_KEY_INFO;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall CryptAcquireContextA(HCRYPTPROV* phProv, LPCSTR szContainer, LPCSTR szProvider, DWORD dwProvType, DWORD dwFlags);
    __declspec(dllimport) BOOL
    __stdcall CryptAcquireContextW(HCRYPTPROV* phProv, LPCWSTR szContainer, LPCWSTR szProvider, DWORD dwProvType, DWORD dwFlags);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptReleaseContext(HCRYPTPROV hProv, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptGenKey(HCRYPTPROV hProv, ALG_ID Algid, DWORD dwFlags, HCRYPTKEY* phKey);

    __declspec(dllimport) BOOL
    __stdcall CryptDeriveKey(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTHASH hBaseData, DWORD dwFlags, HCRYPTKEY* phKey);

    __declspec(dllimport) BOOL __stdcall CryptDestroyKey(HCRYPTKEY hKey);

    __declspec(dllimport) BOOL __stdcall CryptSetKeyParam(HCRYPTKEY hKey, DWORD dwParam, const BYTE* pbData, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall CryptGetKeyParam(HCRYPTKEY hKey, DWORD dwParam, BYTE* pbData, DWORD* pdwDataLen, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall CryptSetHashParam(HCRYPTHASH hHash, DWORD dwParam, const BYTE* pbData, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall CryptGetHashParam(HCRYPTHASH hHash, DWORD dwParam, BYTE* pbData, DWORD* pdwDataLen, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall CryptSetProvParam(HCRYPTPROV hProv, DWORD dwParam, const BYTE* pbData, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall CryptGetProvParam(HCRYPTPROV hProv, DWORD dwParam, BYTE* pbData, DWORD* pdwDataLen, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall CryptGenRandom(HCRYPTPROV hProv, DWORD dwLen, BYTE* pbBuffer);

    __declspec(dllimport) BOOL __stdcall CryptGetUserKey(HCRYPTPROV hProv, DWORD dwKeySpec, HCRYPTKEY* phUserKey);

    __declspec(dllimport) BOOL
    __stdcall CryptExportKey(HCRYPTKEY hKey, HCRYPTKEY hExpKey, DWORD dwBlobType, DWORD dwFlags, BYTE* pbData, DWORD* pdwDataLen);

    __declspec(dllimport) BOOL
    __stdcall CryptImportKey(HCRYPTPROV hProv, const BYTE* pbData, DWORD dwDataLen, HCRYPTKEY hPubKey, DWORD dwFlags, HCRYPTKEY* phKey);

    __declspec(dllimport) BOOL
    __stdcall CryptEncrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE* pbData, DWORD* pdwDataLen, DWORD dwBufLen);

    __declspec(dllimport) BOOL
    __stdcall CryptDecrypt(HCRYPTKEY hKey, HCRYPTHASH hHash, BOOL Final, DWORD dwFlags, BYTE* pbData, DWORD* pdwDataLen);

    __declspec(dllimport) BOOL
    __stdcall CryptCreateHash(HCRYPTPROV hProv, ALG_ID Algid, HCRYPTKEY hKey, DWORD dwFlags, HCRYPTHASH* phHash);

    __declspec(dllimport) BOOL __stdcall CryptHashData(HCRYPTHASH hHash, const BYTE* pbData, DWORD dwDataLen, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall CryptHashSessionKey(HCRYPTHASH hHash, HCRYPTKEY hKey, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall CryptDestroyHash(HCRYPTHASH hHash);

    __declspec(dllimport) BOOL
    __stdcall CryptSignHashA(HCRYPTHASH hHash, DWORD dwKeySpec, LPCSTR szDescription, DWORD dwFlags, BYTE* pbSignature, DWORD* pdwSigLen);
    __declspec(dllimport) BOOL
    __stdcall CryptSignHashW(HCRYPTHASH hHash, DWORD dwKeySpec, LPCWSTR szDescription, DWORD dwFlags, BYTE* pbSignature, DWORD* pdwSigLen);

    __declspec(dllimport) BOOL __stdcall CryptVerifySignatureA(
    HCRYPTHASH hHash, const BYTE* pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCSTR szDescription, DWORD dwFlags);
    __declspec(dllimport) BOOL __stdcall CryptVerifySignatureW(
    HCRYPTHASH hHash, const BYTE* pbSignature, DWORD dwSigLen, HCRYPTKEY hPubKey, LPCWSTR szDescription, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall CryptSetProviderA(LPCSTR pszProvName, DWORD dwProvType);
    __declspec(dllimport) BOOL __stdcall CryptSetProviderW(LPCWSTR pszProvName, DWORD dwProvType);

    __declspec(dllimport) BOOL
    __stdcall CryptSetProviderExA(LPCSTR pszProvName, DWORD dwProvType, DWORD* pdwReserved, DWORD dwFlags);
    __declspec(dllimport) BOOL
    __stdcall CryptSetProviderExW(LPCWSTR pszProvName, DWORD dwProvType, DWORD* pdwReserved, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall CryptGetDefaultProviderA(DWORD dwProvType, DWORD* pdwReserved, DWORD dwFlags, LPSTR pszProvName, DWORD* pcbProvName);
    __declspec(dllimport) BOOL
    __stdcall CryptGetDefaultProviderW(DWORD dwProvType, DWORD* pdwReserved, DWORD dwFlags, LPWSTR pszProvName, DWORD* pcbProvName);

    __declspec(dllimport) BOOL
    __stdcall CryptEnumProviderTypesA(DWORD dwIndex, DWORD* pdwReserved, DWORD dwFlags, DWORD* pdwProvType, LPSTR szTypeName, DWORD* pcbTypeName);
    __declspec(dllimport) BOOL
    __stdcall CryptEnumProviderTypesW(DWORD dwIndex, DWORD* pdwReserved, DWORD dwFlags, DWORD* pdwProvType, LPWSTR szTypeName, DWORD* pcbTypeName);

    __declspec(dllimport) BOOL
    __stdcall CryptEnumProvidersA(DWORD dwIndex, DWORD* pdwReserved, DWORD dwFlags, DWORD* pdwProvType, LPSTR szProvName, DWORD* pcbProvName);
    __declspec(dllimport) BOOL
    __stdcall CryptEnumProvidersW(DWORD dwIndex, DWORD* pdwReserved, DWORD dwFlags, DWORD* pdwProvType, LPWSTR szProvName, DWORD* pcbProvName);

    __declspec(dllimport) BOOL __stdcall CryptContextAddRef(HCRYPTPROV hProv, DWORD* pdwReserved, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall CryptDuplicateKey(HCRYPTKEY hKey, DWORD* pdwReserved, DWORD dwFlags, HCRYPTKEY* phKey);

    __declspec(dllimport) BOOL
    __stdcall CryptDuplicateHash(HCRYPTHASH hHash, DWORD* pdwReserved, DWORD dwFlags, HCRYPTHASH* phHash);

#pragma endregion

#pragma region Desktop Family

    BOOL __cdecl GetEncSChannel(BYTE** pData, DWORD* dwDecSize);

#pragma endregion

#pragma region Desktop Family or OneCore Family

#pragma once

#pragma warning(push)
#pragma warning(disable : 4820)

    extern "C"
    {
#pragma region Desktop Family or OneCore Family

        typedef LONG NTSTATUS;
        typedef NTSTATUS* PNTSTATUS;

        typedef struct __BCRYPT_KEY_LENGTHS_STRUCT
        {
            ULONG dwMinLength;
            ULONG dwMaxLength;
            ULONG dwIncrement;
        } BCRYPT_KEY_LENGTHS_STRUCT;

        typedef BCRYPT_KEY_LENGTHS_STRUCT BCRYPT_AUTH_TAG_LENGTHS_STRUCT;

        typedef struct _BCRYPT_OID
        {
            ULONG cbOID;
            PUCHAR pbOID;
        } BCRYPT_OID;

        typedef struct _BCRYPT_OID_LIST
        {
            ULONG dwOIDCount;
            BCRYPT_OID* pOIDs;
        } BCRYPT_OID_LIST;

        typedef struct _BCRYPT_PKCS1_PADDING_INFO
        {
            LPCWSTR pszAlgId;
        } BCRYPT_PKCS1_PADDING_INFO;

        typedef struct _BCRYPT_PSS_PADDING_INFO
        {
            LPCWSTR pszAlgId;
            ULONG cbSalt;
        } BCRYPT_PSS_PADDING_INFO;

        typedef struct _BCRYPT_OAEP_PADDING_INFO
        {
            LPCWSTR pszAlgId;
            PUCHAR pbLabel;
            ULONG cbLabel;
        } BCRYPT_OAEP_PADDING_INFO;

        typedef struct _BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO
        {
            ULONG cbSize;
            ULONG dwInfoVersion;
            PUCHAR pbNonce;
            ULONG cbNonce;
            PUCHAR pbAuthData;
            ULONG cbAuthData;
            PUCHAR pbTag;
            ULONG cbTag;
            PUCHAR pbMacContext;
            ULONG cbMacContext;
            ULONG cbAAD;
            ULONGLONG cbData;
            ULONG dwFlags;
        } BCRYPT_AUTHENTICATED_CIPHER_MODE_INFO, *PBCRYPT_AUTHENTICATED_CIPHER_MODE_INFO;

        typedef struct _BCryptBuffer
        {
            ULONG cbBuffer;
            ULONG BufferType;
            PVOID pvBuffer;
        } BCryptBuffer, *PBCryptBuffer;

        typedef struct _BCryptBufferDesc
        {
            ULONG ulVersion;
            ULONG cBuffers;
            PBCryptBuffer pBuffers;
        } BCryptBufferDesc, *PBCryptBufferDesc;

        typedef PVOID BCRYPT_HANDLE;
        typedef PVOID BCRYPT_ALG_HANDLE;
        typedef PVOID BCRYPT_KEY_HANDLE;
        typedef PVOID BCRYPT_HASH_HANDLE;
        typedef PVOID BCRYPT_SECRET_HANDLE;

        typedef struct _BCRYPT_KEY_BLOB
        {
            ULONG Magic;
        } BCRYPT_KEY_BLOB;

        typedef struct _BCRYPT_RSAKEY_BLOB
        {
            ULONG Magic;
            ULONG BitLength;
            ULONG cbPublicExp;
            ULONG cbModulus;
            ULONG cbPrime1;
            ULONG cbPrime2;
        } BCRYPT_RSAKEY_BLOB;

        typedef struct _BCRYPT_ECCKEY_BLOB
        {
            ULONG dwMagic;
            ULONG cbKey;
        } BCRYPT_ECCKEY_BLOB, *PBCRYPT_ECCKEY_BLOB;

        typedef struct _SSL_ECCKEY_BLOB
        {
            ULONG dwCurveType;
            ULONG cbKey;
        } SSL_ECCKEY_BLOB, *PSSL_ECCKEY_BLOB;

        typedef enum
        {
            BCRYPT_ECC_PRIME_SHORT_WEIERSTRASS_CURVE = 0x1,
            BCRYPT_ECC_PRIME_TWISTED_EDWARDS_CURVE = 0x2,
            BCRYPT_ECC_PRIME_MONTGOMERY_CURVE = 0x3
        } ECC_CURVE_TYPE_ENUM;

        typedef enum
        {
            BCRYPT_NO_CURVE_GENERATION_ALG_ID = 0x0
        } ECC_CURVE_ALG_ID_ENUM;

        typedef struct _BCRYPT_ECCFULLKEY_BLOB
        {
            ULONG dwMagic;
            ULONG dwVersion;
            ECC_CURVE_TYPE_ENUM dwCurveType;
            ECC_CURVE_ALG_ID_ENUM dwCurveGenerationAlgId;
            ULONG cbFieldLength;
            ULONG cbSubgroupOrder;
            ULONG cbCofactor;
            ULONG cbSeed;

        } BCRYPT_ECCFULLKEY_BLOB, *PBCRYPT_ECCFULLKEY_BLOB;

        typedef struct _BCRYPT_DH_KEY_BLOB
        {
            ULONG dwMagic;
            ULONG cbKey;
        } BCRYPT_DH_KEY_BLOB, *PBCRYPT_DH_KEY_BLOB;

        typedef struct _BCRYPT_DH_PARAMETER_HEADER
        {
            ULONG cbLength;
            ULONG dwMagic;
            ULONG cbKeyLength;
        } BCRYPT_DH_PARAMETER_HEADER;

        typedef struct _BCRYPT_DSA_KEY_BLOB
        {
            ULONG dwMagic;
            ULONG cbKey;
            UCHAR Count[4];
            UCHAR Seed[20];
            UCHAR q[20];
        } BCRYPT_DSA_KEY_BLOB, *PBCRYPT_DSA_KEY_BLOB;

        typedef enum
        {
            DSA_HASH_ALGORITHM_SHA1,
            DSA_HASH_ALGORITHM_SHA256,
            DSA_HASH_ALGORITHM_SHA512
        } HASHALGORITHM_ENUM;

        typedef enum
        {
            DSA_FIPS186_2,
            DSA_FIPS186_3
        } DSAFIPSVERSION_ENUM;

        typedef struct _BCRYPT_DSA_KEY_BLOB_V2
        {
            ULONG dwMagic;
            ULONG cbKey;
            HASHALGORITHM_ENUM hashAlgorithm;
            DSAFIPSVERSION_ENUM standardVersion;
            ULONG cbSeedLength;
            ULONG cbGroupSize;
            UCHAR Count[4];
        } BCRYPT_DSA_KEY_BLOB_V2, *PBCRYPT_DSA_KEY_BLOB_V2;

        typedef struct _BCRYPT_KEY_DATA_BLOB_HEADER
        {
            ULONG dwMagic;
            ULONG dwVersion;
            ULONG cbKeyData;
        } BCRYPT_KEY_DATA_BLOB_HEADER, *PBCRYPT_KEY_DATA_BLOB_HEADER;

        typedef struct _BCRYPT_DSA_PARAMETER_HEADER
        {
            ULONG cbLength;
            ULONG dwMagic;
            ULONG cbKeyLength;
            UCHAR Count[4];
            UCHAR Seed[20];
            UCHAR q[20];
        } BCRYPT_DSA_PARAMETER_HEADER;

        typedef struct _BCRYPT_DSA_PARAMETER_HEADER_V2
        {
            ULONG cbLength;
            ULONG dwMagic;
            ULONG cbKeyLength;
            HASHALGORITHM_ENUM hashAlgorithm;
            DSAFIPSVERSION_ENUM standardVersion;
            ULONG cbSeedLength;
            ULONG cbGroupSize;
            UCHAR Count[4];
        } BCRYPT_DSA_PARAMETER_HEADER_V2;

        typedef struct _BCRYPT_ECC_CURVE_NAMES
        {
            ULONG dwEccCurveNames;
            LPWSTR* pEccCurveNames;
        } BCRYPT_ECC_CURVE_NAMES;

        typedef enum
        {
            BCRYPT_HASH_OPERATION_HASH_DATA = 1,
            BCRYPT_HASH_OPERATION_FINISH_HASH = 2,
        } BCRYPT_HASH_OPERATION_TYPE;

        typedef struct _BCRYPT_MULTI_HASH_OPERATION
        {
            ULONG iHash;
            BCRYPT_HASH_OPERATION_TYPE hashOperation;
            PUCHAR pbBuffer;
            ULONG cbBuffer;
        } BCRYPT_MULTI_HASH_OPERATION;

        typedef enum
        {
            BCRYPT_OPERATION_TYPE_HASH = 1,
        } BCRYPT_MULTI_OPERATION_TYPE;

        typedef struct _BCRYPT_MULTI_OBJECT_LENGTH_STRUCT
        {
            ULONG cbPerObject;
            ULONG cbPerElement;
        } BCRYPT_MULTI_OBJECT_LENGTH_STRUCT;

        NTSTATUS
        __stdcall BCryptOpenAlgorithmProvider(BCRYPT_ALG_HANDLE* phAlgorithm, LPCWSTR pszAlgId, LPCWSTR pszImplementation, ULONG dwFlags);

        typedef struct _BCRYPT_ALGORITHM_IDENTIFIER
        {
            LPWSTR pszName;
            ULONG dwClass;
            ULONG dwFlags;

        } BCRYPT_ALGORITHM_IDENTIFIER;

        NTSTATUS
        __stdcall BCryptEnumAlgorithms(ULONG dwAlgOperations, ULONG* pAlgCount, BCRYPT_ALGORITHM_IDENTIFIER** ppAlgList, ULONG dwFlags);

        typedef struct _BCRYPT_PROVIDER_NAME
        {
            LPWSTR pszProviderName;
        } BCRYPT_PROVIDER_NAME;

        NTSTATUS
        __stdcall BCryptEnumProviders(LPCWSTR pszAlgId, ULONG* pImplCount, BCRYPT_PROVIDER_NAME** ppImplList, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptGetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbOutput, ULONG cbOutput, ULONG* pcbResult, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptSetProperty(BCRYPT_HANDLE hObject, LPCWSTR pszProperty, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptCloseAlgorithmProvider(BCRYPT_ALG_HANDLE hAlgorithm, ULONG dwFlags);

        void __stdcall BCryptFreeBuffer(PVOID pvBuffer);

        NTSTATUS
        __stdcall BCryptGenerateSymmetricKey(BCRYPT_ALG_HANDLE hAlgorithm,
                                             BCRYPT_KEY_HANDLE* phKey,
                                             PUCHAR pbKeyObject,
                                             ULONG cbKeyObject,
                                             PUCHAR pbSecret,
                                             ULONG cbSecret,
                                             ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptGenerateKeyPair(BCRYPT_ALG_HANDLE hAlgorithm, BCRYPT_KEY_HANDLE* phKey, ULONG dwLength, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptEncrypt(BCRYPT_KEY_HANDLE hKey,
                                PUCHAR pbInput,
                                ULONG cbInput,
                                void* pPaddingInfo,
                                PUCHAR pbIV,
                                ULONG cbIV,
                                PUCHAR pbOutput,
                                ULONG cbOutput,
                                ULONG* pcbResult,
                                ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptDecrypt(BCRYPT_KEY_HANDLE hKey,
                                PUCHAR pbInput,
                                ULONG cbInput,
                                void* pPaddingInfo,
                                PUCHAR pbIV,
                                ULONG cbIV,
                                PUCHAR pbOutput,
                                ULONG cbOutput,
                                ULONG* pcbResult,
                                ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptExportKey(BCRYPT_KEY_HANDLE hKey,
                                  BCRYPT_KEY_HANDLE hExportKey,
                                  LPCWSTR pszBlobType,
                                  PUCHAR pbOutput,
                                  ULONG cbOutput,
                                  ULONG* pcbResult,
                                  ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptImportKey(BCRYPT_ALG_HANDLE hAlgorithm,
                                  BCRYPT_KEY_HANDLE hImportKey,
                                  LPCWSTR pszBlobType,
                                  BCRYPT_KEY_HANDLE* phKey,
                                  PUCHAR pbKeyObject,
                                  ULONG cbKeyObject,
                                  PUCHAR pbInput,
                                  ULONG cbInput,
                                  ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptImportKeyPair(BCRYPT_ALG_HANDLE hAlgorithm,
                                      BCRYPT_KEY_HANDLE hImportKey,
                                      LPCWSTR pszBlobType,
                                      BCRYPT_KEY_HANDLE* phKey,
                                      PUCHAR pbInput,
                                      ULONG cbInput,
                                      ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptDuplicateKey(BCRYPT_KEY_HANDLE hKey, BCRYPT_KEY_HANDLE* phNewKey, PUCHAR pbKeyObject, ULONG cbKeyObject, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptFinalizeKeyPair(BCRYPT_KEY_HANDLE hKey, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptDestroyKey(BCRYPT_KEY_HANDLE hKey);

        NTSTATUS
        __stdcall BCryptDestroySecret(BCRYPT_SECRET_HANDLE hSecret);

        NTSTATUS
        __stdcall BCryptSignHash(
        BCRYPT_KEY_HANDLE hKey, void* pPaddingInfo, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput, ULONG* pcbResult, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptVerifySignature(
        BCRYPT_KEY_HANDLE hKey, void* pPaddingInfo, PUCHAR pbHash, ULONG cbHash, PUCHAR pbSignature, ULONG cbSignature, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptSecretAgreement(BCRYPT_KEY_HANDLE hPrivKey, BCRYPT_KEY_HANDLE hPubKey, BCRYPT_SECRET_HANDLE* phAgreedSecret, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptDeriveKey(BCRYPT_SECRET_HANDLE hSharedSecret,
                                  LPCWSTR pwszKDF,
                                  BCryptBufferDesc* pParameterList,
                                  PUCHAR pbDerivedKey,
                                  ULONG cbDerivedKey,
                                  ULONG* pcbResult,
                                  ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptKeyDerivation(BCRYPT_KEY_HANDLE hKey,
                                      BCryptBufferDesc* pParameterList,
                                      PUCHAR pbDerivedKey,
                                      ULONG cbDerivedKey,
                                      ULONG* pcbResult,
                                      ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptCreateHash(BCRYPT_ALG_HANDLE hAlgorithm,
                                   BCRYPT_HASH_HANDLE* phHash,
                                   PUCHAR pbHashObject,
                                   ULONG cbHashObject,
                                   PUCHAR pbSecret,
                                   ULONG cbSecret,
                                   ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptHashData(BCRYPT_HASH_HANDLE hHash, PUCHAR pbInput, ULONG cbInput, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptFinishHash(BCRYPT_HASH_HANDLE hHash, PUCHAR pbOutput, ULONG cbOutput, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptCreateMultiHash(BCRYPT_ALG_HANDLE hAlgorithm,
                                        BCRYPT_HASH_HANDLE* phHash,
                                        ULONG nHashes,
                                        PUCHAR pbHashObject,
                                        ULONG cbHashObject,
                                        PUCHAR pbSecret,
                                        ULONG cbSecret,
                                        ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptProcessMultiOperations(
        BCRYPT_HANDLE hObject, BCRYPT_MULTI_OPERATION_TYPE operationType, PVOID pOperations, ULONG cbOperations, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptDuplicateHash(BCRYPT_HASH_HANDLE hHash, BCRYPT_HASH_HANDLE* phNewHash, PUCHAR pbHashObject, ULONG cbHashObject, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptDestroyHash(BCRYPT_HASH_HANDLE hHash);

        NTSTATUS
        __stdcall BCryptHash(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbSecret, ULONG cbSecret, PUCHAR pbInput, ULONG cbInput, PUCHAR pbOutput, ULONG cbOutput);

        NTSTATUS
        __stdcall BCryptGenRandom(BCRYPT_ALG_HANDLE hAlgorithm, PUCHAR pbBuffer, ULONG cbBuffer, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptDeriveKeyCapi(BCRYPT_HASH_HANDLE hHash, BCRYPT_ALG_HANDLE hTargetAlg, PUCHAR pbDerivedKey, ULONG cbDerivedKey, ULONG dwFlags);

        NTSTATUS
        __stdcall BCryptDeriveKeyPBKDF2(BCRYPT_ALG_HANDLE hPrf,
                                        PUCHAR pbPassword,
                                        ULONG cbPassword,
                                        PUCHAR pbSalt,
                                        ULONG cbSalt,
                                        ULONGLONG cIterations,
                                        PUCHAR pbDerivedKey,
                                        ULONG cbDerivedKey,
                                        ULONG dwFlags);

        typedef struct _BCRYPT_INTERFACE_VERSION
        {
            USHORT MajorVersion;
            USHORT MinorVersion;

        } BCRYPT_INTERFACE_VERSION, *PBCRYPT_INTERFACE_VERSION;

        typedef struct _CRYPT_INTERFACE_REG
        {
            ULONG dwInterface;
            ULONG dwFlags;

            ULONG cFunctions;
            PWSTR* rgpszFunctions;
        } CRYPT_INTERFACE_REG, *PCRYPT_INTERFACE_REG;

        typedef struct _CRYPT_IMAGE_REG
        {
            PWSTR pszImage;

            ULONG cInterfaces;
            PCRYPT_INTERFACE_REG* rgpInterfaces;
        } CRYPT_IMAGE_REG, *PCRYPT_IMAGE_REG;

        typedef struct _CRYPT_PROVIDER_REG
        {
            ULONG cAliases;
            PWSTR* rgpszAliases;

            PCRYPT_IMAGE_REG pUM;
            PCRYPT_IMAGE_REG pKM;
        } CRYPT_PROVIDER_REG, *PCRYPT_PROVIDER_REG;

        typedef struct _CRYPT_PROVIDERS
        {
            ULONG cProviders;
            PWSTR* rgpszProviders;
        } CRYPT_PROVIDERS, *PCRYPT_PROVIDERS;

        typedef struct _CRYPT_CONTEXT_CONFIG
        {
            ULONG dwFlags;
            ULONG dwReserved;
        } CRYPT_CONTEXT_CONFIG, *PCRYPT_CONTEXT_CONFIG;

        typedef struct _CRYPT_CONTEXT_FUNCTION_CONFIG
        {
            ULONG dwFlags;
            ULONG dwReserved;
        } CRYPT_CONTEXT_FUNCTION_CONFIG, *PCRYPT_CONTEXT_FUNCTION_CONFIG;

        typedef struct _CRYPT_CONTEXTS
        {
            ULONG cContexts;
            PWSTR* rgpszContexts;
        } CRYPT_CONTEXTS, *PCRYPT_CONTEXTS;

        typedef struct _CRYPT_CONTEXT_FUNCTIONS
        {
            ULONG cFunctions;
            PWSTR* rgpszFunctions;
        } CRYPT_CONTEXT_FUNCTIONS, *PCRYPT_CONTEXT_FUNCTIONS;

        typedef struct _CRYPT_CONTEXT_FUNCTION_PROVIDERS
        {
            ULONG cProviders;
            PWSTR* rgpszProviders;
        } CRYPT_CONTEXT_FUNCTION_PROVIDERS, *PCRYPT_CONTEXT_FUNCTION_PROVIDERS;

        typedef struct _CRYPT_PROPERTY_REF
        {
            PWSTR pszProperty;

            ULONG cbValue;
            PUCHAR pbValue;
        } CRYPT_PROPERTY_REF, *PCRYPT_PROPERTY_REF;

        typedef struct _CRYPT_IMAGE_REF
        {
            PWSTR pszImage;
            ULONG dwFlags;
        } CRYPT_IMAGE_REF, *PCRYPT_IMAGE_REF;

        typedef struct _CRYPT_PROVIDER_REF
        {
            ULONG dwInterface;
            PWSTR pszFunction;
            PWSTR pszProvider;

            ULONG cProperties;
            PCRYPT_PROPERTY_REF* rgpProperties;

            PCRYPT_IMAGE_REF pUM;
            PCRYPT_IMAGE_REF pKM;
        } CRYPT_PROVIDER_REF, *PCRYPT_PROVIDER_REF;

        typedef struct _CRYPT_PROVIDER_REFS
        {
            ULONG cProviders;
            PCRYPT_PROVIDER_REF* rgpProviders;
        } CRYPT_PROVIDER_REFS, *PCRYPT_PROVIDER_REFS;

#pragma endregion

#pragma region Desktop Family or OneCore Family

        NTSTATUS
        __stdcall BCryptQueryProviderRegistration(LPCWSTR pszProvider,
                                                  ULONG dwMode,
                                                  ULONG dwInterface,
                                                  ULONG* pcbBuffer,

                                                  PCRYPT_PROVIDER_REG* ppBuffer);

        NTSTATUS
        __stdcall BCryptEnumRegisteredProviders(ULONG* pcbBuffer,

                                                PCRYPT_PROVIDERS* ppBuffer);

        NTSTATUS
        __stdcall BCryptCreateContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig);

        NTSTATUS
        __stdcall BCryptDeleteContext(ULONG dwTable, LPCWSTR pszContext);

        NTSTATUS
        __stdcall BCryptEnumContexts(ULONG dwTable,
                                     ULONG* pcbBuffer,

                                     PCRYPT_CONTEXTS* ppBuffer);

        NTSTATUS
        __stdcall BCryptConfigureContext(ULONG dwTable, LPCWSTR pszContext, PCRYPT_CONTEXT_CONFIG pConfig);

        NTSTATUS
        __stdcall BCryptQueryContextConfiguration(ULONG dwTable,
                                                  LPCWSTR pszContext,
                                                  ULONG* pcbBuffer,

                                                  PCRYPT_CONTEXT_CONFIG* ppBuffer);

        NTSTATUS
        __stdcall BCryptAddContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, ULONG dwPosition);

        NTSTATUS
        __stdcall BCryptRemoveContextFunction(ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction);

        NTSTATUS
        __stdcall BCryptEnumContextFunctions(ULONG dwTable,
                                             LPCWSTR pszContext,
                                             ULONG dwInterface,
                                             ULONG* pcbBuffer,

                                             PCRYPT_CONTEXT_FUNCTIONS* ppBuffer);

        NTSTATUS
        __stdcall BCryptConfigureContextFunction(
        ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, PCRYPT_CONTEXT_FUNCTION_CONFIG pConfig);

        NTSTATUS
        __stdcall BCryptQueryContextFunctionConfiguration(ULONG dwTable,
                                                          LPCWSTR pszContext,
                                                          ULONG dwInterface,
                                                          LPCWSTR pszFunction,
                                                          ULONG* pcbBuffer,

                                                          PCRYPT_CONTEXT_FUNCTION_CONFIG* ppBuffer);

        NTSTATUS
        __stdcall BCryptEnumContextFunctionProviders(ULONG dwTable,
                                                     LPCWSTR pszContext,
                                                     ULONG dwInterface,
                                                     LPCWSTR pszFunction,
                                                     ULONG* pcbBuffer,

                                                     PCRYPT_CONTEXT_FUNCTION_PROVIDERS* ppBuffer);

        NTSTATUS
        __stdcall BCryptSetContextFunctionProperty(
        ULONG dwTable, LPCWSTR pszContext, ULONG dwInterface, LPCWSTR pszFunction, LPCWSTR pszProperty, ULONG cbValue, PUCHAR pbValue);

        NTSTATUS
        __stdcall BCryptQueryContextFunctionProperty(ULONG dwTable,
                                                     LPCWSTR pszContext,
                                                     ULONG dwInterface,
                                                     LPCWSTR pszFunction,
                                                     LPCWSTR pszProperty,
                                                     ULONG* pcbValue,

                                                     PUCHAR* ppbValue);

        NTSTATUS
        __stdcall BCryptRegisterConfigChangeNotify(HANDLE* phEvent);

        NTSTATUS
        __stdcall BCryptUnregisterConfigChangeNotify(HANDLE hEvent);

        NTSTATUS __stdcall BCryptResolveProviders(LPCWSTR pszContext,
                                                  ULONG dwInterface,
                                                  LPCWSTR pszFunction,
                                                  LPCWSTR pszProvider,
                                                  ULONG dwMode,
                                                  ULONG dwFlags,
                                                  ULONG* pcbBuffer,

                                                  PCRYPT_PROVIDER_REFS* ppBuffer);

#pragma endregion

#pragma region Application Family or OneCore Family

        NTSTATUS
        __stdcall BCryptGetFipsAlgorithmMode(BOOLEAN* pfEnabled);

#pragma endregion

#pragma region Desktop Family

        BOOLEAN
        CngGetFipsAlgorithmMode(void);

#pragma endregion
    }

#pragma warning(pop)

#pragma endregion

#pragma region Application Family or OneCore Family

#pragma warning(push)
#pragma warning(disable : 4820)

    extern "C"
    {
        typedef LONG SECURITY_STATUS;

        typedef LPVOID(__stdcall* PFN_NCRYPT_ALLOC)(SIZE_T cbSize);

        typedef void(__stdcall* PFN_NCRYPT_FREE)(LPVOID pv);

        typedef struct NCRYPT_ALLOC_PARA
        {
            DWORD cbSize;
            PFN_NCRYPT_ALLOC pfnAlloc;
            PFN_NCRYPT_FREE pfnFree;
        } NCRYPT_ALLOC_PARA;

        typedef BCryptBuffer NCryptBuffer;
        typedef BCryptBuffer* PNCryptBuffer;
        typedef BCryptBufferDesc NCryptBufferDesc;
        typedef BCryptBufferDesc* PNCryptBufferDesc;

        typedef ULONG_PTR NCRYPT_HANDLE;
        typedef ULONG_PTR NCRYPT_PROV_HANDLE;
        typedef ULONG_PTR NCRYPT_KEY_HANDLE;
        typedef ULONG_PTR NCRYPT_HASH_HANDLE;
        typedef ULONG_PTR NCRYPT_SECRET_HANDLE;

        typedef struct _NCRYPT_CIPHER_PADDING_INFO
        {
            ULONG cbSize;

            DWORD dwFlags;

            PUCHAR pbIV;
            ULONG cbIV;

            PUCHAR pbOtherInfo;
            ULONG cbOtherInfo;

        } NCRYPT_CIPHER_PADDING_INFO, *PNCRYPT_CIPHER_PADDING_INFO;

        typedef struct _NCRYPT_PLATFORM_ATTEST_PADDING_INFO
        {
            ULONG magic;
            ULONG pcrMask;
        } NCRYPT_PLATFORM_ATTEST_PADDING_INFO;

        typedef struct _NCRYPT_KEY_ATTEST_PADDING_INFO
        {
            ULONG magic;
            PUCHAR pbKeyBlob;
            ULONG cbKeyBlob;
            PUCHAR pbKeyAuth;
            ULONG cbKeyAuth;
        } NCRYPT_KEY_ATTEST_PADDING_INFO;

        typedef struct _NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES
        {
            ULONG Version;
            ULONG Flags;
            ULONG cbPublicKeyBlob;

        } NCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES, *PNCRYPT_ISOLATED_KEY_ATTESTED_ATTRIBUTES;

        typedef struct _NCRYPT_VSM_KEY_ATTESTATION_STATEMENT
        {
            ULONG Magic;
            ULONG Version;
            ULONG cbSignature;
            ULONG cbReport;
            ULONG cbAttributes;

        } NCRYPT_VSM_KEY_ATTESTATION_STATEMENT, *PNCRYPT_VSM_KEY_ATTESTATION_STATEMENT;

#pragma warning(disable : 4214)
        typedef struct _NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS
        {
            ULONG Version;
            ULONGLONG TrustletId;
            ULONG MinSvn;
            ULONG FlagsMask;
            ULONG FlagsExpected;
            ULONG AllowDebugging : 1;
            ULONG Reserved : 31;
        } NCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS, *PNCRYPT_VSM_KEY_ATTESTATION_CLAIM_RESTRICTIONS;
#pragma warning(default : 4214)

#pragma warning(disable : 4214)
        typedef struct _NCRYPT_EXPORTED_ISOLATED_KEY_HEADER
        {
            ULONG Version;
            ULONG KeyUsage;
            ULONG PerBootKey : 1;
            ULONG Reserved : 31;
            ULONG cbAlgName;
            ULONG cbNonce;
            ULONG cbAuthTag;
            ULONG cbWrappingKey;
            ULONG cbIsolatedKey;
        } NCRYPT_EXPORTED_ISOLATED_KEY_HEADER, *PNCRYPT_EXPORTED_ISOLATED_KEY_HEADER;
#pragma warning(default : 4214)

        typedef struct _NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE
        {
            NCRYPT_EXPORTED_ISOLATED_KEY_HEADER Header;

        } NCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE, *PNCRYPT_EXPORTED_ISOLATED_KEY_ENVELOPE;

        typedef struct __NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT
        {
            UINT32 Magic;
            UINT32 Version;
            UINT32 HeaderSize;
            UINT32 cbCertifyInfo;
            UINT32 cbSignature;
            UINT32 cbTpmPublic;

        } NCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT, *PNCRYPT_PCP_TPM_WEB_AUTHN_ATTESTATION_STATEMENT;

        typedef struct _NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT
        {
            ULONG Magic;
            ULONG Version;
            ULONG pcrAlg;
            ULONG cbSignature;
            ULONG cbQuote;
            ULONG cbPcrs;

        } NCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT, *PNCRYPT_TPM_PLATFORM_ATTESTATION_STATEMENT;

        SECURITY_STATUS
        __stdcall NCryptOpenStorageProvider(NCRYPT_PROV_HANDLE* phProvider, LPCWSTR pszProviderName, DWORD dwFlags);

        typedef struct _NCryptAlgorithmName
        {
            LPWSTR pszName;
            DWORD dwClass;
            DWORD dwAlgOperations;
            DWORD dwFlags;
        } NCryptAlgorithmName;

        SECURITY_STATUS
        __stdcall NCryptEnumAlgorithms(
        NCRYPT_PROV_HANDLE hProvider, DWORD dwAlgOperations, DWORD* pdwAlgCount, NCryptAlgorithmName** ppAlgList, DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptIsAlgSupported(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszAlgId, DWORD dwFlags);

        typedef struct NCryptKeyName
        {
            LPWSTR pszName;
            LPWSTR pszAlgid;
            DWORD dwLegacyKeySpec;
            DWORD dwFlags;
        } NCryptKeyName;

        SECURITY_STATUS
        __stdcall NCryptEnumKeys(NCRYPT_PROV_HANDLE hProvider, LPCWSTR pszScope, NCryptKeyName** ppKeyName, PVOID* ppEnumState, DWORD dwFlags);

        typedef struct NCryptProviderName
        {
            LPWSTR pszName;
            LPWSTR pszComment;
        } NCryptProviderName;

#pragma region Desktop Family or OneCore Family

        SECURITY_STATUS
        __stdcall NCryptEnumStorageProviders(DWORD* pdwProviderCount, NCryptProviderName** ppProviderList, DWORD dwFlags);

#pragma endregion

        SECURITY_STATUS
        __stdcall NCryptFreeBuffer(PVOID pvInput);

        SECURITY_STATUS
        __stdcall NCryptOpenKey(NCRYPT_PROV_HANDLE hProvider, NCRYPT_KEY_HANDLE* phKey, LPCWSTR pszKeyName, DWORD dwLegacyKeySpec, DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptCreatePersistedKey(NCRYPT_PROV_HANDLE hProvider,
                                           NCRYPT_KEY_HANDLE* phKey,
                                           LPCWSTR pszAlgId,
                                           LPCWSTR pszKeyName,
                                           DWORD dwLegacyKeySpec,
                                           DWORD dwFlags);

        typedef struct __NCRYPT_UI_POLICY
        {
            DWORD dwVersion;
            DWORD dwFlags;
            LPCWSTR pszCreationTitle;
            LPCWSTR pszFriendlyName;
            LPCWSTR pszDescription;
        } NCRYPT_UI_POLICY;

        typedef struct __NCRYPT_KEY_ACCESS_POLICY_BLOB
        {
            DWORD dwVersion;
            DWORD dwPolicyFlags;
            DWORD cbUserSid;
            DWORD cbApplicationSid;

        } NCRYPT_KEY_ACCESS_POLICY_BLOB;

        typedef struct __NCRYPT_SUPPORTED_LENGTHS
        {
            DWORD dwMinLength;
            DWORD dwMaxLength;
            DWORD dwIncrement;
            DWORD dwDefaultLength;
        } NCRYPT_SUPPORTED_LENGTHS;

        typedef struct __NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO
        {
            DWORD dwVersion;
            INT32 iExpiration;
            BYTE pabNonce[32];
            BYTE pabPolicyRef[32];
            BYTE pabHMAC[32];
        } NCRYPT_PCP_HMAC_AUTH_SIGNATURE_INFO;

        typedef struct __NCRYPT_PCP_TPM_FW_VERSION_INFO
        {
            UINT16 major1;
            UINT16 major2;
            UINT16 minor1;
            UINT16 minor2;
        } NCRYPT_PCP_TPM_FW_VERSION_INFO;

        typedef struct __NCRYPT_PCP_RAW_POLICYDIGEST
        {
            DWORD dwVersion;
            DWORD cbDigest;
        } NCRYPT_PCP_RAW_POLICYDIGEST_INFO;

        SECURITY_STATUS
        __stdcall NCryptGetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbOutput, DWORD cbOutput, DWORD* pcbResult, DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptSetProperty(NCRYPT_HANDLE hObject, LPCWSTR pszProperty, PBYTE pbInput, DWORD cbInput, DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptFinalizeKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptEncrypt(
        NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void* pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD* pcbResult, DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptDecrypt(
        NCRYPT_KEY_HANDLE hKey, PBYTE pbInput, DWORD cbInput, void* pPaddingInfo, PBYTE pbOutput, DWORD cbOutput, DWORD* pcbResult, DWORD dwFlags);

        typedef struct _NCRYPT_KEY_BLOB_HEADER
        {
            ULONG cbSize;
            ULONG dwMagic;
            ULONG cbAlgName;
            ULONG cbKeyData;
        } NCRYPT_KEY_BLOB_HEADER, *PNCRYPT_KEY_BLOB_HEADER;

        typedef struct NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER
        {
            DWORD magic;
            DWORD cbHeader;
            DWORD cbPublic;
            DWORD cbPrivate;
            DWORD cbName;
        } NCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER, *PNCRYPT_TPM_LOADABLE_KEY_BLOB_HEADER;

        SECURITY_STATUS
        __stdcall NCryptImportKey(NCRYPT_PROV_HANDLE hProvider,
                                  NCRYPT_KEY_HANDLE hImportKey,
                                  LPCWSTR pszBlobType,
                                  NCryptBufferDesc* pParameterList,
                                  NCRYPT_KEY_HANDLE* phKey,
                                  PBYTE pbData,
                                  DWORD cbData,
                                  DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptExportKey(NCRYPT_KEY_HANDLE hKey,
                                  NCRYPT_KEY_HANDLE hExportKey,
                                  LPCWSTR pszBlobType,
                                  NCryptBufferDesc* pParameterList,
                                  PBYTE pbOutput,
                                  DWORD cbOutput,
                                  DWORD* pcbResult,
                                  DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptSignHash(NCRYPT_KEY_HANDLE hKey,
                                 void* pPaddingInfo,
                                 PBYTE pbHashValue,
                                 DWORD cbHashValue,
                                 PBYTE pbSignature,
                                 DWORD cbSignature,
                                 DWORD* pcbResult,
                                 DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptVerifySignature(
        NCRYPT_KEY_HANDLE hKey, void* pPaddingInfo, PBYTE pbHashValue, DWORD cbHashValue, PBYTE pbSignature, DWORD cbSignature, DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptDeleteKey(NCRYPT_KEY_HANDLE hKey, DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptFreeObject(NCRYPT_HANDLE hObject);

#pragma region Desktop Family or OneCore Family

        BOOL __stdcall NCryptIsKeyHandle(NCRYPT_KEY_HANDLE hKey);

        SECURITY_STATUS
        __stdcall NCryptTranslateHandle(NCRYPT_PROV_HANDLE* phProvider,
                                        NCRYPT_KEY_HANDLE* phKey,
                                        HCRYPTPROV hLegacyProv,
                                        HCRYPTKEY hLegacyKey,
                                        DWORD dwLegacyKeySpec,
                                        DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

        SECURITY_STATUS
        __stdcall NCryptNotifyChangeKey(NCRYPT_PROV_HANDLE hProvider, HANDLE* phEvent, DWORD dwFlags);

#pragma endregion

        SECURITY_STATUS
        __stdcall NCryptSecretAgreement(NCRYPT_KEY_HANDLE hPrivKey, NCRYPT_KEY_HANDLE hPubKey, NCRYPT_SECRET_HANDLE* phAgreedSecret, DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptDeriveKey(NCRYPT_SECRET_HANDLE hSharedSecret,
                                  LPCWSTR pwszKDF,
                                  NCryptBufferDesc* pParameterList,
                                  PBYTE pbDerivedKey,
                                  DWORD cbDerivedKey,
                                  DWORD* pcbResult,
                                  ULONG dwFlags);

        SECURITY_STATUS
        __stdcall NCryptKeyDerivation(NCRYPT_KEY_HANDLE hKey,
                                      NCryptBufferDesc* pParameterList,
                                      PUCHAR pbDerivedKey,
                                      DWORD cbDerivedKey,
                                      DWORD* pcbResult,
                                      ULONG dwFlags);

        SECURITY_STATUS
        __stdcall NCryptCreateClaim(NCRYPT_KEY_HANDLE hSubjectKey,
                                    NCRYPT_KEY_HANDLE hAuthorityKey,
                                    DWORD dwClaimType,
                                    NCryptBufferDesc* pParameterList,
                                    PBYTE pbClaimBlob,
                                    DWORD cbClaimBlob,
                                    DWORD* pcbResult,
                                    DWORD dwFlags);

        SECURITY_STATUS
        __stdcall NCryptVerifyClaim(NCRYPT_KEY_HANDLE hSubjectKey,
                                    NCRYPT_KEY_HANDLE hAuthorityKey,
                                    DWORD dwClaimType,
                                    NCryptBufferDesc* pParameterList,
                                    PBYTE pbClaimBlob,
                                    DWORD cbClaimBlob,
                                    NCryptBufferDesc* pOutput,
                                    DWORD dwFlags);
    }

#pragma warning(pop)

    typedef ULONG_PTR HCRYPTPROV_OR_NCRYPT_KEY_HANDLE;

    typedef ULONG_PTR HCRYPTPROV_LEGACY;

    typedef struct _CRYPT_BIT_BLOB
    {
        DWORD cbData;
        BYTE* pbData;
        DWORD cUnusedBits;
    } CRYPT_BIT_BLOB, *PCRYPT_BIT_BLOB;

    typedef struct _CRYPT_ALGORITHM_IDENTIFIER
    {
        LPSTR pszObjId;
        CRYPT_OBJID_BLOB Parameters;
    } CRYPT_ALGORITHM_IDENTIFIER, *PCRYPT_ALGORITHM_IDENTIFIER;

    typedef struct _CRYPT_OBJID_TABLE
    {
        DWORD dwAlgId;
        LPCSTR pszObjId;
    } CRYPT_OBJID_TABLE, *PCRYPT_OBJID_TABLE;

    typedef struct _CRYPT_HASH_INFO
    {
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        CRYPT_HASH_BLOB Hash;
    } CRYPT_HASH_INFO, *PCRYPT_HASH_INFO;

    typedef struct _CERT_EXTENSION
    {
        LPSTR pszObjId;
        BOOL fCritical;
        CRYPT_OBJID_BLOB Value;
    } CERT_EXTENSION, *PCERT_EXTENSION;
    typedef const CERT_EXTENSION* PCCERT_EXTENSION;

    typedef struct _CRYPT_ATTRIBUTE_TYPE_VALUE
    {
        LPSTR pszObjId;
        CRYPT_OBJID_BLOB Value;
    } CRYPT_ATTRIBUTE_TYPE_VALUE, *PCRYPT_ATTRIBUTE_TYPE_VALUE;

    typedef struct _CRYPT_ATTRIBUTE
    {
        LPSTR pszObjId;
        DWORD cValue;
        PCRYPT_ATTR_BLOB rgValue;
    } CRYPT_ATTRIBUTE, *PCRYPT_ATTRIBUTE;

    typedef struct _CRYPT_ATTRIBUTES
    {
        DWORD cAttr;
        PCRYPT_ATTRIBUTE rgAttr;
    } CRYPT_ATTRIBUTES, *PCRYPT_ATTRIBUTES;

    typedef struct _CERT_RDN_ATTR
    {
        LPSTR pszObjId;
        DWORD dwValueType;
        CERT_RDN_VALUE_BLOB Value;
    } CERT_RDN_ATTR, *PCERT_RDN_ATTR;

    typedef struct _CERT_RDN
    {
        DWORD cRDNAttr;
        PCERT_RDN_ATTR rgRDNAttr;
    } CERT_RDN, *PCERT_RDN;

    typedef struct _CERT_NAME_INFO
    {
        DWORD cRDN;
        PCERT_RDN rgRDN;
    } CERT_NAME_INFO, *PCERT_NAME_INFO;

    typedef struct _CERT_NAME_VALUE
    {
        DWORD dwValueType;
        CERT_RDN_VALUE_BLOB Value;
    } CERT_NAME_VALUE, *PCERT_NAME_VALUE;

    typedef struct _CERT_PUBLIC_KEY_INFO
    {
        CRYPT_ALGORITHM_IDENTIFIER Algorithm;
        CRYPT_BIT_BLOB PublicKey;
    } CERT_PUBLIC_KEY_INFO, *PCERT_PUBLIC_KEY_INFO;

    typedef struct _CRYPT_ECC_PRIVATE_KEY_INFO
    {
        DWORD dwVersion;
        CRYPT_DER_BLOB PrivateKey;
        LPSTR szCurveOid;
        CRYPT_BIT_BLOB PublicKey;
    } CRYPT_ECC_PRIVATE_KEY_INFO, *PCRYPT_ECC_PRIVATE_KEY_INFO;

    typedef struct _CRYPT_PRIVATE_KEY_INFO
    {
        DWORD Version;
        CRYPT_ALGORITHM_IDENTIFIER Algorithm;
        CRYPT_DER_BLOB PrivateKey;
        PCRYPT_ATTRIBUTES pAttributes;
    } CRYPT_PRIVATE_KEY_INFO, *PCRYPT_PRIVATE_KEY_INFO;

    typedef struct _CRYPT_ENCRYPTED_PRIVATE_KEY_INFO
    {
        CRYPT_ALGORITHM_IDENTIFIER EncryptionAlgorithm;
        CRYPT_DATA_BLOB EncryptedPrivateKey;
    } CRYPT_ENCRYPTED_PRIVATE_KEY_INFO, *PCRYPT_ENCRYPTED_PRIVATE_KEY_INFO;

    typedef BOOL(__stdcall* PCRYPT_DECRYPT_PRIVATE_KEY_FUNC)(CRYPT_ALGORITHM_IDENTIFIER Algorithm,
                                                             CRYPT_DATA_BLOB EncryptedPrivateKey,
                                                             BYTE* pbClearTextKey,
                                                             DWORD* pcbClearTextKey,
                                                             LPVOID pVoidDecryptFunc);

    typedef BOOL(__stdcall* PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC)(CRYPT_ALGORITHM_IDENTIFIER* pAlgorithm,
                                                             CRYPT_DATA_BLOB* pClearTextPrivateKey,
                                                             BYTE* pbEncryptedKey,
                                                             DWORD* pcbEncryptedKey,
                                                             LPVOID pVoidEncryptFunc);

    typedef BOOL(__stdcall* PCRYPT_RESOLVE_HCRYPTPROV_FUNC)(CRYPT_PRIVATE_KEY_INFO* pPrivateKeyInfo,
                                                            HCRYPTPROV* phCryptProv,
                                                            LPVOID pVoidResolveFunc);

    typedef struct _CRYPT_PKCS8_IMPORT_PARAMS
    {
        CRYPT_DIGEST_BLOB PrivateKey;
        PCRYPT_RESOLVE_HCRYPTPROV_FUNC pResolvehCryptProvFunc;
        LPVOID pVoidResolveFunc;
        PCRYPT_DECRYPT_PRIVATE_KEY_FUNC pDecryptPrivateKeyFunc;
        LPVOID pVoidDecryptFunc;
    } CRYPT_PKCS8_IMPORT_PARAMS, *PCRYPT_PKCS8_IMPORT_PARAMS, CRYPT_PRIVATE_KEY_BLOB_AND_PARAMS, *PCRYPT_PRIVATE_KEY_BLOB_AND_PARAMS;

    typedef struct _CRYPT_PKCS8_EXPORT_PARAMS
    {
        HCRYPTPROV hCryptProv;
        DWORD dwKeySpec;
        LPSTR pszPrivateKeyObjId;

        PCRYPT_ENCRYPT_PRIVATE_KEY_FUNC pEncryptPrivateKeyFunc;
        LPVOID pVoidEncryptFunc;
    } CRYPT_PKCS8_EXPORT_PARAMS, *PCRYPT_PKCS8_EXPORT_PARAMS;

    typedef struct _CERT_INFO
    {
        DWORD dwVersion;
        CRYPT_INTEGER_BLOB SerialNumber;
        CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
        CERT_NAME_BLOB Issuer;
        FILETIME NotBefore;
        FILETIME NotAfter;
        CERT_NAME_BLOB Subject;
        CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
        CRYPT_BIT_BLOB IssuerUniqueId;
        CRYPT_BIT_BLOB SubjectUniqueId;
        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } CERT_INFO, *PCERT_INFO;

    typedef struct _CRL_ENTRY
    {
        CRYPT_INTEGER_BLOB SerialNumber;
        FILETIME RevocationDate;
        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } CRL_ENTRY, *PCRL_ENTRY;

    typedef struct _CRL_INFO
    {
        DWORD dwVersion;
        CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
        CERT_NAME_BLOB Issuer;
        FILETIME ThisUpdate;
        FILETIME NextUpdate;
        DWORD cCRLEntry;
        PCRL_ENTRY rgCRLEntry;
        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } CRL_INFO, *PCRL_INFO;

    typedef struct _CERT_OR_CRL_BLOB
    {
        DWORD dwChoice;
        DWORD cbEncoded;

        BYTE* pbEncoded;
    } CERT_OR_CRL_BLOB, *PCERT_OR_CRL_BLOB;

    typedef struct _CERT_OR_CRL_BUNDLE
    {
        DWORD cItem;

        PCERT_OR_CRL_BLOB rgItem;
    } CERT_OR_CRL_BUNDLE, *PCERT_OR_CRL_BUNDLE;

    typedef struct _CERT_REQUEST_INFO
    {
        DWORD dwVersion;
        CERT_NAME_BLOB Subject;
        CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
        DWORD cAttribute;
        PCRYPT_ATTRIBUTE rgAttribute;
    } CERT_REQUEST_INFO, *PCERT_REQUEST_INFO;

    typedef struct _CERT_KEYGEN_REQUEST_INFO
    {
        DWORD dwVersion;
        CERT_PUBLIC_KEY_INFO SubjectPublicKeyInfo;
        LPWSTR pwszChallengeString;
    } CERT_KEYGEN_REQUEST_INFO, *PCERT_KEYGEN_REQUEST_INFO;

    typedef struct _CERT_SIGNED_CONTENT_INFO
    {
        CRYPT_DER_BLOB ToBeSigned;
        CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
        CRYPT_BIT_BLOB Signature;
    } CERT_SIGNED_CONTENT_INFO, *PCERT_SIGNED_CONTENT_INFO;

    typedef struct _CTL_USAGE
    {
        DWORD cUsageIdentifier;
        LPSTR* rgpszUsageIdentifier;
    } CTL_USAGE, *PCTL_USAGE, CERT_ENHKEY_USAGE, *PCERT_ENHKEY_USAGE;
    typedef const CTL_USAGE* PCCTL_USAGE;
    typedef const CERT_ENHKEY_USAGE* PCCERT_ENHKEY_USAGE;

    typedef struct _CTL_ENTRY
    {
        CRYPT_DATA_BLOB SubjectIdentifier;
        DWORD cAttribute;
        PCRYPT_ATTRIBUTE rgAttribute;
    } CTL_ENTRY, *PCTL_ENTRY;

    typedef struct _CTL_INFO
    {
        DWORD dwVersion;
        CTL_USAGE SubjectUsage;
        CRYPT_DATA_BLOB ListIdentifier;
        CRYPT_INTEGER_BLOB SequenceNumber;
        FILETIME ThisUpdate;
        FILETIME NextUpdate;
        CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
        DWORD cCTLEntry;
        PCTL_ENTRY rgCTLEntry;
        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } CTL_INFO, *PCTL_INFO;

    typedef struct _CRYPT_TIME_STAMP_REQUEST_INFO
    {
        LPSTR pszTimeStampAlgorithm;
        LPSTR pszContentType;
        CRYPT_OBJID_BLOB Content;
        DWORD cAttribute;
        PCRYPT_ATTRIBUTE rgAttribute;
    } CRYPT_TIME_STAMP_REQUEST_INFO, *PCRYPT_TIME_STAMP_REQUEST_INFO;

    typedef struct _CRYPT_ENROLLMENT_NAME_VALUE_PAIR
    {
        LPWSTR pwszName;
        LPWSTR pwszValue;
    } CRYPT_ENROLLMENT_NAME_VALUE_PAIR, *PCRYPT_ENROLLMENT_NAME_VALUE_PAIR;

    typedef struct _CRYPT_CSP_PROVIDER
    {
        DWORD dwKeySpec;
        LPWSTR pwszProviderName;
        CRYPT_BIT_BLOB Signature;
    } CRYPT_CSP_PROVIDER, *PCRYPT_CSP_PROVIDER;

    __declspec(dllimport) BOOL __stdcall CryptFormatObject(DWORD dwCertEncodingType,
                                                           DWORD dwFormatType,
                                                           DWORD dwFormatStrType,
                                                           void* pFormatStruct,
                                                           LPCSTR lpszStructType,
                                                           const BYTE* pbEncoded,
                                                           DWORD cbEncoded,
                                                           void* pbFormat,
                                                           DWORD* pcbFormat);

    typedef LPVOID(__stdcall* PFN_CRYPT_ALLOC)(size_t cbSize);

    typedef void(__stdcall* PFN_CRYPT_FREE)(LPVOID pv);

    typedef struct _CRYPT_ENCODE_PARA
    {
        DWORD cbSize;
        PFN_CRYPT_ALLOC pfnAlloc;
        PFN_CRYPT_FREE pfnFree;
    } CRYPT_ENCODE_PARA, *PCRYPT_ENCODE_PARA;

    __declspec(dllimport) BOOL __stdcall CryptEncodeObjectEx(DWORD dwCertEncodingType,
                                                             LPCSTR lpszStructType,
                                                             const void* pvStructInfo,
                                                             DWORD dwFlags,
                                                             PCRYPT_ENCODE_PARA pEncodePara,
                                                             void* pvEncoded,
                                                             DWORD* pcbEncoded);

    __declspec(dllimport) BOOL
    __stdcall CryptEncodeObject(DWORD dwCertEncodingType, LPCSTR lpszStructType, const void* pvStructInfo, BYTE* pbEncoded, DWORD* pcbEncoded);

    typedef struct _CRYPT_DECODE_PARA
    {
        DWORD cbSize;
        PFN_CRYPT_ALLOC pfnAlloc;
        PFN_CRYPT_FREE pfnFree;
    } CRYPT_DECODE_PARA, *PCRYPT_DECODE_PARA;

    __declspec(dllimport) BOOL __stdcall CryptDecodeObjectEx(DWORD dwCertEncodingType,
                                                             LPCSTR lpszStructType,
                                                             const BYTE* pbEncoded,
                                                             DWORD cbEncoded,
                                                             DWORD dwFlags,
                                                             PCRYPT_DECODE_PARA pDecodePara,
                                                             void* pvStructInfo,
                                                             DWORD* pcbStructInfo);

    __declspec(dllimport) BOOL __stdcall CryptDecodeObject(DWORD dwCertEncodingType,
                                                           LPCSTR lpszStructType,
                                                           const BYTE* pbEncoded,
                                                           DWORD cbEncoded,
                                                           DWORD dwFlags,
                                                           void* pvStructInfo,
                                                           DWORD* pcbStructInfo);

    typedef struct _CERT_EXTENSIONS
    {
        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } CERT_EXTENSIONS, *PCERT_EXTENSIONS;

    typedef struct _CERT_AUTHORITY_KEY_ID_INFO
    {
        CRYPT_DATA_BLOB KeyId;
        CERT_NAME_BLOB CertIssuer;
        CRYPT_INTEGER_BLOB CertSerialNumber;
    } CERT_AUTHORITY_KEY_ID_INFO, *PCERT_AUTHORITY_KEY_ID_INFO;

    typedef struct _CERT_PRIVATE_KEY_VALIDITY
    {
        FILETIME NotBefore;
        FILETIME NotAfter;
    } CERT_PRIVATE_KEY_VALIDITY, *PCERT_PRIVATE_KEY_VALIDITY;

    typedef struct _CERT_KEY_ATTRIBUTES_INFO
    {
        CRYPT_DATA_BLOB KeyId;
        CRYPT_BIT_BLOB IntendedKeyUsage;
        PCERT_PRIVATE_KEY_VALIDITY pPrivateKeyUsagePeriod;
    } CERT_KEY_ATTRIBUTES_INFO, *PCERT_KEY_ATTRIBUTES_INFO;

    typedef struct _CERT_POLICY_ID
    {
        DWORD cCertPolicyElementId;
        LPSTR* rgpszCertPolicyElementId;
    } CERT_POLICY_ID, *PCERT_POLICY_ID;

    typedef struct _CERT_KEY_USAGE_RESTRICTION_INFO
    {
        DWORD cCertPolicyId;
        PCERT_POLICY_ID rgCertPolicyId;
        CRYPT_BIT_BLOB RestrictedKeyUsage;
    } CERT_KEY_USAGE_RESTRICTION_INFO, *PCERT_KEY_USAGE_RESTRICTION_INFO;

    typedef struct _CERT_OTHER_NAME
    {
        LPSTR pszObjId;
        CRYPT_OBJID_BLOB Value;
    } CERT_OTHER_NAME, *PCERT_OTHER_NAME;

    typedef struct _CERT_ALT_NAME_ENTRY
    {
        DWORD dwAltNameChoice;
        union
        {
            PCERT_OTHER_NAME pOtherName;
            LPWSTR pwszRfc822Name;
            LPWSTR pwszDNSName;

            CERT_NAME_BLOB DirectoryName;

            LPWSTR pwszURL;
            CRYPT_DATA_BLOB IPAddress;
            LPSTR pszRegisteredID;
        };
    } CERT_ALT_NAME_ENTRY, *PCERT_ALT_NAME_ENTRY;

    typedef struct _CERT_ALT_NAME_INFO
    {
        DWORD cAltEntry;
        PCERT_ALT_NAME_ENTRY rgAltEntry;
    } CERT_ALT_NAME_INFO, *PCERT_ALT_NAME_INFO;

    typedef struct _CERT_BASIC_CONSTRAINTS_INFO
    {
        CRYPT_BIT_BLOB SubjectType;
        BOOL fPathLenConstraint;
        DWORD dwPathLenConstraint;
        DWORD cSubtreesConstraint;
        CERT_NAME_BLOB* rgSubtreesConstraint;
    } CERT_BASIC_CONSTRAINTS_INFO, *PCERT_BASIC_CONSTRAINTS_INFO;

    typedef struct _CERT_BASIC_CONSTRAINTS2_INFO
    {
        BOOL fCA;
        BOOL fPathLenConstraint;
        DWORD dwPathLenConstraint;
    } CERT_BASIC_CONSTRAINTS2_INFO, *PCERT_BASIC_CONSTRAINTS2_INFO;

    typedef struct _CERT_POLICY_QUALIFIER_INFO
    {
        LPSTR pszPolicyQualifierId;
        CRYPT_OBJID_BLOB Qualifier;
    } CERT_POLICY_QUALIFIER_INFO, *PCERT_POLICY_QUALIFIER_INFO;

    typedef struct _CERT_POLICY_INFO
    {
        LPSTR pszPolicyIdentifier;
        DWORD cPolicyQualifier;
        CERT_POLICY_QUALIFIER_INFO* rgPolicyQualifier;
    } CERT_POLICY_INFO, *PCERT_POLICY_INFO;

    typedef struct _CERT_POLICIES_INFO
    {
        DWORD cPolicyInfo;
        CERT_POLICY_INFO* rgPolicyInfo;
    } CERT_POLICIES_INFO, *PCERT_POLICIES_INFO;

    typedef struct _CERT_POLICY_QUALIFIER_NOTICE_REFERENCE
    {
        LPSTR pszOrganization;
        DWORD cNoticeNumbers;
        int* rgNoticeNumbers;
    } CERT_POLICY_QUALIFIER_NOTICE_REFERENCE, *PCERT_POLICY_QUALIFIER_NOTICE_REFERENCE;

    typedef struct _CERT_POLICY_QUALIFIER_USER_NOTICE
    {
        CERT_POLICY_QUALIFIER_NOTICE_REFERENCE* pNoticeReference;
        LPWSTR pszDisplayText;
    } CERT_POLICY_QUALIFIER_USER_NOTICE, *PCERT_POLICY_QUALIFIER_USER_NOTICE;

    typedef struct _CPS_URLS
    {
        LPWSTR pszURL;
        CRYPT_ALGORITHM_IDENTIFIER* pAlgorithm;
        CRYPT_DATA_BLOB* pDigest;
    } CPS_URLS, *PCPS_URLS;

    typedef struct _CERT_POLICY95_QUALIFIER1
    {
        LPWSTR pszPracticesReference;
        LPSTR pszNoticeIdentifier;
        LPSTR pszNSINoticeIdentifier;
        DWORD cCPSURLs;
        CPS_URLS* rgCPSURLs;
    } CERT_POLICY95_QUALIFIER1, *PCERT_POLICY95_QUALIFIER1;

    typedef struct _CERT_POLICY_MAPPING
    {
        LPSTR pszIssuerDomainPolicy;
        LPSTR pszSubjectDomainPolicy;
    } CERT_POLICY_MAPPING, *PCERT_POLICY_MAPPING;

    typedef struct _CERT_POLICY_MAPPINGS_INFO
    {
        DWORD cPolicyMapping;
        PCERT_POLICY_MAPPING rgPolicyMapping;
    } CERT_POLICY_MAPPINGS_INFO, *PCERT_POLICY_MAPPINGS_INFO;

    typedef struct _CERT_POLICY_CONSTRAINTS_INFO
    {
        BOOL fRequireExplicitPolicy;
        DWORD dwRequireExplicitPolicySkipCerts;

        BOOL fInhibitPolicyMapping;
        DWORD dwInhibitPolicyMappingSkipCerts;
    } CERT_POLICY_CONSTRAINTS_INFO, *PCERT_POLICY_CONSTRAINTS_INFO;

    typedef struct _CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY
    {
        LPSTR pszObjId;
        DWORD cValue;
        PCRYPT_DER_BLOB rgValue;
    } CRYPT_CONTENT_INFO_SEQUENCE_OF_ANY, *PCRYPT_CONTENT_INFO_SEQUENCE_OF_ANY;

    typedef struct _CRYPT_CONTENT_INFO
    {
        LPSTR pszObjId;
        CRYPT_DER_BLOB Content;
    } CRYPT_CONTENT_INFO, *PCRYPT_CONTENT_INFO;

    typedef struct _CRYPT_SEQUENCE_OF_ANY
    {
        DWORD cValue;
        PCRYPT_DER_BLOB rgValue;
    } CRYPT_SEQUENCE_OF_ANY, *PCRYPT_SEQUENCE_OF_ANY;

    typedef struct _CERT_AUTHORITY_KEY_ID2_INFO
    {
        CRYPT_DATA_BLOB KeyId;
        CERT_ALT_NAME_INFO AuthorityCertIssuer;

        CRYPT_INTEGER_BLOB AuthorityCertSerialNumber;
    } CERT_AUTHORITY_KEY_ID2_INFO, *PCERT_AUTHORITY_KEY_ID2_INFO;

    typedef struct _CERT_ACCESS_DESCRIPTION
    {
        LPSTR pszAccessMethod;
        CERT_ALT_NAME_ENTRY AccessLocation;
    } CERT_ACCESS_DESCRIPTION, *PCERT_ACCESS_DESCRIPTION;

    typedef struct _CERT_AUTHORITY_INFO_ACCESS
    {
        DWORD cAccDescr;
        PCERT_ACCESS_DESCRIPTION rgAccDescr;
    } CERT_AUTHORITY_INFO_ACCESS, *PCERT_AUTHORITY_INFO_ACCESS, CERT_SUBJECT_INFO_ACCESS, *PCERT_SUBJECT_INFO_ACCESS;

    typedef struct _CRL_DIST_POINT_NAME
    {
        DWORD dwDistPointNameChoice;
        union
        {
            CERT_ALT_NAME_INFO FullName;
        };
    } CRL_DIST_POINT_NAME, *PCRL_DIST_POINT_NAME;

    typedef struct _CRL_DIST_POINT
    {
        CRL_DIST_POINT_NAME DistPointName;
        CRYPT_BIT_BLOB ReasonFlags;
        CERT_ALT_NAME_INFO CRLIssuer;
    } CRL_DIST_POINT, *PCRL_DIST_POINT;

    typedef struct _CRL_DIST_POINTS_INFO
    {
        DWORD cDistPoint;
        PCRL_DIST_POINT rgDistPoint;
    } CRL_DIST_POINTS_INFO, *PCRL_DIST_POINTS_INFO;

    typedef struct _CROSS_CERT_DIST_POINTS_INFO
    {
        DWORD dwSyncDeltaTime;

        DWORD cDistPoint;
        PCERT_ALT_NAME_INFO rgDistPoint;
    } CROSS_CERT_DIST_POINTS_INFO, *PCROSS_CERT_DIST_POINTS_INFO;

    typedef struct _CERT_PAIR
    {
        CERT_BLOB Forward;
        CERT_BLOB Reverse;
    } CERT_PAIR, *PCERT_PAIR;

    typedef struct _CRL_ISSUING_DIST_POINT
    {
        CRL_DIST_POINT_NAME DistPointName;
        BOOL fOnlyContainsUserCerts;
        BOOL fOnlyContainsCACerts;
        CRYPT_BIT_BLOB OnlySomeReasonFlags;
        BOOL fIndirectCRL;
    } CRL_ISSUING_DIST_POINT, *PCRL_ISSUING_DIST_POINT;

    typedef struct _CERT_GENERAL_SUBTREE
    {
        CERT_ALT_NAME_ENTRY Base;
        DWORD dwMinimum;
        BOOL fMaximum;
        DWORD dwMaximum;
    } CERT_GENERAL_SUBTREE, *PCERT_GENERAL_SUBTREE;

    typedef struct _CERT_NAME_CONSTRAINTS_INFO
    {
        DWORD cPermittedSubtree;
        PCERT_GENERAL_SUBTREE rgPermittedSubtree;
        DWORD cExcludedSubtree;
        PCERT_GENERAL_SUBTREE rgExcludedSubtree;
    } CERT_NAME_CONSTRAINTS_INFO, *PCERT_NAME_CONSTRAINTS_INFO;

    typedef struct _CERT_DSS_PARAMETERS
    {
        CRYPT_UINT_BLOB p;
        CRYPT_UINT_BLOB q;
        CRYPT_UINT_BLOB g;
    } CERT_DSS_PARAMETERS, *PCERT_DSS_PARAMETERS;

    typedef struct _CERT_DH_PARAMETERS
    {
        CRYPT_UINT_BLOB p;
        CRYPT_UINT_BLOB g;
    } CERT_DH_PARAMETERS, *PCERT_DH_PARAMETERS;

    typedef struct _CERT_ECC_SIGNATURE
    {
        CRYPT_UINT_BLOB r;
        CRYPT_UINT_BLOB s;
    } CERT_ECC_SIGNATURE, *PCERT_ECC_SIGNATURE;

    typedef struct _CERT_X942_DH_VALIDATION_PARAMS
    {
        CRYPT_BIT_BLOB seed;
        DWORD pgenCounter;
    } CERT_X942_DH_VALIDATION_PARAMS, *PCERT_X942_DH_VALIDATION_PARAMS;

    typedef struct _CERT_X942_DH_PARAMETERS
    {
        CRYPT_UINT_BLOB p;
        CRYPT_UINT_BLOB g;
        CRYPT_UINT_BLOB q;
        CRYPT_UINT_BLOB j;
        PCERT_X942_DH_VALIDATION_PARAMS pValidationParams;
    } CERT_X942_DH_PARAMETERS, *PCERT_X942_DH_PARAMETERS;

    typedef struct _CRYPT_X942_OTHER_INFO
    {
        LPSTR pszContentEncryptionObjId;
        BYTE rgbCounter[4];
        BYTE rgbKeyLength[4];
        CRYPT_DATA_BLOB PubInfo;
    } CRYPT_X942_OTHER_INFO, *PCRYPT_X942_OTHER_INFO;

    typedef struct _CRYPT_ECC_CMS_SHARED_INFO
    {
        CRYPT_ALGORITHM_IDENTIFIER Algorithm;
        CRYPT_DATA_BLOB EntityUInfo;
        BYTE rgbSuppPubInfo[4];
    } CRYPT_ECC_CMS_SHARED_INFO, *PCRYPT_ECC_CMS_SHARED_INFO;

    typedef struct _CRYPT_RC2_CBC_PARAMETERS
    {
        DWORD dwVersion;
        BOOL fIV;
        BYTE rgbIV[8];
    } CRYPT_RC2_CBC_PARAMETERS, *PCRYPT_RC2_CBC_PARAMETERS;

    typedef struct _CRYPT_SMIME_CAPABILITY
    {
        LPSTR pszObjId;
        CRYPT_OBJID_BLOB Parameters;
    } CRYPT_SMIME_CAPABILITY, *PCRYPT_SMIME_CAPABILITY;

    typedef struct _CRYPT_SMIME_CAPABILITIES
    {
        DWORD cCapability;
        PCRYPT_SMIME_CAPABILITY rgCapability;
    } CRYPT_SMIME_CAPABILITIES, *PCRYPT_SMIME_CAPABILITIES;

    typedef struct _CERT_QC_STATEMENT
    {
        LPSTR pszStatementId;
        CRYPT_OBJID_BLOB StatementInfo;
    } CERT_QC_STATEMENT, *PCERT_QC_STATEMENT;

    typedef struct _CERT_QC_STATEMENTS_EXT_INFO
    {
        DWORD cStatement;
        PCERT_QC_STATEMENT rgStatement;
    } CERT_QC_STATEMENTS_EXT_INFO, *PCERT_QC_STATEMENTS_EXT_INFO;

    typedef struct _CRYPT_MASK_GEN_ALGORITHM
    {
        LPSTR pszObjId;
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
    } CRYPT_MASK_GEN_ALGORITHM, *PCRYPT_MASK_GEN_ALGORITHM;

    typedef struct _CRYPT_RSA_SSA_PSS_PARAMETERS
    {
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        CRYPT_MASK_GEN_ALGORITHM MaskGenAlgorithm;
        DWORD dwSaltLength;
        DWORD dwTrailerField;
    } CRYPT_RSA_SSA_PSS_PARAMETERS, *PCRYPT_RSA_SSA_PSS_PARAMETERS;

    typedef struct _CRYPT_PSOURCE_ALGORITHM
    {
        LPSTR pszObjId;
        CRYPT_DATA_BLOB EncodingParameters;
    } CRYPT_PSOURCE_ALGORITHM, *PCRYPT_PSOURCE_ALGORITHM;

    typedef struct _CRYPT_RSAES_OAEP_PARAMETERS
    {
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        CRYPT_MASK_GEN_ALGORITHM MaskGenAlgorithm;
        CRYPT_PSOURCE_ALGORITHM PSourceAlgorithm;
    } CRYPT_RSAES_OAEP_PARAMETERS, *PCRYPT_RSAES_OAEP_PARAMETERS;

    typedef struct _CMC_TAGGED_ATTRIBUTE
    {
        DWORD dwBodyPartID;
        CRYPT_ATTRIBUTE Attribute;
    } CMC_TAGGED_ATTRIBUTE, *PCMC_TAGGED_ATTRIBUTE;

    typedef struct _CMC_TAGGED_CERT_REQUEST
    {
        DWORD dwBodyPartID;
        CRYPT_DER_BLOB SignedCertRequest;
    } CMC_TAGGED_CERT_REQUEST, *PCMC_TAGGED_CERT_REQUEST;

    typedef struct _CMC_TAGGED_REQUEST
    {
        DWORD dwTaggedRequestChoice;
        union
        {
            PCMC_TAGGED_CERT_REQUEST pTaggedCertRequest;
        };
    } CMC_TAGGED_REQUEST, *PCMC_TAGGED_REQUEST;

    typedef struct _CMC_TAGGED_CONTENT_INFO
    {
        DWORD dwBodyPartID;
        CRYPT_DER_BLOB EncodedContentInfo;
    } CMC_TAGGED_CONTENT_INFO, *PCMC_TAGGED_CONTENT_INFO;

    typedef struct _CMC_TAGGED_OTHER_MSG
    {
        DWORD dwBodyPartID;
        LPSTR pszObjId;
        CRYPT_OBJID_BLOB Value;
    } CMC_TAGGED_OTHER_MSG, *PCMC_TAGGED_OTHER_MSG;

    typedef struct _CMC_DATA_INFO
    {
        DWORD cTaggedAttribute;
        PCMC_TAGGED_ATTRIBUTE rgTaggedAttribute;
        DWORD cTaggedRequest;
        PCMC_TAGGED_REQUEST rgTaggedRequest;
        DWORD cTaggedContentInfo;
        PCMC_TAGGED_CONTENT_INFO rgTaggedContentInfo;
        DWORD cTaggedOtherMsg;
        PCMC_TAGGED_OTHER_MSG rgTaggedOtherMsg;
    } CMC_DATA_INFO, *PCMC_DATA_INFO;

    typedef struct _CMC_RESPONSE_INFO
    {
        DWORD cTaggedAttribute;
        PCMC_TAGGED_ATTRIBUTE rgTaggedAttribute;
        DWORD cTaggedContentInfo;
        PCMC_TAGGED_CONTENT_INFO rgTaggedContentInfo;
        DWORD cTaggedOtherMsg;
        PCMC_TAGGED_OTHER_MSG rgTaggedOtherMsg;
    } CMC_RESPONSE_INFO, *PCMC_RESPONSE_INFO;

    typedef struct _CMC_PEND_INFO
    {
        CRYPT_DATA_BLOB PendToken;
        FILETIME PendTime;
    } CMC_PEND_INFO, *PCMC_PEND_INFO;

    typedef struct _CMC_STATUS_INFO
    {
        DWORD dwStatus;
        DWORD cBodyList;
        DWORD* rgdwBodyList;
        LPWSTR pwszStatusString;
        DWORD dwOtherInfoChoice;
        union
        {
            DWORD dwFailInfo;

            PCMC_PEND_INFO pPendInfo;
        };
    } CMC_STATUS_INFO, *PCMC_STATUS_INFO;

    typedef struct _CMC_ADD_EXTENSIONS_INFO
    {
        DWORD dwCmcDataReference;
        DWORD cCertReference;
        DWORD* rgdwCertReference;
        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } CMC_ADD_EXTENSIONS_INFO, *PCMC_ADD_EXTENSIONS_INFO;

    typedef struct _CMC_ADD_ATTRIBUTES_INFO
    {
        DWORD dwCmcDataReference;
        DWORD cCertReference;
        DWORD* rgdwCertReference;
        DWORD cAttribute;
        PCRYPT_ATTRIBUTE rgAttribute;
    } CMC_ADD_ATTRIBUTES_INFO, *PCMC_ADD_ATTRIBUTES_INFO;

    typedef struct _CERT_TEMPLATE_EXT
    {
        LPSTR pszObjId;
        DWORD dwMajorVersion;
        BOOL fMinorVersion;
        DWORD dwMinorVersion;
    } CERT_TEMPLATE_EXT, *PCERT_TEMPLATE_EXT;

    typedef struct _CERT_HASHED_URL
    {
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        CRYPT_HASH_BLOB Hash;
        LPWSTR pwszUrl;

    } CERT_HASHED_URL, *PCERT_HASHED_URL;

    typedef struct _CERT_LOGOTYPE_DETAILS
    {
        LPWSTR pwszMimeType;
        DWORD cHashedUrl;
        PCERT_HASHED_URL rgHashedUrl;
    } CERT_LOGOTYPE_DETAILS, *PCERT_LOGOTYPE_DETAILS;

    typedef struct _CERT_LOGOTYPE_REFERENCE
    {
        DWORD cHashedUrl;
        PCERT_HASHED_URL rgHashedUrl;
    } CERT_LOGOTYPE_REFERENCE, *PCERT_LOGOTYPE_REFERENCE;

    typedef struct _CERT_LOGOTYPE_IMAGE_INFO
    {
        DWORD dwLogotypeImageInfoChoice;

        DWORD dwFileSize;
        DWORD dwXSize;
        DWORD dwYSize;

        DWORD dwLogotypeImageResolutionChoice;
        union
        {
            DWORD dwNumBits;

            DWORD dwTableSize;
        };
        LPWSTR pwszLanguage;

    } CERT_LOGOTYPE_IMAGE_INFO, *PCERT_LOGOTYPE_IMAGE_INFO;

    typedef struct _CERT_LOGOTYPE_IMAGE
    {
        CERT_LOGOTYPE_DETAILS LogotypeDetails;

        PCERT_LOGOTYPE_IMAGE_INFO pLogotypeImageInfo;
    } CERT_LOGOTYPE_IMAGE, *PCERT_LOGOTYPE_IMAGE;

    typedef struct _CERT_LOGOTYPE_AUDIO_INFO
    {
        DWORD dwFileSize;
        DWORD dwPlayTime;
        DWORD dwChannels;
        DWORD dwSampleRate;

        LPWSTR pwszLanguage;

    } CERT_LOGOTYPE_AUDIO_INFO, *PCERT_LOGOTYPE_AUDIO_INFO;

    typedef struct _CERT_LOGOTYPE_AUDIO
    {
        CERT_LOGOTYPE_DETAILS LogotypeDetails;

        PCERT_LOGOTYPE_AUDIO_INFO pLogotypeAudioInfo;
    } CERT_LOGOTYPE_AUDIO, *PCERT_LOGOTYPE_AUDIO;

    typedef struct _CERT_LOGOTYPE_DATA
    {
        DWORD cLogotypeImage;
        PCERT_LOGOTYPE_IMAGE rgLogotypeImage;

        DWORD cLogotypeAudio;
        PCERT_LOGOTYPE_AUDIO rgLogotypeAudio;
    } CERT_LOGOTYPE_DATA, *PCERT_LOGOTYPE_DATA;

    typedef struct _CERT_LOGOTYPE_INFO
    {
        DWORD dwLogotypeInfoChoice;
        union
        {
            PCERT_LOGOTYPE_DATA pLogotypeDirectInfo;

            PCERT_LOGOTYPE_REFERENCE pLogotypeIndirectInfo;
        };
    } CERT_LOGOTYPE_INFO, *PCERT_LOGOTYPE_INFO;

    typedef struct _CERT_OTHER_LOGOTYPE_INFO
    {
        LPSTR pszObjId;
        CERT_LOGOTYPE_INFO LogotypeInfo;
    } CERT_OTHER_LOGOTYPE_INFO, *PCERT_OTHER_LOGOTYPE_INFO;

    typedef struct _CERT_LOGOTYPE_EXT_INFO
    {
        DWORD cCommunityLogo;
        PCERT_LOGOTYPE_INFO rgCommunityLogo;
        PCERT_LOGOTYPE_INFO pIssuerLogo;
        PCERT_LOGOTYPE_INFO pSubjectLogo;
        DWORD cOtherLogo;
        PCERT_OTHER_LOGOTYPE_INFO rgOtherLogo;
    } CERT_LOGOTYPE_EXT_INFO, *PCERT_LOGOTYPE_EXT_INFO;

    typedef struct _CERT_BIOMETRIC_DATA
    {
        DWORD dwTypeOfBiometricDataChoice;
        union
        {
            DWORD dwPredefined;

            LPSTR pszObjId;
        };

        CERT_HASHED_URL HashedUrl;
    } CERT_BIOMETRIC_DATA, *PCERT_BIOMETRIC_DATA;

    typedef struct _CERT_BIOMETRIC_EXT_INFO
    {
        DWORD cBiometricData;
        PCERT_BIOMETRIC_DATA rgBiometricData;
    } CERT_BIOMETRIC_EXT_INFO, *PCERT_BIOMETRIC_EXT_INFO;

    typedef struct _OCSP_SIGNATURE_INFO
    {
        CRYPT_ALGORITHM_IDENTIFIER SignatureAlgorithm;
        CRYPT_BIT_BLOB Signature;
        DWORD cCertEncoded;
        PCERT_BLOB rgCertEncoded;
    } OCSP_SIGNATURE_INFO, *POCSP_SIGNATURE_INFO;

    typedef struct _OCSP_SIGNED_REQUEST_INFO
    {
        CRYPT_DER_BLOB ToBeSigned;
        POCSP_SIGNATURE_INFO pOptionalSignatureInfo;
    } OCSP_SIGNED_REQUEST_INFO, *POCSP_SIGNED_REQUEST_INFO;

    typedef struct _OCSP_CERT_ID
    {
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        CRYPT_HASH_BLOB IssuerNameHash;
        CRYPT_HASH_BLOB IssuerKeyHash;
        CRYPT_INTEGER_BLOB SerialNumber;
    } OCSP_CERT_ID, *POCSP_CERT_ID;

    typedef struct _OCSP_REQUEST_ENTRY
    {
        OCSP_CERT_ID CertId;
        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } OCSP_REQUEST_ENTRY, *POCSP_REQUEST_ENTRY;

    typedef struct _OCSP_REQUEST_INFO
    {
        DWORD dwVersion;
        PCERT_ALT_NAME_ENTRY pRequestorName;
        DWORD cRequestEntry;
        POCSP_REQUEST_ENTRY rgRequestEntry;
        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } OCSP_REQUEST_INFO, *POCSP_REQUEST_INFO;

    typedef struct _OCSP_RESPONSE_INFO
    {
        DWORD dwStatus;
        LPSTR pszObjId;
        CRYPT_OBJID_BLOB Value;
    } OCSP_RESPONSE_INFO, *POCSP_RESPONSE_INFO;

    typedef struct _OCSP_BASIC_SIGNED_RESPONSE_INFO
    {
        CRYPT_DER_BLOB ToBeSigned;
        OCSP_SIGNATURE_INFO SignatureInfo;
    } OCSP_BASIC_SIGNED_RESPONSE_INFO, *POCSP_BASIC_SIGNED_RESPONSE_INFO;

    typedef struct _OCSP_BASIC_REVOKED_INFO
    {
        FILETIME RevocationDate;

        DWORD dwCrlReasonCode;
    } OCSP_BASIC_REVOKED_INFO, *POCSP_BASIC_REVOKED_INFO;

    typedef struct _OCSP_BASIC_RESPONSE_ENTRY
    {
        OCSP_CERT_ID CertId;
        DWORD dwCertStatus;
        union
        {
            POCSP_BASIC_REVOKED_INFO pRevokedInfo;
        };
        FILETIME ThisUpdate;
        FILETIME NextUpdate;

        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } OCSP_BASIC_RESPONSE_ENTRY, *POCSP_BASIC_RESPONSE_ENTRY;

    typedef struct _OCSP_BASIC_RESPONSE_INFO
    {
        DWORD dwVersion;
        DWORD dwResponderIdChoice;
        union
        {
            CERT_NAME_BLOB ByNameResponderId;

            CRYPT_HASH_BLOB ByKeyResponderId;
        };
        FILETIME ProducedAt;
        DWORD cResponseEntry;
        POCSP_BASIC_RESPONSE_ENTRY rgResponseEntry;
        DWORD cExtension;
        PCERT_EXTENSION rgExtension;
    } OCSP_BASIC_RESPONSE_INFO, *POCSP_BASIC_RESPONSE_INFO;

    typedef struct _CERT_SUPPORTED_ALGORITHM_INFO
    {
        CRYPT_ALGORITHM_IDENTIFIER Algorithm;
        CRYPT_BIT_BLOB IntendedKeyUsage;
        CERT_POLICIES_INFO IntendedCertPolicies;
    } CERT_SUPPORTED_ALGORITHM_INFO, *PCERT_SUPPORTED_ALGORITHM_INFO;

    typedef struct _CERT_TPM_SPECIFICATION_INFO
    {
        LPWSTR pwszFamily;
        DWORD dwLevel;
        DWORD dwRevision;
    } CERT_TPM_SPECIFICATION_INFO, *PCERT_TPM_SPECIFICATION_INFO;

    typedef void* HCRYPTOIDFUNCSET;
    typedef void* HCRYPTOIDFUNCADDR;

    typedef struct _CRYPT_OID_FUNC_ENTRY
    {
        LPCSTR pszOID;
        void* pvFuncAddr;
    } CRYPT_OID_FUNC_ENTRY, *PCRYPT_OID_FUNC_ENTRY;

    __declspec(dllimport) BOOL __stdcall CryptInstallOIDFunctionAddress(
    HMODULE hModule, DWORD dwEncodingType, LPCSTR pszFuncName, DWORD cFuncEntry, const CRYPT_OID_FUNC_ENTRY rgFuncEntry[], DWORD dwFlags);

    __declspec(dllimport) HCRYPTOIDFUNCSET __stdcall CryptInitOIDFunctionSet(LPCSTR pszFuncName, DWORD dwFlags);

    __declspec(dllimport)

    BOOL __stdcall CryptGetOIDFunctionAddress(
    HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCSTR pszOID, DWORD dwFlags, void** ppvFuncAddr, HCRYPTOIDFUNCADDR* phFuncAddr);

    __declspec(dllimport)

    BOOL __stdcall CryptGetDefaultOIDDllList(HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, WCHAR* pwszDllList, DWORD* pcchDllList);

    __declspec(dllimport)

    BOOL __stdcall CryptGetDefaultOIDFunctionAddress(
    HCRYPTOIDFUNCSET hFuncSet, DWORD dwEncodingType, LPCWSTR pwszDll, DWORD dwFlags, void** ppvFuncAddr, HCRYPTOIDFUNCADDR* phFuncAddr);

    __declspec(dllimport) BOOL __stdcall CryptFreeOIDFunctionAddress(HCRYPTOIDFUNCADDR hFuncAddr, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall CryptRegisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszDll, LPCSTR pszOverrideFuncName);

    __declspec(dllimport) BOOL __stdcall CryptUnregisterOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID);

    __declspec(dllimport) BOOL
    __stdcall CryptRegisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, DWORD dwIndex, LPCWSTR pwszDll);

    __declspec(dllimport) BOOL
    __stdcall CryptUnregisterDefaultOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCWSTR pwszDll);

    __declspec(dllimport) BOOL __stdcall CryptSetOIDFunctionValue(
    DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD dwValueType, const BYTE* pbValueData, DWORD cbValueData);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptGetOIDFunctionValue(
    DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, LPCWSTR pwszValueName, DWORD* pdwValueType, BYTE* pbValueData, DWORD* pcbValueData);

    typedef BOOL(__stdcall* PFN_CRYPT_ENUM_OID_FUNC)(DWORD dwEncodingType,
                                                     LPCSTR pszFuncName,
                                                     LPCSTR pszOID,
                                                     DWORD cValue,
                                                     const DWORD rgdwValueType[],
                                                     LPCWSTR const rgpwszValueName[],
                                                     const BYTE* const rgpbValueData[],
                                                     const DWORD rgcbValueData[],
                                                     void* pvArg);

    __declspec(dllimport) BOOL
    __stdcall CryptEnumOIDFunction(DWORD dwEncodingType, LPCSTR pszFuncName, LPCSTR pszOID, DWORD dwFlags, void* pvArg, PFN_CRYPT_ENUM_OID_FUNC pfnEnumOIDFunc);

    typedef struct _CRYPT_OID_INFO
    {
        DWORD cbSize;
        LPCSTR pszOID;
        LPCWSTR pwszName;
        DWORD dwGroupId;
        union
        {
            DWORD dwValue;
            ALG_ID Algid;
            DWORD dwLength;
        };
        CRYPT_DATA_BLOB ExtraInfo;

    } CRYPT_OID_INFO, *PCRYPT_OID_INFO;
    typedef const CRYPT_OID_INFO CCRYPT_OID_INFO, *PCCRYPT_OID_INFO;

    __declspec(dllimport) PCCRYPT_OID_INFO __stdcall CryptFindOIDInfo(DWORD dwKeyType, void* pvKey, DWORD dwGroupId);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptRegisterOIDInfo(PCCRYPT_OID_INFO pInfo, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall CryptUnregisterOIDInfo(PCCRYPT_OID_INFO pInfo);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef BOOL(__stdcall* PFN_CRYPT_ENUM_OID_INFO)(PCCRYPT_OID_INFO pInfo, void* pvArg);

    __declspec(dllimport) BOOL
    __stdcall CryptEnumOIDInfo(DWORD dwGroupId, DWORD dwFlags, void* pvArg, PFN_CRYPT_ENUM_OID_INFO pfnEnumOIDInfo);

    __declspec(dllimport) LPCWSTR __stdcall CryptFindLocalizedName(LPCWSTR pwszCryptName);

    typedef struct _CERT_STRONG_SIGN_SERIALIZED_INFO
    {
        DWORD dwFlags;
        LPWSTR pwszCNGSignHashAlgids;
        LPWSTR pwszCNGPubKeyMinBitLengths;
    } CERT_STRONG_SIGN_SERIALIZED_INFO, *PCERT_STRONG_SIGN_SERIALIZED_INFO;

    typedef struct _CERT_STRONG_SIGN_PARA
    {
        DWORD cbSize;

        DWORD dwInfoChoice;
        union
        {
            void* pvInfo;

            PCERT_STRONG_SIGN_SERIALIZED_INFO pSerializedInfo;

            LPSTR pszOID;
        };
    } CERT_STRONG_SIGN_PARA, *PCERT_STRONG_SIGN_PARA;

    typedef const CERT_STRONG_SIGN_PARA* PCCERT_STRONG_SIGN_PARA;

    typedef void* HCRYPTMSG;

    typedef struct _CERT_ISSUER_SERIAL_NUMBER
    {
        CERT_NAME_BLOB Issuer;
        CRYPT_INTEGER_BLOB SerialNumber;
    } CERT_ISSUER_SERIAL_NUMBER, *PCERT_ISSUER_SERIAL_NUMBER;

    typedef struct _CERT_ID
    {
        DWORD dwIdChoice;
        union
        {
            CERT_ISSUER_SERIAL_NUMBER IssuerSerialNumber;

            CRYPT_HASH_BLOB KeyId;

            CRYPT_HASH_BLOB HashId;
        };
    } CERT_ID, *PCERT_ID;

    typedef struct _CMSG_SIGNER_ENCODE_INFO
    {
        DWORD cbSize;
        PCERT_INFO pCertInfo;

        union
        {
            HCRYPTPROV hCryptProv;
            NCRYPT_KEY_HANDLE hNCryptKey;
        };

        DWORD dwKeySpec;

        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        void* pvHashAuxInfo;
        DWORD cAuthAttr;
        PCRYPT_ATTRIBUTE rgAuthAttr;
        DWORD cUnauthAttr;
        PCRYPT_ATTRIBUTE rgUnauthAttr;

    } CMSG_SIGNER_ENCODE_INFO, *PCMSG_SIGNER_ENCODE_INFO;

    typedef struct _CMSG_SIGNED_ENCODE_INFO
    {
        DWORD cbSize;
        DWORD cSigners;
        PCMSG_SIGNER_ENCODE_INFO rgSigners;
        DWORD cCertEncoded;
        PCERT_BLOB rgCertEncoded;
        DWORD cCrlEncoded;
        PCRL_BLOB rgCrlEncoded;

    } CMSG_SIGNED_ENCODE_INFO, *PCMSG_SIGNED_ENCODE_INFO;

    typedef struct _CMSG_RECIPIENT_ENCODE_INFO CMSG_RECIPIENT_ENCODE_INFO, *PCMSG_RECIPIENT_ENCODE_INFO;

    typedef struct _CMSG_ENVELOPED_ENCODE_INFO
    {
        DWORD cbSize;
        HCRYPTPROV_LEGACY hCryptProv;
        CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
        void* pvEncryptionAuxInfo;
        DWORD cRecipients;

        PCERT_INFO* rgpRecipients;

    } CMSG_ENVELOPED_ENCODE_INFO, *PCMSG_ENVELOPED_ENCODE_INFO;

    typedef struct _CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO
    {
        DWORD cbSize;
        CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
        void* pvKeyEncryptionAuxInfo;
        HCRYPTPROV_LEGACY hCryptProv;
        CRYPT_BIT_BLOB RecipientPublicKey;
        CERT_ID RecipientId;
    } CMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO, *PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO;

    typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO
    {
        DWORD cbSize;
        CRYPT_BIT_BLOB RecipientPublicKey;
        CERT_ID RecipientId;

        FILETIME Date;
        PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
    } CMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO, *PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO;

    typedef struct _CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO
    {
        DWORD cbSize;
        CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
        void* pvKeyEncryptionAuxInfo;
        CRYPT_ALGORITHM_IDENTIFIER KeyWrapAlgorithm;
        void* pvKeyWrapAuxInfo;

        HCRYPTPROV_LEGACY hCryptProv;
        DWORD dwKeySpec;

        DWORD dwKeyChoice;
        union
        {
            PCRYPT_ALGORITHM_IDENTIFIER pEphemeralAlgorithm;

            PCERT_ID pSenderId;
        };
        CRYPT_DATA_BLOB UserKeyingMaterial;

        DWORD cRecipientEncryptedKeys;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_ENCODE_INFO* rgpRecipientEncryptedKeys;
    } CMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO, *PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO;

    typedef struct _CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO
    {
        DWORD cbSize;
        CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
        void* pvKeyEncryptionAuxInfo;
        HCRYPTPROV hCryptProv;
        DWORD dwKeyChoice;
        union
        {
            HCRYPTKEY hKeyEncryptionKey;

            void* pvKeyEncryptionKey;
        };
        CRYPT_DATA_BLOB KeyId;

        FILETIME Date;
        PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
    } CMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO, *PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO;

    struct _CMSG_RECIPIENT_ENCODE_INFO
    {
        DWORD dwRecipientChoice;
        union
        {
            PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTrans;

            PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgree;

            PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailList;
        };
    };

    typedef struct _CMSG_RC2_AUX_INFO
    {
        DWORD cbSize;
        DWORD dwBitLen;
    } CMSG_RC2_AUX_INFO, *PCMSG_RC2_AUX_INFO;

    typedef struct _CMSG_SP3_COMPATIBLE_AUX_INFO
    {
        DWORD cbSize;
        DWORD dwFlags;
    } CMSG_SP3_COMPATIBLE_AUX_INFO, *PCMSG_SP3_COMPATIBLE_AUX_INFO;

    typedef struct _CMSG_RC4_AUX_INFO
    {
        DWORD cbSize;
        DWORD dwBitLen;
    } CMSG_RC4_AUX_INFO, *PCMSG_RC4_AUX_INFO;

    typedef struct _CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO
    {
        DWORD cbSize;
        CMSG_SIGNED_ENCODE_INFO SignedInfo;
        CMSG_ENVELOPED_ENCODE_INFO EnvelopedInfo;
    } CMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO, *PCMSG_SIGNED_AND_ENVELOPED_ENCODE_INFO;

    typedef struct _CMSG_HASHED_ENCODE_INFO
    {
        DWORD cbSize;
        HCRYPTPROV_LEGACY hCryptProv;
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        void* pvHashAuxInfo;
    } CMSG_HASHED_ENCODE_INFO, *PCMSG_HASHED_ENCODE_INFO;

    typedef struct _CMSG_ENCRYPTED_ENCODE_INFO
    {
        DWORD cbSize;
        CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
        void* pvEncryptionAuxInfo;
    } CMSG_ENCRYPTED_ENCODE_INFO, *PCMSG_ENCRYPTED_ENCODE_INFO;

    typedef BOOL(__stdcall* PFN_CMSG_STREAM_OUTPUT)(const void* pvArg, BYTE* pbData, DWORD cbData, BOOL fFinal);

    typedef struct _CMSG_STREAM_INFO
    {
        DWORD cbContent;
        PFN_CMSG_STREAM_OUTPUT pfnStreamOutput;
        void* pvArg;
    } CMSG_STREAM_INFO, *PCMSG_STREAM_INFO;

    __declspec(dllimport) HCRYPTMSG __stdcall CryptMsgOpenToEncode(DWORD dwMsgEncodingType,
                                                                   DWORD dwFlags,
                                                                   DWORD dwMsgType,
                                                                   void const* pvMsgEncodeInfo,
                                                                   LPSTR pszInnerContentObjID,
                                                                   PCMSG_STREAM_INFO pStreamInfo);

    __declspec(dllimport) DWORD __stdcall CryptMsgCalculateEncodedLength(
    DWORD dwMsgEncodingType, DWORD dwFlags, DWORD dwMsgType, void const* pvMsgEncodeInfo, LPSTR pszInnerContentObjID, DWORD cbData);

    __declspec(dllimport) HCRYPTMSG __stdcall CryptMsgOpenToDecode(DWORD dwMsgEncodingType,
                                                                   DWORD dwFlags,
                                                                   DWORD dwMsgType,
                                                                   HCRYPTPROV_LEGACY hCryptProv,
                                                                   PCERT_INFO pRecipientInfo,
                                                                   PCMSG_STREAM_INFO pStreamInfo);

    __declspec(dllimport) HCRYPTMSG __stdcall CryptMsgDuplicate(HCRYPTMSG hCryptMsg);

    __declspec(dllimport) BOOL __stdcall CryptMsgClose(HCRYPTMSG hCryptMsg);

    __declspec(dllimport) BOOL __stdcall CryptMsgUpdate(HCRYPTMSG hCryptMsg, const BYTE* pbData, DWORD cbData, BOOL fFinal);

    __declspec(dllimport) BOOL
    __stdcall CryptMsgGetParam(HCRYPTMSG hCryptMsg, DWORD dwParamType, DWORD dwIndex, void* pvData, DWORD* pcbData);

    typedef struct _CMSG_SIGNER_INFO
    {
        DWORD dwVersion;
        CERT_NAME_BLOB Issuer;
        CRYPT_INTEGER_BLOB SerialNumber;
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;

        CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;

        CRYPT_DATA_BLOB EncryptedHash;
        CRYPT_ATTRIBUTES AuthAttrs;
        CRYPT_ATTRIBUTES UnauthAttrs;
    } CMSG_SIGNER_INFO, *PCMSG_SIGNER_INFO;

    typedef struct _CMSG_CMS_SIGNER_INFO
    {
        DWORD dwVersion;
        CERT_ID SignerId;
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;

        CRYPT_ALGORITHM_IDENTIFIER HashEncryptionAlgorithm;

        CRYPT_DATA_BLOB EncryptedHash;
        CRYPT_ATTRIBUTES AuthAttrs;
        CRYPT_ATTRIBUTES UnauthAttrs;
    } CMSG_CMS_SIGNER_INFO, *PCMSG_CMS_SIGNER_INFO;

    typedef CRYPT_ATTRIBUTES CMSG_ATTR;
    typedef CRYPT_ATTRIBUTES* PCMSG_ATTR;

    typedef struct _CMSG_KEY_TRANS_RECIPIENT_INFO
    {
        DWORD dwVersion;

        CERT_ID RecipientId;

        CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
        CRYPT_DATA_BLOB EncryptedKey;
    } CMSG_KEY_TRANS_RECIPIENT_INFO, *PCMSG_KEY_TRANS_RECIPIENT_INFO;

    typedef struct _CMSG_RECIPIENT_ENCRYPTED_KEY_INFO
    {
        CERT_ID RecipientId;

        CRYPT_DATA_BLOB EncryptedKey;

        FILETIME Date;
        PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
    } CMSG_RECIPIENT_ENCRYPTED_KEY_INFO, *PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO;

    typedef struct _CMSG_KEY_AGREE_RECIPIENT_INFO
    {
        DWORD dwVersion;
        DWORD dwOriginatorChoice;
        union
        {
            CERT_ID OriginatorCertId;

            CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
        };
        CRYPT_DATA_BLOB UserKeyingMaterial;
        CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;

        DWORD cRecipientEncryptedKeys;
        PCMSG_RECIPIENT_ENCRYPTED_KEY_INFO* rgpRecipientEncryptedKeys;
    } CMSG_KEY_AGREE_RECIPIENT_INFO, *PCMSG_KEY_AGREE_RECIPIENT_INFO;

    typedef struct _CMSG_MAIL_LIST_RECIPIENT_INFO
    {
        DWORD dwVersion;
        CRYPT_DATA_BLOB KeyId;
        CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
        CRYPT_DATA_BLOB EncryptedKey;

        FILETIME Date;
        PCRYPT_ATTRIBUTE_TYPE_VALUE pOtherAttr;
    } CMSG_MAIL_LIST_RECIPIENT_INFO, *PCMSG_MAIL_LIST_RECIPIENT_INFO;

    typedef struct _CMSG_CMS_RECIPIENT_INFO
    {
        DWORD dwRecipientChoice;
        union
        {
            PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans;

            PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree;

            PCMSG_MAIL_LIST_RECIPIENT_INFO pMailList;
        };
    } CMSG_CMS_RECIPIENT_INFO, *PCMSG_CMS_RECIPIENT_INFO;

    __declspec(dllimport) BOOL
    __stdcall CryptMsgControl(HCRYPTMSG hCryptMsg, DWORD dwFlags, DWORD dwCtrlType, void const* pvCtrlPara);

    typedef struct _CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA
    {
        DWORD cbSize;
        HCRYPTPROV_LEGACY hCryptProv;
        DWORD dwSignerIndex;
        DWORD dwSignerType;
        void* pvSigner;
    } CMSG_CTRL_VERIFY_SIGNATURE_EX_PARA, *PCMSG_CTRL_VERIFY_SIGNATURE_EX_PARA;

    typedef struct _CMSG_CTRL_DECRYPT_PARA
    {
        DWORD cbSize;

        union
        {
            HCRYPTPROV hCryptProv;
            NCRYPT_KEY_HANDLE hNCryptKey;
        };

        DWORD dwKeySpec;

        DWORD dwRecipientIndex;
    } CMSG_CTRL_DECRYPT_PARA, *PCMSG_CTRL_DECRYPT_PARA;

    typedef struct _CMSG_CTRL_KEY_TRANS_DECRYPT_PARA
    {
        DWORD cbSize;

        union
        {
            HCRYPTPROV hCryptProv;
            NCRYPT_KEY_HANDLE hNCryptKey;
        };

        DWORD dwKeySpec;

        PCMSG_KEY_TRANS_RECIPIENT_INFO pKeyTrans;
        DWORD dwRecipientIndex;
    } CMSG_CTRL_KEY_TRANS_DECRYPT_PARA, *PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA;

    typedef struct _CMSG_CTRL_KEY_AGREE_DECRYPT_PARA
    {
        DWORD cbSize;

        union
        {
            HCRYPTPROV hCryptProv;
            NCRYPT_KEY_HANDLE hNCryptKey;
        };

        DWORD dwKeySpec;

        PCMSG_KEY_AGREE_RECIPIENT_INFO pKeyAgree;
        DWORD dwRecipientIndex;
        DWORD dwRecipientEncryptedKeyIndex;
        CRYPT_BIT_BLOB OriginatorPublicKey;
    } CMSG_CTRL_KEY_AGREE_DECRYPT_PARA, *PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA;

    typedef struct _CMSG_CTRL_MAIL_LIST_DECRYPT_PARA
    {
        DWORD cbSize;
        HCRYPTPROV hCryptProv;
        PCMSG_MAIL_LIST_RECIPIENT_INFO pMailList;
        DWORD dwRecipientIndex;
        DWORD dwKeyChoice;
        union
        {
            HCRYPTKEY hKeyEncryptionKey;

            void* pvKeyEncryptionKey;
        };
    } CMSG_CTRL_MAIL_LIST_DECRYPT_PARA, *PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA;

    typedef struct _CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA
    {
        DWORD cbSize;
        DWORD dwSignerIndex;
        CRYPT_DATA_BLOB blob;
    } CMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA, *PCMSG_CTRL_ADD_SIGNER_UNAUTH_ATTR_PARA;

    typedef struct _CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA
    {
        DWORD cbSize;
        DWORD dwSignerIndex;
        DWORD dwUnauthAttrIndex;
    } CMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA, *PCMSG_CTRL_DEL_SIGNER_UNAUTH_ATTR_PARA;

    BOOL __stdcall CryptMsgVerifyCountersignatureEncoded(HCRYPTPROV_LEGACY hCryptProv,
                                                         DWORD dwEncodingType,
                                                         PBYTE pbSignerInfo,
                                                         DWORD cbSignerInfo,
                                                         PBYTE pbSignerInfoCountersignature,
                                                         DWORD cbSignerInfoCountersignature,
                                                         PCERT_INFO pciCountersigner);

    BOOL __stdcall CryptMsgVerifyCountersignatureEncodedEx(HCRYPTPROV_LEGACY hCryptProv,
                                                           DWORD dwEncodingType,
                                                           PBYTE pbSignerInfo,
                                                           DWORD cbSignerInfo,
                                                           PBYTE pbSignerInfoCountersignature,
                                                           DWORD cbSignerInfoCountersignature,
                                                           DWORD dwSignerType,
                                                           void* pvSigner,
                                                           DWORD dwFlags,
                                                           void* pvExtra);

    BOOL __stdcall CryptMsgCountersign(HCRYPTMSG hCryptMsg, DWORD dwIndex, DWORD cCountersigners, PCMSG_SIGNER_ENCODE_INFO rgCountersigners);

    BOOL __stdcall CryptMsgCountersignEncoded(DWORD dwEncodingType,
                                              PBYTE pbSignerInfo,
                                              DWORD cbSignerInfo,
                                              DWORD cCountersigners,
                                              PCMSG_SIGNER_ENCODE_INFO rgCountersigners,
                                              PBYTE pbCountersignature,
                                              PDWORD pcbCountersignature);

    typedef void*(__stdcall* PFN_CMSG_ALLOC)(size_t cb);

    typedef void(__stdcall* PFN_CMSG_FREE)(void* pv);

    typedef BOOL(__stdcall* PFN_CMSG_GEN_ENCRYPT_KEY)(HCRYPTPROV* phCryptProv,
                                                      PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
                                                      PVOID pvEncryptAuxInfo,
                                                      PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
                                                      PFN_CMSG_ALLOC pfnAlloc,
                                                      HCRYPTKEY* phEncryptKey,
                                                      PBYTE* ppbEncryptParameters,
                                                      PDWORD pcbEncryptParameters);

    typedef BOOL(__stdcall* PFN_CMSG_EXPORT_ENCRYPT_KEY)(
    HCRYPTPROV hCryptProv, HCRYPTKEY hEncryptKey, PCERT_PUBLIC_KEY_INFO pPublicKeyInfo, PBYTE pbData, PDWORD pcbData);

    typedef BOOL(__stdcall* PFN_CMSG_IMPORT_ENCRYPT_KEY)(HCRYPTPROV hCryptProv,
                                                         DWORD dwKeySpec,
                                                         PCRYPT_ALGORITHM_IDENTIFIER paiEncrypt,
                                                         PCRYPT_ALGORITHM_IDENTIFIER paiPubKey,
                                                         PBYTE pbEncodedKey,
                                                         DWORD cbEncodedKey,
                                                         HCRYPTKEY* phEncryptKey);

    typedef struct _CMSG_CONTENT_ENCRYPT_INFO
    {
        DWORD cbSize;
        HCRYPTPROV_LEGACY hCryptProv;
        CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
        void* pvEncryptionAuxInfo;
        DWORD cRecipients;
        PCMSG_RECIPIENT_ENCODE_INFO rgCmsRecipients;
        PFN_CMSG_ALLOC pfnAlloc;
        PFN_CMSG_FREE pfnFree;
        DWORD dwEncryptFlags;
        union
        {
            HCRYPTKEY hContentEncryptKey;

            BCRYPT_KEY_HANDLE hCNGContentEncryptKey;
        };
        DWORD dwFlags;

        BOOL fCNG;

        BYTE* pbCNGContentEncryptKeyObject;
        BYTE* pbContentEncryptKey;
        DWORD cbContentEncryptKey;
    } CMSG_CONTENT_ENCRYPT_INFO, *PCMSG_CONTENT_ENCRYPT_INFO;

    typedef BOOL(__stdcall* PFN_CMSG_GEN_CONTENT_ENCRYPT_KEY)(PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo, DWORD dwFlags, void* pvReserved);

    typedef struct _CMSG_KEY_TRANS_ENCRYPT_INFO
    {
        DWORD cbSize;
        DWORD dwRecipientIndex;
        CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
        CRYPT_DATA_BLOB EncryptedKey;
        DWORD dwFlags;
    } CMSG_KEY_TRANS_ENCRYPT_INFO, *PCMSG_KEY_TRANS_ENCRYPT_INFO;

    typedef BOOL(__stdcall* PFN_CMSG_EXPORT_KEY_TRANS)(PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
                                                       PCMSG_KEY_TRANS_RECIPIENT_ENCODE_INFO pKeyTransEncodeInfo,
                                                       PCMSG_KEY_TRANS_ENCRYPT_INFO pKeyTransEncryptInfo,
                                                       DWORD dwFlags,
                                                       void* pvReserved);

    typedef struct _CMSG_KEY_AGREE_KEY_ENCRYPT_INFO
    {
        DWORD cbSize;
        CRYPT_DATA_BLOB EncryptedKey;
    } CMSG_KEY_AGREE_KEY_ENCRYPT_INFO, *PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO;

    typedef struct _CMSG_KEY_AGREE_ENCRYPT_INFO
    {
        DWORD cbSize;
        DWORD dwRecipientIndex;
        CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
        CRYPT_DATA_BLOB UserKeyingMaterial;
        DWORD dwOriginatorChoice;
        union
        {
            CERT_ID OriginatorCertId;

            CERT_PUBLIC_KEY_INFO OriginatorPublicKeyInfo;
        };
        DWORD cKeyAgreeKeyEncryptInfo;
        PCMSG_KEY_AGREE_KEY_ENCRYPT_INFO* rgpKeyAgreeKeyEncryptInfo;
        DWORD dwFlags;
    } CMSG_KEY_AGREE_ENCRYPT_INFO, *PCMSG_KEY_AGREE_ENCRYPT_INFO;

    typedef BOOL(__stdcall* PFN_CMSG_EXPORT_KEY_AGREE)(PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
                                                       PCMSG_KEY_AGREE_RECIPIENT_ENCODE_INFO pKeyAgreeEncodeInfo,
                                                       PCMSG_KEY_AGREE_ENCRYPT_INFO pKeyAgreeEncryptInfo,
                                                       DWORD dwFlags,
                                                       void* pvReserved);

    typedef struct _CMSG_MAIL_LIST_ENCRYPT_INFO
    {
        DWORD cbSize;
        DWORD dwRecipientIndex;
        CRYPT_ALGORITHM_IDENTIFIER KeyEncryptionAlgorithm;
        CRYPT_DATA_BLOB EncryptedKey;
        DWORD dwFlags;
    } CMSG_MAIL_LIST_ENCRYPT_INFO, *PCMSG_MAIL_LIST_ENCRYPT_INFO;

    typedef BOOL(__stdcall* PFN_CMSG_EXPORT_MAIL_LIST)(PCMSG_CONTENT_ENCRYPT_INFO pContentEncryptInfo,
                                                       PCMSG_MAIL_LIST_RECIPIENT_ENCODE_INFO pMailListEncodeInfo,
                                                       PCMSG_MAIL_LIST_ENCRYPT_INFO pMailListEncryptInfo,
                                                       DWORD dwFlags,
                                                       void* pvReserved);

    typedef BOOL(__stdcall* PFN_CMSG_IMPORT_KEY_TRANS)(PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
                                                       PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
                                                       DWORD dwFlags,
                                                       void* pvReserved,
                                                       HCRYPTKEY* phContentEncryptKey);

    typedef BOOL(__stdcall* PFN_CMSG_IMPORT_KEY_AGREE)(PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
                                                       PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
                                                       DWORD dwFlags,
                                                       void* pvReserved,
                                                       HCRYPTKEY* phContentEncryptKey);

    typedef BOOL(__stdcall* PFN_CMSG_IMPORT_MAIL_LIST)(PCRYPT_ALGORITHM_IDENTIFIER pContentEncryptionAlgorithm,
                                                       PCMSG_CTRL_MAIL_LIST_DECRYPT_PARA pMailListDecryptPara,
                                                       DWORD dwFlags,
                                                       void* pvReserved,
                                                       HCRYPTKEY* phContentEncryptKey);

    typedef struct _CMSG_CNG_CONTENT_DECRYPT_INFO
    {
        DWORD cbSize;
        CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
        PFN_CMSG_ALLOC pfnAlloc;
        PFN_CMSG_FREE pfnFree;

        NCRYPT_KEY_HANDLE hNCryptKey;

        BYTE* pbContentEncryptKey;
        DWORD cbContentEncryptKey;

        BCRYPT_KEY_HANDLE hCNGContentEncryptKey;
        BYTE* pbCNGContentEncryptKeyObject;
    } CMSG_CNG_CONTENT_DECRYPT_INFO, *PCMSG_CNG_CONTENT_DECRYPT_INFO;

    typedef BOOL(__stdcall* PFN_CMSG_CNG_IMPORT_KEY_TRANS)(PCMSG_CNG_CONTENT_DECRYPT_INFO pCNGContentDecryptInfo,
                                                           PCMSG_CTRL_KEY_TRANS_DECRYPT_PARA pKeyTransDecryptPara,
                                                           DWORD dwFlags,
                                                           void* pvReserved);

    typedef BOOL(__stdcall* PFN_CMSG_CNG_IMPORT_KEY_AGREE)(PCMSG_CNG_CONTENT_DECRYPT_INFO pCNGContentDecryptInfo,
                                                           PCMSG_CTRL_KEY_AGREE_DECRYPT_PARA pKeyAgreeDecryptPara,
                                                           DWORD dwFlags,
                                                           void* pvReserved);

    typedef BOOL(__stdcall* PFN_CMSG_CNG_IMPORT_CONTENT_ENCRYPT_KEY)(PCMSG_CNG_CONTENT_DECRYPT_INFO pCNGContentDecryptInfo,
                                                                     DWORD dwFlags,
                                                                     void* pvReserved);

    typedef void* HCERTSTORE;

    typedef struct _CERT_CONTEXT
    {
        DWORD dwCertEncodingType;
        BYTE* pbCertEncoded;
        DWORD cbCertEncoded;
        PCERT_INFO pCertInfo;
        HCERTSTORE hCertStore;
    } CERT_CONTEXT, *PCERT_CONTEXT;
    typedef const CERT_CONTEXT* PCCERT_CONTEXT;

    typedef struct _CRL_CONTEXT
    {
        DWORD dwCertEncodingType;
        BYTE* pbCrlEncoded;
        DWORD cbCrlEncoded;
        PCRL_INFO pCrlInfo;
        HCERTSTORE hCertStore;
    } CRL_CONTEXT, *PCRL_CONTEXT;
    typedef const CRL_CONTEXT* PCCRL_CONTEXT;

    typedef struct _CTL_CONTEXT
    {
        DWORD dwMsgAndCertEncodingType;
        BYTE* pbCtlEncoded;
        DWORD cbCtlEncoded;
        PCTL_INFO pCtlInfo;
        HCERTSTORE hCertStore;
        HCRYPTMSG hCryptMsg;
        BYTE* pbCtlContent;
        DWORD cbCtlContent;
    } CTL_CONTEXT, *PCTL_CONTEXT;
    typedef const CTL_CONTEXT* PCCTL_CONTEXT;

    typedef enum CertKeyType : DWORD
    {
        KeyTypeOther = 0,
        KeyTypeVirtualSmartCard = 1,
        KeyTypePhysicalSmartCard = 2,
        KeyTypePassport = 3,
        KeyTypePassportRemote = 4,
        KeyTypePassportSmartCard = 5,
        KeyTypeHardware = 6,
        KeyTypeSoftware = 7,
        KeyTypeSelfSigned = 8,
    } CertKeyType;

    typedef struct _CRYPT_KEY_PROV_PARAM
    {
        DWORD dwParam;
        BYTE* pbData;
        DWORD cbData;
        DWORD dwFlags;
    } CRYPT_KEY_PROV_PARAM, *PCRYPT_KEY_PROV_PARAM;

    typedef struct _CRYPT_KEY_PROV_INFO
    {
        LPWSTR pwszContainerName;
        LPWSTR pwszProvName;
        DWORD dwProvType;
        DWORD dwFlags;
        DWORD cProvParam;
        PCRYPT_KEY_PROV_PARAM rgProvParam;
        DWORD dwKeySpec;
    } CRYPT_KEY_PROV_INFO, *PCRYPT_KEY_PROV_INFO;

    typedef struct _CERT_KEY_CONTEXT
    {
        DWORD cbSize;
        union
        {
            HCRYPTPROV hCryptProv;

            NCRYPT_KEY_HANDLE hNCryptKey;
        };
        DWORD dwKeySpec;
    } CERT_KEY_CONTEXT, *PCERT_KEY_CONTEXT;

    typedef struct _ROOT_INFO_LUID
    {
        DWORD LowPart;
        LONG HighPart;
    } ROOT_INFO_LUID, *PROOT_INFO_LUID;

    typedef struct _CRYPT_SMART_CARD_ROOT_INFO
    {
        BYTE rgbCardID[16];
        ROOT_INFO_LUID luid;
    } CRYPT_SMART_CARD_ROOT_INFO, *PCRYPT_SMART_CARD_ROOT_INFO;

    typedef struct _CERT_SYSTEM_STORE_RELOCATE_PARA
    {
        union
        {
            HKEY hKeyBase;
            void* pvBase;
        };
        union
        {
            void* pvSystemStore;
            LPCSTR pszSystemStore;
            LPCWSTR pwszSystemStore;
        };
    } CERT_SYSTEM_STORE_RELOCATE_PARA, *PCERT_SYSTEM_STORE_RELOCATE_PARA;

    typedef struct _CERT_REGISTRY_STORE_CLIENT_GPT_PARA
    {
        HKEY hKeyBase;
        LPWSTR pwszRegPath;
    } CERT_REGISTRY_STORE_CLIENT_GPT_PARA, *PCERT_REGISTRY_STORE_CLIENT_GPT_PARA;

    typedef struct _CERT_REGISTRY_STORE_ROAMING_PARA
    {
        HKEY hKey;
        LPWSTR pwszStoreDirectory;
    } CERT_REGISTRY_STORE_ROAMING_PARA, *PCERT_REGISTRY_STORE_ROAMING_PARA;

    typedef struct _CERT_LDAP_STORE_OPENED_PARA
    {
        void* pvLdapSessionHandle;

        LPCWSTR pwszLdapUrl;
    } CERT_LDAP_STORE_OPENED_PARA, *PCERT_LDAP_STORE_OPENED_PARA;

    __declspec(dllimport)

    HCERTSTORE
    __stdcall CertOpenStore(LPCSTR lpszStoreProvider, DWORD dwEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const void* pvPara);

    typedef void* HCERTSTOREPROV;

    typedef struct _CERT_STORE_PROV_INFO
    {
        DWORD cbSize;
        DWORD cStoreProvFunc;
        void** rgpvStoreProvFunc;
        HCERTSTOREPROV hStoreProv;
        DWORD dwStoreProvFlags;
        HCRYPTOIDFUNCADDR hStoreProvFuncAddr2;
    } CERT_STORE_PROV_INFO, *PCERT_STORE_PROV_INFO;

    typedef BOOL(__stdcall* PFN_CERT_DLL_OPEN_STORE_PROV_FUNC)(LPCSTR lpszStoreProvider,
                                                               DWORD dwEncodingType,
                                                               HCRYPTPROV_LEGACY hCryptProv,
                                                               DWORD dwFlags,
                                                               const void* pvPara,
                                                               HCERTSTORE hCertStore,
                                                               PCERT_STORE_PROV_INFO pStoreProvInfo);

    typedef void(__stdcall* PFN_CERT_STORE_PROV_CLOSE)(HCERTSTOREPROV hStoreProv, DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_READ_CERT)(HCERTSTOREPROV hStoreProv,
                                                           PCCERT_CONTEXT pStoreCertContext,
                                                           DWORD dwFlags,
                                                           PCCERT_CONTEXT* ppProvCertContext);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_WRITE_CERT)(HCERTSTOREPROV hStoreProv, PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_DELETE_CERT)(HCERTSTOREPROV hStoreProv, PCCERT_CONTEXT pCertContext, DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_SET_CERT_PROPERTY)(
    HCERTSTOREPROV hStoreProv, PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void* pvData);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_READ_CRL)(HCERTSTOREPROV hStoreProv,
                                                          PCCRL_CONTEXT pStoreCrlContext,
                                                          DWORD dwFlags,
                                                          PCCRL_CONTEXT* ppProvCrlContext);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_WRITE_CRL)(HCERTSTOREPROV hStoreProv, PCCRL_CONTEXT pCrlContext, DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_DELETE_CRL)(HCERTSTOREPROV hStoreProv, PCCRL_CONTEXT pCrlContext, DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_SET_CRL_PROPERTY)(
    HCERTSTOREPROV hStoreProv, PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void* pvData);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_READ_CTL)(HCERTSTOREPROV hStoreProv,
                                                          PCCTL_CONTEXT pStoreCtlContext,
                                                          DWORD dwFlags,
                                                          PCCTL_CONTEXT* ppProvCtlContext);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_WRITE_CTL)(HCERTSTOREPROV hStoreProv, PCCTL_CONTEXT pCtlContext, DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_DELETE_CTL)(HCERTSTOREPROV hStoreProv, PCCTL_CONTEXT pCtlContext, DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_SET_CTL_PROPERTY)(
    HCERTSTOREPROV hStoreProv, PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void* pvData);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_CONTROL)(HCERTSTOREPROV hStoreProv, DWORD dwFlags, DWORD dwCtrlType, void const* pvCtrlPara);

    typedef struct _CERT_STORE_PROV_FIND_INFO
    {
        DWORD cbSize;
        DWORD dwMsgAndCertEncodingType;
        DWORD dwFindFlags;
        DWORD dwFindType;
        const void* pvFindPara;
    } CERT_STORE_PROV_FIND_INFO, *PCERT_STORE_PROV_FIND_INFO;
    typedef const CERT_STORE_PROV_FIND_INFO CCERT_STORE_PROV_FIND_INFO, *PCCERT_STORE_PROV_FIND_INFO;

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_FIND_CERT)(HCERTSTOREPROV hStoreProv,
                                                           PCCERT_STORE_PROV_FIND_INFO pFindInfo,
                                                           PCCERT_CONTEXT pPrevCertContext,
                                                           DWORD dwFlags,
                                                           void** ppvStoreProvFindInfo,
                                                           PCCERT_CONTEXT* ppProvCertContext);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_FREE_FIND_CERT)(HCERTSTOREPROV hStoreProv,
                                                                PCCERT_CONTEXT pCertContext,
                                                                void* pvStoreProvFindInfo,
                                                                DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_GET_CERT_PROPERTY)(
    HCERTSTOREPROV hStoreProv, PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, void* pvData, DWORD* pcbData);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_FIND_CRL)(HCERTSTOREPROV hStoreProv,
                                                          PCCERT_STORE_PROV_FIND_INFO pFindInfo,
                                                          PCCRL_CONTEXT pPrevCrlContext,
                                                          DWORD dwFlags,
                                                          void** ppvStoreProvFindInfo,
                                                          PCCRL_CONTEXT* ppProvCrlContext);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_FREE_FIND_CRL)(HCERTSTOREPROV hStoreProv,
                                                               PCCRL_CONTEXT pCrlContext,
                                                               void* pvStoreProvFindInfo,
                                                               DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_GET_CRL_PROPERTY)(
    HCERTSTOREPROV hStoreProv, PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, void* pvData, DWORD* pcbData);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_FIND_CTL)(HCERTSTOREPROV hStoreProv,
                                                          PCCERT_STORE_PROV_FIND_INFO pFindInfo,
                                                          PCCTL_CONTEXT pPrevCtlContext,
                                                          DWORD dwFlags,
                                                          void** ppvStoreProvFindInfo,
                                                          PCCTL_CONTEXT* ppProvCtlContext);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_FREE_FIND_CTL)(HCERTSTOREPROV hStoreProv,
                                                               PCCTL_CONTEXT pCtlContext,
                                                               void* pvStoreProvFindInfo,
                                                               DWORD dwFlags);

    typedef BOOL(__stdcall* PFN_CERT_STORE_PROV_GET_CTL_PROPERTY)(
    HCERTSTOREPROV hStoreProv, PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, void* pvData, DWORD* pcbData);

    __declspec(dllimport) HCERTSTORE __stdcall CertDuplicateStore(HCERTSTORE hCertStore);

    __declspec(dllimport) BOOL
    __stdcall CertSaveStore(HCERTSTORE hCertStore, DWORD dwEncodingType, DWORD dwSaveAs, DWORD dwSaveTo, void* pvSaveToPara, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall CertCloseStore(HCERTSTORE hCertStore, DWORD dwFlags);

    __declspec(dllimport) PCCERT_CONTEXT
    __stdcall CertGetSubjectCertificateFromStore(HCERTSTORE hCertStore, DWORD dwCertEncodingType, PCERT_INFO pCertId

    );

    __declspec(dllimport) PCCERT_CONTEXT
    __stdcall CertEnumCertificatesInStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pPrevCertContext);

    __declspec(dllimport) PCCERT_CONTEXT __stdcall CertFindCertificateInStore(HCERTSTORE hCertStore,
                                                                              DWORD dwCertEncodingType,
                                                                              DWORD dwFindFlags,
                                                                              DWORD dwFindType,
                                                                              const void* pvFindPara,
                                                                              PCCERT_CONTEXT pPrevCertContext);

    __declspec(dllimport) PCCERT_CONTEXT __stdcall CertGetIssuerCertificateFromStore(HCERTSTORE hCertStore,
                                                                                     PCCERT_CONTEXT pSubjectContext,
                                                                                     PCCERT_CONTEXT pPrevIssuerContext,
                                                                                     DWORD* pdwFlags);

    __declspec(dllimport) BOOL
    __stdcall CertVerifySubjectCertificateContext(PCCERT_CONTEXT pSubject, PCCERT_CONTEXT pIssuer, DWORD* pdwFlags);

    __declspec(dllimport) PCCERT_CONTEXT __stdcall CertDuplicateCertificateContext(PCCERT_CONTEXT pCertContext);

    __declspec(dllimport) PCCERT_CONTEXT
    __stdcall CertCreateCertificateContext(DWORD dwCertEncodingType, const BYTE* pbCertEncoded, DWORD cbCertEncoded);

    __declspec(dllimport) BOOL __stdcall CertFreeCertificateContext(PCCERT_CONTEXT pCertContext);

    __declspec(dllimport) BOOL
    __stdcall CertSetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, DWORD dwFlags, const void* pvData);

    __declspec(dllimport) BOOL
    __stdcall CertGetCertificateContextProperty(PCCERT_CONTEXT pCertContext, DWORD dwPropId, void* pvData, DWORD* pcbData);

    __declspec(dllimport) DWORD __stdcall CertEnumCertificateContextProperties(PCCERT_CONTEXT pCertContext, DWORD dwPropId);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall CertCreateCTLEntryFromCertificateContextProperties(PCCERT_CONTEXT pCertContext,
                                                                      DWORD cOptAttr,
                                                                      PCRYPT_ATTRIBUTE rgOptAttr,
                                                                      DWORD dwFlags,
                                                                      void* pvReserved,
                                                                      PCTL_ENTRY pCtlEntry,
                                                                      DWORD* pcbCtlEntry);

    __declspec(dllimport) BOOL
    __stdcall CertSetCertificateContextPropertiesFromCTLEntry(PCCERT_CONTEXT pCertContext, PCTL_ENTRY pCtlEntry, DWORD dwFlags);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) PCCRL_CONTEXT
    __stdcall CertGetCRLFromStore(HCERTSTORE hCertStore, PCCERT_CONTEXT pIssuerContext, PCCRL_CONTEXT pPrevCrlContext, DWORD* pdwFlags);

    __declspec(dllimport) PCCRL_CONTEXT __stdcall CertEnumCRLsInStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pPrevCrlContext);

    __declspec(dllimport) PCCRL_CONTEXT __stdcall CertFindCRLInStore(HCERTSTORE hCertStore,
                                                                     DWORD dwCertEncodingType,
                                                                     DWORD dwFindFlags,
                                                                     DWORD dwFindType,
                                                                     const void* pvFindPara,
                                                                     PCCRL_CONTEXT pPrevCrlContext);

    typedef struct _CRL_FIND_ISSUED_FOR_PARA
    {
        PCCERT_CONTEXT pSubjectCert;
        PCCERT_CONTEXT pIssuerCert;
    } CRL_FIND_ISSUED_FOR_PARA, *PCRL_FIND_ISSUED_FOR_PARA;

    __declspec(dllimport) PCCRL_CONTEXT __stdcall CertDuplicateCRLContext(PCCRL_CONTEXT pCrlContext);

    __declspec(dllimport) PCCRL_CONTEXT
    __stdcall CertCreateCRLContext(DWORD dwCertEncodingType, const BYTE* pbCrlEncoded, DWORD cbCrlEncoded);

    __declspec(dllimport) BOOL __stdcall CertFreeCRLContext(PCCRL_CONTEXT pCrlContext);

    __declspec(dllimport) BOOL
    __stdcall CertSetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, DWORD dwFlags, const void* pvData);

    __declspec(dllimport) BOOL
    __stdcall CertGetCRLContextProperty(PCCRL_CONTEXT pCrlContext, DWORD dwPropId, void* pvData, DWORD* pcbData);

    __declspec(dllimport) DWORD __stdcall CertEnumCRLContextProperties(PCCRL_CONTEXT pCrlContext, DWORD dwPropId);

    __declspec(dllimport) BOOL
    __stdcall CertFindCertificateInCRL(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrlContext, DWORD dwFlags, void* pvReserved, PCRL_ENTRY* ppCrlEntry);

    __declspec(dllimport) BOOL
    __stdcall CertIsValidCRLForCertificate(PCCERT_CONTEXT pCert, PCCRL_CONTEXT pCrl, DWORD dwFlags, void* pvReserved);

    __declspec(dllimport)

    BOOL __stdcall CertAddEncodedCertificateToStore(HCERTSTORE hCertStore,
                                                    DWORD dwCertEncodingType,
                                                    const BYTE* pbCertEncoded,
                                                    DWORD cbCertEncoded,
                                                    DWORD dwAddDisposition,
                                                    PCCERT_CONTEXT* ppCertContext);

    __declspec(dllimport)

    BOOL __stdcall CertAddCertificateContextToStore(HCERTSTORE hCertStore,
                                                    PCCERT_CONTEXT pCertContext,
                                                    DWORD dwAddDisposition,
                                                    PCCERT_CONTEXT* ppStoreContext);

    __declspec(dllimport)

    BOOL __stdcall CertAddSerializedElementToStore(HCERTSTORE hCertStore,
                                                   const BYTE* pbElement,
                                                   DWORD cbElement,
                                                   DWORD dwAddDisposition,
                                                   DWORD dwFlags,
                                                   DWORD dwContextTypeFlags,
                                                   DWORD* pdwContextType,
                                                   const void** ppvContext);

    __declspec(dllimport) BOOL __stdcall CertDeleteCertificateFromStore(PCCERT_CONTEXT pCertContext);

    __declspec(dllimport)

    BOOL __stdcall CertAddEncodedCRLToStore(HCERTSTORE hCertStore,
                                            DWORD dwCertEncodingType,
                                            const BYTE* pbCrlEncoded,
                                            DWORD cbCrlEncoded,
                                            DWORD dwAddDisposition,
                                            PCCRL_CONTEXT* ppCrlContext);

    __declspec(dllimport)

    BOOL
    __stdcall CertAddCRLContextToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT* ppStoreContext);

    __declspec(dllimport) BOOL __stdcall CertDeleteCRLFromStore(PCCRL_CONTEXT pCrlContext);

    __declspec(dllimport) BOOL
    __stdcall CertSerializeCertificateStoreElement(PCCERT_CONTEXT pCertContext, DWORD dwFlags, BYTE* pbElement, DWORD* pcbElement);

    __declspec(dllimport) BOOL
    __stdcall CertSerializeCRLStoreElement(PCCRL_CONTEXT pCrlContext, DWORD dwFlags, BYTE* pbElement, DWORD* pcbElement);

    __declspec(dllimport) PCCTL_CONTEXT __stdcall CertDuplicateCTLContext(PCCTL_CONTEXT pCtlContext);

    __declspec(dllimport) PCCTL_CONTEXT
    __stdcall CertCreateCTLContext(DWORD dwMsgAndCertEncodingType, const BYTE* pbCtlEncoded, DWORD cbCtlEncoded);

    __declspec(dllimport) BOOL __stdcall CertFreeCTLContext(PCCTL_CONTEXT pCtlContext);

    __declspec(dllimport) BOOL
    __stdcall CertSetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, DWORD dwFlags, const void* pvData);

    __declspec(dllimport) BOOL
    __stdcall CertGetCTLContextProperty(PCCTL_CONTEXT pCtlContext, DWORD dwPropId, void* pvData, DWORD* pcbData);

    __declspec(dllimport) DWORD __stdcall CertEnumCTLContextProperties(PCCTL_CONTEXT pCtlContext, DWORD dwPropId);

    __declspec(dllimport) PCCTL_CONTEXT __stdcall CertEnumCTLsInStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pPrevCtlContext);

    __declspec(dllimport) PCTL_ENTRY
    __stdcall CertFindSubjectInCTL(DWORD dwEncodingType, DWORD dwSubjectType, void* pvSubject, PCCTL_CONTEXT pCtlContext, DWORD dwFlags);

    typedef struct _CTL_ANY_SUBJECT_INFO
    {
        CRYPT_ALGORITHM_IDENTIFIER SubjectAlgorithm;
        CRYPT_DATA_BLOB SubjectIdentifier;
    } CTL_ANY_SUBJECT_INFO, *PCTL_ANY_SUBJECT_INFO;

    __declspec(dllimport) PCCTL_CONTEXT __stdcall CertFindCTLInStore(HCERTSTORE hCertStore,
                                                                     DWORD dwMsgAndCertEncodingType,
                                                                     DWORD dwFindFlags,
                                                                     DWORD dwFindType,
                                                                     const void* pvFindPara,
                                                                     PCCTL_CONTEXT pPrevCtlContext);

    typedef struct _CTL_FIND_USAGE_PARA
    {
        DWORD cbSize;
        CTL_USAGE SubjectUsage;
        CRYPT_DATA_BLOB ListIdentifier;
        PCERT_INFO pSigner;
    } CTL_FIND_USAGE_PARA, *PCTL_FIND_USAGE_PARA;

    typedef struct _CTL_FIND_SUBJECT_PARA
    {
        DWORD cbSize;
        PCTL_FIND_USAGE_PARA pUsagePara;
        DWORD dwSubjectType;
        void* pvSubject;
    } CTL_FIND_SUBJECT_PARA, *PCTL_FIND_SUBJECT_PARA;

    __declspec(dllimport)

    BOOL __stdcall CertAddEncodedCTLToStore(HCERTSTORE hCertStore,
                                            DWORD dwMsgAndCertEncodingType,
                                            const BYTE* pbCtlEncoded,
                                            DWORD cbCtlEncoded,
                                            DWORD dwAddDisposition,
                                            PCCTL_CONTEXT* ppCtlContext);

    __declspec(dllimport)

    BOOL
    __stdcall CertAddCTLContextToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT* ppStoreContext);

    __declspec(dllimport) BOOL
    __stdcall CertSerializeCTLStoreElement(PCCTL_CONTEXT pCtlContext, DWORD dwFlags, BYTE* pbElement, DWORD* pcbElement);

    __declspec(dllimport) BOOL __stdcall CertDeleteCTLFromStore(PCCTL_CONTEXT pCtlContext);

    __declspec(dllimport)

    BOOL __stdcall CertAddCertificateLinkToStore(HCERTSTORE hCertStore,
                                                 PCCERT_CONTEXT pCertContext,
                                                 DWORD dwAddDisposition,
                                                 PCCERT_CONTEXT* ppStoreContext);

    __declspec(dllimport)

    BOOL
    __stdcall CertAddCRLLinkToStore(HCERTSTORE hCertStore, PCCRL_CONTEXT pCrlContext, DWORD dwAddDisposition, PCCRL_CONTEXT* ppStoreContext);

    __declspec(dllimport)

    BOOL
    __stdcall CertAddCTLLinkToStore(HCERTSTORE hCertStore, PCCTL_CONTEXT pCtlContext, DWORD dwAddDisposition, PCCTL_CONTEXT* ppStoreContext);

    __declspec(dllimport) BOOL
    __stdcall CertAddStoreToCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore, DWORD dwUpdateFlags, DWORD dwPriority);

    __declspec(dllimport) void __stdcall CertRemoveStoreFromCollection(HCERTSTORE hCollectionStore, HCERTSTORE hSiblingStore);

    __declspec(dllimport) BOOL
    __stdcall CertControlStore(HCERTSTORE hCertStore, DWORD dwFlags, DWORD dwCtrlType, void const* pvCtrlPara);

    __declspec(dllimport) BOOL
    __stdcall CertSetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, DWORD dwFlags, const void* pvData);

    __declspec(dllimport)

    BOOL __stdcall CertGetStoreProperty(HCERTSTORE hCertStore, DWORD dwPropId, void* pvData, DWORD* pcbData);

    typedef BOOL(__stdcall* PFN_CERT_CREATE_CONTEXT_SORT_FUNC)(DWORD cbTotalEncoded, DWORD cbRemainEncoded, DWORD cEntry, void* pvSort);

    typedef struct _CERT_CREATE_CONTEXT_PARA
    {
        DWORD cbSize;
        PFN_CRYPT_FREE pfnFree;
        void* pvFree;

        PFN_CERT_CREATE_CONTEXT_SORT_FUNC pfnSort;
        void* pvSort;
    } CERT_CREATE_CONTEXT_PARA, *PCERT_CREATE_CONTEXT_PARA;

    __declspec(dllimport) const void* __stdcall CertCreateContext(DWORD dwContextType,
                                                                  DWORD dwEncodingType,
                                                                  const BYTE* pbEncoded,
                                                                  DWORD cbEncoded,
                                                                  DWORD dwFlags,
                                                                  PCERT_CREATE_CONTEXT_PARA pCreatePara);

    typedef struct _CERT_SYSTEM_STORE_INFO
    {
        DWORD cbSize;
    } CERT_SYSTEM_STORE_INFO, *PCERT_SYSTEM_STORE_INFO;

    typedef struct _CERT_PHYSICAL_STORE_INFO
    {
        DWORD cbSize;
        LPSTR pszOpenStoreProvider;
        DWORD dwOpenEncodingType;
        DWORD dwOpenFlags;
        CRYPT_DATA_BLOB OpenParameters;
        DWORD dwFlags;
        DWORD dwPriority;
    } CERT_PHYSICAL_STORE_INFO, *PCERT_PHYSICAL_STORE_INFO;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall CertRegisterSystemStore(const void* pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void* pvReserved);

    __declspec(dllimport) BOOL __stdcall CertRegisterPhysicalStore(
    const void* pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName, PCERT_PHYSICAL_STORE_INFO pStoreInfo, void* pvReserved);

    __declspec(dllimport) BOOL __stdcall CertUnregisterSystemStore(const void* pvSystemStore, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall CertUnregisterPhysicalStore(const void* pvSystemStore, DWORD dwFlags, LPCWSTR pwszStoreName);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef BOOL(__stdcall* PFN_CERT_ENUM_SYSTEM_STORE_LOCATION)(LPCWSTR pwszStoreLocation, DWORD dwFlags, void* pvReserved, void* pvArg);

    typedef BOOL(__stdcall* PFN_CERT_ENUM_SYSTEM_STORE)(
    const void* pvSystemStore, DWORD dwFlags, PCERT_SYSTEM_STORE_INFO pStoreInfo, void* pvReserved, void* pvArg);

    typedef BOOL(__stdcall* PFN_CERT_ENUM_PHYSICAL_STORE)(const void* pvSystemStore,
                                                          DWORD dwFlags,
                                                          LPCWSTR pwszStoreName,
                                                          PCERT_PHYSICAL_STORE_INFO pStoreInfo,
                                                          void* pvReserved,
                                                          void* pvArg);

    __declspec(dllimport) BOOL
    __stdcall CertEnumSystemStoreLocation(DWORD dwFlags, void* pvArg, PFN_CERT_ENUM_SYSTEM_STORE_LOCATION pfnEnum);

    __declspec(dllimport) BOOL
    __stdcall CertEnumSystemStore(DWORD dwFlags, void* pvSystemStoreLocationPara, void* pvArg, PFN_CERT_ENUM_SYSTEM_STORE pfnEnum);

    __declspec(dllimport) BOOL
    __stdcall CertEnumPhysicalStore(const void* pvSystemStore, DWORD dwFlags, void* pvArg, PFN_CERT_ENUM_PHYSICAL_STORE pfnEnum);

    __declspec(dllimport) BOOL
    __stdcall CertGetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, DWORD dwFlags, PCERT_ENHKEY_USAGE pUsage, DWORD* pcbUsage);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CertSetEnhancedKeyUsage(PCCERT_CONTEXT pCertContext, PCERT_ENHKEY_USAGE pUsage);

    __declspec(dllimport) BOOL __stdcall CertAddEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier);

    __declspec(dllimport) BOOL
    __stdcall CertRemoveEnhancedKeyUsageIdentifier(PCCERT_CONTEXT pCertContext, LPCSTR pszUsageIdentifier);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall CertGetValidUsages(DWORD cCerts, PCCERT_CONTEXT* rghCerts, int* cNumOIDs, LPSTR* rghOIDs, DWORD* pcbOIDs);

    __declspec(dllimport)

    BOOL __stdcall CryptMsgGetAndVerifySigner(
    HCRYPTMSG hCryptMsg, DWORD cSignerStore, HCERTSTORE* rghSignerStore, DWORD dwFlags, PCCERT_CONTEXT* ppSigner, DWORD* pdwSignerIndex);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptMsgSignCTL(DWORD dwMsgEncodingType,
                                                         BYTE* pbCtlContent,
                                                         DWORD cbCtlContent,
                                                         PCMSG_SIGNED_ENCODE_INFO pSignInfo,
                                                         DWORD dwFlags,
                                                         BYTE* pbEncoded,
                                                         DWORD* pcbEncoded);

    __declspec(dllimport) BOOL __stdcall CryptMsgEncodeAndSignCTL(
    DWORD dwMsgEncodingType, PCTL_INFO pCtlInfo, PCMSG_SIGNED_ENCODE_INFO pSignInfo, DWORD dwFlags, BYTE* pbEncoded, DWORD* pcbEncoded);

    __declspec(dllimport) BOOL __stdcall CertFindSubjectInSortedCTL(PCRYPT_DATA_BLOB pSubjectIdentifier,
                                                                    PCCTL_CONTEXT pCtlContext,
                                                                    DWORD dwFlags,
                                                                    void* pvReserved,
                                                                    PCRYPT_DER_BLOB pEncodedAttributes);

    __declspec(dllimport) BOOL __stdcall CertEnumSubjectInSortedCTL(PCCTL_CONTEXT pCtlContext,
                                                                    void** ppvNextSubject,
                                                                    PCRYPT_DER_BLOB pSubjectIdentifier,
                                                                    PCRYPT_DER_BLOB pEncodedAttributes);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct _CTL_VERIFY_USAGE_PARA
    {
        DWORD cbSize;
        CRYPT_DATA_BLOB ListIdentifier;
        DWORD cCtlStore;
        HCERTSTORE* rghCtlStore;
        DWORD cSignerStore;
        HCERTSTORE* rghSignerStore;
    } CTL_VERIFY_USAGE_PARA, *PCTL_VERIFY_USAGE_PARA;

    typedef struct _CTL_VERIFY_USAGE_STATUS
    {
        DWORD cbSize;
        DWORD dwError;
        DWORD dwFlags;
        PCCTL_CONTEXT* ppCtl;
        DWORD dwCtlEntryIndex;
        PCCERT_CONTEXT* ppSigner;
        DWORD dwSignerIndex;
    } CTL_VERIFY_USAGE_STATUS, *PCTL_VERIFY_USAGE_STATUS;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CertVerifyCTLUsage(DWORD dwEncodingType,
                                                            DWORD dwSubjectType,
                                                            void* pvSubject,
                                                            PCTL_USAGE pSubjectUsage,
                                                            DWORD dwFlags,
                                                            PCTL_VERIFY_USAGE_PARA pVerifyUsagePara,
                                                            PCTL_VERIFY_USAGE_STATUS pVerifyUsageStatus);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct _CERT_REVOCATION_CRL_INFO
    {
        DWORD cbSize;
        PCCRL_CONTEXT pBaseCrlContext;
        PCCRL_CONTEXT pDeltaCrlContext;

        PCRL_ENTRY pCrlEntry;
        BOOL fDeltaCrlEntry;
    } CERT_REVOCATION_CRL_INFO, *PCERT_REVOCATION_CRL_INFO;

    typedef struct _CERT_REVOCATION_CHAIN_PARA CERT_REVOCATION_CHAIN_PARA, *PCERT_REVOCATION_CHAIN_PARA;

    typedef struct _CERT_REVOCATION_PARA
    {
        DWORD cbSize;
        PCCERT_CONTEXT pIssuerCert;
        DWORD cCertStore;
        HCERTSTORE* rgCertStore;
        HCERTSTORE hCrlStore;
        LPFILETIME pftTimeToUse;

    } CERT_REVOCATION_PARA, *PCERT_REVOCATION_PARA;

    typedef struct _CERT_REVOCATION_STATUS
    {
        DWORD cbSize;
        DWORD dwIndex;
        DWORD dwError;
        DWORD dwReason;

        BOOL fHasFreshnessTime;
        DWORD dwFreshnessTime;
    } CERT_REVOCATION_STATUS, *PCERT_REVOCATION_STATUS;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CertVerifyRevocation(DWORD dwEncodingType,
                                                              DWORD dwRevType,
                                                              DWORD cContext,
                                                              PVOID rgpvContext[],
                                                              DWORD dwFlags,
                                                              PCERT_REVOCATION_PARA pRevPara,
                                                              PCERT_REVOCATION_STATUS pRevStatus);

#pragma endregion

#pragma region Application Family or OneCore Family

    BOOL __stdcall CertCompareIntegerBlob(PCRYPT_INTEGER_BLOB pInt1, PCRYPT_INTEGER_BLOB pInt2);

    __declspec(dllimport) BOOL __stdcall CertCompareCertificate(DWORD dwCertEncodingType, PCERT_INFO pCertId1, PCERT_INFO pCertId2);

    __declspec(dllimport) BOOL
    __stdcall CertCompareCertificateName(DWORD dwCertEncodingType, PCERT_NAME_BLOB pCertName1, PCERT_NAME_BLOB pCertName2);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall CertIsRDNAttrsInCertificateName(DWORD dwCertEncodingType, DWORD dwFlags, PCERT_NAME_BLOB pCertName, PCERT_RDN pRDN);

    __declspec(dllimport) BOOL
    __stdcall CertComparePublicKeyInfo(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey1, PCERT_PUBLIC_KEY_INFO pPublicKey2);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) DWORD __stdcall CertGetPublicKeyLength(DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pPublicKey);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall CryptVerifyCertificateSignature(HCRYPTPROV_LEGACY hCryptProv,
                                                   DWORD dwCertEncodingType,
                                                   const BYTE* pbEncoded,
                                                   DWORD cbEncoded,
                                                   PCERT_PUBLIC_KEY_INFO pPublicKey);

    __declspec(dllimport)

    BOOL __stdcall CryptVerifyCertificateSignatureEx(HCRYPTPROV_LEGACY hCryptProv,
                                                     DWORD dwCertEncodingType,
                                                     DWORD dwSubjectType,
                                                     void* pvSubject,
                                                     DWORD dwIssuerType,
                                                     void* pvIssuer,
                                                     DWORD dwFlags,
                                                     void* pvExtra);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct _CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO
    {
        CRYPT_DATA_BLOB CertSignHashCNGAlgPropData;

        CRYPT_DATA_BLOB CertIssuerPubKeyBitLengthPropData;
    } CRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO, *PCRYPT_VERIFY_CERT_SIGN_STRONG_PROPERTIES_INFO;

    typedef struct _CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO
    {
        DWORD cCNGHashAlgid;
        PCWSTR* rgpwszCNGHashAlgid;

        DWORD dwWeakIndex;
    } CRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO, *PCRYPT_VERIFY_CERT_SIGN_WEAK_HASH_INFO;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL
    __stdcall CertIsStrongHashToSign(PCCERT_STRONG_SIGN_PARA pStrongSignPara, LPCWSTR pwszCNGHashAlgid, PCCERT_CONTEXT pSigningCert);

    __declspec(dllimport) BOOL __stdcall CryptHashToBeSigned(HCRYPTPROV_LEGACY hCryptProv,
                                                             DWORD dwCertEncodingType,
                                                             const BYTE* pbEncoded,
                                                             DWORD cbEncoded,
                                                             BYTE* pbComputedHash,
                                                             DWORD* pcbComputedHash);

    __declspec(dllimport) BOOL __stdcall CryptHashCertificate(HCRYPTPROV_LEGACY hCryptProv,
                                                              ALG_ID Algid,
                                                              DWORD dwFlags,
                                                              const BYTE* pbEncoded,
                                                              DWORD cbEncoded,
                                                              BYTE* pbComputedHash,
                                                              DWORD* pcbComputedHash);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall CryptHashCertificate2(LPCWSTR pwszCNGHashAlgid,
                                         DWORD dwFlags,
                                         void* pvReserved,
                                         const BYTE* pbEncoded,
                                         DWORD cbEncoded,
                                         BYTE* pbComputedHash,
                                         DWORD* pcbComputedHash);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptSignCertificate(

    HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
    DWORD dwKeySpec,
    DWORD dwCertEncodingType,
    const BYTE* pbEncodedToBeSigned,
    DWORD cbEncodedToBeSigned,
    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    const void* pvHashAuxInfo,
    BYTE* pbSignature,
    DWORD* pcbSignature);

    __declspec(dllimport) BOOL __stdcall CryptSignAndEncodeCertificate(

    HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
    DWORD dwKeySpec,
    DWORD dwCertEncodingType,
    LPCSTR lpszStructType,
    const void* pvStructInfo,
    PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
    const void* pvHashAuxInfo,
    BYTE* pbEncoded,
    DWORD* pcbEncoded);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef BOOL(__stdcall* PFN_CRYPT_EXTRACT_ENCODED_SIGNATURE_PARAMETERS_FUNC)(DWORD dwCertEncodingType,
                                                                                 PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
                                                                                 void** ppvDecodedSignPara,
                                                                                 LPWSTR* ppwszCNGHashAlgid);

    typedef BOOL(__stdcall* PFN_CRYPT_SIGN_AND_ENCODE_HASH_FUNC)(NCRYPT_KEY_HANDLE hKey,
                                                                 DWORD dwCertEncodingType,
                                                                 PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
                                                                 void* pvDecodedSignPara,
                                                                 LPCWSTR pwszCNGPubKeyAlgid,
                                                                 LPCWSTR pwszCNGHashAlgid,
                                                                 BYTE* pbComputedHash,
                                                                 DWORD cbComputedHash,
                                                                 BYTE* pbSignature,
                                                                 DWORD* pcbSignature);

    typedef BOOL(__stdcall* PFN_CRYPT_VERIFY_ENCODED_SIGNATURE_FUNC)(DWORD dwCertEncodingType,
                                                                     PCERT_PUBLIC_KEY_INFO pPubKeyInfo,
                                                                     PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
                                                                     void* pvDecodedSignPara,
                                                                     LPCWSTR pwszCNGPubKeyAlgid,
                                                                     LPCWSTR pwszCNGHashAlgid,
                                                                     BYTE* pbComputedHash,
                                                                     DWORD cbComputedHash,
                                                                     BYTE* pbSignature,
                                                                     DWORD cbSignature);

    __declspec(dllimport) LONG __stdcall CertVerifyTimeValidity(LPFILETIME pTimeToVerify, PCERT_INFO pCertInfo);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) LONG __stdcall CertVerifyCRLTimeValidity(LPFILETIME pTimeToVerify, PCRL_INFO pCrlInfo);

    __declspec(dllimport) BOOL __stdcall CertVerifyValidityNesting(PCERT_INFO pSubjectInfo, PCERT_INFO pIssuerInfo);

    __declspec(dllimport) BOOL __stdcall CertVerifyCRLRevocation(DWORD dwCertEncodingType,
                                                                 PCERT_INFO pCertId,

                                                                 DWORD cCrlInfo,
                                                                 PCRL_INFO rgpCrlInfo[]);

    __declspec(dllimport) LPCSTR __stdcall CertAlgIdToOID(DWORD dwAlgId);

    __declspec(dllimport) DWORD __stdcall CertOIDToAlgId(LPCSTR pszObjId);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) PCERT_EXTENSION
    __stdcall CertFindExtension(LPCSTR pszObjId, DWORD cExtensions, CERT_EXTENSION rgExtensions[]);

    __declspec(dllimport) PCRYPT_ATTRIBUTE __stdcall CertFindAttribute(LPCSTR pszObjId, DWORD cAttr, CRYPT_ATTRIBUTE rgAttr[]);

    __declspec(dllimport) PCERT_RDN_ATTR __stdcall CertFindRDNAttr(LPCSTR pszObjId, PCERT_NAME_INFO pName);

    __declspec(dllimport) BOOL
    __stdcall CertGetIntendedKeyUsage(DWORD dwCertEncodingType, PCERT_INFO pCertInfo, BYTE* pbKeyUsage, DWORD cbKeyUsage);

    typedef void* HCRYPTDEFAULTCONTEXT;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptInstallDefaultContext(HCRYPTPROV hCryptProv,
                                                                    DWORD dwDefaultType,
                                                                    const void* pvDefaultPara,
                                                                    DWORD dwFlags,
                                                                    void* pvReserved,
                                                                    HCRYPTDEFAULTCONTEXT* phDefaultContext);

    typedef struct _CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA
    {
        DWORD cOID;
        LPSTR* rgpszOID;
    } CRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA, *PCRYPT_DEFAULT_CONTEXT_MULTI_OID_PARA;

    __declspec(dllimport) BOOL
    __stdcall CryptUninstallDefaultContext(HCRYPTDEFAULTCONTEXT hDefaultContext, DWORD dwFlags, void* pvReserved);

    __declspec(dllimport) BOOL __stdcall CryptExportPublicKeyInfo(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
                                                                  DWORD dwKeySpec,
                                                                  DWORD dwCertEncodingType,
                                                                  PCERT_PUBLIC_KEY_INFO pInfo,
                                                                  DWORD* pcbInfo);

    __declspec(dllimport) BOOL __stdcall CryptExportPublicKeyInfoEx(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
                                                                    DWORD dwKeySpec,
                                                                    DWORD dwCertEncodingType,
                                                                    LPSTR pszPublicKeyObjId,
                                                                    DWORD dwFlags,
                                                                    void* pvAuxInfo,
                                                                    PCERT_PUBLIC_KEY_INFO pInfo,
                                                                    DWORD* pcbInfo);

    typedef BOOL(__stdcall* PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_EX2_FUNC)(NCRYPT_KEY_HANDLE hNCryptKey,
                                                                       DWORD dwCertEncodingType,
                                                                       LPSTR pszPublicKeyObjId,
                                                                       DWORD dwFlags,
                                                                       void* pvAuxInfo,
                                                                       PCERT_PUBLIC_KEY_INFO pInfo,
                                                                       DWORD* pcbInfo);

    __declspec(dllimport) BOOL __stdcall CryptExportPublicKeyInfoFromBCryptKeyHandle(BCRYPT_KEY_HANDLE hBCryptKey,
                                                                                     DWORD dwCertEncodingType,
                                                                                     LPSTR pszPublicKeyObjId,
                                                                                     DWORD dwFlags,
                                                                                     void* pvAuxInfo,
                                                                                     PCERT_PUBLIC_KEY_INFO pInfo,
                                                                                     DWORD* pcbInfo);

    typedef BOOL(__stdcall* PFN_CRYPT_EXPORT_PUBLIC_KEY_INFO_FROM_BCRYPT_HANDLE_FUNC)(BCRYPT_KEY_HANDLE hBCryptKey,
                                                                                      DWORD dwCertEncodingType,
                                                                                      LPSTR pszPublicKeyObjId,
                                                                                      DWORD dwFlags,
                                                                                      void* pvAuxInfo,
                                                                                      PCERT_PUBLIC_KEY_INFO pInfo,
                                                                                      DWORD* pcbInfo);

    __declspec(dllimport) BOOL
    __stdcall CryptImportPublicKeyInfo(HCRYPTPROV hCryptProv, DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, HCRYPTKEY* phKey);

    __declspec(dllimport) BOOL __stdcall CryptImportPublicKeyInfoEx(HCRYPTPROV hCryptProv,
                                                                    DWORD dwCertEncodingType,
                                                                    PCERT_PUBLIC_KEY_INFO pInfo,
                                                                    ALG_ID aiKeyAlg,
                                                                    DWORD dwFlags,
                                                                    void* pvAuxInfo,
                                                                    HCRYPTKEY* phKey);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptImportPublicKeyInfoEx2(
    DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void* pvAuxInfo, BCRYPT_KEY_HANDLE* phKey);

    typedef BOOL(__stdcall* PFN_IMPORT_PUBLIC_KEY_INFO_EX2_FUNC)(
    DWORD dwCertEncodingType, PCERT_PUBLIC_KEY_INFO pInfo, DWORD dwFlags, void* pvAuxInfo, BCRYPT_KEY_HANDLE* phKey);

#pragma endregion

#pragma region Desktop Family or OneCore Family

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptAcquireCertificatePrivateKey(PCCERT_CONTEXT pCert,
                                                                           DWORD dwFlags,
                                                                           void* pvParameters,
                                                                           HCRYPTPROV_OR_NCRYPT_KEY_HANDLE* phCryptProvOrNCryptKey,
                                                                           DWORD* pdwKeySpec,
                                                                           BOOL* pfCallerFreeProvOrNCryptKey);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptFindCertificateKeyProvInfo(PCCERT_CONTEXT pCert, DWORD dwFlags, void* pvReserved);

    typedef BOOL(__stdcall* PFN_IMPORT_PRIV_KEY_FUNC)(HCRYPTPROV hCryptProv,
                                                      CRYPT_PRIVATE_KEY_INFO* pPrivateKeyInfo,
                                                      DWORD dwFlags,
                                                      void* pvAuxInfo);

    __declspec(dllimport) BOOL
    __stdcall CryptImportPKCS8(CRYPT_PKCS8_IMPORT_PARAMS sPrivateKeyAndParams, DWORD dwFlags, HCRYPTPROV* phCryptProv, void* pvAuxInfo);

    typedef BOOL(__stdcall* PFN_EXPORT_PRIV_KEY_FUNC)(HCRYPTPROV hCryptProv,
                                                      DWORD dwKeySpec,
                                                      LPSTR pszPrivateKeyObjId,
                                                      DWORD dwFlags,
                                                      void* pvAuxInfo,
                                                      CRYPT_PRIVATE_KEY_INFO* pPrivateKeyInfo,
                                                      DWORD* pcbPrivateKeyInfo);

    __declspec(dllimport) BOOL __stdcall CryptExportPKCS8(HCRYPTPROV hCryptProv,
                                                          DWORD dwKeySpec,
                                                          LPSTR pszPrivateKeyObjId,
                                                          DWORD dwFlags,
                                                          void* pvAuxInfo,
                                                          BYTE* pbPrivateKeyBlob,
                                                          DWORD* pcbPrivateKeyBlob);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall CryptExportPKCS8Ex(
    CRYPT_PKCS8_EXPORT_PARAMS* psExportParams, DWORD dwFlags, void* pvAuxInfo, BYTE* pbPrivateKeyBlob, DWORD* pcbPrivateKeyBlob);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptHashPublicKeyInfo(HCRYPTPROV_LEGACY hCryptProv,
                                                                ALG_ID Algid,
                                                                DWORD dwFlags,
                                                                DWORD dwCertEncodingType,
                                                                PCERT_PUBLIC_KEY_INFO pInfo,
                                                                BYTE* pbComputedHash,
                                                                DWORD* pcbComputedHash);

    __declspec(dllimport) DWORD __stdcall CertRDNValueToStrA(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPSTR psz, DWORD csz);

    __declspec(dllimport) DWORD
    __stdcall CertRDNValueToStrW(DWORD dwValueType, PCERT_RDN_VALUE_BLOB pValue, LPWSTR psz, DWORD csz);

    __declspec(dllimport) DWORD
    __stdcall CertNameToStrA(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPSTR psz, DWORD csz);
    __declspec(dllimport) DWORD
    __stdcall CertNameToStrW(DWORD dwCertEncodingType, PCERT_NAME_BLOB pName, DWORD dwStrType, LPWSTR psz, DWORD csz);

    __declspec(dllimport) BOOL __stdcall CertStrToNameA(
    DWORD dwCertEncodingType, LPCSTR pszX500, DWORD dwStrType, void* pvReserved, BYTE* pbEncoded, DWORD* pcbEncoded, LPCSTR* ppszError);

    __declspec(dllimport) BOOL __stdcall CertStrToNameW(
    DWORD dwCertEncodingType, LPCWSTR pszX500, DWORD dwStrType, void* pvReserved, BYTE* pbEncoded, DWORD* pcbEncoded, LPCWSTR* ppszError);

    __declspec(dllimport) DWORD __stdcall CertGetNameStringA(
    PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void* pvTypePara, LPSTR pszNameString, DWORD cchNameString);

    __declspec(dllimport) DWORD __stdcall CertGetNameStringW(
    PCCERT_CONTEXT pCertContext, DWORD dwType, DWORD dwFlags, void* pvTypePara, LPWSTR pszNameString, DWORD cchNameString);

    typedef PCCERT_CONTEXT(__stdcall* PFN_CRYPT_GET_SIGNER_CERTIFICATE)(void* pvGetArg,
                                                                        DWORD dwCertEncodingType,
                                                                        PCERT_INFO pSignerId,

                                                                        HCERTSTORE hMsgCertStore);

    typedef struct _CRYPT_SIGN_MESSAGE_PARA
    {
        DWORD cbSize;
        DWORD dwMsgEncodingType;
        PCCERT_CONTEXT pSigningCert;
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        void* pvHashAuxInfo;
        DWORD cMsgCert;
        PCCERT_CONTEXT* rgpMsgCert;
        DWORD cMsgCrl;
        PCCRL_CONTEXT* rgpMsgCrl;
        DWORD cAuthAttr;
        PCRYPT_ATTRIBUTE rgAuthAttr;
        DWORD cUnauthAttr;
        PCRYPT_ATTRIBUTE rgUnauthAttr;
        DWORD dwFlags;
        DWORD dwInnerContentType;

    } CRYPT_SIGN_MESSAGE_PARA, *PCRYPT_SIGN_MESSAGE_PARA;

    typedef struct _CRYPT_VERIFY_MESSAGE_PARA
    {
        DWORD cbSize;
        DWORD dwMsgAndCertEncodingType;
        HCRYPTPROV_LEGACY hCryptProv;
        PFN_CRYPT_GET_SIGNER_CERTIFICATE pfnGetSignerCertificate;
        void* pvGetArg;

    } CRYPT_VERIFY_MESSAGE_PARA, *PCRYPT_VERIFY_MESSAGE_PARA;

    typedef struct _CRYPT_ENCRYPT_MESSAGE_PARA
    {
        DWORD cbSize;
        DWORD dwMsgEncodingType;
        HCRYPTPROV_LEGACY hCryptProv;
        CRYPT_ALGORITHM_IDENTIFIER ContentEncryptionAlgorithm;
        void* pvEncryptionAuxInfo;
        DWORD dwFlags;
        DWORD dwInnerContentType;
    } CRYPT_ENCRYPT_MESSAGE_PARA, *PCRYPT_ENCRYPT_MESSAGE_PARA;

    typedef struct _CRYPT_DECRYPT_MESSAGE_PARA
    {
        DWORD cbSize;
        DWORD dwMsgAndCertEncodingType;
        DWORD cCertStore;
        HCERTSTORE* rghCertStore;

    } CRYPT_DECRYPT_MESSAGE_PARA, *PCRYPT_DECRYPT_MESSAGE_PARA;

    typedef struct _CRYPT_HASH_MESSAGE_PARA
    {
        DWORD cbSize;
        DWORD dwMsgEncodingType;
        HCRYPTPROV_LEGACY hCryptProv;
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        void* pvHashAuxInfo;
    } CRYPT_HASH_MESSAGE_PARA, *PCRYPT_HASH_MESSAGE_PARA;

    typedef struct _CRYPT_KEY_SIGN_MESSAGE_PARA
    {
        DWORD cbSize;
        DWORD dwMsgAndCertEncodingType;

        union
        {
            HCRYPTPROV hCryptProv;
            NCRYPT_KEY_HANDLE hNCryptKey;
        };

        DWORD dwKeySpec;

        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        void* pvHashAuxInfo;

        CRYPT_ALGORITHM_IDENTIFIER PubKeyAlgorithm;
    } CRYPT_KEY_SIGN_MESSAGE_PARA, *PCRYPT_KEY_SIGN_MESSAGE_PARA;

    typedef struct _CRYPT_KEY_VERIFY_MESSAGE_PARA
    {
        DWORD cbSize;
        DWORD dwMsgEncodingType;
        HCRYPTPROV_LEGACY hCryptProv;
    } CRYPT_KEY_VERIFY_MESSAGE_PARA, *PCRYPT_KEY_VERIFY_MESSAGE_PARA;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptSignMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara,
                                                          BOOL fDetachedSignature,
                                                          DWORD cToBeSigned,
                                                          const BYTE* rgpbToBeSigned[],
                                                          DWORD rgcbToBeSigned[],
                                                          BYTE* pbSignedBlob,
                                                          DWORD* pcbSignedBlob);

    __declspec(dllimport) BOOL __stdcall CryptVerifyMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
                                                                     DWORD dwSignerIndex,
                                                                     const BYTE* pbSignedBlob,
                                                                     DWORD cbSignedBlob,
                                                                     BYTE* pbDecoded,
                                                                     DWORD* pcbDecoded,
                                                                     PCCERT_CONTEXT* ppSignerCert);

    __declspec(dllimport) LONG
    __stdcall CryptGetMessageSignerCount(DWORD dwMsgEncodingType, const BYTE* pbSignedBlob, DWORD cbSignedBlob);

    __declspec(dllimport) HCERTSTORE __stdcall CryptGetMessageCertificates(
    DWORD dwMsgAndCertEncodingType, HCRYPTPROV_LEGACY hCryptProv, DWORD dwFlags, const BYTE* pbSignedBlob, DWORD cbSignedBlob);

    __declspec(dllimport) BOOL __stdcall CryptVerifyDetachedMessageSignature(PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
                                                                             DWORD dwSignerIndex,
                                                                             const BYTE* pbDetachedSignBlob,
                                                                             DWORD cbDetachedSignBlob,
                                                                             DWORD cToBeSigned,
                                                                             const BYTE* rgpbToBeSigned[],
                                                                             DWORD rgcbToBeSigned[],
                                                                             PCCERT_CONTEXT* ppSignerCert);

    __declspec(dllimport) BOOL __stdcall CryptEncryptMessage(PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
                                                             DWORD cRecipientCert,
                                                             PCCERT_CONTEXT rgpRecipientCert[],
                                                             const BYTE* pbToBeEncrypted,
                                                             DWORD cbToBeEncrypted,
                                                             BYTE* pbEncryptedBlob,
                                                             DWORD* pcbEncryptedBlob);

    __declspec(dllimport) BOOL __stdcall CryptDecryptMessage(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
                                                             const BYTE* pbEncryptedBlob,
                                                             DWORD cbEncryptedBlob,
                                                             BYTE* pbDecrypted,
                                                             DWORD* pcbDecrypted,
                                                             PCCERT_CONTEXT* ppXchgCert);

    __declspec(dllimport) BOOL __stdcall CryptSignAndEncryptMessage(PCRYPT_SIGN_MESSAGE_PARA pSignPara,
                                                                    PCRYPT_ENCRYPT_MESSAGE_PARA pEncryptPara,
                                                                    DWORD cRecipientCert,
                                                                    PCCERT_CONTEXT rgpRecipientCert[],
                                                                    const BYTE* pbToBeSignedAndEncrypted,
                                                                    DWORD cbToBeSignedAndEncrypted,
                                                                    BYTE* pbSignedAndEncryptedBlob,
                                                                    DWORD* pcbSignedAndEncryptedBlob);

    __declspec(dllimport) BOOL __stdcall CryptDecryptAndVerifyMessageSignature(PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
                                                                               PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
                                                                               DWORD dwSignerIndex,
                                                                               const BYTE* pbEncryptedBlob,
                                                                               DWORD cbEncryptedBlob,
                                                                               BYTE* pbDecrypted,
                                                                               DWORD* pcbDecrypted,
                                                                               PCCERT_CONTEXT* ppXchgCert,
                                                                               PCCERT_CONTEXT* ppSignerCert);

    __declspec(dllimport) BOOL __stdcall CryptDecodeMessage(DWORD dwMsgTypeFlags,
                                                            PCRYPT_DECRYPT_MESSAGE_PARA pDecryptPara,
                                                            PCRYPT_VERIFY_MESSAGE_PARA pVerifyPara,
                                                            DWORD dwSignerIndex,
                                                            const BYTE* pbEncodedBlob,
                                                            DWORD cbEncodedBlob,
                                                            DWORD dwPrevInnerContentType,
                                                            DWORD* pdwMsgType,
                                                            DWORD* pdwInnerContentType,
                                                            BYTE* pbDecoded,
                                                            DWORD* pcbDecoded,
                                                            PCCERT_CONTEXT* ppXchgCert,
                                                            PCCERT_CONTEXT* ppSignerCert);

    __declspec(dllimport) BOOL __stdcall CryptHashMessage(PCRYPT_HASH_MESSAGE_PARA pHashPara,
                                                          BOOL fDetachedHash,
                                                          DWORD cToBeHashed,
                                                          const BYTE* rgpbToBeHashed[],
                                                          DWORD rgcbToBeHashed[],
                                                          BYTE* pbHashedBlob,
                                                          DWORD* pcbHashedBlob,
                                                          BYTE* pbComputedHash,
                                                          DWORD* pcbComputedHash);

    __declspec(dllimport) BOOL __stdcall CryptVerifyMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara,
                                                                BYTE* pbHashedBlob,
                                                                DWORD cbHashedBlob,
                                                                BYTE* pbToBeHashed,
                                                                DWORD* pcbToBeHashed,
                                                                BYTE* pbComputedHash,
                                                                DWORD* pcbComputedHash);

    __declspec(dllimport) BOOL __stdcall CryptVerifyDetachedMessageHash(PCRYPT_HASH_MESSAGE_PARA pHashPara,
                                                                        BYTE* pbDetachedHashBlob,
                                                                        DWORD cbDetachedHashBlob,
                                                                        DWORD cToBeHashed,
                                                                        const BYTE* rgpbToBeHashed[],
                                                                        DWORD rgcbToBeHashed[],
                                                                        BYTE* pbComputedHash,
                                                                        DWORD* pcbComputedHash);

    __declspec(dllimport) BOOL __stdcall CryptSignMessageWithKey(PCRYPT_KEY_SIGN_MESSAGE_PARA pSignPara,
                                                                 const BYTE* pbToBeSigned,
                                                                 DWORD cbToBeSigned,
                                                                 BYTE* pbSignedBlob,
                                                                 DWORD* pcbSignedBlob);

    __declspec(dllimport) BOOL __stdcall CryptVerifyMessageSignatureWithKey(PCRYPT_KEY_VERIFY_MESSAGE_PARA pVerifyPara,
                                                                            PCERT_PUBLIC_KEY_INFO pPublicKeyInfo,
                                                                            const BYTE* pbSignedBlob,
                                                                            DWORD cbSignedBlob,
                                                                            BYTE* pbDecoded,
                                                                            DWORD* pcbDecoded);

    __declspec(dllimport) HCERTSTORE __stdcall CertOpenSystemStoreA(HCRYPTPROV_LEGACY hProv, LPCSTR szSubsystemProtocol);
    __declspec(dllimport) HCERTSTORE __stdcall CertOpenSystemStoreW(HCRYPTPROV_LEGACY hProv, LPCWSTR szSubsystemProtocol);

    __declspec(dllimport) BOOL
    __stdcall CertAddEncodedCertificateToSystemStoreA(LPCSTR szCertStoreName, const BYTE* pbCertEncoded, DWORD cbCertEncoded);
    __declspec(dllimport) BOOL
    __stdcall CertAddEncodedCertificateToSystemStoreW(LPCWSTR szCertStoreName, const BYTE* pbCertEncoded, DWORD cbCertEncoded);

#pragma endregion

#pragma region Desktop Family or Wintrust Package

    typedef struct _CERT_CHAIN
    {
        DWORD cCerts;
        PCERT_BLOB certs;

        CRYPT_KEY_PROV_INFO keyLocatorInfo;
    } CERT_CHAIN, *PCERT_CHAIN;

    HRESULT
    __stdcall FindCertsByIssuer(PCERT_CHAIN pCertChains,
                                DWORD* pcbCertChains,
                                DWORD* pcCertChains,
                                BYTE* pbEncodedIssuerName,
                                DWORD cbEncodedIssuerName,
                                LPCWSTR pwszPurpose,
                                DWORD dwKeySpec

    );

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptQueryObject(DWORD dwObjectType,
                                                          const void* pvObject,
                                                          DWORD dwExpectedContentTypeFlags,
                                                          DWORD dwExpectedFormatTypeFlags,
                                                          DWORD dwFlags,
                                                          DWORD* pdwMsgAndCertEncodingType,
                                                          DWORD* pdwContentType,
                                                          DWORD* pdwFormatType,
                                                          HCERTSTORE* phCertStore,
                                                          HCRYPTMSG* phMsg,
                                                          const void** ppvContext);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) LPVOID __stdcall CryptMemAlloc(ULONG cbSize);

    __declspec(dllimport) LPVOID __stdcall CryptMemRealloc(LPVOID pv, ULONG cbSize);

    __declspec(dllimport) void __stdcall CryptMemFree(LPVOID pv);

    typedef HANDLE HCRYPTASYNC, *PHCRYPTASYNC;

    typedef void(__stdcall* PFN_CRYPT_ASYNC_PARAM_FREE_FUNC)(LPSTR pszParamOid, LPVOID pvParam);

    __declspec(dllimport) BOOL __stdcall CryptCreateAsyncHandle(DWORD dwFlags, PHCRYPTASYNC phAsync);

    __declspec(dllimport) BOOL
    __stdcall CryptSetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID pvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC pfnFree);

    __declspec(dllimport) BOOL
    __stdcall CryptGetAsyncParam(HCRYPTASYNC hAsync, LPSTR pszParamOid, LPVOID* ppvParam, PFN_CRYPT_ASYNC_PARAM_FREE_FUNC* ppfnFree);

    __declspec(dllimport) BOOL __stdcall CryptCloseAsyncHandle(HCRYPTASYNC hAsync);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct _CRYPT_BLOB_ARRAY
    {
        DWORD cBlob;
        PCRYPT_DATA_BLOB rgBlob;
    } CRYPT_BLOB_ARRAY, *PCRYPT_BLOB_ARRAY;

    typedef struct _CRYPT_CREDENTIALS
    {
        DWORD cbSize;
        LPCSTR pszCredentialsOid;
        LPVOID pvCredentials;
    } CRYPT_CREDENTIALS, *PCRYPT_CREDENTIALS;

    typedef struct _CRYPT_PASSWORD_CREDENTIALSA
    {
        DWORD cbSize;
        LPSTR pszUsername;
        LPSTR pszPassword;
    } CRYPT_PASSWORD_CREDENTIALSA, *PCRYPT_PASSWORD_CREDENTIALSA;
    typedef struct _CRYPT_PASSWORD_CREDENTIALSW
    {
        DWORD cbSize;
        LPWSTR pszUsername;
        LPWSTR pszPassword;
    } CRYPT_PASSWORD_CREDENTIALSW, *PCRYPT_PASSWORD_CREDENTIALSW;

    typedef CRYPT_PASSWORD_CREDENTIALSA CRYPT_PASSWORD_CREDENTIALS;
    typedef PCRYPT_PASSWORD_CREDENTIALSA PCRYPT_PASSWORD_CREDENTIALS;

    typedef void(__stdcall* PFN_FREE_ENCODED_OBJECT_FUNC)(LPCSTR pszObjectOid, PCRYPT_BLOB_ARRAY pObject, LPVOID pvFreeContext);

    typedef struct _CRYPTNET_URL_CACHE_PRE_FETCH_INFO
    {
        DWORD cbSize;
        DWORD dwObjectType;

        DWORD dwError;
        DWORD dwReserved;

        FILETIME ThisUpdateTime;
        FILETIME NextUpdateTime;
        FILETIME PublishTime;
    } CRYPTNET_URL_CACHE_PRE_FETCH_INFO, *PCRYPTNET_URL_CACHE_PRE_FETCH_INFO;

    typedef struct _CRYPTNET_URL_CACHE_FLUSH_INFO
    {
        DWORD cbSize;

        DWORD dwExemptSeconds;

        FILETIME ExpireTime;
    } CRYPTNET_URL_CACHE_FLUSH_INFO, *PCRYPTNET_URL_CACHE_FLUSH_INFO;

    typedef struct _CRYPTNET_URL_CACHE_RESPONSE_INFO
    {
        DWORD cbSize;
        WORD wResponseType;
        WORD wResponseFlags;

        FILETIME LastModifiedTime;
        DWORD dwMaxAge;
        LPCWSTR pwszETag;
        DWORD dwProxyId;
    } CRYPTNET_URL_CACHE_RESPONSE_INFO, *PCRYPTNET_URL_CACHE_RESPONSE_INFO;

    typedef struct _CRYPT_RETRIEVE_AUX_INFO
    {
        DWORD cbSize;
        FILETIME* pLastSyncTime;

        DWORD dwMaxUrlRetrievalByteCount;

        PCRYPTNET_URL_CACHE_PRE_FETCH_INFO pPreFetchInfo;

        PCRYPTNET_URL_CACHE_FLUSH_INFO pFlushInfo;

        PCRYPTNET_URL_CACHE_RESPONSE_INFO* ppResponseInfo;

        LPWSTR pwszCacheFileNamePrefix;

        LPFILETIME pftCacheResync;

        BOOL fProxyCacheRetrieval;

        DWORD dwHttpStatusCode;

        LPWSTR* ppwszErrorResponseHeaders;

        PCRYPT_DATA_BLOB* ppErrorContentBlob;
    } CRYPT_RETRIEVE_AUX_INFO, *PCRYPT_RETRIEVE_AUX_INFO;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport)

    BOOL __stdcall CryptRetrieveObjectByUrlA(LPCSTR pszUrl,
                                             LPCSTR pszObjectOid,
                                             DWORD dwRetrievalFlags,
                                             DWORD dwTimeout,
                                             LPVOID* ppvObject,
                                             HCRYPTASYNC hAsyncRetrieve,
                                             PCRYPT_CREDENTIALS pCredentials,
                                             LPVOID pvVerify,
                                             PCRYPT_RETRIEVE_AUX_INFO pAuxInfo);
    __declspec(dllimport)

    BOOL __stdcall CryptRetrieveObjectByUrlW(LPCWSTR pszUrl,
                                             LPCSTR pszObjectOid,
                                             DWORD dwRetrievalFlags,
                                             DWORD dwTimeout,
                                             LPVOID* ppvObject,
                                             HCRYPTASYNC hAsyncRetrieve,
                                             PCRYPT_CREDENTIALS pCredentials,
                                             LPVOID pvVerify,
                                             PCRYPT_RETRIEVE_AUX_INFO pAuxInfo);

    typedef BOOL(__stdcall* PFN_CRYPT_CANCEL_RETRIEVAL)(DWORD dwFlags, void* pvArg);

    __declspec(dllimport) BOOL
    __stdcall CryptInstallCancelRetrieval(PFN_CRYPT_CANCEL_RETRIEVAL pfnCancel, const void* pvArg, DWORD dwFlags, void* pvReserved);

    __declspec(dllimport) BOOL __stdcall CryptUninstallCancelRetrieval(DWORD dwFlags, void* pvReserved);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall CryptCancelAsyncRetrieval(HCRYPTASYNC hAsyncRetrieval);

    typedef void(__stdcall* PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC)(
    LPVOID pvCompletion, DWORD dwCompletionCode, LPCSTR pszUrl, LPSTR pszObjectOid, LPVOID pvObject);

    typedef struct _CRYPT_ASYNC_RETRIEVAL_COMPLETION
    {
        PFN_CRYPT_ASYNC_RETRIEVAL_COMPLETION_FUNC pfnCompletion;
        LPVOID pvCompletion;
    } CRYPT_ASYNC_RETRIEVAL_COMPLETION, *PCRYPT_ASYNC_RETRIEVAL_COMPLETION;

    typedef BOOL(__stdcall* PFN_CANCEL_ASYNC_RETRIEVAL_FUNC)(HCRYPTASYNC hAsyncRetrieve);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef struct _CRYPT_URL_ARRAY
    {
        DWORD cUrl;
        LPWSTR* rgwszUrl;
    } CRYPT_URL_ARRAY, *PCRYPT_URL_ARRAY;

    typedef struct _CRYPT_URL_INFO
    {
        DWORD cbSize;

        DWORD dwSyncDeltaTime;

        DWORD cGroup;
        DWORD* rgcGroupEntry;
    } CRYPT_URL_INFO, *PCRYPT_URL_INFO;

    __declspec(dllimport) BOOL __stdcall CryptGetObjectUrl(LPCSTR pszUrlOid,
                                                           LPVOID pvPara,
                                                           DWORD dwFlags,
                                                           PCRYPT_URL_ARRAY pUrlArray,
                                                           DWORD* pcbUrlArray,
                                                           PCRYPT_URL_INFO pUrlInfo,
                                                           DWORD* pcbUrlInfo,
                                                           LPVOID pvReserved);

    typedef struct _CERT_CRL_CONTEXT_PAIR
    {
        PCCERT_CONTEXT pCertContext;
        PCCRL_CONTEXT pCrlContext;
    } CERT_CRL_CONTEXT_PAIR, *PCERT_CRL_CONTEXT_PAIR;
    typedef const CERT_CRL_CONTEXT_PAIR* PCCERT_CRL_CONTEXT_PAIR;

#pragma endregion

#pragma region Desktop Family

    typedef struct _CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO
    {
        DWORD cbSize;

        int iDeltaCrlIndicator;

        LPFILETIME pftCacheResync;

        LPFILETIME pLastSyncTime;

        LPFILETIME pMaxAgeTime;

        PCERT_REVOCATION_CHAIN_PARA pChainPara;

        PCRYPT_INTEGER_BLOB pDeltaCrlIndicator;

    } CRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO, *PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO;

    __declspec(dllimport)

    BOOL __stdcall CryptGetTimeValidObject(LPCSTR pszTimeValidOid,
                                           LPVOID pvPara,
                                           PCCERT_CONTEXT pIssuer,
                                           LPFILETIME pftValidFor,
                                           DWORD dwFlags,
                                           DWORD dwTimeout,
                                           LPVOID* ppvObject,
                                           PCRYPT_CREDENTIALS pCredentials,
                                           PCRYPT_GET_TIME_VALID_OBJECT_EXTRA_INFO pExtraInfo);

    __declspec(dllimport) BOOL
    __stdcall CryptFlushTimeValidObject(LPCSTR pszFlushTimeValidOid, LPVOID pvPara, PCCERT_CONTEXT pIssuer, DWORD dwFlags, LPVOID pvReserved);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) PCCERT_CONTEXT
    __stdcall CertCreateSelfSignCertificate(HCRYPTPROV_OR_NCRYPT_KEY_HANDLE hCryptProvOrNCryptKey,
                                            PCERT_NAME_BLOB pSubjectIssuerBlob,
                                            DWORD dwFlags,
                                            PCRYPT_KEY_PROV_INFO pKeyProvInfo,
                                            PCRYPT_ALGORITHM_IDENTIFIER pSignatureAlgorithm,
                                            PSYSTEMTIME pStartTime,
                                            PSYSTEMTIME pEndTime,
                                            PCERT_EXTENSIONS pExtensions);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall CryptGetKeyIdentifierProperty(const CRYPT_HASH_BLOB* pKeyIdentifier,
                                                                       DWORD dwPropId,
                                                                       DWORD dwFlags,
                                                                       LPCWSTR pwszComputerName,
                                                                       void* pvReserved,
                                                                       void* pvData,
                                                                       DWORD* pcbData);

    __declspec(dllimport) BOOL __stdcall CryptSetKeyIdentifierProperty(const CRYPT_HASH_BLOB* pKeyIdentifier,
                                                                       DWORD dwPropId,
                                                                       DWORD dwFlags,
                                                                       LPCWSTR pwszComputerName,
                                                                       void* pvReserved,
                                                                       const void* pvData);

    typedef BOOL(__stdcall* PFN_CRYPT_ENUM_KEYID_PROP)(const CRYPT_HASH_BLOB* pKeyIdentifier,
                                                       DWORD dwFlags,
                                                       void* pvReserved,
                                                       void* pvArg,
                                                       DWORD cProp,
                                                       DWORD* rgdwPropId,
                                                       void** rgpvData,
                                                       DWORD* rgcbData);

    __declspec(dllimport) BOOL __stdcall CryptEnumKeyIdentifierProperties(const CRYPT_HASH_BLOB* pKeyIdentifier,
                                                                          DWORD dwPropId,
                                                                          DWORD dwFlags,
                                                                          LPCWSTR pwszComputerName,
                                                                          void* pvReserved,
                                                                          void* pvArg,
                                                                          PFN_CRYPT_ENUM_KEYID_PROP pfnEnum);

    __declspec(dllimport) BOOL __stdcall CryptCreateKeyIdentifierFromCSP(DWORD dwCertEncodingType,
                                                                         LPCSTR pszPubKeyOID,
                                                                         const PUBLICKEYSTRUC* pPubKeyStruc,
                                                                         DWORD cbPubKeyStruc,
                                                                         DWORD dwFlags,
                                                                         void* pvReserved,
                                                                         BYTE* pbHash,
                                                                         DWORD* pcbHash);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef HANDLE HCERTCHAINENGINE;

    typedef struct _CERT_CHAIN_ENGINE_CONFIG
    {
        DWORD cbSize;
        HCERTSTORE hRestrictedRoot;
        HCERTSTORE hRestrictedTrust;
        HCERTSTORE hRestrictedOther;
        DWORD cAdditionalStore;
        HCERTSTORE* rghAdditionalStore;
        DWORD dwFlags;
        DWORD dwUrlRetrievalTimeout;
        DWORD MaximumCachedCertificates;
        DWORD CycleDetectionModulus;

        HCERTSTORE hExclusiveRoot;
        HCERTSTORE hExclusiveTrustedPeople;

        DWORD dwExclusiveFlags;

    } CERT_CHAIN_ENGINE_CONFIG, *PCERT_CHAIN_ENGINE_CONFIG;

    __declspec(dllimport)

    BOOL __stdcall CertCreateCertificateChainEngine(PCERT_CHAIN_ENGINE_CONFIG pConfig, HCERTCHAINENGINE* phChainEngine);

    __declspec(dllimport) void __stdcall CertFreeCertificateChainEngine(HCERTCHAINENGINE hChainEngine);

    __declspec(dllimport) BOOL __stdcall CertResyncCertificateChainEngine(HCERTCHAINENGINE hChainEngine);

    typedef struct _CERT_TRUST_STATUS
    {
        DWORD dwErrorStatus;
        DWORD dwInfoStatus;

    } CERT_TRUST_STATUS, *PCERT_TRUST_STATUS;

    typedef struct _CERT_REVOCATION_INFO
    {
        DWORD cbSize;
        DWORD dwRevocationResult;
        LPCSTR pszRevocationOid;
        LPVOID pvOidSpecificInfo;

        BOOL fHasFreshnessTime;
        DWORD dwFreshnessTime;

        PCERT_REVOCATION_CRL_INFO pCrlInfo;

    } CERT_REVOCATION_INFO, *PCERT_REVOCATION_INFO;

    typedef struct _CERT_TRUST_LIST_INFO
    {
        DWORD cbSize;
        PCTL_ENTRY pCtlEntry;
        PCCTL_CONTEXT pCtlContext;

    } CERT_TRUST_LIST_INFO, *PCERT_TRUST_LIST_INFO;

    typedef struct _CERT_CHAIN_ELEMENT
    {
        DWORD cbSize;
        PCCERT_CONTEXT pCertContext;
        CERT_TRUST_STATUS TrustStatus;
        PCERT_REVOCATION_INFO pRevocationInfo;

        PCERT_ENHKEY_USAGE pIssuanceUsage;
        PCERT_ENHKEY_USAGE pApplicationUsage;

        LPCWSTR pwszExtendedErrorInfo;
    } CERT_CHAIN_ELEMENT, *PCERT_CHAIN_ELEMENT;
    typedef const CERT_CHAIN_ELEMENT* PCCERT_CHAIN_ELEMENT;

    typedef struct _CERT_SIMPLE_CHAIN
    {
        DWORD cbSize;
        CERT_TRUST_STATUS TrustStatus;
        DWORD cElement;
        PCERT_CHAIN_ELEMENT* rgpElement;
        PCERT_TRUST_LIST_INFO pTrustListInfo;

        BOOL fHasRevocationFreshnessTime;
        DWORD dwRevocationFreshnessTime;

    } CERT_SIMPLE_CHAIN, *PCERT_SIMPLE_CHAIN;
    typedef const CERT_SIMPLE_CHAIN* PCCERT_SIMPLE_CHAIN;

    typedef struct _CERT_CHAIN_CONTEXT CERT_CHAIN_CONTEXT, *PCERT_CHAIN_CONTEXT;
    typedef const CERT_CHAIN_CONTEXT* PCCERT_CHAIN_CONTEXT;

    struct _CERT_CHAIN_CONTEXT
    {
        DWORD cbSize;
        CERT_TRUST_STATUS TrustStatus;
        DWORD cChain;
        PCERT_SIMPLE_CHAIN* rgpChain;

        DWORD cLowerQualityChainContext;
        PCCERT_CHAIN_CONTEXT* rgpLowerQualityChainContext;

        BOOL fHasRevocationFreshnessTime;
        DWORD dwRevocationFreshnessTime;

        DWORD dwCreateFlags;

        GUID ChainId;
    };

    typedef struct _CERT_USAGE_MATCH
    {
        DWORD dwType;
        CERT_ENHKEY_USAGE Usage;

    } CERT_USAGE_MATCH, *PCERT_USAGE_MATCH;

    typedef struct _CTL_USAGE_MATCH
    {
        DWORD dwType;
        CTL_USAGE Usage;

    } CTL_USAGE_MATCH, *PCTL_USAGE_MATCH;

    typedef struct _CERT_CHAIN_PARA
    {
        DWORD cbSize;
        CERT_USAGE_MATCH RequestedUsage;

    } CERT_CHAIN_PARA, *PCERT_CHAIN_PARA;

    __declspec(dllimport)

    BOOL __stdcall CertGetCertificateChain(HCERTCHAINENGINE hChainEngine,
                                           PCCERT_CONTEXT pCertContext,
                                           LPFILETIME pTime,
                                           HCERTSTORE hAdditionalStore,
                                           PCERT_CHAIN_PARA pChainPara,
                                           DWORD dwFlags,
                                           LPVOID pvReserved,
                                           PCCERT_CHAIN_CONTEXT* ppChainContext);

    __declspec(dllimport) void __stdcall CertFreeCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext);

    __declspec(dllimport) PCCERT_CHAIN_CONTEXT __stdcall CertDuplicateCertificateChain(PCCERT_CHAIN_CONTEXT pChainContext);

    struct _CERT_REVOCATION_CHAIN_PARA
    {
        DWORD cbSize;
        HCERTCHAINENGINE hChainEngine;
        HCERTSTORE hAdditionalStore;
        DWORD dwChainFlags;
        DWORD dwUrlRetrievalTimeout;
        LPFILETIME pftCurrentTime;
        LPFILETIME pftCacheResync;

        DWORD cbMaxUrlRetrievalByteCount;
    };

    typedef struct _CRL_REVOCATION_INFO
    {
        PCRL_ENTRY pCrlEntry;
        PCCRL_CONTEXT pCrlContext;
        PCCERT_CHAIN_CONTEXT pCrlIssuerChain;

    } CRL_REVOCATION_INFO, *PCRL_REVOCATION_INFO;

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) PCCERT_CHAIN_CONTEXT __stdcall CertFindChainInStore(HCERTSTORE hCertStore,
                                                                              DWORD dwCertEncodingType,
                                                                              DWORD dwFindFlags,
                                                                              DWORD dwFindType,
                                                                              const void* pvFindPara,
                                                                              PCCERT_CHAIN_CONTEXT pPrevChainContext);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef BOOL(__stdcall* PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK)(PCCERT_CONTEXT pCert, void* pvFindArg);

    typedef struct _CERT_CHAIN_FIND_BY_ISSUER_PARA
    {
        DWORD cbSize;

        LPCSTR pszUsageIdentifier;

        DWORD dwKeySpec;

        DWORD dwAcquirePrivateKeyFlags;

        DWORD cIssuer;
        CERT_NAME_BLOB* rgIssuer;

        PFN_CERT_CHAIN_FIND_BY_ISSUER_CALLBACK pfnFindCallback;
        void* pvFindArg;

    } CERT_CHAIN_FIND_ISSUER_PARA, *PCERT_CHAIN_FIND_ISSUER_PARA, CERT_CHAIN_FIND_BY_ISSUER_PARA, *PCERT_CHAIN_FIND_BY_ISSUER_PARA;

    typedef struct _CERT_CHAIN_POLICY_PARA
    {
        DWORD cbSize;
        DWORD dwFlags;
        void* pvExtraPolicyPara;
    } CERT_CHAIN_POLICY_PARA, *PCERT_CHAIN_POLICY_PARA;

    typedef struct _CERT_CHAIN_POLICY_STATUS
    {
        DWORD cbSize;
        DWORD dwError;
        LONG lChainIndex;
        LONG lElementIndex;
        void* pvExtraPolicyStatus;
    } CERT_CHAIN_POLICY_STATUS, *PCERT_CHAIN_POLICY_STATUS;

    __declspec(dllimport) BOOL __stdcall CertVerifyCertificateChainPolicy(LPCSTR pszPolicyOID,
                                                                          PCCERT_CHAIN_CONTEXT pChainContext,
                                                                          PCERT_CHAIN_POLICY_PARA pPolicyPara,
                                                                          PCERT_CHAIN_POLICY_STATUS pPolicyStatus);

    typedef struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA
    {
        DWORD cbSize;
        DWORD dwRegPolicySettings;
        PCMSG_SIGNER_INFO pSignerInfo;
    } AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA, *PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_PARA;

    typedef struct _AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS
    {
        DWORD cbSize;
        BOOL fCommercial;
    } AUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS, *PAUTHENTICODE_EXTRA_CERT_CHAIN_POLICY_STATUS;

    typedef struct _AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA
    {
        DWORD cbSize;
        DWORD dwRegPolicySettings;
        BOOL fCommercial;
    } AUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA, *PAUTHENTICODE_TS_EXTRA_CERT_CHAIN_POLICY_PARA;

    typedef struct _HTTPSPolicyCallbackData
    {
        union
        {
            DWORD cbStruct;
            DWORD cbSize;
        };

        DWORD dwAuthType;

        DWORD fdwChecks;

        WCHAR* pwszServerName;

    } HTTPSPolicyCallbackData, *PHTTPSPolicyCallbackData, SSL_EXTRA_CERT_CHAIN_POLICY_PARA, *PSSL_EXTRA_CERT_CHAIN_POLICY_PARA;

    typedef struct _EV_EXTRA_CERT_CHAIN_POLICY_PARA
    {
        DWORD cbSize;
        DWORD dwRootProgramQualifierFlags;
    } EV_EXTRA_CERT_CHAIN_POLICY_PARA, *PEV_EXTRA_CERT_CHAIN_POLICY_PARA;

    typedef struct _EV_EXTRA_CERT_CHAIN_POLICY_STATUS
    {
        DWORD cbSize;
        DWORD dwQualifiers;
        DWORD dwIssuanceUsageIndex;
    } EV_EXTRA_CERT_CHAIN_POLICY_STATUS, *PEV_EXTRA_CERT_CHAIN_POLICY_STATUS;

    typedef struct _SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS
    {
        DWORD cbSize;
        DWORD dwErrorLevel;
        DWORD dwErrorCategory;
        DWORD dwReserved;
        WCHAR wszErrorText[256];
    } SSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS, *PSSL_F12_EXTRA_CERT_CHAIN_POLICY_STATUS;

    typedef struct _SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA
    {
        DWORD cbSize;
        DWORD dwReserved;
        LPWSTR pwszServerName;

        LPSTR rgpszHpkpValue[2];
    } SSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA, *PSSL_HPKP_HEADER_EXTRA_CERT_CHAIN_POLICY_PARA;

    typedef struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA
    {
        DWORD cbSize;
        DWORD dwReserved;
        PCWSTR pwszServerName;
    } SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA, *PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_PARA;

    typedef struct _SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS
    {
        DWORD cbSize;
        LONG lError;
        WCHAR wszErrorText[512];
    } SSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS, *PSSL_KEY_PIN_EXTRA_CERT_CHAIN_POLICY_STATUS;

    __declspec(dllimport) BOOL __stdcall CryptStringToBinaryA(
    LPCSTR pszString, DWORD cchString, DWORD dwFlags, BYTE* pbBinary, DWORD* pcbBinary, DWORD* pdwSkip, DWORD* pdwFlags);

    __declspec(dllimport) BOOL __stdcall CryptStringToBinaryW(
    LPCWSTR pszString, DWORD cchString, DWORD dwFlags, BYTE* pbBinary, DWORD* pcbBinary, DWORD* pdwSkip, DWORD* pdwFlags);

    __declspec(dllimport) BOOL
    __stdcall CryptBinaryToStringA(const BYTE* pbBinary, DWORD cbBinary, DWORD dwFlags, LPSTR pszString, DWORD* pcchString);

    __declspec(dllimport) BOOL
    __stdcall CryptBinaryToStringW(const BYTE* pbBinary, DWORD cbBinary, DWORD dwFlags, LPWSTR pszString, DWORD* pcchString);

    typedef struct _CRYPT_PKCS12_PBE_PARAMS
    {
        int iIterations;
        ULONG cbSalt;
    } CRYPT_PKCS12_PBE_PARAMS;

    __declspec(dllimport) HCERTSTORE __stdcall PFXImportCertStore(CRYPT_DATA_BLOB* pPFX, LPCWSTR szPassword, DWORD dwFlags);

    __declspec(dllimport) BOOL __stdcall PFXIsPFXBlob(CRYPT_DATA_BLOB* pPFX);

    __declspec(dllimport) BOOL __stdcall PFXVerifyPassword(CRYPT_DATA_BLOB* pPFX, LPCWSTR szPassword, DWORD dwFlags);

    __declspec(dllimport) BOOL
    __stdcall PFXExportCertStoreEx(HCERTSTORE hStore, CRYPT_DATA_BLOB* pPFX, LPCWSTR szPassword, void* pvPara, DWORD dwFlags);

    typedef struct _PKCS12_PBES2_EXPORT_PARAMS
    {
        DWORD dwSize;
        PVOID hNcryptDescriptor;
        LPWSTR pwszPbes2Alg;
    } PKCS12_PBES2_EXPORT_PARAMS, *PPKCS12_PBES2_EXPORT_PARAMS;

    __declspec(dllimport) BOOL
    __stdcall PFXExportCertStore(HCERTSTORE hStore, CRYPT_DATA_BLOB* pPFX, LPCWSTR szPassword, DWORD dwFlags);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef void* HCERT_SERVER_OCSP_RESPONSE;

    typedef struct _CERT_SERVER_OCSP_RESPONSE_CONTEXT CERT_SERVER_OCSP_RESPONSE_CONTEXT, *PCERT_SERVER_OCSP_RESPONSE_CONTEXT;
    typedef const CERT_SERVER_OCSP_RESPONSE_CONTEXT* PCCERT_SERVER_OCSP_RESPONSE_CONTEXT;

    struct _CERT_SERVER_OCSP_RESPONSE_CONTEXT
    {
        DWORD cbSize;
        BYTE* pbEncodedOcspResponse;
        DWORD cbEncodedOcspResponse;
    };

    typedef void(__stdcall* PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK)(PCCERT_CHAIN_CONTEXT pChainContext,
                                                                           PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext,
                                                                           PCCRL_CONTEXT pNewCrlContext,
                                                                           PCCRL_CONTEXT pPrevCrlContext,
                                                                           PVOID pvArg,
                                                                           DWORD dwWriteOcspFileError);

    typedef struct _CERT_SERVER_OCSP_RESPONSE_OPEN_PARA
    {
        DWORD cbSize;
        DWORD dwFlags;

        DWORD* pcbUsedSize;

        PWSTR pwszOcspDirectory;

        PFN_CERT_SERVER_OCSP_RESPONSE_UPDATE_CALLBACK pfnUpdateCallback;
        PVOID pvUpdateCallbackArg;
    } CERT_SERVER_OCSP_RESPONSE_OPEN_PARA, *PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA;

    __declspec(dllimport) HCERT_SERVER_OCSP_RESPONSE
    __stdcall CertOpenServerOcspResponse(PCCERT_CHAIN_CONTEXT pChainContext, DWORD dwFlags, PCERT_SERVER_OCSP_RESPONSE_OPEN_PARA pOpenPara);

    __declspec(dllimport) void __stdcall CertAddRefServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse);

    __declspec(dllimport) void __stdcall CertCloseServerOcspResponse(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags);

    __declspec(dllimport) PCCERT_SERVER_OCSP_RESPONSE_CONTEXT
    __stdcall CertGetServerOcspResponseContext(HCERT_SERVER_OCSP_RESPONSE hServerOcspResponse, DWORD dwFlags, LPVOID pvReserved);

    __declspec(dllimport) void __stdcall CertAddRefServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext);

    __declspec(dllimport) void __stdcall CertFreeServerOcspResponseContext(PCCERT_SERVER_OCSP_RESPONSE_CONTEXT pServerOcspResponseContext);

    __declspec(dllimport)

    BOOL __stdcall CertRetrieveLogoOrBiometricInfo(PCCERT_CONTEXT pCertContext,
                                                   LPCSTR lpszLogoOrBiometricType,
                                                   DWORD dwRetrievalFlags,
                                                   DWORD dwTimeout,
                                                   DWORD dwFlags,
                                                   void* pvReserved,
                                                   BYTE** ppbData,
                                                   DWORD* pcbData,
                                                   LPWSTR* ppwszMimeType);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef struct _CERT_SELECT_CHAIN_PARA
    {
        HCERTCHAINENGINE hChainEngine;
        PFILETIME pTime;
        HCERTSTORE hAdditionalStore;
        PCERT_CHAIN_PARA pChainPara;
        DWORD dwFlags;
    } CERT_SELECT_CHAIN_PARA, *PCERT_SELECT_CHAIN_PARA;
    typedef const CERT_SELECT_CHAIN_PARA* PCCERT_SELECT_CHAIN_PARA;

    typedef struct _CERT_SELECT_CRITERIA
    {
        DWORD dwType;
        DWORD cPara;
        void** ppPara;
    } CERT_SELECT_CRITERIA, *PCERT_SELECT_CRITERIA;
    typedef const CERT_SELECT_CRITERIA* PCCERT_SELECT_CRITERIA;

    __declspec(dllimport)

    BOOL __stdcall CertSelectCertificateChains(LPCGUID pSelectionContext,
                                               DWORD dwFlags,
                                               PCCERT_SELECT_CHAIN_PARA pChainParameters,
                                               DWORD cCriteria,
                                               PCCERT_SELECT_CRITERIA rgpCriteria,
                                               HCERTSTORE hStore,
                                               PDWORD pcSelection,
                                               PCCERT_CHAIN_CONTEXT** pprgpSelection);

    __declspec(dllimport) void __stdcall CertFreeCertificateChainList(PCCERT_CHAIN_CONTEXT* prgpSelection);

    typedef struct _CRYPT_TIMESTAMP_REQUEST
    {
        DWORD dwVersion;
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        CRYPT_DER_BLOB HashedMessage;
        LPSTR pszTSAPolicyId;
        CRYPT_INTEGER_BLOB Nonce;
        BOOL fCertReq;
        DWORD cExtension;

        PCERT_EXTENSION rgExtension;
    } CRYPT_TIMESTAMP_REQUEST, *PCRYPT_TIMESTAMP_REQUEST;

    typedef struct _CRYPT_TIMESTAMP_RESPONSE
    {
        DWORD dwStatus;
        DWORD cFreeText;

        LPWSTR* rgFreeText;
        CRYPT_BIT_BLOB FailureInfo;
        CRYPT_DER_BLOB ContentInfo;
    } CRYPT_TIMESTAMP_RESPONSE, *PCRYPT_TIMESTAMP_RESPONSE;

    typedef struct _CRYPT_TIMESTAMP_ACCURACY
    {
        DWORD dwSeconds;
        DWORD dwMillis;
        DWORD dwMicros;
    } CRYPT_TIMESTAMP_ACCURACY, *PCRYPT_TIMESTAMP_ACCURACY;

    typedef struct _CRYPT_TIMESTAMP_INFO
    {
        DWORD dwVersion;
        LPSTR pszTSAPolicyId;
        CRYPT_ALGORITHM_IDENTIFIER HashAlgorithm;
        CRYPT_DER_BLOB HashedMessage;
        CRYPT_INTEGER_BLOB SerialNumber;
        FILETIME ftTime;
        PCRYPT_TIMESTAMP_ACCURACY pvAccuracy;
        BOOL fOrdering;
        CRYPT_DER_BLOB Nonce;
        CRYPT_DER_BLOB Tsa;
        DWORD cExtension;

        PCERT_EXTENSION rgExtension;
    } CRYPT_TIMESTAMP_INFO, *PCRYPT_TIMESTAMP_INFO;

    typedef struct _CRYPT_TIMESTAMP_CONTEXT
    {
        DWORD cbEncoded;

        BYTE* pbEncoded;
        PCRYPT_TIMESTAMP_INFO pTimeStamp;
    } CRYPT_TIMESTAMP_CONTEXT, *PCRYPT_TIMESTAMP_CONTEXT;

    typedef struct _CRYPT_TIMESTAMP_PARA
    {
        LPCSTR pszTSAPolicyId;
        BOOL fRequestCerts;
        CRYPT_INTEGER_BLOB Nonce;
        DWORD cExtension;

        PCERT_EXTENSION rgExtension;
    } CRYPT_TIMESTAMP_PARA, *PCRYPT_TIMESTAMP_PARA;

    BOOL __stdcall CryptRetrieveTimeStamp(LPCWSTR wszUrl,
                                          DWORD dwRetrievalFlags,
                                          DWORD dwTimeout,
                                          LPCSTR pszHashId,
                                          const CRYPT_TIMESTAMP_PARA* pPara,

                                          const BYTE* pbData,
                                          DWORD cbData,
                                          PCRYPT_TIMESTAMP_CONTEXT* ppTsContext,
                                          PCCERT_CONTEXT* ppTsSigner,
                                          HCERTSTORE* phStore);

    BOOL __stdcall CryptVerifyTimeStampSignature(

    const BYTE* pbTSContentInfo,
    DWORD cbTSContentInfo,

    const BYTE* pbData,
    DWORD cbData,
    HCERTSTORE hAdditionalStore,
    PCRYPT_TIMESTAMP_CONTEXT* ppTsContext,
    PCCERT_CONTEXT* ppTsSigner,
    HCERTSTORE* phStore);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    typedef BOOL(__stdcall* PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH)(LPVOID pContext,
                                                                     PCERT_NAME_BLOB* rgIdentifierOrNameList,
                                                                     DWORD dwIdentifierOrNameListCount);

    typedef BOOL(__stdcall* PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET)(LPVOID pPluginContext,
                                                                   PCRYPT_DATA_BLOB pIdentifier,
                                                                   DWORD dwNameType,
                                                                   PCERT_NAME_BLOB pNameBlob,
                                                                   PBYTE* ppbContent,
                                                                   DWORD* pcbContent,
                                                                   PCWSTR* ppwszPassword,
                                                                   PCRYPT_DATA_BLOB* ppIdentifier);

    typedef void(__stdcall* PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE)(DWORD dwReason, LPVOID pPluginContext);

    typedef void(__stdcall* PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD)(LPVOID pPluginContext, PCWSTR pwszPassword);

    typedef void(__stdcall* PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE)(LPVOID pPluginContext, PBYTE pbData);

    typedef void(__stdcall* PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER)(LPVOID pPluginContext, PCRYPT_DATA_BLOB pIdentifier);

    typedef struct _CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE
    {
        DWORD cbSize;
        PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_GET pfnGet;
        PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_RELEASE pfnRelease;
        PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_PASSWORD pfnFreePassword;
        PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE pfnFree;
        PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FREE_IDENTIFIER pfnFreeIdentifier;
    } CRYPT_OBJECT_LOCATOR_PROVIDER_TABLE, *PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE;

    typedef BOOL(__stdcall* PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_INITIALIZE)(PFN_CRYPT_OBJECT_LOCATOR_PROVIDER_FLUSH pfnFlush,
                                                                          LPVOID pContext,
                                                                          DWORD* pdwExpectedObjectCount,
                                                                          PCRYPT_OBJECT_LOCATOR_PROVIDER_TABLE* ppFuncTable,
                                                                          void** ppPluginContext);

    __declspec(dllimport) BOOL __stdcall CertIsWeakHash(DWORD dwHashUseType,
                                                        LPCWSTR pwszCNGHashAlgid,
                                                        DWORD dwChainFlags,
                                                        PCCERT_CHAIN_CONTEXT pSignerChainContext,
                                                        LPFILETIME pTimeStamp,
                                                        LPCWSTR pwszFileName);

    typedef __declspec(dllimport) BOOL(__stdcall* PFN_CERT_IS_WEAK_HASH)(DWORD dwHashUseType,
                                                                         LPCWSTR pwszCNGHashAlgid,
                                                                         DWORD dwChainFlags,
                                                                         PCCERT_CHAIN_CONTEXT pSignerChainContext,
                                                                         LPFILETIME pTimeStamp,
                                                                         LPCWSTR pwszFileName);

#pragma endregion
}

#pragma warning(pop)

#pragma region Desktop Family or OneCore Family

#pragma once

extern "C"
{
#pragma region App Family or OneCore Family

    typedef struct _CRYPTPROTECT_PROMPTSTRUCT
    {
        DWORD cbSize;
        DWORD dwPromptFlags;
        HWND hwndApp;
        LPCWSTR szPrompt;
    } CRYPTPROTECT_PROMPTSTRUCT, *PCRYPTPROTECT_PROMPTSTRUCT;

    BOOL __stdcall CryptProtectData(DATA_BLOB* pDataIn,
                                    LPCWSTR szDataDescr,
                                    DATA_BLOB* pOptionalEntropy,
                                    PVOID pvReserved,
                                    CRYPTPROTECT_PROMPTSTRUCT* pPromptStruct,
                                    DWORD dwFlags,
                                    DATA_BLOB* pDataOut);

    BOOL __stdcall CryptUnprotectData(DATA_BLOB* pDataIn,
                                      LPWSTR* ppszDataDescr,
                                      DATA_BLOB* pOptionalEntropy,
                                      PVOID pvReserved,
                                      CRYPTPROTECT_PROMPTSTRUCT* pPromptStruct,
                                      DWORD dwFlags,
                                      DATA_BLOB* pDataOut);

#pragma endregion

#pragma region Desktop Family

    BOOL __stdcall CryptProtectDataNoUI(DATA_BLOB* pDataIn,
                                        LPCWSTR szDataDescr,
                                        DATA_BLOB* pOptionalEntropy,
                                        PVOID pvReserved,
                                        CRYPTPROTECT_PROMPTSTRUCT* pPromptStruct,
                                        DWORD dwFlags,

                                        const BYTE* pbOptionalPassword,
                                        DWORD cbOptionalPassword,
                                        DATA_BLOB* pDataOut);

    BOOL __stdcall CryptUnprotectDataNoUI(DATA_BLOB* pDataIn,
                                          LPWSTR* ppszDataDescr,
                                          DATA_BLOB* pOptionalEntropy,
                                          PVOID pvReserved,
                                          CRYPTPROTECT_PROMPTSTRUCT* pPromptStruct,
                                          DWORD dwFlags,

                                          const BYTE* pbOptionalPassword,
                                          DWORD cbOptionalPassword,
                                          DATA_BLOB* pDataOut);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    BOOL __stdcall CryptUpdateProtectedState(PSID pOldSid, LPCWSTR pwszOldPassword, DWORD dwFlags, DWORD* pdwSuccessCount, DWORD* pdwFailureCount);

#pragma endregion

#pragma region App Family or OneCore Family

    BOOL __stdcall CryptProtectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags);

    BOOL __stdcall CryptUnprotectMemory(LPVOID pDataIn, DWORD cbDataIn, DWORD dwFlags);

#pragma endregion
}

#pragma endregion

#pragma once

#pragma warning(push)
#pragma warning(disable : 4820)

extern "C"
{
#pragma region Desktop Family

    typedef struct _CERTIFICATE_BLOB
    {
        DWORD dwCertEncodingType;

        DWORD cbData;

        PBYTE pbData;

    } EFS_CERTIFICATE_BLOB, *PEFS_CERTIFICATE_BLOB;

    typedef struct _EFS_HASH_BLOB
    {
        DWORD cbData;

        PBYTE pbData;

    } EFS_HASH_BLOB, *PEFS_HASH_BLOB;

    typedef struct _EFS_RPC_BLOB
    {
        DWORD cbData;

        PBYTE pbData;

    } EFS_RPC_BLOB, *PEFS_RPC_BLOB;

    typedef struct _EFS_PIN_BLOB
    {
        DWORD cbPadding;

        DWORD cbData;

        PBYTE pbData;

    } EFS_PIN_BLOB, *PEFS_PIN_BLOB;

    typedef struct _EFS_KEY_INFO
    {
        DWORD dwVersion;
        ULONG Entropy;
        ALG_ID Algorithm;
        ULONG KeyLength;

    } EFS_KEY_INFO, *PEFS_KEY_INFO;

    typedef struct _EFS_COMPATIBILITY_INFO
    {
        DWORD EfsVersion;

    } EFS_COMPATIBILITY_INFO, *PEFS_COMPATIBILITY_INFO;

    typedef struct _EFS_VERSION_INFO
    {
        DWORD EfsVersion;
        DWORD SubVersion;
    } EFS_VERSION_INFO, *PEFS_VERSION_INFO;

    typedef struct _EFS_DECRYPTION_STATUS_INFO
    {
        DWORD dwDecryptionError;
        DWORD dwHashOffset;
        DWORD cbHash;

    } EFS_DECRYPTION_STATUS_INFO, *PEFS_DECRYPTION_STATUS_INFO;

    typedef struct _EFS_ENCRYPTION_STATUS_INFO
    {
        BOOL bHasCurrentKey;
        DWORD dwEncryptionError;

    } EFS_ENCRYPTION_STATUS_INFO, *PEFS_ENCRYPTION_STATUS_INFO;

    typedef struct _ENCRYPTION_CERTIFICATE
    {
        DWORD cbTotalLength;
        SID* pUserSid;
        PEFS_CERTIFICATE_BLOB pCertBlob;
    } ENCRYPTION_CERTIFICATE, *PENCRYPTION_CERTIFICATE;

    typedef struct _ENCRYPTION_CERTIFICATE_HASH
    {
        DWORD cbTotalLength;
        SID* pUserSid;
        PEFS_HASH_BLOB pHash;

        LPWSTR lpDisplayInformation;

    } ENCRYPTION_CERTIFICATE_HASH, *PENCRYPTION_CERTIFICATE_HASH;

    typedef struct _ENCRYPTION_CERTIFICATE_HASH_LIST
    {
        DWORD nCert_Hash;

        PENCRYPTION_CERTIFICATE_HASH* pUsers;
    } ENCRYPTION_CERTIFICATE_HASH_LIST, *PENCRYPTION_CERTIFICATE_HASH_LIST;

    typedef struct _ENCRYPTION_CERTIFICATE_LIST
    {
        DWORD nUsers;

        PENCRYPTION_CERTIFICATE* pUsers;
    } ENCRYPTION_CERTIFICATE_LIST, *PENCRYPTION_CERTIFICATE_LIST;

    typedef struct _ENCRYPTED_FILE_METADATA_SIGNATURE
    {
        DWORD dwEfsAccessType;
        PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded;
        PENCRYPTION_CERTIFICATE pEncryptionCertificate;
        PEFS_RPC_BLOB pEfsStreamSignature;

    } ENCRYPTED_FILE_METADATA_SIGNATURE, *PENCRYPTED_FILE_METADATA_SIGNATURE;

    typedef struct _ENCRYPTION_PROTECTOR
    {
        DWORD cbTotalLength;
        SID* pUserSid;

        LPWSTR lpProtectorDescriptor;
    } ENCRYPTION_PROTECTOR, *PENCRYPTION_PROTECTOR;

    typedef struct _ENCRYPTION_PROTECTOR_LIST
    {
        DWORD nProtectors;

        PENCRYPTION_PROTECTOR* pProtectors;
    } ENCRYPTION_PROTECTOR_LIST, *PENCRYPTION_PROTECTOR_LIST;

    __declspec(dllimport) DWORD __stdcall QueryUsersOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST* pUsers);

    __declspec(dllimport) DWORD
    __stdcall QueryRecoveryAgentsOnEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST* pRecoveryAgents);

    __declspec(dllimport) DWORD
    __stdcall RemoveUsersFromEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_HASH_LIST pHashes);

    __declspec(dllimport) DWORD
    __stdcall AddUsersToEncryptedFile(LPCWSTR lpFileName, PENCRYPTION_CERTIFICATE_LIST pEncryptionCertificates);

    __declspec(dllimport) DWORD __stdcall SetUserFileEncryptionKey(PENCRYPTION_CERTIFICATE pEncryptionCertificate);

    __declspec(dllimport) DWORD
    __stdcall SetUserFileEncryptionKeyEx(PENCRYPTION_CERTIFICATE pEncryptionCertificate, DWORD dwCapabilities, DWORD dwFlags, LPVOID pvReserved);

    __declspec(dllimport) void __stdcall FreeEncryptionCertificateHashList(PENCRYPTION_CERTIFICATE_HASH_LIST pUsers);

    __declspec(dllimport) BOOL __stdcall EncryptionDisable(LPCWSTR DirPath, BOOL Disable);

    __declspec(dllimport) DWORD __stdcall DuplicateEncryptionInfoFile(LPCWSTR SrcFileName,
                                                                      LPCWSTR DstFileName,
                                                                      DWORD dwCreationDistribution,
                                                                      DWORD dwAttributes,
                                                                      const LPSECURITY_ATTRIBUTES lpSecurityAttributes);

    __declspec(deprecated) __declspec(dllimport) DWORD
    __stdcall GetEncryptedFileMetadata(LPCWSTR lpFileName, PDWORD pcbMetadata, PBYTE* ppbMetadata);

    __declspec(deprecated) __declspec(dllimport) DWORD
    __stdcall SetEncryptedFileMetadata(LPCWSTR lpFileName,
                                       PBYTE pbOldMetadata,
                                       PBYTE pbNewMetadata,
                                       PENCRYPTION_CERTIFICATE_HASH pOwnerHash,
                                       DWORD dwOperation,
                                       PENCRYPTION_CERTIFICATE_HASH_LIST pCertificatesAdded);

    __declspec(deprecated) __declspec(dllimport) void __stdcall FreeEncryptedFileMetadata(PBYTE pbMetadata);

#pragma endregion
}

#pragma warning(pop)

#pragma once

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4255)
#pragma warning(disable : 4668)
#pragma warning(disable : 4820)

#pragma once

#pragma warning(disable : 4103)

#pragma pack(push, 8)

#pragma once

extern "C"
{
#pragma region Desktop Family

    typedef struct
    {
        RPC_NS_HANDLE LookupContext;
        RPC_BINDING_HANDLE ProposedHandle;
        RPC_BINDING_VECTOR* Bindings;

    } RPC_IMPORT_CONTEXT_P, *PRPC_IMPORT_CONTEXT_P;

    __declspec(dllimport) RPC_STATUS __stdcall I_RpcNsGetBuffer(PRPC_MESSAGE Message);

    __declspec(dllimport) RPC_STATUS __stdcall I_RpcNsSendReceive(PRPC_MESSAGE Message, RPC_BINDING_HANDLE* Handle);

    __declspec(dllimport)

    void __stdcall I_RpcNsRaiseException(PRPC_MESSAGE Message, RPC_STATUS Status);

    __declspec(dllimport) RPC_STATUS __stdcall I_RpcReBindBuffer(PRPC_MESSAGE Message);

    __declspec(dllimport) RPC_STATUS __stdcall I_NsServerBindSearch(void);

    __declspec(dllimport) RPC_STATUS __stdcall I_NsClientBindSearch(void);

    __declspec(dllimport) void __stdcall I_NsClientBindDone(void);

#pragma endregion
}

#pragma once

extern "C"
{
}

extern "C"
{
#pragma region Application Family or OneCore Family

    typedef unsigned char byte;
    typedef byte cs_byte;
    typedef unsigned char boolean;

    void* __stdcall MIDL_user_allocate(size_t size);
    void __stdcall MIDL_user_free(void*);

    void* __stdcall I_RpcDefaultAllocate(handle_t bh, size_t size, void* (*RealAlloc)(size_t));

    void __stdcall I_RpcDefaultFree(handle_t bh, void*, void (*RealFree)(void*));

    typedef void* NDR_CCONTEXT;

    typedef struct
    {
        void* pad[2];
        void* userContext;
    } * NDR_SCONTEXT;

    typedef void(__stdcall* NDR_RUNDOWN)(void* context);

    typedef void(__stdcall* NDR_NOTIFY_ROUTINE)(void);

    typedef void(__stdcall* NDR_NOTIFY2_ROUTINE)(boolean flag);

    typedef struct _SCONTEXT_QUEUE
    {
        unsigned long NumberOfObjects;
        NDR_SCONTEXT* ArrayOfObjects;
    } SCONTEXT_QUEUE, *PSCONTEXT_QUEUE;

    __declspec(dllimport) RPC_BINDING_HANDLE __stdcall NDRCContextBinding(NDR_CCONTEXT CContext);

    __declspec(dllimport) void __stdcall NDRCContextMarshall(NDR_CCONTEXT CContext, void* pBuff);

    __declspec(dllimport) void __stdcall NDRCContextUnmarshall(NDR_CCONTEXT* pCContext,
                                                               RPC_BINDING_HANDLE hBinding,
                                                               void* pBuff,
                                                               unsigned long DataRepresentation);

    __declspec(dllimport) void __stdcall NDRCContextUnmarshall2(NDR_CCONTEXT* pCContext,
                                                                RPC_BINDING_HANDLE hBinding,
                                                                void* pBuff,
                                                                unsigned long DataRepresentation);

    __declspec(dllimport) void __stdcall NDRSContextMarshall(NDR_SCONTEXT CContext, void* pBuff, NDR_RUNDOWN userRunDownIn);

    __declspec(dllimport) NDR_SCONTEXT __stdcall NDRSContextUnmarshall(void* pBuff, unsigned long DataRepresentation);

    __declspec(dllimport) void __stdcall NDRSContextMarshallEx(RPC_BINDING_HANDLE BindingHandle,
                                                               NDR_SCONTEXT CContext,
                                                               void* pBuff,
                                                               NDR_RUNDOWN userRunDownIn);

    __declspec(dllimport) void __stdcall NDRSContextMarshall2(RPC_BINDING_HANDLE BindingHandle,
                                                              NDR_SCONTEXT CContext,
                                                              void* pBuff,
                                                              NDR_RUNDOWN userRunDownIn,
                                                              void* CtxGuard,
                                                              unsigned long Flags);

    __declspec(dllimport) NDR_SCONTEXT
    __stdcall NDRSContextUnmarshallEx(RPC_BINDING_HANDLE BindingHandle, void* pBuff, unsigned long DataRepresentation);

    __declspec(dllimport) NDR_SCONTEXT __stdcall NDRSContextUnmarshall2(
    RPC_BINDING_HANDLE BindingHandle, void* pBuff, unsigned long DataRepresentation, void* CtxGuard, unsigned long Flags);

    __declspec(dllimport) void __stdcall RpcSsDestroyClientContext(void** ContextHandle);

    typedef unsigned long error_status_t;

    struct _MIDL_STUB_MESSAGE;
    struct _MIDL_STUB_DESC;
    struct _FULL_PTR_XLAT_TABLES;

    typedef unsigned char* RPC_BUFPTR;
    typedef unsigned long RPC_LENGTH;

    typedef void(__stdcall* EXPR_EVAL)(struct _MIDL_STUB_MESSAGE*);

    typedef const unsigned char* PFORMAT_STRING;

    typedef struct
    {
        long Dimension;

        unsigned long* BufferConformanceMark;
        unsigned long* BufferVarianceMark;

        unsigned long* MaxCountArray;
        unsigned long* OffsetArray;
        unsigned long* ActualCountArray;
    } ARRAY_INFO, *PARRAY_INFO;

    typedef struct _NDR_ASYNC_MESSAGE* PNDR_ASYNC_MESSAGE;
    typedef struct _NDR_CORRELATION_INFO* PNDR_CORRELATION_INFO;

    typedef const unsigned char* PFORMAT_STRING;
    typedef struct _MIDL_SYNTAX_INFO MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

    struct NDR_ALLOC_ALL_NODES_CONTEXT;
    struct NDR_POINTER_QUEUE_STATE;
    struct _NDR_PROC_CONTEXT;

    typedef struct _MIDL_STUB_MESSAGE
    {
        PRPC_MESSAGE RpcMsg;

        unsigned char* Buffer;

        unsigned char* BufferStart;
        unsigned char* BufferEnd;

        unsigned char* BufferMark;

        unsigned long BufferLength;

        unsigned long MemorySize;

        unsigned char* Memory;

        unsigned char IsClient;
        unsigned char Pad;
        unsigned short uFlags2;

        int ReuseBuffer;

        struct NDR_ALLOC_ALL_NODES_CONTEXT* pAllocAllNodesContext;
        struct NDR_POINTER_QUEUE_STATE* pPointerQueueState;

        int IgnoreEmbeddedPointers;

        unsigned char* PointerBufferMark;

        unsigned char CorrDespIncrement;

        unsigned char uFlags;
        unsigned short UniquePtrCount;

        ULONG_PTR MaxCount;

        unsigned long Offset;

        unsigned long ActualCount;

        void*(__stdcall* pfnAllocate)(size_t);
        void(__stdcall* pfnFree)(void*);

        unsigned char* StackTop;

        unsigned char* pPresentedType;
        unsigned char* pTransmitType;

        handle_t SavedHandle;

        const struct _MIDL_STUB_DESC* StubDesc;

        struct _FULL_PTR_XLAT_TABLES* FullPtrXlatTables;
        unsigned long FullPtrRefId;

        unsigned long PointerLength;

        int fInDontFree : 1;
        int fDontCallFreeInst : 1;
        int fUnused1 : 1;
        int fHasReturn : 1;
        int fHasExtensions : 1;
        int fHasNewCorrDesc : 1;
        int fIsIn : 1;
        int fIsOut : 1;
        int fIsOicf : 1;
        int fBufferValid : 1;
        int fHasMemoryValidateCallback : 1;
        int fInFree : 1;
        int fNeedMCCP : 1;
        int fUnused2 : 3;
        int fUnused3 : 16;

        unsigned long dwDestContext;
        void* pvDestContext;

        NDR_SCONTEXT* SavedContextHandles;

        long ParamNumber;

        struct IRpcChannelBuffer* pRpcChannelBuffer;

        PARRAY_INFO pArrayInfo;
        unsigned long* SizePtrCountArray;
        unsigned long* SizePtrOffsetArray;
        unsigned long* SizePtrLengthArray;

        void* pArgQueue;

        unsigned long dwStubPhase;

        void* LowStackMark;

        PNDR_ASYNC_MESSAGE pAsyncMsg;
        PNDR_CORRELATION_INFO pCorrInfo;
        unsigned char* pCorrMemory;

        void* pMemoryList;

        INT_PTR pCSInfo;

        unsigned char* ConformanceMark;
        unsigned char* VarianceMark;

        INT_PTR Unused;

        struct _NDR_PROC_CONTEXT* pContext;

        void* ContextHandleHash;
        void* pUserMarshalList;
        INT_PTR Reserved51_3;
        INT_PTR Reserved51_4;
        INT_PTR Reserved51_5;

    } MIDL_STUB_MESSAGE, *PMIDL_STUB_MESSAGE;

    typedef struct _MIDL_STUB_MESSAGE MIDL_STUB_MESSAGE, *PMIDL_STUB_MESSAGE;

    typedef void*(__stdcall* GENERIC_BINDING_ROUTINE)(void*);
    typedef void(__stdcall* GENERIC_UNBIND_ROUTINE)(void*, unsigned char*);

    typedef struct _GENERIC_BINDING_ROUTINE_PAIR
    {
        GENERIC_BINDING_ROUTINE pfnBind;
        GENERIC_UNBIND_ROUTINE pfnUnbind;
    } GENERIC_BINDING_ROUTINE_PAIR, *PGENERIC_BINDING_ROUTINE_PAIR;

    typedef struct __GENERIC_BINDING_INFO
    {
        void* pObj;
        unsigned int Size;
        GENERIC_BINDING_ROUTINE pfnBind;
        GENERIC_UNBIND_ROUTINE pfnUnbind;
    } GENERIC_BINDING_INFO, *PGENERIC_BINDING_INFO;

    typedef void(__stdcall* XMIT_HELPER_ROUTINE)(PMIDL_STUB_MESSAGE);

    typedef struct _XMIT_ROUTINE_QUINTUPLE
    {
        XMIT_HELPER_ROUTINE pfnTranslateToXmit;
        XMIT_HELPER_ROUTINE pfnTranslateFromXmit;
        XMIT_HELPER_ROUTINE pfnFreeXmit;
        XMIT_HELPER_ROUTINE pfnFreeInst;
    } XMIT_ROUTINE_QUINTUPLE, *PXMIT_ROUTINE_QUINTUPLE;

    typedef unsigned long(__stdcall* USER_MARSHAL_SIZING_ROUTINE)(unsigned long*, unsigned long, void*);

    typedef unsigned char*(__stdcall* USER_MARSHAL_MARSHALLING_ROUTINE)(unsigned long*, unsigned char*, void*);

    typedef unsigned char*(__stdcall* USER_MARSHAL_UNMARSHALLING_ROUTINE)(unsigned long*, unsigned char*, void*);

    typedef void(__stdcall* USER_MARSHAL_FREEING_ROUTINE)(unsigned long*, void*);

    typedef struct _USER_MARSHAL_ROUTINE_QUADRUPLE
    {
        USER_MARSHAL_SIZING_ROUTINE pfnBufferSize;
        USER_MARSHAL_MARSHALLING_ROUTINE pfnMarshall;
        USER_MARSHAL_UNMARSHALLING_ROUTINE pfnUnmarshall;
        USER_MARSHAL_FREEING_ROUTINE pfnFree;
    } USER_MARSHAL_ROUTINE_QUADRUPLE;

    typedef enum _USER_MARSHAL_CB_TYPE
    {
        USER_MARSHAL_CB_BUFFER_SIZE,
        USER_MARSHAL_CB_MARSHALL,
        USER_MARSHAL_CB_UNMARSHALL,
        USER_MARSHAL_CB_FREE
    } USER_MARSHAL_CB_TYPE;

    typedef struct _USER_MARSHAL_CB
    {
        unsigned long Flags;
        PMIDL_STUB_MESSAGE pStubMsg;
        PFORMAT_STRING pReserve;
        unsigned long Signature;
        USER_MARSHAL_CB_TYPE CBType;
        PFORMAT_STRING pFormat;
        PFORMAT_STRING pTypeFormat;
    } USER_MARSHAL_CB;

    typedef struct _MALLOC_FREE_STRUCT
    {
        void*(__stdcall* pfnAllocate)(size_t);
        void(__stdcall* pfnFree)(void*);
    } MALLOC_FREE_STRUCT;

    typedef struct _COMM_FAULT_OFFSETS
    {
        short CommOffset;
        short FaultOffset;
    } COMM_FAULT_OFFSETS;

    typedef enum _IDL_CS_CONVERT
    {
        IDL_CS_NO_CONVERT,
        IDL_CS_IN_PLACE_CONVERT,
        IDL_CS_NEW_BUFFER_CONVERT
    } IDL_CS_CONVERT;

    typedef void(__stdcall* CS_TYPE_NET_SIZE_ROUTINE)(RPC_BINDING_HANDLE hBinding,
                                                      unsigned long ulNetworkCodeSet,
                                                      unsigned long ulLocalBufferSize,
                                                      IDL_CS_CONVERT* conversionType,
                                                      unsigned long* pulNetworkBufferSize,
                                                      error_status_t* pStatus);

    typedef void(__stdcall* CS_TYPE_LOCAL_SIZE_ROUTINE)(RPC_BINDING_HANDLE hBinding,
                                                        unsigned long ulNetworkCodeSet,
                                                        unsigned long ulNetworkBufferSize,
                                                        IDL_CS_CONVERT* conversionType,
                                                        unsigned long* pulLocalBufferSize,
                                                        error_status_t* pStatus);

    typedef void(__stdcall* CS_TYPE_TO_NETCS_ROUTINE)(RPC_BINDING_HANDLE hBinding,
                                                      unsigned long ulNetworkCodeSet,
                                                      void* pLocalData,
                                                      unsigned long ulLocalDataLength,
                                                      byte* pNetworkData,
                                                      unsigned long* pulNetworkDataLength,
                                                      error_status_t* pStatus);

    typedef void(__stdcall* CS_TYPE_FROM_NETCS_ROUTINE)(RPC_BINDING_HANDLE hBinding,
                                                        unsigned long ulNetworkCodeSet,
                                                        byte* pNetworkData,
                                                        unsigned long ulNetworkDataLength,
                                                        unsigned long ulLocalBufferSize,
                                                        void* pLocalData,
                                                        unsigned long* pulLocalDataLength,
                                                        error_status_t* pStatus);

    typedef void(__stdcall* CS_TAG_GETTING_ROUTINE)(RPC_BINDING_HANDLE hBinding,
                                                    int fServerSide,
                                                    unsigned long* pulSendingTag,
                                                    unsigned long* pulDesiredReceivingTag,
                                                    unsigned long* pulReceivingTag,
                                                    error_status_t* pStatus);

    void __stdcall RpcCsGetTags(RPC_BINDING_HANDLE hBinding,
                                int fServerSide,
                                unsigned long* pulSendingTag,
                                unsigned long* pulDesiredReceivingTag,
                                unsigned long* pulReceivingTag,
                                error_status_t* pStatus);

    typedef struct _NDR_CS_SIZE_CONVERT_ROUTINES
    {
        CS_TYPE_NET_SIZE_ROUTINE pfnNetSize;
        CS_TYPE_TO_NETCS_ROUTINE pfnToNetCs;
        CS_TYPE_LOCAL_SIZE_ROUTINE pfnLocalSize;
        CS_TYPE_FROM_NETCS_ROUTINE pfnFromNetCs;
    } NDR_CS_SIZE_CONVERT_ROUTINES;

    typedef struct _NDR_CS_ROUTINES
    {
        NDR_CS_SIZE_CONVERT_ROUTINES* pSizeConvertRoutines;
        CS_TAG_GETTING_ROUTINE* pTagGettingRoutines;
    } NDR_CS_ROUTINES;

    typedef struct _NDR_EXPR_DESC
    {
        const unsigned short* pOffset;
        PFORMAT_STRING pFormatExpr;
    } NDR_EXPR_DESC;

    typedef struct _MIDL_STUB_DESC
    {
        void* RpcInterfaceInformation;

        void*(__stdcall* pfnAllocate)(size_t);
        void(__stdcall* pfnFree)(void*);

        union
        {
            handle_t* pAutoHandle;
            handle_t* pPrimitiveHandle;
            PGENERIC_BINDING_INFO pGenericBindingInfo;
        } IMPLICIT_HANDLE_INFO;

        const NDR_RUNDOWN* apfnNdrRundownRoutines;
        const GENERIC_BINDING_ROUTINE_PAIR* aGenericBindingRoutinePairs;
        const EXPR_EVAL* apfnExprEval;
        const XMIT_ROUTINE_QUINTUPLE* aXmitQuintuple;

        const unsigned char* pFormatTypes;

        int fCheckBounds;

        unsigned long Version;

        MALLOC_FREE_STRUCT* pMallocFreeStruct;

        long MIDLVersion;

        const COMM_FAULT_OFFSETS* CommFaultOffsets;

        const USER_MARSHAL_ROUTINE_QUADRUPLE* aUserMarshalQuadruple;

        const NDR_NOTIFY_ROUTINE* NotifyRoutineTable;

        ULONG_PTR mFlags;

        const NDR_CS_ROUTINES* CsRoutineTables;

        void* ProxyServerInfo;
        const NDR_EXPR_DESC* pExprInfo;

    } MIDL_STUB_DESC;

    typedef const MIDL_STUB_DESC* PMIDL_STUB_DESC;

    typedef void* PMIDL_XMIT_TYPE;

#pragma warning(push)
#pragma warning(disable : 4200)
    typedef struct _MIDL_FORMAT_STRING
    {
        short Pad;
        unsigned char Format[];
    } MIDL_FORMAT_STRING;

#pragma warning(pop)

    typedef void(__stdcall* STUB_THUNK)(PMIDL_STUB_MESSAGE);

    typedef long(__stdcall* SERVER_ROUTINE)(void);

    typedef struct _MIDL_METHOD_PROPERTY
    {
        unsigned long Id;
        ULONG_PTR Value;
    } MIDL_METHOD_PROPERTY, *PMIDL_METHOD_PROPERTY;

    typedef struct _MIDL_METHOD_PROPERTY_MAP
    {
        unsigned long Count;
        const MIDL_METHOD_PROPERTY* Properties;
    } MIDL_METHOD_PROPERTY_MAP, *PMIDL_METHOD_PROPERTY_MAP;

    typedef struct _MIDL_INTERFACE_METHOD_PROPERTIES
    {
        unsigned short MethodCount;
        const MIDL_METHOD_PROPERTY_MAP* const* MethodProperties;
    } MIDL_INTERFACE_METHOD_PROPERTIES;

    typedef struct _MIDL_SERVER_INFO_
    {
        PMIDL_STUB_DESC pStubDesc;
        const SERVER_ROUTINE* DispatchTable;
        PFORMAT_STRING ProcString;
        const unsigned short* FmtStringOffset;
        const STUB_THUNK* ThunkTable;
        PRPC_SYNTAX_IDENTIFIER pTransferSyntax;
        ULONG_PTR nCount;
        PMIDL_SYNTAX_INFO pSyntaxInfo;
    } MIDL_SERVER_INFO, *PMIDL_SERVER_INFO;

    typedef struct _MIDL_STUBLESS_PROXY_INFO
    {
        PMIDL_STUB_DESC pStubDesc;
        PFORMAT_STRING ProcFormatString;
        const unsigned short* FormatStringOffset;
        PRPC_SYNTAX_IDENTIFIER pTransferSyntax;
        ULONG_PTR nCount;
        PMIDL_SYNTAX_INFO pSyntaxInfo;
    } MIDL_STUBLESS_PROXY_INFO;

    typedef MIDL_STUBLESS_PROXY_INFO* PMIDL_STUBLESS_PROXY_INFO;

    typedef struct _MIDL_SYNTAX_INFO
    {
        RPC_SYNTAX_IDENTIFIER TransferSyntax;
        RPC_DISPATCH_TABLE* DispatchTable;
        PFORMAT_STRING ProcString;
        const unsigned short* FmtStringOffset;
        PFORMAT_STRING TypeString;
        const void* aUserMarshalQuadruple;
        const MIDL_INTERFACE_METHOD_PROPERTIES* pMethodProperties;
        ULONG_PTR pReserved2;
    } MIDL_SYNTAX_INFO, *PMIDL_SYNTAX_INFO;

    typedef unsigned short *PARAM_OFFSETTABLE, *PPARAM_OFFSETTABLE;

    typedef union _CLIENT_CALL_RETURN
    {
        void* Pointer;
        LONG_PTR Simple;
    } CLIENT_CALL_RETURN;

    typedef enum
    {
        XLAT_SERVER = 1,
        XLAT_CLIENT
    } XLAT_SIDE;

    typedef struct _FULL_PTR_XLAT_TABLES
    {
        void* RefIdToPointer;
        void* PointerToRefId;
        unsigned long NextRefId;
        XLAT_SIDE XlatSide;
    } FULL_PTR_XLAT_TABLES, *PFULL_PTR_XLAT_TABLES;

    typedef enum _system_handle_t
    {
        SYSTEM_HANDLE_FILE = 0,
        SYSTEM_HANDLE_SEMAPHORE = 1,
        SYSTEM_HANDLE_EVENT = 2,
        SYSTEM_HANDLE_MUTEX = 3,
        SYSTEM_HANDLE_PROCESS = 4,
        SYSTEM_HANDLE_TOKEN = 5,
        SYSTEM_HANDLE_SECTION = 6,
        SYSTEM_HANDLE_REG_KEY = 7,
        SYSTEM_HANDLE_THREAD = 8,
        SYSTEM_HANDLE_COMPOSITION_OBJECT = 9,
        SYSTEM_HANDLE_SOCKET = 10,
        SYSTEM_HANDLE_JOB = 11,
        SYSTEM_HANDLE_PIPE = 12,
        SYSTEM_HANDLE_MAX = 12,
        SYSTEM_HANDLE_INVALID = 0xFF,
    } system_handle_t;

    enum
    {
        MidlInterceptionInfoVersionOne = 1
    };

    enum
    {
        MidlWinrtTypeSerializationInfoVersionOne = 1
    };

    typedef struct _MIDL_INTERCEPTION_INFO
    {
        unsigned long Version;
        PFORMAT_STRING ProcString;
        const unsigned short* ProcFormatOffsetTable;
        unsigned long ProcCount;
        PFORMAT_STRING TypeString;
    } MIDL_INTERCEPTION_INFO, *PMIDL_INTERCEPTION_INFO;

    typedef struct _MIDL_WINRT_TYPE_SERIALIZATION_INFO
    {
        unsigned long Version;
        PFORMAT_STRING TypeFormatString;
        unsigned short FormatStringSize;
        unsigned short TypeOffset;
        PMIDL_STUB_DESC StubDesc;
    } MIDL_WINRT_TYPE_SERIALIZATION_INFO, *PMIDL_WINRT_TYPE_SERIALIZATION_INFO;

    RPC_STATUS __stdcall NdrClientGetSupportedSyntaxes(RPC_CLIENT_INTERFACE* pInf, unsigned long* pCount, MIDL_SYNTAX_INFO** pArr);

    RPC_STATUS __stdcall NdrServerGetSupportedSyntaxes(RPC_SERVER_INTERFACE* pInf,
                                                       unsigned long* pCount,
                                                       MIDL_SYNTAX_INFO** pArr,
                                                       unsigned long* pPreferSyntaxIndex);

#pragma warning(push)

#pragma warning(disable : 28740)

    __declspec(dllimport) void __stdcall NdrSimpleTypeMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, unsigned char FormatChar);

    __declspec(dllimport) unsigned char* __stdcall NdrPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                      unsigned char* pMemory,
                                                                      PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrCsArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                      unsigned char* pMemory,
                                                                      PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrCsTagMarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrSimpleStructMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                           unsigned char* pMemory,
                                                                           PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantStructMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                               unsigned char* pMemory,
                                                                               PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantVaryingStructMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                      unsigned char* pMemory,
                                                                                      PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrComplexStructMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                            unsigned char* pMemory,
                                                                            PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrFixedArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                         unsigned char* pMemory,
                                                                         PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                              unsigned char* pMemory,
                                                                              PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                     unsigned char* pMemory,
                                                                                     PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrVaryingArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                           unsigned char* pMemory,
                                                                           PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrComplexArrayMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                           unsigned char* pMemory,
                                                                           PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrNonConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                  unsigned char* pMemory,
                                                                                  PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantStringMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                               unsigned char* pMemory,
                                                                               PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                unsigned char* pMemory,
                                                                                PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrNonEncapsulatedUnionMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                   unsigned char* pMemory,
                                                                                   PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrByteCountPointerMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                               unsigned char* pMemory,
                                                                               PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrXmitOrRepAsMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                          unsigned char* pMemory,
                                                                          PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrUserMarshalMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                          unsigned char* pMemory,
                                                                          PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrInterfacePointerMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                               unsigned char* pMemory,
                                                                               PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrClientContextMarshall(PMIDL_STUB_MESSAGE pStubMsg, NDR_CCONTEXT ContextHandle, int fCheck);

    __declspec(dllimport) void __stdcall NdrServerContextMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                  NDR_SCONTEXT ContextHandle,
                                                                  NDR_RUNDOWN RundownRoutine);

    __declspec(dllimport) void __stdcall NdrServerContextNewMarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                     NDR_SCONTEXT ContextHandle,
                                                                     NDR_RUNDOWN RundownRoutine,
                                                                     PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrSimpleTypeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, unsigned char FormatChar);

    __declspec(dllimport) unsigned char* __stdcall NdrCsArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                        unsigned char** ppMemory,
                                                                        PFORMAT_STRING pFormat,
                                                                        unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrCsTagUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                      unsigned char** ppMemory,
                                                                      PFORMAT_STRING pFormat,
                                                                      unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrRangeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                      unsigned char** ppMemory,
                                                                      PFORMAT_STRING pFormat,
                                                                      unsigned char fMustAlloc);

    __declspec(dllimport) void __stdcall NdrCorrelationInitialize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                  void* pMemory,
                                                                  unsigned long CacheSize,
                                                                  unsigned long flags);

    __declspec(dllimport) void __stdcall NdrCorrelationPass(PMIDL_STUB_MESSAGE pStubMsg);

    __declspec(dllimport) void __stdcall NdrCorrelationFree(PMIDL_STUB_MESSAGE pStubMsg);

    __declspec(dllimport) unsigned char* __stdcall NdrPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                        unsigned char** ppMemory,
                                                                        PFORMAT_STRING pFormat,
                                                                        unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrSimpleStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                             unsigned char** ppMemory,
                                                                             PFORMAT_STRING pFormat,
                                                                             unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                 unsigned char** ppMemory,
                                                                                 PFORMAT_STRING pFormat,
                                                                                 unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantVaryingStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                        unsigned char** ppMemory,
                                                                                        PFORMAT_STRING pFormat,
                                                                                        unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrComplexStructUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                              unsigned char** ppMemory,
                                                                              PFORMAT_STRING pFormat,
                                                                              unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrFixedArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                           unsigned char** ppMemory,
                                                                           PFORMAT_STRING pFormat,
                                                                           unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                unsigned char** ppMemory,
                                                                                PFORMAT_STRING pFormat,
                                                                                unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                       unsigned char** ppMemory,
                                                                                       PFORMAT_STRING pFormat,
                                                                                       unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrVaryingArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                             unsigned char** ppMemory,
                                                                             PFORMAT_STRING pFormat,
                                                                             unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrComplexArrayUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                             unsigned char** ppMemory,
                                                                             PFORMAT_STRING pFormat,
                                                                             unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrNonConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                    unsigned char** ppMemory,
                                                                                    PFORMAT_STRING pFormat,
                                                                                    unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrConformantStringUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                 unsigned char** ppMemory,
                                                                                 PFORMAT_STRING pFormat,
                                                                                 unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                  unsigned char** ppMemory,
                                                                                  PFORMAT_STRING pFormat,
                                                                                  unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrNonEncapsulatedUnionUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                     unsigned char** ppMemory,
                                                                                     PFORMAT_STRING pFormat,
                                                                                     unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrByteCountPointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                 unsigned char** ppMemory,
                                                                                 PFORMAT_STRING pFormat,
                                                                                 unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrXmitOrRepAsUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                            unsigned char** ppMemory,
                                                                            PFORMAT_STRING pFormat,
                                                                            unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrUserMarshalUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                            unsigned char** ppMemory,
                                                                            PFORMAT_STRING pFormat,
                                                                            unsigned char fMustAlloc);

    __declspec(dllimport) unsigned char* __stdcall NdrInterfacePointerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                 unsigned char** ppMemory,
                                                                                 PFORMAT_STRING pFormat,
                                                                                 unsigned char fMustAlloc);

    __declspec(dllimport) void __stdcall NdrClientContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                    NDR_CCONTEXT* pContextHandle,
                                                                    RPC_BINDING_HANDLE BindHandle);

    __declspec(dllimport) NDR_SCONTEXT __stdcall NdrServerContextUnmarshall(PMIDL_STUB_MESSAGE pStubMsg);

    __declspec(dllimport) NDR_SCONTEXT __stdcall NdrContextHandleInitialize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) NDR_SCONTEXT __stdcall NdrServerContextNewUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrCsArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrCsTagBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrSimpleStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConformantStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                       unsigned char* pMemory,
                                                                       PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConformantVaryingStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                              unsigned char* pMemory,
                                                                              PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrComplexStructBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrFixedArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConformantArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                      unsigned char* pMemory,
                                                                      PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConformantVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                             unsigned char* pMemory,
                                                                             PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrVaryingArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrComplexArrayBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                       unsigned char* pMemory,
                                                                       PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrNonConformantStringBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                          unsigned char* pMemory,
                                                                          PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                        unsigned char* pMemory,
                                                                        PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrNonEncapsulatedUnionBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                           unsigned char* pMemory,
                                                                           PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrByteCountPointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                       unsigned char* pMemory,
                                                                       PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrXmitOrRepAsBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrUserMarshalBufferSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrInterfacePointerBufferSize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                       unsigned char* pMemory,
                                                                       PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrContextHandleSize(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrPointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrContextHandleMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrCsArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrCsTagMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrSimpleStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrConformantStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrConformantVaryingStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                       PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrComplexStructMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrFixedArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrConformantArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrConformantVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                      PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrVaryingArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrComplexArrayMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrNonConformantStringMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrNonEncapsulatedUnionMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrXmitOrRepAsMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrUserMarshalMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned long __stdcall NdrInterfacePointerMemorySize(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrCsArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrSimpleStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConformantStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConformantVaryingStructFree(PMIDL_STUB_MESSAGE pStubMsg,
                                                                        unsigned char* pMemory,
                                                                        PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrComplexStructFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrFixedArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConformantArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConformantVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg,
                                                                       unsigned char* pMemory,
                                                                       PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrVaryingArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrComplexArrayFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrNonEncapsulatedUnionFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrByteCountPointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrXmitOrRepAsFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrUserMarshalFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrInterfacePointerFree(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pMemory, PFORMAT_STRING pFormat);

    __declspec(dllimport) void __stdcall NdrConvert2(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, long NumberParams);

    __declspec(dllimport) void __stdcall NdrConvert(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) unsigned char* __stdcall NdrUserMarshalSimpleTypeConvert(unsigned long* pFlags,
                                                                                   unsigned char* pBuffer,
                                                                                   unsigned char FormatChar);

    __declspec(dllimport) void __stdcall NdrClientInitializeNew(PRPC_MESSAGE pRpcMsg,
                                                                PMIDL_STUB_MESSAGE pStubMsg,
                                                                PMIDL_STUB_DESC pStubDescriptor,
                                                                unsigned int ProcNum);

    __declspec(dllimport) unsigned char* __stdcall NdrServerInitializeNew(PRPC_MESSAGE pRpcMsg,
                                                                          PMIDL_STUB_MESSAGE pStubMsg,
                                                                          PMIDL_STUB_DESC pStubDescriptor);

    __declspec(dllimport) void __stdcall NdrServerInitializePartial(PRPC_MESSAGE pRpcMsg,
                                                                    PMIDL_STUB_MESSAGE pStubMsg,
                                                                    PMIDL_STUB_DESC pStubDescriptor,
                                                                    unsigned long RequestedBufferSize);

    __declspec(dllimport) void __stdcall NdrClientInitialize(PRPC_MESSAGE pRpcMsg,
                                                             PMIDL_STUB_MESSAGE pStubMsg,
                                                             PMIDL_STUB_DESC pStubDescriptor,
                                                             unsigned int ProcNum);

    __declspec(dllimport) unsigned char* __stdcall NdrServerInitialize(PRPC_MESSAGE pRpcMsg,
                                                                       PMIDL_STUB_MESSAGE pStubMsg,
                                                                       PMIDL_STUB_DESC pStubDescriptor);

    __declspec(dllimport) unsigned char* __stdcall NdrServerInitializeUnmarshall(PMIDL_STUB_MESSAGE pStubMsg,
                                                                                 PMIDL_STUB_DESC pStubDescriptor,
                                                                                 PRPC_MESSAGE pRpcMsg);

    __declspec(dllimport) void __stdcall NdrServerInitializeMarshall(PRPC_MESSAGE pRpcMsg, PMIDL_STUB_MESSAGE pStubMsg);

    __declspec(dllimport) unsigned char* __stdcall NdrGetBuffer(PMIDL_STUB_MESSAGE pStubMsg,
                                                                unsigned long BufferLength,
                                                                RPC_BINDING_HANDLE Handle);

    __declspec(dllimport) unsigned char* __stdcall NdrNsGetBuffer(PMIDL_STUB_MESSAGE pStubMsg,
                                                                  unsigned long BufferLength,
                                                                  RPC_BINDING_HANDLE Handle);

    __declspec(dllimport) unsigned char* __stdcall NdrSendReceive(PMIDL_STUB_MESSAGE pStubMsg, unsigned char* pBufferEnd);

    __declspec(dllimport) unsigned char* __stdcall NdrNsSendReceive(PMIDL_STUB_MESSAGE pStubMsg,
                                                                    unsigned char* pBufferEnd,
                                                                    RPC_BINDING_HANDLE* pAutoHandle);

    __declspec(dllimport) void __stdcall NdrFreeBuffer(PMIDL_STUB_MESSAGE pStubMsg);

    __declspec(dllimport) HRESULT __stdcall NdrGetDcomProtocolVersion(PMIDL_STUB_MESSAGE pStubMsg, RPC_VERSION* pVersion);

#pragma warning(pop)

    CLIENT_CALL_RETURN __cdecl NdrClientCall2(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...);

    CLIENT_CALL_RETURN __cdecl NdrClientCall(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...);

    CLIENT_CALL_RETURN __cdecl NdrAsyncClientCall(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    CLIENT_CALL_RETURN __cdecl NdrDcomAsyncClientCall(PMIDL_STUB_DESC pStubDescriptor, PFORMAT_STRING pFormat, ...);

#pragma endregion

#pragma region Application Family or OneCore Family

    typedef enum
    {
        STUB_UNMARSHAL,
        STUB_CALL_SERVER,
        STUB_MARSHAL,
        STUB_CALL_SERVER_NO_HRESULT
    } STUB_PHASE;

    typedef enum
    {
        PROXY_CALCSIZE,
        PROXY_GETBUFFER,
        PROXY_MARSHAL,
        PROXY_SENDRECEIVE,
        PROXY_UNMARSHAL
    } PROXY_PHASE;

    struct IRpcStubBuffer;

    __declspec(dllimport) void __stdcall NdrAsyncServerCall(PRPC_MESSAGE pRpcMsg);

    __declspec(dllimport) long __stdcall NdrAsyncStubCall(struct IRpcStubBuffer* pThis,
                                                          struct IRpcChannelBuffer* pChannel,
                                                          PRPC_MESSAGE pRpcMsg,
                                                          unsigned long* pdwStubPhase);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) long __stdcall NdrDcomAsyncStubCall(struct IRpcStubBuffer* pThis,
                                                              struct IRpcChannelBuffer* pChannel,
                                                              PRPC_MESSAGE pRpcMsg,
                                                              unsigned long* pdwStubPhase);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) long __stdcall NdrStubCall2(void* pThis, void* pChannel, PRPC_MESSAGE pRpcMsg, unsigned long* pdwStubPhase);

    __declspec(dllimport) void __stdcall NdrServerCall2(PRPC_MESSAGE pRpcMsg);

    __declspec(dllimport) long __stdcall NdrStubCall(void* pThis, void* pChannel, PRPC_MESSAGE pRpcMsg, unsigned long* pdwStubPhase);

    __declspec(dllimport) void __stdcall NdrServerCall(PRPC_MESSAGE pRpcMsg);

    __declspec(dllimport) int __stdcall NdrServerUnmarshall(void* pChannel,
                                                            PRPC_MESSAGE pRpcMsg,
                                                            PMIDL_STUB_MESSAGE pStubMsg,
                                                            PMIDL_STUB_DESC pStubDescriptor,
                                                            PFORMAT_STRING pFormat,
                                                            void* pParamList);

    __declspec(dllimport) void __stdcall NdrServerMarshall(void* pThis, void* pChannel, PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat);

    __declspec(dllimport) RPC_STATUS
    __stdcall NdrMapCommAndFaultStatus(PMIDL_STUB_MESSAGE pStubMsg, unsigned long* pCommStatus, unsigned long* pFaultStatus, RPC_STATUS Status);

    typedef void* RPC_SS_THREAD_HANDLE;

    typedef void* __stdcall RPC_CLIENT_ALLOC(size_t Size);

    typedef void __stdcall RPC_CLIENT_FREE(void* Ptr);

    __declspec(dllimport) void* __stdcall RpcSsAllocate(size_t Size);

    __declspec(dllimport) void __stdcall RpcSsDisableAllocate(void);

    __declspec(dllimport) void __stdcall RpcSsEnableAllocate(void);

    __declspec(dllimport) void __stdcall RpcSsFree(void* NodeToFree);

    __declspec(dllimport) RPC_SS_THREAD_HANDLE __stdcall RpcSsGetThreadHandle(void);

    __declspec(dllimport) void __stdcall RpcSsSetClientAllocFree(RPC_CLIENT_ALLOC* ClientAlloc, RPC_CLIENT_FREE* ClientFree);

    __declspec(dllimport) void __stdcall RpcSsSetThreadHandle(RPC_SS_THREAD_HANDLE Id);

    __declspec(dllimport) void __stdcall RpcSsSwapClientAllocFree(RPC_CLIENT_ALLOC* ClientAlloc,
                                                                  RPC_CLIENT_FREE* ClientFree,
                                                                  RPC_CLIENT_ALLOC** OldClientAlloc,
                                                                  RPC_CLIENT_FREE** OldClientFree);

    __declspec(dllimport) void* __stdcall RpcSmAllocate(size_t Size, RPC_STATUS* pStatus);

    __declspec(dllimport) RPC_STATUS __stdcall RpcSmClientFree(void* pNodeToFree);

    __declspec(dllimport) RPC_STATUS __stdcall RpcSmDestroyClientContext(void** ContextHandle);

    __declspec(dllimport) RPC_STATUS __stdcall RpcSmDisableAllocate(void);

    __declspec(dllimport) RPC_STATUS __stdcall RpcSmEnableAllocate(void);

    __declspec(dllimport) RPC_STATUS __stdcall RpcSmFree(void* NodeToFree);

    __declspec(dllimport) RPC_SS_THREAD_HANDLE __stdcall RpcSmGetThreadHandle(RPC_STATUS* pStatus);

    __declspec(dllimport) RPC_STATUS __stdcall RpcSmSetClientAllocFree(RPC_CLIENT_ALLOC* ClientAlloc, RPC_CLIENT_FREE* ClientFree);

    __declspec(dllimport) RPC_STATUS __stdcall RpcSmSetThreadHandle(RPC_SS_THREAD_HANDLE Id);

    __declspec(dllimport) RPC_STATUS __stdcall RpcSmSwapClientAllocFree(RPC_CLIENT_ALLOC* ClientAlloc,
                                                                        RPC_CLIENT_FREE* ClientFree,
                                                                        RPC_CLIENT_ALLOC** OldClientAlloc,
                                                                        RPC_CLIENT_FREE** OldClientFree);

    __declspec(dllimport) void __stdcall NdrRpcSsEnableAllocate(PMIDL_STUB_MESSAGE pMessage);

    __declspec(dllimport) void __stdcall NdrRpcSsDisableAllocate(PMIDL_STUB_MESSAGE pMessage);

    __declspec(dllimport) void __stdcall NdrRpcSmSetClientToOsf(PMIDL_STUB_MESSAGE pMessage);

    __declspec(dllimport) void* __stdcall NdrRpcSmClientAllocate(size_t Size);

    __declspec(dllimport) void __stdcall NdrRpcSmClientFree(void* NodeToFree);

    __declspec(dllimport) void* __stdcall NdrRpcSsDefaultAllocate(size_t Size);

    __declspec(dllimport) void __stdcall NdrRpcSsDefaultFree(void* NodeToFree);

    __declspec(dllimport) PFULL_PTR_XLAT_TABLES __stdcall NdrFullPointerXlatInit(unsigned long NumberOfPointers, XLAT_SIDE XlatSide);

    __declspec(dllimport) void __stdcall NdrFullPointerXlatFree(PFULL_PTR_XLAT_TABLES pXlatTables);

    __declspec(dllimport) void* __stdcall NdrAllocate(PMIDL_STUB_MESSAGE pStubMsg, size_t Len);

    __declspec(dllimport) void __stdcall NdrClearOutParameters(PMIDL_STUB_MESSAGE pStubMsg, PFORMAT_STRING pFormat, void* ArgAddr);

    __declspec(dllimport) void* __stdcall NdrOleAllocate(size_t Size);

    __declspec(dllimport) void __stdcall NdrOleFree(void* NodeToFree);

    typedef struct _NDR_USER_MARSHAL_INFO_LEVEL1
    {
        void* Buffer;
        unsigned long BufferSize;
        void*(__stdcall* pfnAllocate)(size_t);
        void(__stdcall* pfnFree)(void*);
        struct IRpcChannelBuffer* pRpcChannelBuffer;
        ULONG_PTR Reserved[5];
    } NDR_USER_MARSHAL_INFO_LEVEL1;

#pragma warning(push)
#pragma warning(disable : 4201)

    typedef struct _NDR_USER_MARSHAL_INFO
    {
        unsigned long InformationLevel;
        union
        {
            NDR_USER_MARSHAL_INFO_LEVEL1 Level1;
        };
    } NDR_USER_MARSHAL_INFO;

#pragma warning(pop)

    RPC_STATUS
    __stdcall NdrGetUserMarshalInfo(unsigned long* pFlags, unsigned long InformationLevel, NDR_USER_MARSHAL_INFO* pMarshalInfo);

    RPC_STATUS __stdcall NdrCreateServerInterfaceFromStub(struct IRpcStubBuffer* pStub, RPC_SERVER_INTERFACE* pServerIf);

    CLIENT_CALL_RETURN __cdecl NdrClientCall3(MIDL_STUBLESS_PROXY_INFO* pProxyInfo, unsigned long nProcNum, void* pReturnValue, ...);

    CLIENT_CALL_RETURN __cdecl Ndr64AsyncClientCall(MIDL_STUBLESS_PROXY_INFO* pProxyInfo, unsigned long nProcNum, void* pReturnValue, ...);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    CLIENT_CALL_RETURN __cdecl Ndr64DcomAsyncClientCall(MIDL_STUBLESS_PROXY_INFO* pProxyInfo, unsigned long nProcNum, void* pReturnValue, ...);

    __declspec(dllimport) void __stdcall Ndr64AsyncServerCall(PRPC_MESSAGE pRpcMsg);

#pragma endregion

#pragma region Application Family or OneCore Family

    struct IRpcStubBuffer;

    __declspec(dllimport) void __stdcall Ndr64AsyncServerCall64(PRPC_MESSAGE pRpcMsg);

    __declspec(dllimport) void __stdcall Ndr64AsyncServerCallAll(PRPC_MESSAGE pRpcMsg);

    __declspec(dllimport) long __stdcall Ndr64AsyncStubCall(struct IRpcStubBuffer* pThis,
                                                            struct IRpcChannelBuffer* pChannel,
                                                            PRPC_MESSAGE pRpcMsg,
                                                            unsigned long* pdwStubPhase);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) long __stdcall Ndr64DcomAsyncStubCall(struct IRpcStubBuffer* pThis,
                                                                struct IRpcChannelBuffer* pChannel,
                                                                PRPC_MESSAGE pRpcMsg,
                                                                unsigned long* pdwStubPhase);

#pragma endregion

#pragma region Application Family or OneCore Family

    __declspec(dllimport) long __stdcall NdrStubCall3(void* pThis, void* pChannel, PRPC_MESSAGE pRpcMsg, unsigned long* pdwStubPhase);

    __declspec(dllimport) void __stdcall NdrServerCallAll(PRPC_MESSAGE pRpcMsg);

    __declspec(dllimport) void __stdcall NdrServerCallNdr64(PRPC_MESSAGE pRpcMsg);

    __declspec(dllimport) void __stdcall NdrServerCall3(PRPC_MESSAGE pRpcMsg);

    __declspec(dllimport) void __stdcall NdrPartialIgnoreClientMarshall(PMIDL_STUB_MESSAGE pStubMsg, void* pMemory);

    __declspec(dllimport) void __stdcall NdrPartialIgnoreServerUnmarshall(PMIDL_STUB_MESSAGE pStubMsg, void** ppMemory);

    __declspec(dllimport) void __stdcall NdrPartialIgnoreClientBufferSize(PMIDL_STUB_MESSAGE pStubMsg, void* pMemory);

    __declspec(dllimport) void __stdcall NdrPartialIgnoreServerInitialize(PMIDL_STUB_MESSAGE pStubMsg, void** ppMemory, PFORMAT_STRING pFormat);

    void __stdcall RpcUserFree(handle_t AsyncHandle, void* pBuffer);

#pragma endregion
}

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(pop)

#pragma once

#pragma once

extern "C"
{
#pragma once

#pragma warning(push)
#pragma warning(disable : 4820)

    extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0000_v0_0_s_ifspec;

    typedef WCHAR OLECHAR;

    typedef OLECHAR* LPOLESTR;

    typedef const OLECHAR* LPCOLESTR;

    typedef unsigned char UCHAR;

    typedef short SHORT;

    typedef unsigned short USHORT;

    typedef DWORD ULONG;

    typedef double DOUBLE;

    typedef struct _COAUTHIDENTITY
    {
        USHORT* User;
        ULONG UserLength;
        USHORT* Domain;
        ULONG DomainLength;
        USHORT* Password;
        ULONG PasswordLength;
        ULONG Flags;
    } COAUTHIDENTITY;

    typedef struct _COAUTHINFO
    {
        DWORD dwAuthnSvc;
        DWORD dwAuthzSvc;
        LPWSTR pwszServerPrincName;
        DWORD dwAuthnLevel;
        DWORD dwImpersonationLevel;
        COAUTHIDENTITY* pAuthIdentityData;
        DWORD dwCapabilities;
    } COAUTHINFO;

    typedef LONG SCODE;

    typedef SCODE* PSCODE;

    typedef enum tagMEMCTX
    {
        MEMCTX_TASK = 1,
        MEMCTX_SHARED = 2,
        MEMCTX_MACSYSTEM = 3,
        MEMCTX_UNKNOWN = -1,
        MEMCTX_SAME = -2
    } MEMCTX;

    typedef enum tagCLSCTX
    {
        CLSCTX_INPROC_SERVER = 0x1,
        CLSCTX_INPROC_HANDLER = 0x2,
        CLSCTX_LOCAL_SERVER = 0x4,
        CLSCTX_INPROC_SERVER16 = 0x8,
        CLSCTX_REMOTE_SERVER = 0x10,
        CLSCTX_INPROC_HANDLER16 = 0x20,
        CLSCTX_RESERVED1 = 0x40,
        CLSCTX_RESERVED2 = 0x80,
        CLSCTX_RESERVED3 = 0x100,
        CLSCTX_RESERVED4 = 0x200,
        CLSCTX_NO_CODE_DOWNLOAD = 0x400,
        CLSCTX_RESERVED5 = 0x800,
        CLSCTX_NO_CUSTOM_MARSHAL = 0x1000,
        CLSCTX_ENABLE_CODE_DOWNLOAD = 0x2000,
        CLSCTX_NO_FAILURE_LOG = 0x4000,
        CLSCTX_DISABLE_AAA = 0x8000,
        CLSCTX_ENABLE_AAA = 0x10000,
        CLSCTX_FROM_DEFAULT_CONTEXT = 0x20000,
        CLSCTX_ACTIVATE_X86_SERVER = 0x40000,
        CLSCTX_ACTIVATE_32_BIT_SERVER = CLSCTX_ACTIVATE_X86_SERVER,
        CLSCTX_ACTIVATE_64_BIT_SERVER = 0x80000,
        CLSCTX_ENABLE_CLOAKING = 0x100000,
        CLSCTX_APPCONTAINER = 0x400000,
        CLSCTX_ACTIVATE_AAA_AS_IU = 0x800000,
        CLSCTX_RESERVED6 = 0x1000000,
        CLSCTX_ACTIVATE_ARM32_SERVER = 0x2000000,
        CLSCTX_PS_DLL = 0x80000000
    } CLSCTX;

    typedef enum tagMSHLFLAGS
    {
        MSHLFLAGS_NORMAL = 0,
        MSHLFLAGS_TABLESTRONG = 1,
        MSHLFLAGS_TABLEWEAK = 2,
        MSHLFLAGS_NOPING = 4,
        MSHLFLAGS_RESERVED1 = 8,
        MSHLFLAGS_RESERVED2 = 16,
        MSHLFLAGS_RESERVED3 = 32,
        MSHLFLAGS_RESERVED4 = 64
    } MSHLFLAGS;

    typedef enum tagMSHCTX
    {
        MSHCTX_LOCAL = 0,
        MSHCTX_NOSHAREDMEM = 1,
        MSHCTX_DIFFERENTMACHINE = 2,
        MSHCTX_INPROC = 3,
        MSHCTX_CROSSCTX = 4,
        MSHCTX_RESERVED1 = 5
    } MSHCTX;

    typedef struct _BYTE_BLOB
    {
        ULONG clSize;
        byte abData[1];
    } BYTE_BLOB;

    typedef BYTE_BLOB* UP_BYTE_BLOB;

    typedef struct _WORD_BLOB
    {
        ULONG clSize;
        unsigned short asData[1];
    } WORD_BLOB;

    typedef WORD_BLOB* UP_WORD_BLOB;

    typedef struct _DWORD_BLOB
    {
        ULONG clSize;
        ULONG alData[1];
    } DWORD_BLOB;

    typedef DWORD_BLOB* UP_DWORD_BLOB;

    typedef struct _FLAGGED_BYTE_BLOB
    {
        ULONG fFlags;
        ULONG clSize;
        byte abData[1];
    } FLAGGED_BYTE_BLOB;

    typedef FLAGGED_BYTE_BLOB* UP_FLAGGED_BYTE_BLOB;

    typedef struct _FLAGGED_WORD_BLOB
    {
        ULONG fFlags;
        ULONG clSize;
        unsigned short asData[1];
    } FLAGGED_WORD_BLOB;

    typedef FLAGGED_WORD_BLOB* UP_FLAGGED_WORD_BLOB;

    typedef struct _BYTE_SIZEDARR
    {
        ULONG clSize;
        byte* pData;
    } BYTE_SIZEDARR;

    typedef struct _SHORT_SIZEDARR
    {
        ULONG clSize;
        unsigned short* pData;
    } WORD_SIZEDARR;

    typedef struct _LONG_SIZEDARR
    {
        ULONG clSize;
        ULONG* pData;
    } DWORD_SIZEDARR;

    typedef struct _HYPER_SIZEDARR
    {
        ULONG clSize;
        __int64* pData;
    } HYPER_SIZEDARR;

    extern RPC_IF_HANDLE IWinTypesBase_v0_1_c_ifspec;
    extern RPC_IF_HANDLE IWinTypesBase_v0_1_s_ifspec;

    typedef boolean BOOLEAN;

    typedef struct tagBLOB
    {
        ULONG cbSize;
        BYTE* pBlobData;
    } BLOB;

    typedef struct tagBLOB* LPBLOB;

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_wtypesbase_0000_0001_v0_0_s_ifspec;
}

extern "C"
{
#pragma once

#pragma warning(push)
#pragma warning(disable : 4820)

    extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0000_v0_0_s_ifspec;

    typedef struct tagRemHGLOBAL
    {
        LONG fNullHGlobal;
        ULONG cbData;
        byte data[1];
    } RemHGLOBAL;

    typedef struct tagRemHMETAFILEPICT
    {
        LONG mm;
        LONG xExt;
        LONG yExt;
        ULONG cbData;
        byte data[1];
    } RemHMETAFILEPICT;

    typedef struct tagRemHENHMETAFILE
    {
        ULONG cbData;
        byte data[1];
    } RemHENHMETAFILE;

    typedef struct tagRemHBITMAP
    {
        ULONG cbData;
        byte data[1];
    } RemHBITMAP;

    typedef struct tagRemHPALETTE
    {
        ULONG cbData;
        byte data[1];
    } RemHPALETTE;

    typedef struct tagRemBRUSH
    {
        ULONG cbData;
        byte data[1];
    } RemHBRUSH;

    typedef enum tagDVASPECT
    {
        DVASPECT_CONTENT = 1,
        DVASPECT_THUMBNAIL = 2,
        DVASPECT_ICON = 4,
        DVASPECT_DOCPRINT = 8
    } DVASPECT;

    typedef enum tagSTGC
    {
        STGC_DEFAULT = 0,
        STGC_OVERWRITE = 1,
        STGC_ONLYIFCURRENT = 2,
        STGC_DANGEROUSLYCOMMITMERELYTODISKCACHE = 4,
        STGC_CONSOLIDATE = 8
    } STGC;

    typedef enum tagSTGMOVE
    {
        STGMOVE_MOVE = 0,
        STGMOVE_COPY = 1,
        STGMOVE_SHALLOWCOPY = 2
    } STGMOVE;

    typedef enum tagSTATFLAG
    {
        STATFLAG_DEFAULT = 0,
        STATFLAG_NONAME = 1,
        STATFLAG_NOOPEN = 2
    } STATFLAG;

    typedef void* HCONTEXT;

    typedef DWORD LCID;

    typedef USHORT LANGID;

    typedef struct _userCLIPFORMAT
    {
        LONG fContext;
        union __MIDL_IWinTypes_0001
        {
            DWORD dwValue;
            wchar_t* pwszName;
        } u;
    } userCLIPFORMAT;

    typedef userCLIPFORMAT* wireCLIPFORMAT;

    typedef WORD CLIPFORMAT;

    typedef struct _GDI_NONREMOTE
    {
        LONG fContext;
        union __MIDL_IWinTypes_0002
        {
            LONG hInproc;
            DWORD_BLOB* hRemote;
        } u;
    } GDI_NONREMOTE;

    typedef struct _userHGLOBAL
    {
        LONG fContext;
        union __MIDL_IWinTypes_0003
        {
            LONG hInproc;
            FLAGGED_BYTE_BLOB* hRemote;
            __int64 hInproc64;
        } u;
    } userHGLOBAL;

    typedef userHGLOBAL* wireHGLOBAL;

    typedef struct _userHMETAFILE
    {
        LONG fContext;
        union __MIDL_IWinTypes_0004
        {
            LONG hInproc;
            BYTE_BLOB* hRemote;
            __int64 hInproc64;
        } u;
    } userHMETAFILE;

    typedef struct _remoteMETAFILEPICT
    {
        LONG mm;
        LONG xExt;
        LONG yExt;
        userHMETAFILE* hMF;
    } remoteMETAFILEPICT;

    typedef struct _userHMETAFILEPICT
    {
        LONG fContext;
        union __MIDL_IWinTypes_0005
        {
            LONG hInproc;
            remoteMETAFILEPICT* hRemote;
            __int64 hInproc64;
        } u;
    } userHMETAFILEPICT;

    typedef struct _userHENHMETAFILE
    {
        LONG fContext;
        union __MIDL_IWinTypes_0006
        {
            LONG hInproc;
            BYTE_BLOB* hRemote;
            __int64 hInproc64;
        } u;
    } userHENHMETAFILE;

    typedef struct _userBITMAP
    {
        LONG bmType;
        LONG bmWidth;
        LONG bmHeight;
        LONG bmWidthBytes;
        WORD bmPlanes;
        WORD bmBitsPixel;
        ULONG cbSize;
        byte pBuffer[1];
    } userBITMAP;

    typedef struct _userHBITMAP
    {
        LONG fContext;
        union __MIDL_IWinTypes_0007
        {
            LONG hInproc;
            userBITMAP* hRemote;
            __int64 hInproc64;
        } u;
    } userHBITMAP;

    typedef struct _userHPALETTE
    {
        LONG fContext;
        union __MIDL_IWinTypes_0008
        {
            LONG hInproc;
            LOGPALETTE* hRemote;
            __int64 hInproc64;
        } u;
    } userHPALETTE;

    typedef struct _RemotableHandle
    {
        LONG fContext;
        union __MIDL_IWinTypes_0009
        {
            LONG hInproc;
            LONG hRemote;
        } u;
    } RemotableHandle;

    typedef RemotableHandle* wireHWND;

    typedef RemotableHandle* wireHMENU;

    typedef RemotableHandle* wireHACCEL;

    typedef RemotableHandle* wireHBRUSH;

    typedef RemotableHandle* wireHFONT;

    typedef RemotableHandle* wireHDC;

    typedef RemotableHandle* wireHICON;

    typedef RemotableHandle* wireHRGN;

    typedef RemotableHandle* wireHMONITOR;

    typedef userHBITMAP* wireHBITMAP;

    typedef userHPALETTE* wireHPALETTE;

    typedef userHENHMETAFILE* wireHENHMETAFILE;

    typedef userHMETAFILE* wireHMETAFILE;

    typedef userHMETAFILEPICT* wireHMETAFILEPICT;

    typedef void* HMETAFILEPICT;

    extern RPC_IF_HANDLE IWinTypes_v0_1_c_ifspec;
    extern RPC_IF_HANDLE IWinTypes_v0_1_s_ifspec;

#pragma warning(push)
#pragma warning(disable : 4201)
    typedef double DATE;

    typedef union tagCY
    {
        struct
        {
            ULONG Lo;
            LONG Hi;
        };
        LONGLONG int64;
    } CY;
    typedef CY* LPCY;

    typedef struct tagDEC
    {
        USHORT wReserved;
        union
        {
            struct
            {
                BYTE scale;
                BYTE sign;
            };
            USHORT signscale;
        };
        ULONG Hi32;
        union
        {
            struct
            {
                ULONG Lo32;
                ULONG Mid32;
            };
            ULONGLONG Lo64;
        };
    } DECIMAL;

    typedef DECIMAL* LPDECIMAL;

#pragma warning(pop)

    typedef FLAGGED_WORD_BLOB* wireBSTR;

    typedef OLECHAR* BSTR;

    typedef BSTR* LPBSTR;

    typedef short VARIANT_BOOL;

    typedef struct tagBSTRBLOB
    {
        ULONG cbSize;
        BYTE* pData;
    } BSTRBLOB;

    typedef struct tagBSTRBLOB* LPBSTRBLOB;

    typedef struct tagCLIPDATA
    {
        ULONG cbSize;
        LONG ulClipFmt;
        BYTE* pClipData;
    } CLIPDATA;

    typedef unsigned short VARTYPE;

    enum VARENUM
    {
        VT_EMPTY = 0,
        VT_NULL = 1,
        VT_I2 = 2,
        VT_I4 = 3,
        VT_R4 = 4,
        VT_R8 = 5,
        VT_CY = 6,
        VT_DATE = 7,
        VT_BSTR = 8,
        VT_DISPATCH = 9,
        VT_ERROR = 10,
        VT_BOOL = 11,
        VT_VARIANT = 12,
        VT_UNKNOWN = 13,
        VT_DECIMAL = 14,
        VT_I1 = 16,
        VT_UI1 = 17,
        VT_UI2 = 18,
        VT_UI4 = 19,
        VT_I8 = 20,
        VT_UI8 = 21,
        VT_INT = 22,
        VT_UINT = 23,
        VT_VOID = 24,
        VT_HRESULT = 25,
        VT_PTR = 26,
        VT_SAFEARRAY = 27,
        VT_CARRAY = 28,
        VT_USERDEFINED = 29,
        VT_LPSTR = 30,
        VT_LPWSTR = 31,
        VT_RECORD = 36,
        VT_INT_PTR = 37,
        VT_UINT_PTR = 38,
        VT_FILETIME = 64,
        VT_BLOB = 65,
        VT_STREAM = 66,
        VT_STORAGE = 67,
        VT_STREAMED_OBJECT = 68,
        VT_STORED_OBJECT = 69,
        VT_BLOB_OBJECT = 70,
        VT_CF = 71,
        VT_CLSID = 72,
        VT_VERSIONED_STREAM = 73,
        VT_BSTR_BLOB = 0xfff,
        VT_VECTOR = 0x1000,
        VT_ARRAY = 0x2000,
        VT_BYREF = 0x4000,
        VT_RESERVED = 0x8000,
        VT_ILLEGAL = 0xffff,
        VT_ILLEGALMASKED = 0xfff,
        VT_TYPEMASK = 0xfff
    };
    typedef ULONG PROPID;

    typedef struct _tagpropertykey
    {
        GUID fmtid;
        DWORD pid;
    } PROPERTYKEY;

    typedef struct tagCSPLATFORM
    {
        DWORD dwPlatformId;
        DWORD dwVersionHi;
        DWORD dwVersionLo;
        DWORD dwProcessorArch;
    } CSPLATFORM;

    typedef struct tagQUERYCONTEXT
    {
        DWORD dwContext;
        CSPLATFORM Platform;
        LCID Locale;
        DWORD dwVersionHi;
        DWORD dwVersionLo;
    } QUERYCONTEXT;

    typedef enum tagTYSPEC
    {
        TYSPEC_CLSID = 0,
        TYSPEC_FILEEXT = (TYSPEC_CLSID + 1),
        TYSPEC_MIMETYPE = (TYSPEC_FILEEXT + 1),
        TYSPEC_FILENAME = (TYSPEC_MIMETYPE + 1),
        TYSPEC_PROGID = (TYSPEC_FILENAME + 1),
        TYSPEC_PACKAGENAME = (TYSPEC_PROGID + 1),
        TYSPEC_OBJECTID = (TYSPEC_PACKAGENAME + 1)
    } TYSPEC;

    typedef struct __MIDL___MIDL_itf_wtypes_0000_0001_0001
    {
        DWORD tyspec;
        union __MIDL___MIDL_itf_wtypes_0000_0001_0005
        {
            CLSID clsid;
            LPOLESTR pFileExt;
            LPOLESTR pMimeType;
            LPOLESTR pProgId;
            LPOLESTR pFileName;
            struct
            {
                LPOLESTR pPackageName;
                GUID PolicyId;
            } ByName;
            struct
            {
                GUID ObjectId;
                GUID PolicyId;
            } ByObjectId;
        } tagged_union;
    } uCLSSPEC;

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_wtypes_0000_0001_v0_0_s_ifspec;
}

extern "C" const GUID GUID_DEVINTERFACE_DISK;
extern "C" const GUID GUID_DEVINTERFACE_CDROM;
extern "C" const GUID GUID_DEVINTERFACE_PARTITION;
extern "C" const GUID GUID_DEVINTERFACE_TAPE;
extern "C" const GUID GUID_DEVINTERFACE_WRITEONCEDISK;
extern "C" const GUID GUID_DEVINTERFACE_VOLUME;
extern "C" const GUID GUID_DEVINTERFACE_MEDIUMCHANGER;
extern "C" const GUID GUID_DEVINTERFACE_FLOPPY;
extern "C" const GUID GUID_DEVINTERFACE_CDCHANGER;
extern "C" const GUID GUID_DEVINTERFACE_STORAGEPORT;
extern "C" const GUID GUID_DEVINTERFACE_VMLUN;
extern "C" const GUID GUID_DEVINTERFACE_SES;

extern "C" const GUID GUID_DEVINTERFACE_SERVICE_VOLUME;
extern "C" const GUID GUID_DEVINTERFACE_HIDDEN_VOLUME;

extern "C" const GUID GUID_DEVINTERFACE_UNIFIED_ACCESS_RPMB;

extern "C" const GUID GUID_DEVINTERFACE_SCM_PHYSICAL_DEVICE;

extern "C" const GUID GUID_SCM_PD_HEALTH_NOTIFICATION;

extern "C" const GUID GUID_SCM_PD_PASSTHROUGH_INVDIMM;

extern "C" const GUID GUID_DEVINTERFACE_COMPORT;

extern "C" const GUID GUID_DEVINTERFACE_SERENUM_BUS_ENUMERATOR;

#pragma warning(push)
#pragma warning(disable : 4201)
#pragma warning(disable : 4820)

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

    typedef struct _STORAGE_HOTPLUG_INFO
    {
        DWORD Size;
        BOOLEAN MediaRemovable;
        BOOLEAN MediaHotplug;
        BOOLEAN DeviceHotplug;
        BOOLEAN WriteCacheEnableOverride;
    } STORAGE_HOTPLUG_INFO, *PSTORAGE_HOTPLUG_INFO;

    typedef struct _STORAGE_DEVICE_NUMBER
    {
        DWORD DeviceType;

        DWORD DeviceNumber;

        DWORD PartitionNumber;
    } STORAGE_DEVICE_NUMBER, *PSTORAGE_DEVICE_NUMBER;

    typedef struct _STORAGE_DEVICE_NUMBERS
    {
        DWORD NumberOfDevices;

        STORAGE_DEVICE_NUMBER Devices[1];

    } STORAGE_DEVICE_NUMBERS, *PSTORAGE_DEVICE_NUMBERS;

    typedef struct _STORAGE_DEVICE_NUMBER_EX
    {
        DWORD Version;

        DWORD Size;

        DWORD Flags;

        DWORD DeviceType;

        DWORD DeviceNumber;

        GUID DeviceGuid;

        DWORD PartitionNumber;
    } STORAGE_DEVICE_NUMBER_EX, *PSTORAGE_DEVICE_NUMBER_EX;

    typedef struct _STORAGE_BUS_RESET_REQUEST
    {
        BYTE PathId;
    } STORAGE_BUS_RESET_REQUEST, *PSTORAGE_BUS_RESET_REQUEST;

    typedef struct STORAGE_BREAK_RESERVATION_REQUEST
    {
        DWORD Length;
        BYTE _unused;
        BYTE PathId;
        BYTE TargetId;
        BYTE Lun;
    } STORAGE_BREAK_RESERVATION_REQUEST, *PSTORAGE_BREAK_RESERVATION_REQUEST;

    typedef struct _PREVENT_MEDIA_REMOVAL
    {
        BOOLEAN PreventMediaRemoval;
    } PREVENT_MEDIA_REMOVAL, *PPREVENT_MEDIA_REMOVAL;

    typedef struct _CLASS_MEDIA_CHANGE_CONTEXT
    {
        DWORD MediaChangeCount;
        DWORD NewState;
    } CLASS_MEDIA_CHANGE_CONTEXT, *PCLASS_MEDIA_CHANGE_CONTEXT;

    typedef struct _TAPE_STATISTICS
    {
        DWORD Version;
        DWORD Flags;
        LARGE_INTEGER RecoveredWrites;
        LARGE_INTEGER UnrecoveredWrites;
        LARGE_INTEGER RecoveredReads;
        LARGE_INTEGER UnrecoveredReads;
        BYTE CompressionRatioReads;
        BYTE CompressionRatioWrites;
    } TAPE_STATISTICS, *PTAPE_STATISTICS;

    typedef struct _TAPE_GET_STATISTICS
    {
        DWORD Operation;
    } TAPE_GET_STATISTICS, *PTAPE_GET_STATISTICS;

    typedef enum _STORAGE_MEDIA_TYPE
    {

        DDS_4mm = 0x20,
        MiniQic,
        Travan,
        QIC,
        MP_8mm,
        AME_8mm,
        AIT1_8mm,
        DLT,
        NCTP,
        IBM_3480,
        IBM_3490E,
        IBM_Magstar_3590,
        IBM_Magstar_MP,
        STK_DATA_D3,
        SONY_DTF,
        DV_6mm,
        DMI,
        SONY_D2,
        CLEANER_CARTRIDGE,
        CD_ROM,
        CD_R,
        CD_RW,
        DVD_ROM,
        DVD_R,
        DVD_RW,
        MO_3_RW,
        MO_5_WO,
        MO_5_RW,
        MO_5_LIMDOW,
        PC_5_WO,
        PC_5_RW,
        PD_5_RW,
        ABL_5_WO,
        PINNACLE_APEX_5_RW,
        SONY_12_WO,
        PHILIPS_12_WO,
        HITACHI_12_WO,
        CYGNET_12_WO,
        KODAK_14_WO,
        MO_NFR_525,
        NIKON_12_RW,
        IOMEGA_ZIP,
        IOMEGA_JAZ,
        SYQUEST_EZ135,
        SYQUEST_EZFLYER,
        SYQUEST_SYJET,
        AVATAR_F2,
        MP2_8mm,
        DST_S,
        DST_M,
        DST_L,
        VXATape_1,
        VXATape_2,

        STK_9840,
        LTO_Ultrium,
        LTO_Accelis,
        DVD_RAM,
        AIT_8mm,
        ADR_1,
        ADR_2,
        STK_9940,
        SAIT,
        VXATape
    } STORAGE_MEDIA_TYPE,
    *PSTORAGE_MEDIA_TYPE;

    typedef enum _STORAGE_BUS_TYPE
    {
        BusTypeUnknown = 0x00,
        BusTypeScsi,
        BusTypeAtapi,
        BusTypeAta,
        BusType1394,
        BusTypeSsa,
        BusTypeFibre,
        BusTypeUsb,
        BusTypeRAID,
        BusTypeiScsi,
        BusTypeSas,
        BusTypeSata,
        BusTypeSd,
        BusTypeMmc,
        BusTypeVirtual,
        BusTypeFileBackedVirtual,
        BusTypeSpaces,
        BusTypeNvme,
        BusTypeSCM,
        BusTypeUfs,
        BusTypeMax,
        BusTypeMaxReserved = 0x7F
    } STORAGE_BUS_TYPE,
    *PSTORAGE_BUS_TYPE;

    typedef struct _DEVICE_MEDIA_INFO
    {
        union
        {
            struct
            {
                LARGE_INTEGER Cylinders;
                STORAGE_MEDIA_TYPE MediaType;
                DWORD TracksPerCylinder;
                DWORD SectorsPerTrack;
                DWORD BytesPerSector;
                DWORD NumberMediaSides;
                DWORD MediaCharacteristics;
            } DiskInfo;

            struct
            {
                LARGE_INTEGER Cylinders;
                STORAGE_MEDIA_TYPE MediaType;
                DWORD TracksPerCylinder;
                DWORD SectorsPerTrack;
                DWORD BytesPerSector;
                DWORD NumberMediaSides;
                DWORD MediaCharacteristics;
            } RemovableDiskInfo;

            struct
            {
                STORAGE_MEDIA_TYPE MediaType;
                DWORD MediaCharacteristics;
                DWORD CurrentBlockSize;
                STORAGE_BUS_TYPE BusType;

                union
                {
                    struct
                    {
                        BYTE MediumType;
                        BYTE DensityCode;
                    } ScsiInformation;
                } BusSpecificData;

            } TapeInfo;
        } DeviceSpecific;
    } DEVICE_MEDIA_INFO, *PDEVICE_MEDIA_INFO;

    typedef struct _GET_MEDIA_TYPES
    {
        DWORD DeviceType;
        DWORD MediaInfoCount;
        DEVICE_MEDIA_INFO MediaInfo[1];
    } GET_MEDIA_TYPES, *PGET_MEDIA_TYPES;

    typedef struct _STORAGE_PREDICT_FAILURE
    {
        DWORD PredictFailure;
        BYTE VendorSpecific[512];
    } STORAGE_PREDICT_FAILURE, *PSTORAGE_PREDICT_FAILURE;

    typedef struct _STORAGE_FAILURE_PREDICTION_CONFIG
    {
        DWORD Version;
        DWORD Size;
        BOOLEAN Set;
        BOOLEAN Enabled;
        WORD Reserved;
    } STORAGE_FAILURE_PREDICTION_CONFIG, *PSTORAGE_FAILURE_PREDICTION_CONFIG;

    typedef enum _STORAGE_QUERY_TYPE
    {
        PropertyStandardQuery = 0,
        PropertyExistsQuery,
        PropertyMaskQuery,
        PropertyQueryMaxDefined
    } STORAGE_QUERY_TYPE,
    *PSTORAGE_QUERY_TYPE;

    typedef enum _STORAGE_PROPERTY_ID
    {
        StorageDeviceProperty = 0,
        StorageAdapterProperty,
        StorageDeviceIdProperty,
        StorageDeviceUniqueIdProperty,
        StorageDeviceWriteCacheProperty,
        StorageMiniportProperty,
        StorageAccessAlignmentProperty,
        StorageDeviceSeekPenaltyProperty,
        StorageDeviceTrimProperty,
        StorageDeviceWriteAggregationProperty,
        StorageDeviceDeviceTelemetryProperty,
        StorageDeviceLBProvisioningProperty,
        StorageDevicePowerProperty,
        StorageDeviceCopyOffloadProperty,
        StorageDeviceResiliencyProperty,
        StorageDeviceMediumProductType,
        StorageAdapterRpmbProperty,
        StorageAdapterCryptoProperty,
        StorageDeviceIoCapabilityProperty = 48,
        StorageAdapterProtocolSpecificProperty,
        StorageDeviceProtocolSpecificProperty,
        StorageAdapterTemperatureProperty,
        StorageDeviceTemperatureProperty,
        StorageAdapterPhysicalTopologyProperty,
        StorageDevicePhysicalTopologyProperty,
        StorageDeviceAttributesProperty,
        StorageDeviceManagementStatus,
        StorageAdapterSerialNumberProperty,
        StorageDeviceLocationProperty,
        StorageDeviceNumaProperty,
        StorageDeviceZonedDeviceProperty,
        StorageDeviceUnsafeShutdownCount
    } STORAGE_PROPERTY_ID,
    *PSTORAGE_PROPERTY_ID;

    typedef struct _STORAGE_PROPERTY_QUERY
    {
        STORAGE_PROPERTY_ID PropertyId;

        STORAGE_QUERY_TYPE QueryType;

        BYTE AdditionalParameters[1];

    } STORAGE_PROPERTY_QUERY, *PSTORAGE_PROPERTY_QUERY;

    typedef struct _STORAGE_DESCRIPTOR_HEADER
    {
        DWORD Version;

        DWORD Size;

    } STORAGE_DESCRIPTOR_HEADER, *PSTORAGE_DESCRIPTOR_HEADER;

    typedef struct _STORAGE_DEVICE_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        BYTE DeviceType;

        BYTE DeviceTypeModifier;

        BOOLEAN RemovableMedia;

        BOOLEAN CommandQueueing;

        DWORD VendorIdOffset;

        DWORD ProductIdOffset;

        DWORD ProductRevisionOffset;

        DWORD SerialNumberOffset;

        STORAGE_BUS_TYPE BusType;

        DWORD RawPropertiesLength;

        BYTE RawDeviceProperties[1];

    } STORAGE_DEVICE_DESCRIPTOR, *PSTORAGE_DEVICE_DESCRIPTOR;

    typedef struct _STORAGE_ADAPTER_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD MaximumTransferLength;

        DWORD MaximumPhysicalPages;

        DWORD AlignmentMask;

        BOOLEAN AdapterUsesPio;

        BOOLEAN AdapterScansDown;

        BOOLEAN CommandQueueing;

        BOOLEAN AcceleratedTransfer;

        BYTE BusType;

        WORD BusMajorVersion;

        WORD BusMinorVersion;

        BYTE SrbType;

        BYTE AddressType;

    } STORAGE_ADAPTER_DESCRIPTOR, *PSTORAGE_ADAPTER_DESCRIPTOR;

    typedef struct _STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD BytesPerCacheLine;

        DWORD BytesOffsetForCacheAlignment;

        DWORD BytesPerLogicalSector;

        DWORD BytesPerPhysicalSector;

        DWORD BytesOffsetForSectorAlignment;

    } STORAGE_ACCESS_ALIGNMENT_DESCRIPTOR, *PSTORAGE_ACCESS_ALIGNMENT_DESCRIPTOR;

    typedef struct _STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD MediumProductType;

    } STORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR, *PSTORAGE_MEDIUM_PRODUCT_TYPE_DESCRIPTOR;

    typedef enum _STORAGE_PORT_CODE_SET
    {
        StoragePortCodeSetReserved = 0,
        StoragePortCodeSetStorport = 1,
        StoragePortCodeSetSCSIport = 2,
        StoragePortCodeSetSpaceport = 3,
        StoragePortCodeSetATAport = 4,
        StoragePortCodeSetUSBport = 5,
        StoragePortCodeSetSBP2port = 6,
        StoragePortCodeSetSDport = 7
    } STORAGE_PORT_CODE_SET,
    *PSTORAGE_PORT_CODE_SET;

    typedef struct _STORAGE_MINIPORT_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        STORAGE_PORT_CODE_SET Portdriver;

        BOOLEAN LUNResetSupported;

        BOOLEAN TargetResetSupported;

        WORD IoTimeoutValue;

        BOOLEAN ExtraIoInfoSupported;

        BYTE Reserved0[3];

        DWORD Reserved1;

    } STORAGE_MINIPORT_DESCRIPTOR, *PSTORAGE_MINIPORT_DESCRIPTOR;

    typedef enum _STORAGE_IDENTIFIER_CODE_SET
    {
        StorageIdCodeSetReserved = 0,
        StorageIdCodeSetBinary = 1,
        StorageIdCodeSetAscii = 2,
        StorageIdCodeSetUtf8 = 3
    } STORAGE_IDENTIFIER_CODE_SET,
    *PSTORAGE_IDENTIFIER_CODE_SET;

    typedef enum _STORAGE_IDENTIFIER_TYPE
    {
        StorageIdTypeVendorSpecific = 0,
        StorageIdTypeVendorId = 1,
        StorageIdTypeEUI64 = 2,
        StorageIdTypeFCPHName = 3,
        StorageIdTypePortRelative = 4,
        StorageIdTypeTargetPortGroup = 5,
        StorageIdTypeLogicalUnitGroup = 6,
        StorageIdTypeMD5LogicalUnitIdentifier = 7,
        StorageIdTypeScsiNameString = 8
    } STORAGE_IDENTIFIER_TYPE,
    *PSTORAGE_IDENTIFIER_TYPE;

    typedef enum _STORAGE_ID_NAA_FORMAT
    {
        StorageIdNAAFormatIEEEExtended = 2,
        StorageIdNAAFormatIEEERegistered = 3,
        StorageIdNAAFormatIEEEERegisteredExtended = 5
    } STORAGE_ID_NAA_FORMAT,
    *PSTORAGE_ID_NAA_FORMAT;

    typedef enum _STORAGE_ASSOCIATION_TYPE
    {
        StorageIdAssocDevice = 0,
        StorageIdAssocPort = 1,
        StorageIdAssocTarget = 2
    } STORAGE_ASSOCIATION_TYPE,
    *PSTORAGE_ASSOCIATION_TYPE;

    typedef struct _STORAGE_IDENTIFIER
    {
        STORAGE_IDENTIFIER_CODE_SET CodeSet;

        STORAGE_IDENTIFIER_TYPE Type;

        WORD IdentifierSize;

        WORD NextOffset;

        STORAGE_ASSOCIATION_TYPE Association;

        BYTE Identifier[1];

    } STORAGE_IDENTIFIER, *PSTORAGE_IDENTIFIER;

    typedef struct _STORAGE_DEVICE_ID_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD NumberOfIdentifiers;

        BYTE Identifiers[1];

    } STORAGE_DEVICE_ID_DESCRIPTOR, *PSTORAGE_DEVICE_ID_DESCRIPTOR;

    typedef struct _DEVICE_SEEK_PENALTY_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        BOOLEAN IncursSeekPenalty;
    } DEVICE_SEEK_PENALTY_DESCRIPTOR, *PDEVICE_SEEK_PENALTY_DESCRIPTOR;

    typedef struct _DEVICE_WRITE_AGGREGATION_DESCRIPTOR
    {
        DWORD Version;
        DWORD Size;

        BOOLEAN BenefitsFromWriteAggregation;
    } DEVICE_WRITE_AGGREGATION_DESCRIPTOR, *PDEVICE_WRITE_AGGREGATION_DESCRIPTOR;

    typedef struct _DEVICE_TRIM_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        BOOLEAN TrimEnabled;

    } DEVICE_TRIM_DESCRIPTOR, *PDEVICE_TRIM_DESCRIPTOR;

#pragma warning(push)
#pragma warning(disable : 4214)

    typedef struct _DEVICE_LB_PROVISIONING_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        BYTE ThinProvisioningEnabled : 1;

        BYTE ThinProvisioningReadZeros : 1;

        BYTE AnchorSupported : 3;

        BYTE UnmapGranularityAlignmentValid : 1;

        BYTE Reserved0 : 2;

        BYTE Reserved1[7];

        DWORDLONG OptimalUnmapGranularity;

        DWORDLONG UnmapGranularityAlignment;

        DWORD MaxUnmapLbaCount;

        DWORD MaxUnmapBlockDescriptorCount;

    } DEVICE_LB_PROVISIONING_DESCRIPTOR, *PDEVICE_LB_PROVISIONING_DESCRIPTOR;

    typedef struct _STORAGE_LB_PROVISIONING_MAP_RESOURCES
    {
        DWORD Size;
        DWORD Version;
        BYTE AvailableMappingResourcesValid : 1;
        BYTE UsedMappingResourcesValid : 1;
        BYTE Reserved0 : 6;
        BYTE Reserved1[3];
        BYTE AvailableMappingResourcesScope : 2;
        BYTE UsedMappingResourcesScope : 2;
        BYTE Reserved2 : 4;
        BYTE Reserved3[3];
        DWORDLONG AvailableMappingResources;
        DWORDLONG UsedMappingResources;
    } STORAGE_LB_PROVISIONING_MAP_RESOURCES, *PSTORAGE_LB_PROVISIONING_MAP_RESOURCES;

#pragma warning(pop)

    typedef struct _DEVICE_POWER_DESCRIPTOR
    {
        DWORD Version;
        DWORD Size;

        BOOLEAN DeviceAttentionSupported;
        BOOLEAN AsynchronousNotificationSupported;
        BOOLEAN IdlePowerManagementEnabled;
        BOOLEAN D3ColdEnabled;
        BOOLEAN D3ColdSupported;
        BOOLEAN NoVerifyDuringIdlePower;
        BYTE Reserved[2];
        DWORD IdleTimeoutInMS;
    } DEVICE_POWER_DESCRIPTOR, *PDEVICE_POWER_DESCRIPTOR;

    typedef struct _DEVICE_COPY_OFFLOAD_DESCRIPTOR
    {
        DWORD Version;
        DWORD Size;

        DWORD MaximumTokenLifetime;
        DWORD DefaultTokenLifetime;
        DWORDLONG MaximumTransferSize;
        DWORDLONG OptimalTransferCount;
        DWORD MaximumDataDescriptors;
        DWORD MaximumTransferLengthPerDescriptor;
        DWORD OptimalTransferLengthPerDescriptor;
        WORD OptimalTransferLengthGranularity;
        BYTE Reserved[2];
    } DEVICE_COPY_OFFLOAD_DESCRIPTOR, *PDEVICE_COPY_OFFLOAD_DESCRIPTOR;

    typedef struct _STORAGE_DEVICE_RESILIENCY_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD NameOffset;

        DWORD NumberOfLogicalCopies;

        DWORD NumberOfPhysicalCopies;

        DWORD PhysicalDiskRedundancy;

        DWORD NumberOfColumns;

        DWORD Interleave;

    } STORAGE_DEVICE_RESILIENCY_DESCRIPTOR, *PSTORAGE_DEVICE_RESILIENCY_DESCRIPTOR;

    typedef enum _STORAGE_RPMB_FRAME_TYPE
    {

        StorageRpmbFrameTypeUnknown = 0,
        StorageRpmbFrameTypeStandard,
        StorageRpmbFrameTypeMax,

    } STORAGE_RPMB_FRAME_TYPE,
    *PSTORAGE_RPMB_FRAME_TYPE;

    typedef struct _STORAGE_RPMB_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD SizeInBytes;

        DWORD MaxReliableWriteSizeInBytes;

        STORAGE_RPMB_FRAME_TYPE FrameFormat;

    } STORAGE_RPMB_DESCRIPTOR, *PSTORAGE_RPMB_DESCRIPTOR;

    typedef enum _STORAGE_CRYPTO_ALGORITHM_ID
    {

        StorageCryptoAlgorithmUnknown = 0,
        StorageCryptoAlgorithmXTSAES = 1,
        StorageCryptoAlgorithmBitlockerAESCBC,
        StorageCryptoAlgorithmAESECB,
        StorageCryptoAlgorithmESSIVAESCBC,
        StorageCryptoAlgorithmMax

    } STORAGE_CRYPTO_ALGORITHM_ID,
    *PSTORAGE_CRYPTO_ALGORITHM_ID;

    typedef enum _STORAGE_CRYPTO_KEY_SIZE
    {

        StorageCryptoKeySizeUnknown = 0,
        StorageCryptoKeySize128Bits = 1,
        StorageCryptoKeySize192Bits,
        StorageCryptoKeySize256Bits,
        StorageCryptoKeySize512Bits

    } STORAGE_CRYPTO_KEY_SIZE,
    *PSTORAGE_CRYPTO_KEY_SIZE;

    typedef struct _STORAGE_CRYPTO_CAPABILITY
    {
        DWORD Version;

        DWORD Size;

        DWORD CryptoCapabilityIndex;

        STORAGE_CRYPTO_ALGORITHM_ID AlgorithmId;

        STORAGE_CRYPTO_KEY_SIZE KeySize;

        DWORD DataUnitSizeBitmask;

    } STORAGE_CRYPTO_CAPABILITY, *PSTORAGE_CRYPTO_CAPABILITY;

    typedef struct _STORAGE_CRYPTO_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD NumKeysSupported;

        DWORD NumCryptoCapabilities;

        STORAGE_CRYPTO_CAPABILITY CryptoCapabilities[1];

    } STORAGE_CRYPTO_DESCRIPTOR, *PSTORAGE_CRYPTO_DESCRIPTOR;

    typedef enum _STORAGE_TIER_MEDIA_TYPE
    {

        StorageTierMediaTypeUnspecified = 0,
        StorageTierMediaTypeDisk = 1,
        StorageTierMediaTypeSsd = 2,
        StorageTierMediaTypeScm = 4,
        StorageTierMediaTypeMax

    } STORAGE_TIER_MEDIA_TYPE,
    *PSTORAGE_TIER_MEDIA_TYPE;

    typedef enum _STORAGE_TIER_CLASS
    {

        StorageTierClassUnspecified = 0,
        StorageTierClassCapacity,
        StorageTierClassPerformance,
        StorageTierClassMax

    } STORAGE_TIER_CLASS,
    *PSTORAGE_TIER_CLASS;

    typedef struct _STORAGE_TIER
    {
        GUID Id;

        WCHAR Name[(256)];

        WCHAR Description[(256)];

        DWORDLONG Flags;

        DWORDLONG ProvisionedCapacity;

        STORAGE_TIER_MEDIA_TYPE MediaType;

        STORAGE_TIER_CLASS Class;

    } STORAGE_TIER, *PSTORAGE_TIER;

    typedef struct _STORAGE_DEVICE_TIERING_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD Flags;

        DWORD TotalNumberOfTiers;

        DWORD NumberOfTiersReturned;

        STORAGE_TIER Tiers[1];

    } STORAGE_DEVICE_TIERING_DESCRIPTOR, *PSTORAGE_DEVICE_TIERING_DESCRIPTOR;

    typedef struct _STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD NumberOfFaultDomains;

        GUID FaultDomainIds[1];

    } STORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR, *PSTORAGE_DEVICE_FAULT_DOMAIN_DESCRIPTOR;

    typedef enum _STORAGE_PROTOCOL_TYPE
    {
        ProtocolTypeUnknown = 0x00,
        ProtocolTypeScsi,
        ProtocolTypeAta,
        ProtocolTypeNvme,
        ProtocolTypeSd,
        ProtocolTypeUfs,
        ProtocolTypeProprietary = 0x7E,
        ProtocolTypeMaxReserved = 0x7F
    } STORAGE_PROTOCOL_TYPE,
    *PSTORAGE_PROTOCOL_TYPE;

    typedef enum _STORAGE_PROTOCOL_NVME_DATA_TYPE
    {
        NVMeDataTypeUnknown = 0,

        NVMeDataTypeIdentify,

        NVMeDataTypeLogPage,

        NVMeDataTypeFeature,

    } STORAGE_PROTOCOL_NVME_DATA_TYPE,
    *PSTORAGE_PROTOCOL_NVME_DATA_TYPE;

    typedef enum _STORAGE_PROTOCOL_ATA_DATA_TYPE
    {
        AtaDataTypeUnknown = 0,
        AtaDataTypeIdentify,
        AtaDataTypeLogPage,
    } STORAGE_PROTOCOL_ATA_DATA_TYPE,
    *PSTORAGE_PROTOCOL_ATA_DATA_TYPE;

    typedef enum _STORAGE_PROTOCOL_UFS_DATA_TYPE
    {
        UfsDataTypeUnknown = 0,
        UfsDataTypeQueryDescriptor,
        UfsDataTypeMax,
    } STORAGE_PROTOCOL_UFS_DATA_TYPE,
    *PSTORAGE_PROTOCOL_UFS_DATA_TYPE;

    typedef struct _STORAGE_PROTOCOL_SPECIFIC_DATA
    {
        STORAGE_PROTOCOL_TYPE ProtocolType;
        DWORD DataType;

        DWORD ProtocolDataRequestValue;
        DWORD ProtocolDataRequestSubValue;

        DWORD ProtocolDataOffset;
        DWORD ProtocolDataLength;

        DWORD FixedProtocolReturnData;
        DWORD ProtocolDataRequestSubValue2;

        DWORD Reserved[2];
    } STORAGE_PROTOCOL_SPECIFIC_DATA, *PSTORAGE_PROTOCOL_SPECIFIC_DATA;

    typedef struct _STORAGE_PROTOCOL_DATA_DESCRIPTOR
    {
        DWORD Version;
        DWORD Size;

        STORAGE_PROTOCOL_SPECIFIC_DATA ProtocolSpecificData;

    } STORAGE_PROTOCOL_DATA_DESCRIPTOR, *PSTORAGE_PROTOCOL_DATA_DESCRIPTOR;

    typedef struct _STORAGE_TEMPERATURE_INFO
    {
        WORD Index;
        SHORT Temperature;
        SHORT OverThreshold;
        SHORT UnderThreshold;

        BOOLEAN OverThresholdChangable;
        BOOLEAN UnderThresholdChangable;
        BOOLEAN EventGenerated;
        BYTE Reserved0;
        DWORD Reserved1;

    } STORAGE_TEMPERATURE_INFO, *PSTORAGE_TEMPERATURE_INFO;

    typedef struct _STORAGE_TEMPERATURE_DATA_DESCRIPTOR
    {
        DWORD Version;
        DWORD Size;

        SHORT CriticalTemperature;

        SHORT WarningTemperature;

        WORD InfoCount;

        BYTE Reserved0[2];

        DWORD Reserved1[2];

        STORAGE_TEMPERATURE_INFO TemperatureInfo[1];

    } STORAGE_TEMPERATURE_DATA_DESCRIPTOR, *PSTORAGE_TEMPERATURE_DATA_DESCRIPTOR;

    typedef struct _STORAGE_TEMPERATURE_THRESHOLD
    {
        DWORD Version;
        DWORD Size;

        WORD Flags;
        WORD Index;

        SHORT Threshold;
        BOOLEAN OverThreshold;
        BYTE Reserved;

    } STORAGE_TEMPERATURE_THRESHOLD, *PSTORAGE_TEMPERATURE_THRESHOLD;

    typedef enum _STORAGE_DEVICE_FORM_FACTOR
    {
        FormFactorUnknown = 0,

        FormFactor3_5,
        FormFactor2_5,
        FormFactor1_8,
        FormFactor1_8Less,

        FormFactorEmbedded,
        FormFactorMemoryCard,
        FormFactormSata,
        FormFactorM_2,
        FormFactorPCIeBoard,
        FormFactorDimm,

    } STORAGE_DEVICE_FORM_FACTOR,
    *PSTORAGE_DEVICE_FORM_FACTOR;

    typedef enum _STORAGE_COMPONENT_HEALTH_STATUS
    {
        HealthStatusUnknown = 0,
        HealthStatusNormal,
        HealthStatusThrottled,
        HealthStatusWarning,
        HealthStatusDisabled,
        HealthStatusFailed,
    } STORAGE_COMPONENT_HEALTH_STATUS,
    *PSTORAGE_COMPONENT_HEALTH_STATUS;

#pragma warning(push)
#pragma warning(disable : 4201)

    typedef union _STORAGE_SPEC_VERSION
    {
        struct
        {
            union
            {
                struct
                {
                    BYTE SubMinor;
                    BYTE Minor;
                };

                WORD AsUshort;

            } MinorVersion;

            WORD MajorVersion;
        };

        DWORD AsUlong;

    } STORAGE_SPEC_VERSION, *PSTORAGE_SPEC_VERSION;

#pragma warning(pop)

    typedef struct _STORAGE_PHYSICAL_DEVICE_DATA
    {
        DWORD DeviceId;
        DWORD Role;

        STORAGE_COMPONENT_HEALTH_STATUS HealthStatus;
        STORAGE_PROTOCOL_TYPE CommandProtocol;
        STORAGE_SPEC_VERSION SpecVersion;
        STORAGE_DEVICE_FORM_FACTOR FormFactor;

        BYTE Vendor[8];
        BYTE Model[40];
        BYTE FirmwareRevision[16];

        DWORDLONG Capacity;

        BYTE PhysicalLocation[32];

        DWORD Reserved[2];

    } STORAGE_PHYSICAL_DEVICE_DATA, *PSTORAGE_PHYSICAL_DEVICE_DATA;

    typedef struct _STORAGE_PHYSICAL_ADAPTER_DATA
    {
        DWORD AdapterId;
        STORAGE_COMPONENT_HEALTH_STATUS HealthStatus;
        STORAGE_PROTOCOL_TYPE CommandProtocol;
        STORAGE_SPEC_VERSION SpecVersion;

        BYTE Vendor[8];
        BYTE Model[40];
        BYTE FirmwareRevision[16];

        BYTE PhysicalLocation[32];

        BOOLEAN ExpanderConnected;
        BYTE Reserved0[3];
        DWORD Reserved1[3];

    } STORAGE_PHYSICAL_ADAPTER_DATA, *PSTORAGE_PHYSICAL_ADAPTER_DATA;

    typedef struct _STORAGE_PHYSICAL_NODE_DATA
    {
        DWORD NodeId;

        DWORD AdapterCount;
        DWORD AdapterDataLength;
        DWORD AdapterDataOffset;

        DWORD DeviceCount;
        DWORD DeviceDataLength;
        DWORD DeviceDataOffset;

        DWORD Reserved[3];

    } STORAGE_PHYSICAL_NODE_DATA, *PSTORAGE_PHYSICAL_NODE_DATA;

    typedef struct _STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR
    {
        DWORD Version;
        DWORD Size;

        DWORD NodeCount;
        DWORD Reserved;

        STORAGE_PHYSICAL_NODE_DATA Node[1];

    } STORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR, *PSTORAGE_PHYSICAL_TOPOLOGY_DESCRIPTOR;

    typedef struct _STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD LunMaxIoCount;

        DWORD AdapterMaxIoCount;

    } STORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR, *PSTORAGE_DEVICE_IO_CAPABILITY_DESCRIPTOR;

    typedef struct _STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DWORD64 Attributes;

    } STORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR, *PSTORAGE_DEVICE_ATTRIBUTES_DESCRIPTOR;

    typedef enum _STORAGE_DISK_HEALTH_STATUS
    {
        DiskHealthUnknown = 0,
        DiskHealthUnhealthy,
        DiskHealthWarning,
        DiskHealthHealthy,
        DiskHealthMax
    } STORAGE_DISK_HEALTH_STATUS,
    *PSTORAGE_DISK_HEALTH_STATUS;

    typedef enum _STORAGE_DISK_OPERATIONAL_STATUS
    {
        DiskOpStatusNone = 0,
        DiskOpStatusUnknown,
        DiskOpStatusOk,
        DiskOpStatusPredictingFailure,
        DiskOpStatusInService,
        DiskOpStatusHardwareError,
        DiskOpStatusNotUsable,
        DiskOpStatusTransientError,
        DiskOpStatusMissing,
    } STORAGE_DISK_OPERATIONAL_STATUS,
    *PSTORAGE_DISK_OPERATIONAL_STATUS;

    typedef enum _STORAGE_OPERATIONAL_STATUS_REASON
    {
        DiskOpReasonUnknown = 0,
        DiskOpReasonScsiSenseCode,
        DiskOpReasonMedia,
        DiskOpReasonIo,
        DiskOpReasonThresholdExceeded,
        DiskOpReasonLostData,
        DiskOpReasonEnergySource,
        DiskOpReasonConfiguration,
        DiskOpReasonDeviceController,
        DiskOpReasonMediaController,
        DiskOpReasonComponent,
        DiskOpReasonNVDIMM_N,
        DiskOpReasonBackgroundOperation,
        DiskOpReasonInvalidFirmware,
        DiskOpReasonHealthCheck,
        DiskOpReasonLostDataPersistence,
        DiskOpReasonDisabledByPlatform,
        DiskOpReasonLostWritePersistence,
        DiskOpReasonDataPersistenceLossImminent,
        DiskOpReasonWritePersistenceLossImminent,
        DiskOpReasonMax
    } STORAGE_OPERATIONAL_STATUS_REASON,
    *PSTORAGE_OPERATIONAL_STATUS_REASON;

    typedef struct _STORAGE_OPERATIONAL_REASON
    {
        DWORD Version;
        DWORD Size;
        STORAGE_OPERATIONAL_STATUS_REASON Reason;

        union
        {
            struct
            {
                BYTE SenseKey;
                BYTE ASC;
                BYTE ASCQ;
                BYTE Reserved;
            } ScsiSenseKey;

            struct
            {
                BYTE CriticalHealth;
                BYTE ModuleHealth[2];
                BYTE ErrorThresholdStatus;
            } NVDIMM_N;

            DWORD AsUlong;
        } RawBytes;
    } STORAGE_OPERATIONAL_REASON, *PSTORAGE_OPERATIONAL_REASON;

    typedef struct _STORAGE_DEVICE_MANAGEMENT_STATUS
    {
        DWORD Version;

        DWORD Size;

        STORAGE_DISK_HEALTH_STATUS Health;

        DWORD NumberOfOperationalStatus;

        DWORD NumberOfAdditionalReasons;

        STORAGE_DISK_OPERATIONAL_STATUS OperationalStatus[16];

        STORAGE_OPERATIONAL_REASON AdditionalReasons[1];

    } STORAGE_DEVICE_MANAGEMENT_STATUS, *PSTORAGE_DEVICE_MANAGEMENT_STATUS;

    typedef struct _STORAGE_ADAPTER_SERIAL_NUMBER
    {
        DWORD Version;

        DWORD Size;

        WCHAR SerialNumber[(128)];

    } STORAGE_ADAPTER_SERIAL_NUMBER, *PSTORAGE_ADAPTER_SERIAL_NUMBER;

    typedef enum _STORAGE_ZONED_DEVICE_TYPES
    {
        ZonedDeviceTypeUnknown = 0,
        ZonedDeviceTypeHostManaged,
        ZonedDeviceTypeHostAware,
        ZonedDeviceTypeDeviceManaged,
    } STORAGE_ZONED_DEVICE_TYPES,
    *PSTORAGE_ZONED_DEVICE_TYPES;

    typedef enum _STORAGE_ZONE_TYPES
    {
        ZoneTypeUnknown = 0,
        ZoneTypeConventional = 1,
        ZoneTypeSequentialWriteRequired = 2,
        ZoneTypeSequentialWritePreferred = 3,
        ZoneTypeMax
    } STORAGE_ZONE_TYPES,
    *PSTORAGE_ZONE_TYPES;

    typedef struct _STORAGE_ZONE_GROUP
    {
        DWORD ZoneCount;

        STORAGE_ZONE_TYPES ZoneType;

        DWORDLONG ZoneSize;

    } STORAGE_ZONE_GROUP, *PSTORAGE_ZONE_GROUP;

    typedef struct _STORAGE_ZONED_DEVICE_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        STORAGE_ZONED_DEVICE_TYPES DeviceType;

        DWORD ZoneCount;

        union
        {
            struct
            {
                DWORD MaxOpenZoneCount;

                BOOLEAN UnrestrictedRead;

                BYTE Reserved[3];

            } SequentialRequiredZone;

            struct
            {
                DWORD OptimalOpenZoneCount;

                DWORD Reserved;

            } SequentialPreferredZone;

        } ZoneAttributes;

        DWORD ZoneGroupCount;

        STORAGE_ZONE_GROUP ZoneGroup[1];

    } STORAGE_ZONED_DEVICE_DESCRIPTOR, *PSTORAGE_ZONED_DEVICE_DESCRIPTOR;

#pragma warning(push)
#pragma warning(disable : 4201)
    typedef struct _DEVICE_LOCATION
    {
        DWORD Socket;

        DWORD Slot;

        DWORD Adapter;

        DWORD Port;

        union
        {
            struct
            {
                DWORD Channel;

                DWORD Device;
            };

            struct
            {
                DWORD Target;

                DWORD Lun;
            };
        };

    } DEVICE_LOCATION, *PDEVICE_LOCATION;
#pragma warning(pop)

    typedef struct _STORAGE_DEVICE_LOCATION_DESCRIPTOR
    {
        DWORD Version;

        DWORD Size;

        DEVICE_LOCATION Location;

        DWORD StringOffset;

    } STORAGE_DEVICE_LOCATION_DESCRIPTOR, *PSTORAGE_DEVICE_LOCATION_DESCRIPTOR;

    typedef struct _STORAGE_DEVICE_NUMA_PROPERTY
    {
        DWORD Version;
        DWORD Size;
        DWORD NumaNode;
    } STORAGE_DEVICE_NUMA_PROPERTY, *PSTORAGE_DEVICE_NUMA_PROPERTY;

    typedef struct _STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT
    {
        DWORD Version;
        DWORD Size;
        DWORD UnsafeShutdownCount;
    } STORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT, *PSTORAGE_DEVICE_UNSAFE_SHUTDOWN_COUNT;

    typedef DWORD DEVICE_DATA_MANAGEMENT_SET_ACTION, DEVICE_DSM_ACTION;

    typedef struct _DEVICE_DATA_SET_RANGE
    {
        LONGLONG StartingOffset;
        DWORDLONG LengthInBytes;

    } DEVICE_DATA_SET_RANGE, *PDEVICE_DATA_SET_RANGE, DEVICE_DSM_RANGE, *PDEVICE_DSM_RANGE;

    typedef struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES
    {
        DWORD Size;

        DEVICE_DSM_ACTION Action;
        DWORD Flags;

        DWORD ParameterBlockOffset;
        DWORD ParameterBlockLength;

        DWORD DataSetRangesOffset;
        DWORD DataSetRangesLength;

    } DEVICE_MANAGE_DATA_SET_ATTRIBUTES, *PDEVICE_MANAGE_DATA_SET_ATTRIBUTES, DEVICE_DSM_INPUT, *PDEVICE_DSM_INPUT;

    typedef struct _DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT
    {
        DWORD Size;

        DEVICE_DSM_ACTION Action;
        DWORD Flags;

        DWORD OperationStatus;
        DWORD ExtendedError;
        DWORD TargetDetailedError;
        DWORD ReservedStatus;

        DWORD OutputBlockOffset;
        DWORD OutputBlockLength;

    } DEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT, *PDEVICE_MANAGE_DATA_SET_ATTRIBUTES_OUTPUT, DEVICE_DSM_OUTPUT, *PDEVICE_DSM_OUTPUT;

    typedef struct _DEVICE_DSM_DEFINITION
    {
        DEVICE_DSM_ACTION Action;

        BOOLEAN SingleRange;

        DWORD ParameterBlockAlignment;
        DWORD ParameterBlockLength;

        BOOLEAN HasOutput;

        DWORD OutputBlockAlignment;
        DWORD OutputBlockLength;

    } DEVICE_DSM_DEFINITION, *PDEVICE_DSM_DEFINITION;

    typedef struct _DEVICE_DSM_NOTIFICATION_PARAMETERS
    {
        DWORD Size;

        DWORD Flags;

        DWORD NumFileTypeIDs;
        GUID FileTypeID[1];

    } DEVICE_DSM_NOTIFICATION_PARAMETERS, *PDEVICE_DSM_NOTIFICATION_PARAMETERS;

#pragma warning(push)
#pragma warning(disable : 4201)

    typedef struct _STORAGE_OFFLOAD_TOKEN
    {
        BYTE TokenType[4];
        BYTE Reserved[2];
        BYTE TokenIdLength[2];
        union
        {
            struct
            {
                BYTE Reserved2[0x1F8];
            } StorageOffloadZeroDataToken;
            BYTE Token[0x1F8];
        };

    } STORAGE_OFFLOAD_TOKEN, *PSTORAGE_OFFLOAD_TOKEN;

#pragma warning(pop)

    typedef struct _DEVICE_DSM_OFFLOAD_READ_PARAMETERS
    {
        DWORD Flags;

        DWORD TimeToLive;

        DWORD Reserved[2];

    } DEVICE_DSM_OFFLOAD_READ_PARAMETERS, *PDEVICE_DSM_OFFLOAD_READ_PARAMETERS;

    typedef struct _STORAGE_OFFLOAD_READ_OUTPUT
    {
        DWORD OffloadReadFlags;
        DWORD Reserved;

        DWORDLONG LengthProtected;

        DWORD TokenLength;
        STORAGE_OFFLOAD_TOKEN Token;

    } STORAGE_OFFLOAD_READ_OUTPUT, *PSTORAGE_OFFLOAD_READ_OUTPUT;

    typedef struct _DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS
    {
        DWORD Flags;
        DWORD Reserved;

        DWORDLONG TokenOffset;

        STORAGE_OFFLOAD_TOKEN Token;

    } DEVICE_DSM_OFFLOAD_WRITE_PARAMETERS, *PDEVICE_DSM_OFFLOAD_WRITE_PARAMETERS;

    typedef struct _STORAGE_OFFLOAD_WRITE_OUTPUT
    {
        DWORD OffloadWriteFlags;
        DWORD Reserved;

        DWORDLONG LengthCopied;

    } STORAGE_OFFLOAD_WRITE_OUTPUT, *PSTORAGE_OFFLOAD_WRITE_OUTPUT;

    typedef struct _DEVICE_DATA_SET_LBP_STATE_PARAMETERS
    {
        DWORD Version;
        DWORD Size;

        DWORD Flags;

        DWORD OutputVersion;

    } DEVICE_DATA_SET_LBP_STATE_PARAMETERS, *PDEVICE_DATA_SET_LBP_STATE_PARAMETERS, DEVICE_DSM_ALLOCATION_PARAMETERS,
    *PDEVICE_DSM_ALLOCATION_PARAMETERS;

    typedef struct _DEVICE_DATA_SET_LB_PROVISIONING_STATE
    {
        DWORD Size;
        DWORD Version;

        DWORDLONG SlabSizeInBytes;

        DWORD SlabOffsetDeltaInBytes;

        DWORD SlabAllocationBitMapBitCount;

        DWORD SlabAllocationBitMapLength;

        DWORD SlabAllocationBitMap[1];

    } DEVICE_DATA_SET_LB_PROVISIONING_STATE, *PDEVICE_DATA_SET_LB_PROVISIONING_STATE, DEVICE_DSM_ALLOCATION_OUTPUT,
    *PDEVICE_DSM_ALLOCATION_OUTPUT;

    typedef struct _DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2
    {
        DWORD Size;
        DWORD Version;

        DWORDLONG SlabSizeInBytes;

        DWORDLONG SlabOffsetDeltaInBytes;

        DWORD SlabAllocationBitMapBitCount;

        DWORD SlabAllocationBitMapLength;

        DWORD SlabAllocationBitMap[1];

    } DEVICE_DATA_SET_LB_PROVISIONING_STATE_V2, *PDEVICE_DATA_SET_LB_PROVISIONING_STATE_V2,
    DEVICE_DSM_ALLOCATION_OUTPUT2, *PDEVICE_DSM_ALLOCATION_OUTPUT2;

    typedef struct _DEVICE_DATA_SET_REPAIR_PARAMETERS
    {
        DWORD NumberOfRepairCopies;
        DWORD SourceCopy;
        DWORD RepairCopies[1];

    } DEVICE_DATA_SET_REPAIR_PARAMETERS, *PDEVICE_DATA_SET_REPAIR_PARAMETERS, DEVICE_DSM_REPAIR_PARAMETERS,
    *PDEVICE_DSM_REPAIR_PARAMETERS;

    typedef struct _DEVICE_DATA_SET_REPAIR_OUTPUT
    {
        DEVICE_DSM_RANGE ParityExtent;

    } DEVICE_DATA_SET_REPAIR_OUTPUT, *PDEVICE_DATA_SET_REPAIR_OUTPUT, DEVICE_DSM_REPAIR_OUTPUT, *PDEVICE_DSM_REPAIR_OUTPUT;

    typedef struct _DEVICE_DATA_SET_SCRUB_OUTPUT
    {
        DWORDLONG BytesProcessed;
        DWORDLONG BytesRepaired;
        DWORDLONG BytesFailed;

    } DEVICE_DATA_SET_SCRUB_OUTPUT, *PDEVICE_DATA_SET_SCRUB_OUTPUT, DEVICE_DSM_SCRUB_OUTPUT, *PDEVICE_DSM_SCRUB_OUTPUT;

    typedef struct _DEVICE_DATA_SET_SCRUB_EX_OUTPUT
    {
        DWORDLONG BytesProcessed;
        DWORDLONG BytesRepaired;
        DWORDLONG BytesFailed;

        DEVICE_DSM_RANGE ParityExtent;

    } DEVICE_DATA_SET_SCRUB_EX_OUTPUT, *PDEVICE_DATA_SET_SCRUB_EX_OUTPUT, DEVICE_DSM_SCRUB_OUTPUT2, *PDEVICE_DSM_SCRUB_OUTPUT2;

    typedef struct _DEVICE_DSM_TIERING_QUERY_INPUT
    {
        DWORD Version;
        DWORD Size;

        DWORD Flags;

        DWORD NumberOfTierIds;
        GUID TierIds[1];

    } DEVICE_DSM_TIERING_QUERY_INPUT, *PDEVICE_DSM_TIERING_QUERY_INPUT, DEVICE_DSM_TIERING_QUERY_PARAMETERS,
    *PDEVICE_DSM_TIERING_QUERY_PARAMETERS;

    typedef struct _STORAGE_TIER_REGION
    {
        GUID TierId;

        DWORDLONG Offset;
        DWORDLONG Length;

    } STORAGE_TIER_REGION, *PSTORAGE_TIER_REGION;

    typedef struct _DEVICE_DSM_TIERING_QUERY_OUTPUT
    {
        DWORD Version;
        DWORD Size;

        DWORD Flags;
        DWORD Reserved;

        DWORDLONG Alignment;

        DWORD TotalNumberOfRegions;

        DWORD NumberOfRegionsReturned;
        STORAGE_TIER_REGION Regions[1];

    } DEVICE_DSM_TIERING_QUERY_OUTPUT, *PDEVICE_DSM_TIERING_QUERY_OUTPUT;

    typedef struct _DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS
    {
        DWORD Size;

        BYTE TargetPriority;
        BYTE Reserved[3];

    } DEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS, *PDEVICE_DSM_NVCACHE_CHANGE_PRIORITY_PARAMETERS;

    typedef struct _DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT
    {
        DWORDLONG TopologyRangeBytes;

        BYTE TopologyId[16];

    } DEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT, *PDEVICE_DATA_SET_TOPOLOGY_ID_QUERY_OUTPUT,
    DEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT, *PDEVICE_DSM_TOPOLOGY_ID_QUERY_OUTPUT;

    typedef struct _DEVICE_STORAGE_ADDRESS_RANGE
    {
        LONGLONG StartAddress;
        DWORDLONG LengthInBytes;

    } DEVICE_STORAGE_ADDRESS_RANGE, *PDEVICE_STORAGE_ADDRESS_RANGE;

    typedef struct _DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT
    {
        DWORD Version;

        DWORD Flags;

        DWORD TotalNumberOfRanges;

        DWORD NumberOfRangesReturned;
        DEVICE_STORAGE_ADDRESS_RANGE Ranges[1];

    } DEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT, *PDEVICE_DSM_PHYSICAL_ADDRESSES_OUTPUT;

    typedef struct _DEVICE_DSM_REPORT_ZONES_PARAMETERS
    {
        DWORD Size;

        BYTE ReportOption;

        BYTE Partial;

        BYTE Reserved[2];

    } DEVICE_DSM_REPORT_ZONES_PARAMETERS, *PDEVICE_DSM_REPORT_ZONES_PARAMETERS;

    typedef enum _STORAGE_ZONES_ATTRIBUTES
    {

        ZonesAttributeTypeAndLengthMayDifferent = 0,
        ZonesAttributeTypeSameLengthSame = 1,
        ZonesAttributeTypeSameLastZoneLengthDifferent = 2,
        ZonesAttributeTypeMayDifferentLengthSame = 3,

    } STORAGE_ZONES_ATTRIBUTES,
    *PSTORAGE_ZONES_ATTRIBUTES;

    typedef enum _STORAGE_ZONE_CONDITION
    {

        ZoneConditionConventional = 0x00,
        ZoneConditionEmpty = 0x01,
        ZoneConditionImplicitlyOpened = 0x02,
        ZoneConditionExplicitlyOpened = 0x03,
        ZoneConditionClosed = 0x04,

        ZoneConditionReadOnly = 0x0D,
        ZoneConditionFull = 0x0E,
        ZoneConditionOffline = 0x0F,

    } STORAGE_ZONE_CONDITION,
    *PSTORAGE_ZONE_CONDITION;

    typedef struct _STORAGE_ZONE_DESCRIPTOR
    {
        DWORD Size;

        STORAGE_ZONE_TYPES ZoneType;
        STORAGE_ZONE_CONDITION ZoneCondition;

        BOOLEAN ResetWritePointerRecommend;
        BYTE Reserved0[3];

        DWORDLONG ZoneSize;
        DWORDLONG WritePointerOffset;

    } STORAGE_ZONE_DESCRIPTOR, *PSTORAGE_ZONE_DESCRIPTOR;

    typedef struct _DEVICE_DSM_REPORT_ZONES_DATA
    {
        DWORD Size;

        DWORD ZoneCount;
        STORAGE_ZONES_ATTRIBUTES Attributes;

        DWORD Reserved0;

        STORAGE_ZONE_DESCRIPTOR ZoneDescriptors[1];

    } DEVICE_DSM_REPORT_ZONES_DATA, *PDEVICE_DSM_REPORT_ZONES_DATA, DEVICE_DSM_REPORT_ZONES_OUTPUT, *PDEVICE_DSM_REPORT_ZONES_OUTPUT;

#pragma warning(push)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)

    typedef struct _DEVICE_STORAGE_RANGE_ATTRIBUTES
    {
        DWORDLONG LengthInBytes;

        union
        {
            DWORD AllFlags;

            struct
            {
                DWORD IsRangeBad : 1;
            };
        };

        DWORD Reserved;

    } DEVICE_STORAGE_RANGE_ATTRIBUTES, *PDEVICE_STORAGE_RANGE_ATTRIBUTES;

#pragma warning(pop)

    typedef struct _DEVICE_DSM_RANGE_ERROR_INFO
    {
        DWORD Version;

        DWORD Flags;

        DWORD TotalNumberOfRanges;

        DWORD NumberOfRangesReturned;
        DEVICE_STORAGE_RANGE_ATTRIBUTES Ranges[1];

    } DEVICE_DSM_RANGE_ERROR_INFO, *PDEVICE_DSM_RANGE_ERROR_INFO, DEVICE_DSM_RANGE_ERROR_OUTPUT, *PDEVICE_DSM_RANGE_ERROR_OUTPUT;

    typedef struct _DEVICE_DSM_LOST_QUERY_PARAMETERS
    {
        DWORD Version;

        DWORDLONG Granularity;

    } DEVICE_DSM_LOST_QUERY_PARAMETERS, *PDEVICE_DSM_LOST_QUERY_PARAMETERS;

    typedef struct _DEVICE_DSM_LOST_QUERY_OUTPUT
    {
        DWORD Version;

        DWORD Size;

        DWORDLONG Alignment;

        DWORD NumberOfBits;
        DWORD BitMap[1];

    } DEVICE_DSM_LOST_QUERY_OUTPUT, *PDEVICE_DSM_LOST_QUERY_OUTPUT;

    typedef struct _DEVICE_DSM_FREE_SPACE_OUTPUT
    {
        DWORD Version;

        DWORDLONG FreeSpace;

    } DEVICE_DSM_FREE_SPACE_OUTPUT, *PDEVICE_DSM_FREE_SPACE_OUTPUT;

    __forceinline PVOID DeviceDsmParameterBlock(PDEVICE_DSM_INPUT Input)
    {
        return (PVOID)((DWORD_PTR)Input + Input->ParameterBlockOffset);
    }

    __forceinline PDEVICE_DSM_RANGE DeviceDsmDataSetRanges(PDEVICE_DSM_INPUT Input)
    {
        return (PDEVICE_DSM_RANGE)((DWORD_PTR)Input + Input->DataSetRangesOffset);
    }

    __forceinline DWORD DeviceDsmNumberOfDataSetRanges(PDEVICE_DSM_INPUT Input)
    {
        return Input->DataSetRangesLength / sizeof(DEVICE_DSM_RANGE);
    }

    __forceinline DWORD DeviceDsmGetInputLength(PDEVICE_DSM_DEFINITION Definition, DWORD ParameterBlockLength, DWORD NumberOfDataSetRanges)
    {
        DWORD Bytes = sizeof(DEVICE_DSM_INPUT);

        if(ParameterBlockLength != 0)
        {
            Bytes = (((Bytes) + ((Definition->ParameterBlockAlignment) - 1)) / (Definition->ParameterBlockAlignment)
                     * (Definition->ParameterBlockAlignment));
            Bytes += ParameterBlockLength;
        }

        if(NumberOfDataSetRanges != 0)
        {
            Bytes = (((Bytes) + ((__alignof(DEVICE_DSM_RANGE)) - 1)) / (__alignof(DEVICE_DSM_RANGE)) * (__alignof(DEVICE_DSM_RANGE)));
            Bytes += sizeof(DEVICE_DSM_RANGE) * NumberOfDataSetRanges;
        }

        return Bytes;
    }

    __forceinline DWORD DeviceDsmGetNumberOfDataSetRanges(PDEVICE_DSM_DEFINITION Definition, DWORD InputLength, DWORD ParameterBlockLength)
    {
        DWORD Bytes = sizeof(DEVICE_DSM_INPUT);

        if(ParameterBlockLength != 0)
        {
            Bytes = (((Bytes) + ((Definition->ParameterBlockAlignment) - 1)) / (Definition->ParameterBlockAlignment)
                     * (Definition->ParameterBlockAlignment));
            Bytes += ParameterBlockLength;
        }

        Bytes = (((Bytes) + ((__alignof(DEVICE_DSM_RANGE)) - 1)) / (__alignof(DEVICE_DSM_RANGE)) * (__alignof(DEVICE_DSM_RANGE)));
        Bytes = InputLength - Bytes;

        return Bytes / sizeof(DEVICE_DSM_RANGE);
    }

    __forceinline void DeviceDsmInitializeInput(
    PDEVICE_DSM_DEFINITION Definition, PDEVICE_DSM_INPUT Input, DWORD InputLength, DWORD Flags, PVOID Parameters, DWORD ParameterBlockLength)
    {
        DWORD Bytes = sizeof(DEVICE_DSM_INPUT);

        memset((Input), 0, (InputLength));

        Input->Size = Bytes;
        Input->Action = Definition->Action;
        Input->Flags = Flags;

        if(ParameterBlockLength == 0)
        {
            goto Cleanup;
        }

        Bytes = (((Bytes) + ((Definition->ParameterBlockAlignment) - 1)) / (Definition->ParameterBlockAlignment)
                 * (Definition->ParameterBlockAlignment));

        Input->ParameterBlockOffset = Bytes;
        Input->ParameterBlockLength = ParameterBlockLength;

        if(!Parameters)
        {
            goto Cleanup;
        }

        memcpy((DeviceDsmParameterBlock(Input)), (Parameters), (Input->ParameterBlockLength));

    Cleanup:

        return;
    }

    __forceinline BOOLEAN DeviceDsmAddDataSetRange(PDEVICE_DSM_INPUT Input, DWORD InputLength, LONGLONG Offset, DWORDLONG Length)
    {
        DWORD Bytes = 0;
        DWORD Index = 0;
        PDEVICE_DSM_RANGE Ranges = 0;
        BOOLEAN Return = 0;

        if(Input->Flags & 0x00000001)
        {
            goto Cleanup;
        }

        if(Input->DataSetRangesLength == 0)
        {
            if(Input->ParameterBlockLength == 0)
            {
                Bytes = sizeof(DEVICE_DSM_INPUT);
            }
            else
            {
                Bytes = Input->ParameterBlockOffset + Input->ParameterBlockLength;
            }

            Bytes = (((Bytes) + ((__alignof(DEVICE_DSM_RANGE)) - 1)) / (__alignof(DEVICE_DSM_RANGE)) * (__alignof(DEVICE_DSM_RANGE)));
        }
        else
        {
            Bytes = Input->DataSetRangesOffset + Input->DataSetRangesLength;
        }

        if((InputLength - Bytes) < sizeof(DEVICE_DSM_RANGE))
        {
            goto Cleanup;
        }

        if(Input->DataSetRangesOffset == 0)
        {
            Input->DataSetRangesOffset = Bytes;
        }

        Ranges = DeviceDsmDataSetRanges(Input);
        Index = DeviceDsmNumberOfDataSetRanges(Input);

        Ranges[Index].StartingOffset = Offset;
        Ranges[Index].LengthInBytes = Length;

        Input->DataSetRangesLength += sizeof(DEVICE_DSM_RANGE);

        Return = 1;

    Cleanup:

        return Return;
    }

    __forceinline BOOLEAN DeviceDsmValidateInput(PDEVICE_DSM_DEFINITION Definition, PDEVICE_DSM_INPUT Input, DWORD InputLength)
    {
        DWORD Max = 0;
        DWORD Min = 0;
        BOOLEAN Valid = 0;

        if(Definition->Action != Input->Action)
        {
            goto Cleanup;
        }

        if(Definition->ParameterBlockLength != 0)
        {
            Min = sizeof(*Input);
            Max = InputLength;

            if(Input->ParameterBlockOffset < Min || Input->ParameterBlockOffset > Max
               || Input->ParameterBlockOffset % Definition->ParameterBlockAlignment)
            {
                goto Cleanup;
            }

            Min = Definition->ParameterBlockLength;
            Max = InputLength - Input->ParameterBlockOffset;

            if(Input->ParameterBlockLength < Min || Input->ParameterBlockLength > Max)
            {
                goto Cleanup;
            }
        }

        if(!(Input->Flags & 0x00000001))
        {
            Min = sizeof(*Input);
            Max = InputLength;

            if(Input->DataSetRangesOffset < Min || Input->DataSetRangesOffset > Max
               || Input->DataSetRangesOffset % __alignof(DEVICE_DSM_RANGE))
            {
                goto Cleanup;
            }

            Min = sizeof(DEVICE_DSM_RANGE);
            Max = InputLength - Input->DataSetRangesOffset;

            if(Input->DataSetRangesLength < Min || Input->DataSetRangesLength > Max || Input->DataSetRangesLength % Min)
            {
                goto Cleanup;
            }

            if(Definition->SingleRange && Input->DataSetRangesLength != Min)
            {
                goto Cleanup;
            }
        }
        else
        {
            if(Input->DataSetRangesOffset != 0 || Input->DataSetRangesLength != 0)
            {
                goto Cleanup;
            }
        }

        if(Input->ParameterBlockOffset < Input->DataSetRangesOffset
           && Input->ParameterBlockOffset + Input->ParameterBlockLength > Input->DataSetRangesOffset)
        {
            goto Cleanup;
        }

        if(Input->DataSetRangesOffset < Input->ParameterBlockOffset
           && Input->DataSetRangesOffset + Input->DataSetRangesLength > Input->ParameterBlockOffset)
        {
            goto Cleanup;
        }

        Valid = 1;

    Cleanup:

        return Valid;
    }

    __forceinline PVOID DeviceDsmOutputBlock(PDEVICE_DSM_OUTPUT Output)
    {
        return (PVOID)((DWORD_PTR)Output + Output->OutputBlockOffset);
    }

    __forceinline DWORD DeviceDsmGetOutputLength(PDEVICE_DSM_DEFINITION Definition, DWORD OutputBlockLength)
    {
        DWORD Bytes = sizeof(DEVICE_DSM_OUTPUT);

        if(OutputBlockLength == 0)
        {
            goto Cleanup;
        }

        Bytes = (((Bytes) + ((Definition->OutputBlockAlignment) - 1)) / (Definition->OutputBlockAlignment)
                 * (Definition->OutputBlockAlignment));
        Bytes += OutputBlockLength;

    Cleanup:

        return Bytes;
    }

    __forceinline DWORD DeviceDsmGetOutputBlockLength(PDEVICE_DSM_DEFINITION Definition, DWORD OutputLength)
    {
        DWORD Bytes = 0;

        if(Definition->OutputBlockLength == 0)
        {
            goto Cleanup;
        }

        Bytes = sizeof(DEVICE_DSM_OUTPUT);
        Bytes = (((Bytes) + ((Definition->OutputBlockAlignment) - 1)) / (Definition->OutputBlockAlignment)
                 * (Definition->OutputBlockAlignment));
        Bytes = OutputLength - Bytes;

    Cleanup:

        return Bytes;
    }

    __forceinline void
    DeviceDsmInitializeOutput(PDEVICE_DSM_DEFINITION Definition, PDEVICE_DSM_OUTPUT Output, DWORD OutputLength, DWORD Flags)
    {
        DWORD Bytes = sizeof(DEVICE_DSM_OUTPUT);

        memset((Output), 0, (OutputLength));

        Output->Size = Bytes;
        Output->Action = Definition->Action;
        Output->Flags = Flags;

        if(Definition->OutputBlockLength != 0)
        {
            Bytes = (((Bytes) + ((Definition->OutputBlockAlignment) - 1)) / (Definition->OutputBlockAlignment)
                     * (Definition->OutputBlockAlignment));

            Output->OutputBlockOffset = Bytes;
            Output->OutputBlockLength = OutputLength - Bytes;
        }

        return;
    }

    __forceinline BOOLEAN DeviceDsmValidateOutput(PDEVICE_DSM_DEFINITION Definition, PDEVICE_DSM_OUTPUT Output, DWORD OutputLength)
    {
        DWORD Max = 0;
        DWORD Min = 0;
        BOOLEAN Valid = 0;

        if(Definition->Action != Output->Action)
        {
            goto Cleanup;
        }

        if(!Definition->HasOutput)
        {
            goto Cleanup;
        }

        if(Definition->OutputBlockLength != 0)
        {
            Min = sizeof(*Output);
            Max = OutputLength;

            if(Output->OutputBlockOffset < Min || Output->OutputBlockOffset > Max
               || Output->OutputBlockOffset % Definition->OutputBlockAlignment)
            {
                goto Cleanup;
            }

            Min = Definition->OutputBlockLength;
            Max = OutputLength - Output->OutputBlockOffset;

            if(Output->OutputBlockLength < Min || Output->OutputBlockLength > Max)
            {
                goto Cleanup;
            }
        }
        else
        {
            if(Output->OutputBlockOffset != 0 || Output->OutputBlockLength != 0)
            {
                goto Cleanup;
            }
        }

        Valid = 1;

    Cleanup:

        return Valid;
    }

    typedef struct _STORAGE_GET_BC_PROPERTIES_OUTPUT
    {
        DWORD MaximumRequestsPerPeriod;

        DWORD MinimumPeriod;

        DWORDLONG MaximumRequestSize;

        DWORD EstimatedTimePerRequest;

        DWORD NumOutStandingRequests;

        DWORDLONG RequestSize;

    } STORAGE_GET_BC_PROPERTIES_OUTPUT, *PSTORAGE_GET_BC_PROPERTIES_OUTPUT;

    typedef struct _STORAGE_ALLOCATE_BC_STREAM_INPUT
    {
        DWORD Version;

        DWORD RequestsPerPeriod;

        DWORD Period;

        BOOLEAN RetryFailures;

        BOOLEAN Discardable;

        BOOLEAN Reserved1[2];

        DWORD AccessType;

        DWORD AccessMode;

    } STORAGE_ALLOCATE_BC_STREAM_INPUT, *PSTORAGE_ALLOCATE_BC_STREAM_INPUT;

    typedef struct _STORAGE_ALLOCATE_BC_STREAM_OUTPUT
    {
        DWORDLONG RequestSize;

        DWORD NumOutStandingRequests;

    } STORAGE_ALLOCATE_BC_STREAM_OUTPUT, *PSTORAGE_ALLOCATE_BC_STREAM_OUTPUT;

    typedef struct _STORAGE_PRIORITY_HINT_SUPPORT
    {
        DWORD SupportFlags;
    } STORAGE_PRIORITY_HINT_SUPPORT, *PSTORAGE_PRIORITY_HINT_SUPPORT;

    typedef enum _STORAGE_DIAGNOSTIC_LEVEL
    {
        StorageDiagnosticLevelDefault = 0,
        StorageDiagnosticLevelMax
    } STORAGE_DIAGNOSTIC_LEVEL,
    *PSTORAGE_DIAGNOSTIC_LEVEL;

    typedef enum _STORAGE_DIAGNOSTIC_TARGET_TYPE
    {

        StorageDiagnosticTargetTypeUndefined = 0,
        StorageDiagnosticTargetTypePort,
        StorageDiagnosticTargetTypeMiniport,
        StorageDiagnosticTargetTypeHbaFirmware,
        StorageDiagnosticTargetTypeMax

    } STORAGE_DIAGNOSTIC_TARGET_TYPE,
    *PSTORAGE_DIAGNOSTIC_TARGET_TYPE;

    typedef struct _STORAGE_DIAGNOSTIC_REQUEST
    {
        DWORD Version;

        DWORD Size;

        DWORD Reserved;

        STORAGE_DIAGNOSTIC_TARGET_TYPE TargetType;

        STORAGE_DIAGNOSTIC_LEVEL Level;

    } STORAGE_DIAGNOSTIC_REQUEST, *PSTORAGE_DIAGNOSTIC_REQUEST;

    typedef struct _STORAGE_DIAGNOSTIC_DATA
    {
        DWORD Version;

        DWORD Size;

        GUID ProviderId;

        DWORD BufferSize;

        DWORD Reserved;

        BYTE DiagnosticDataBuffer[1];

    } STORAGE_DIAGNOSTIC_DATA, *PSTORAGE_DIAGNOSTIC_DATA;

    typedef struct _PHYSICAL_ELEMENT_STATUS_REQUEST
    {
        DWORD Version;
        DWORD Size;

        DWORD StartingElement;
        BYTE Filter;
        BYTE ReportType;
        BYTE Reserved[2];

    } PHYSICAL_ELEMENT_STATUS_REQUEST, *PPHYSICAL_ELEMENT_STATUS_REQUEST;

    typedef struct _PHYSICAL_ELEMENT_STATUS_DESCRIPTOR
    {
        DWORD Version;
        DWORD Size;

        DWORD ElementIdentifier;
        BYTE PhysicalElementType;
        BYTE PhysicalElementHealth;
        BYTE Reserved1[2];

        DWORDLONG AssociatedCapacity;

        DWORD Reserved2[4];

    } PHYSICAL_ELEMENT_STATUS_DESCRIPTOR, *PPHYSICAL_ELEMENT_STATUS_DESCRIPTOR;

    typedef struct _PHYSICAL_ELEMENT_STATUS
    {
        DWORD Version;
        DWORD Size;

        DWORD DescriptorCount;
        DWORD ReturnedDescriptorCount;

        DWORD ElementIdentifierBeingDepoped;
        DWORD Reserved;

        PHYSICAL_ELEMENT_STATUS_DESCRIPTOR Descriptors[1];

    } PHYSICAL_ELEMENT_STATUS, *PPHYSICAL_ELEMENT_STATUS;

    typedef struct _REMOVE_ELEMENT_AND_TRUNCATE_REQUEST
    {
        DWORD Version;
        DWORD Size;

        DWORDLONG RequestCapacity;

        DWORD ElementIdentifier;
        DWORD Reserved;

    } REMOVE_ELEMENT_AND_TRUNCATE_REQUEST, *PREMOVE_ELEMENT_AND_TRUNCATE_REQUEST;

#pragma warning(push)
#pragma warning(disable : 4200)

    typedef struct _STORAGE_MEDIA_SERIAL_NUMBER_DATA
    {
        WORD Reserved;

        WORD SerialNumberLength;

        BYTE SerialNumber[0];

    } STORAGE_MEDIA_SERIAL_NUMBER_DATA, *PSTORAGE_MEDIA_SERIAL_NUMBER_DATA;

    typedef struct _STORAGE_READ_CAPACITY
    {
        DWORD Version;

        DWORD Size;

        DWORD BlockLength;

        LARGE_INTEGER NumberOfBlocks;

        LARGE_INTEGER DiskLength;

    } STORAGE_READ_CAPACITY, *PSTORAGE_READ_CAPACITY;

#pragma warning(pop)

    typedef enum _WRITE_CACHE_TYPE
    {
        WriteCacheTypeUnknown,
        WriteCacheTypeNone,
        WriteCacheTypeWriteBack,
        WriteCacheTypeWriteThrough
    } WRITE_CACHE_TYPE;

    typedef enum _WRITE_CACHE_ENABLE
    {
        WriteCacheEnableUnknown,
        WriteCacheDisabled,
        WriteCacheEnabled
    } WRITE_CACHE_ENABLE;

    typedef enum _WRITE_CACHE_CHANGE
    {
        WriteCacheChangeUnknown,
        WriteCacheNotChangeable,
        WriteCacheChangeable
    } WRITE_CACHE_CHANGE;

    typedef enum _WRITE_THROUGH
    {
        WriteThroughUnknown,
        WriteThroughNotSupported,
        WriteThroughSupported
    } WRITE_THROUGH;

    typedef struct _STORAGE_WRITE_CACHE_PROPERTY
    {
        DWORD Version;

        DWORD Size;

        WRITE_CACHE_TYPE WriteCacheType;

        WRITE_CACHE_ENABLE WriteCacheEnabled;

        WRITE_CACHE_CHANGE WriteCacheChangeable;

        WRITE_THROUGH WriteThroughSupported;

        BOOLEAN FlushCacheSupported;

        BOOLEAN UserDefinedPowerProtection;

        BOOLEAN NVCacheEnabled;

    } STORAGE_WRITE_CACHE_PROPERTY, *PSTORAGE_WRITE_CACHE_PROPERTY;

#pragma warning(push)
#pragma warning(disable : 4200)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)

    typedef struct _PERSISTENT_RESERVE_COMMAND
    {
        DWORD Version;
        DWORD Size;

        union
        {
            struct
            {
                BYTE ServiceAction : 5;
                BYTE Reserved1 : 3;

                WORD AllocationLength;

            } PR_IN;

            struct
            {
                BYTE ServiceAction : 5;
                BYTE Reserved1 : 3;

                BYTE Type : 4;
                BYTE Scope : 4;

                BYTE ParameterList[0];

            } PR_OUT;
        };

    } PERSISTENT_RESERVE_COMMAND, *PPERSISTENT_RESERVE_COMMAND;

#pragma warning(pop)

#pragma warning(push)

    typedef enum _DEVICEDUMP_COLLECTION_TYPE
    {
        TCCollectionBugCheck = 1,
        TCCollectionApplicationRequested,
        TCCollectionDeviceRequested
    } DEVICEDUMP_COLLECTION_TYPEIDE_NOTIFICATION_TYPE,
    *PDEVICEDUMP_COLLECTION_TYPE;

#pragma warning(disable : 4103)

#pragma pack(push, 1)

    typedef struct _DEVICEDUMP_SUBSECTION_POINTER
    {
        DWORD dwSize;
        DWORD dwFlags;
        DWORD dwOffset;
    } DEVICEDUMP_SUBSECTION_POINTER, *PDEVICEDUMP_SUBSECTION_POINTER;

    typedef struct _DEVICEDUMP_STRUCTURE_VERSION
    {
        DWORD dwSignature;

        DWORD dwVersion;

        DWORD dwSize;

    } DEVICEDUMP_STRUCTURE_VERSION, *PDEVICEDUMP_STRUCTURE_VERSION;

    typedef struct _DEVICEDUMP_SECTION_HEADER
    {
        GUID guidDeviceDataId;

        BYTE sOrganizationID[16];

        DWORD dwFirmwareRevision;

        BYTE sModelNumber[32];

        BYTE szDeviceManufacturingID[32];

        DWORD dwFlags;

        DWORD bRestrictedPrivateDataVersion;

        DWORD dwFirmwareIssueId;

        BYTE szIssueDescriptionString[132];

    } DEVICEDUMP_SECTION_HEADER, *PDEVICEDUMP_SECTION_HEADER;

    typedef struct _GP_LOG_PAGE_DESCRIPTOR
    {
        WORD LogAddress;
        WORD LogSectors;
    } GP_LOG_PAGE_DESCRIPTOR, *PGP_LOG_PAGE_DESCRIPTOR;

    typedef struct _DEVICEDUMP_PUBLIC_SUBSECTION
    {
        DWORD dwFlags;
        GP_LOG_PAGE_DESCRIPTOR GPLogTable[16];
        CHAR szDescription[16];
        BYTE bData[1];
    } DEVICEDUMP_PUBLIC_SUBSECTION, *PDEVICEDUMP_PUBLIC_SUBSECTION;

    typedef struct _DEVICEDUMP_RESTRICTED_SUBSECTION
    {
        BYTE bData[1];

    } DEVICEDUMP_RESTRICTED_SUBSECTION, *PDEVICEDUMP_RESTRICTED_SUBSECTION;

    typedef struct _DEVICEDUMP_PRIVATE_SUBSECTION
    {
        DWORD dwFlags;
        GP_LOG_PAGE_DESCRIPTOR GPLogId;

        BYTE bData[1];

    } DEVICEDUMP_PRIVATE_SUBSECTION, *PDEVICEDUMP_PRIVATE_SUBSECTION;

    typedef struct _DEVICEDUMP_STORAGEDEVICE_DATA
    {
        DEVICEDUMP_STRUCTURE_VERSION Descriptor;

        DEVICEDUMP_SECTION_HEADER SectionHeader;

        DWORD dwBufferSize;

        DWORD dwReasonForCollection;

        DEVICEDUMP_SUBSECTION_POINTER PublicData;
        DEVICEDUMP_SUBSECTION_POINTER RestrictedData;
        DEVICEDUMP_SUBSECTION_POINTER PrivateData;

    } DEVICEDUMP_STORAGEDEVICE_DATA, *PDEVICEDUMP_STORAGEDEVICE_DATA;

    typedef struct _DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD
    {
        BYTE Cdb[16];

        BYTE Command[16];

        DWORDLONG StartTime;

        DWORDLONG EndTime;

        DWORD OperationStatus;

        DWORD OperationError;

        union
        {
            struct
            {
                DWORD dwReserved;
            } ExternalStack;

            struct
            {
                DWORD dwAtaPortSpecific;
            } AtaPort;

            struct
            {
                DWORD SrbTag;
            } StorPort;

        } StackSpecific;

    } DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD, *PDEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD;

    typedef struct _DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP
    {
        DEVICEDUMP_STRUCTURE_VERSION Descriptor;

        DWORD dwReasonForCollection;

        BYTE cDriverName[16];

        DWORD uiNumRecords;

        DEVICEDUMP_STORAGESTACK_PUBLIC_STATE_RECORD RecordArray[1];

    } DEVICEDUMP_STORAGESTACK_PUBLIC_DUMP, *PDEVICEDUMP_STORAGESTACK_PUBLIC_DUMP;

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(push)
#pragma warning(disable : 4214)

    typedef struct _STORAGE_IDLE_POWER
    {
        DWORD Version;
        DWORD Size;
        DWORD WakeCapableHint : 1;
        DWORD D3ColdSupported : 1;
        DWORD Reserved : 30;
        DWORD D3IdleTimeout;
    } STORAGE_IDLE_POWER, *PSTORAGE_IDLE_POWER;

#pragma warning(pop)

    typedef enum _STORAGE_POWERUP_REASON_TYPE
    {
        StoragePowerupUnknown = 0,
        StoragePowerupIO,
        StoragePowerupDeviceAttention
    } STORAGE_POWERUP_REASON_TYPE,
    *PSTORAGE_POWERUP_REASON_TYPE;

    typedef struct _STORAGE_IDLE_POWERUP_REASON
    {
        DWORD Version;
        DWORD Size;
        STORAGE_POWERUP_REASON_TYPE PowerupReason;
    } STORAGE_IDLE_POWERUP_REASON, *PSTORAGE_IDLE_POWERUP_REASON;

    typedef enum _STORAGE_DEVICE_POWER_CAP_UNITS
    {
        StorageDevicePowerCapUnitsPercent,
        StorageDevicePowerCapUnitsMilliwatts
    } STORAGE_DEVICE_POWER_CAP_UNITS,
    *PSTORAGE_DEVICE_POWER_CAP_UNITS;

    typedef struct _STORAGE_DEVICE_POWER_CAP
    {
        DWORD Version;
        DWORD Size;
        STORAGE_DEVICE_POWER_CAP_UNITS Units;
        DWORDLONG MaxPower;
    } STORAGE_DEVICE_POWER_CAP, *PSTORAGE_DEVICE_POWER_CAP;

#pragma pack(push)
#pragma pack(1)

    typedef struct _STORAGE_RPMB_DATA_FRAME
    {
        BYTE Stuff[196];

        BYTE KeyOrMAC[32];

        BYTE Data[256];

        BYTE Nonce[16];

        BYTE WriteCounter[4];

        BYTE Address[2];

        BYTE BlockCount[2];

        BYTE OperationResult[2];

        BYTE RequestOrResponseType[2];

    } STORAGE_RPMB_DATA_FRAME, *PSTORAGE_RPMB_DATA_FRAME;

    typedef enum _STORAGE_RPMB_COMMAND_TYPE
    {
        StorRpmbProgramAuthKey = 0x00000001,
        StorRpmbQueryWriteCounter = 0x00000002,
        StorRpmbAuthenticatedWrite = 0x00000003,
        StorRpmbAuthenticatedRead = 0x00000004,
        StorRpmbReadResultRequest = 0x00000005,
        StorRpmbAuthenticatedDeviceConfigWrite = 0x00000006,
        StorRpmbAuthenticatedDeviceConfigRead = 0x00000007,
    } STORAGE_RPMB_COMMAND_TYPE,
    *PSTORAGE_RPMB_COMMAND_TYPE;

#pragma pack(pop)

    typedef struct _STORAGE_EVENT_NOTIFICATION
    {
        DWORD Version;
        DWORD Size;
        DWORDLONG Events;
    } STORAGE_EVENT_NOTIFICATION, *PSTORAGE_EVENT_NOTIFICATION;

#pragma warning(pop)

    typedef enum _STORAGE_COUNTER_TYPE
    {

        StorageCounterTypeUnknown = 0,

        StorageCounterTypeTemperatureCelsius,
        StorageCounterTypeTemperatureCelsiusMax,
        StorageCounterTypeReadErrorsTotal,
        StorageCounterTypeReadErrorsCorrected,
        StorageCounterTypeReadErrorsUncorrected,
        StorageCounterTypeWriteErrorsTotal,
        StorageCounterTypeWriteErrorsCorrected,
        StorageCounterTypeWriteErrorsUncorrected,
        StorageCounterTypeManufactureDate,
        StorageCounterTypeStartStopCycleCount,
        StorageCounterTypeStartStopCycleCountMax,
        StorageCounterTypeLoadUnloadCycleCount,
        StorageCounterTypeLoadUnloadCycleCountMax,
        StorageCounterTypeWearPercentage,
        StorageCounterTypeWearPercentageWarning,
        StorageCounterTypeWearPercentageMax,
        StorageCounterTypePowerOnHours,
        StorageCounterTypeReadLatency100NSMax,
        StorageCounterTypeWriteLatency100NSMax,
        StorageCounterTypeFlushLatency100NSMax,

        StorageCounterTypeMax

    } STORAGE_COUNTER_TYPE,
    *PSTORAGE_COUNTER_TYPE;

    typedef struct _STORAGE_COUNTER
    {
        STORAGE_COUNTER_TYPE Type;

        union
        {
            struct
            {
                DWORD Week;

                DWORD Year;
            } ManufactureDate;

            DWORDLONG AsUlonglong;
        } Value;

    } STORAGE_COUNTER, *PSTORAGE_COUNTER;

    typedef struct _STORAGE_COUNTERS
    {
        DWORD Version;

        DWORD Size;

        DWORD NumberOfCounters;

        STORAGE_COUNTER Counters[1];

    } STORAGE_COUNTERS, *PSTORAGE_COUNTERS;

    typedef struct _STORAGE_HW_FIRMWARE_INFO_QUERY
    {
        DWORD Version;
        DWORD Size;
        DWORD Flags;
        DWORD Reserved;
    } STORAGE_HW_FIRMWARE_INFO_QUERY, *PSTORAGE_HW_FIRMWARE_INFO_QUERY;

#pragma warning(push)
#pragma warning(disable : 4214)

    typedef struct _STORAGE_HW_FIRMWARE_SLOT_INFO
    {
        DWORD Version;

        DWORD Size;

        BYTE SlotNumber;

        BYTE ReadOnly : 1;

        BYTE Reserved0 : 7;

        BYTE Reserved1[6];

        BYTE Revision[16];

    } STORAGE_HW_FIRMWARE_SLOT_INFO, *PSTORAGE_HW_FIRMWARE_SLOT_INFO;

    typedef struct _STORAGE_HW_FIRMWARE_INFO
    {
        DWORD Version;

        DWORD Size;

        BYTE SupportUpgrade : 1;

        BYTE Reserved0 : 7;

        BYTE SlotCount;

        BYTE ActiveSlot;

        BYTE PendingActivateSlot;

        BOOLEAN FirmwareShared;

        BYTE Reserved[3];

        DWORD ImagePayloadAlignment;

        DWORD ImagePayloadMaxSize;

        STORAGE_HW_FIRMWARE_SLOT_INFO Slot[1];

    } STORAGE_HW_FIRMWARE_INFO, *PSTORAGE_HW_FIRMWARE_INFO;
#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4200)

    typedef struct _STORAGE_HW_FIRMWARE_DOWNLOAD
    {
        DWORD Version;
        DWORD Size;

        DWORD Flags;
        BYTE Slot;
        BYTE Reserved[3];

        DWORDLONG Offset;
        DWORDLONG BufferSize;

        BYTE ImageBuffer[1];

    } STORAGE_HW_FIRMWARE_DOWNLOAD, *PSTORAGE_HW_FIRMWARE_DOWNLOAD;

    typedef struct _STORAGE_HW_FIRMWARE_DOWNLOAD_V2
    {
        DWORD Version;
        DWORD Size;

        DWORD Flags;
        BYTE Slot;
        BYTE Reserved[3];

        DWORDLONG Offset;
        DWORDLONG BufferSize;

        DWORD ImageSize;
        DWORD Reserved2;

        BYTE ImageBuffer[1];

    } STORAGE_HW_FIRMWARE_DOWNLOAD_V2, *PSTORAGE_HW_FIRMWARE_DOWNLOAD_V2;

#pragma warning(pop)

    typedef struct _STORAGE_HW_FIRMWARE_ACTIVATE
    {
        DWORD Version;
        DWORD Size;

        DWORD Flags;
        BYTE Slot;
        BYTE Reserved0[3];

    } STORAGE_HW_FIRMWARE_ACTIVATE, *PSTORAGE_HW_FIRMWARE_ACTIVATE;

    typedef struct _STORAGE_PROTOCOL_COMMAND
    {
        DWORD Version;
        DWORD Length;

        STORAGE_PROTOCOL_TYPE ProtocolType;
        DWORD Flags;

        DWORD ReturnStatus;
        DWORD ErrorCode;

        DWORD CommandLength;
        DWORD ErrorInfoLength;
        DWORD DataToDeviceTransferLength;
        DWORD DataFromDeviceTransferLength;

        DWORD TimeOutValue;

        DWORD ErrorInfoOffset;
        DWORD DataToDeviceBufferOffset;
        DWORD DataFromDeviceBufferOffset;

        DWORD CommandSpecific;
        DWORD Reserved0;

        DWORD FixedProtocolReturnData;
        DWORD Reserved1[3];

        BYTE Command[1];

    } STORAGE_PROTOCOL_COMMAND, *PSTORAGE_PROTOCOL_COMMAND;

    typedef enum _STORAGE_ATTRIBUTE_MGMT_ACTION
    {
        StorAttributeMgmt_ClearAttribute = 0,
        StorAttributeMgmt_SetAttribute = 1,
        StorAttributeMgmt_ResetAttribute = 2
    } STORAGE_ATTRIBUTE_MGMT_ACTION,
    *PSTORAGE_ATTRIBUTE_MGMT_ACTION;

    typedef struct _STORAGE_ATTRIBUTE_MGMT
    {
        DWORD Version;

        DWORD Size;

        STORAGE_ATTRIBUTE_MGMT_ACTION Action;

        DWORD Attribute;

    } STORAGE_ATTRIBUTE_MGMT, *PSTORAGE_ATTRIBUTE_MGMT;

#pragma warning(pop)
}

#pragma warning(push)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)

typedef struct _SCM_PD_HEALTH_NOTIFICATION_DATA
{
    GUID DeviceGuid;

} SCM_PD_HEALTH_NOTIFICATION_DATA, *PSCM_PD_HEALTH_NOTIFICATION_DATA;

typedef struct _SCM_LOGICAL_DEVICE_INSTANCE
{
    DWORD Version;

    DWORD Size;

    GUID DeviceGuid;

    WCHAR SymbolicLink[256];

} SCM_LOGICAL_DEVICE_INSTANCE, *PSCM_LOGICAL_DEVICE_INSTANCE;

typedef struct _SCM_LOGICAL_DEVICES
{
    DWORD Version;

    DWORD Size;

    DWORD DeviceCount;

    SCM_LOGICAL_DEVICE_INSTANCE Devices[1];

} SCM_LOGICAL_DEVICES, *PSCM_LOGICAL_DEVICES;

typedef struct _SCM_PHYSICAL_DEVICE_INSTANCE
{
    DWORD Version;

    DWORD Size;

    DWORD NfitHandle;

    WCHAR SymbolicLink[256];

} SCM_PHYSICAL_DEVICE_INSTANCE, *PSCM_PHYSICAL_DEVICE_INSTANCE;

typedef struct _SCM_PHYSICAL_DEVICES
{
    DWORD Version;

    DWORD Size;

    DWORD DeviceCount;

    SCM_PHYSICAL_DEVICE_INSTANCE Devices[1];

} SCM_PHYSICAL_DEVICES, *PSCM_PHYSICAL_DEVICES;

typedef enum _SCM_REGION_FLAG
{
    ScmRegionFlagNone = 0x0,

    ScmRegionFlagLabel = 0x1

} SCM_REGION_FLAG,
*PSCM_REGION_FLAG;

typedef struct _SCM_REGION
{
    DWORD Version;

    DWORD Size;

    DWORD Flags;

    DWORD NfitHandle;

    GUID LogicalDeviceGuid;

    GUID AddressRangeType;

    DWORD AssociatedId;

    DWORD64 Length;

    DWORD64 StartingDPA;

    DWORD64 BaseSPA;

    DWORD64 SPAOffset;

    DWORD64 RegionOffset;

} SCM_REGION, *PSCM_REGION;

typedef struct _SCM_REGIONS
{
    DWORD Version;

    DWORD Size;

    DWORD RegionCount;

    SCM_REGION Regions[1];

} SCM_REGIONS, *PSCM_REGIONS;

typedef struct _SCM_INTERLEAVED_PD_INFO
{
    DWORD DeviceHandle;

    GUID DeviceGuid;

} SCM_INTERLEAVED_PD_INFO, *PSCM_INTERLEAVED_PD_INFO;

typedef struct _SCM_LD_INTERLEAVE_SET_INFO
{
    DWORD Version;

    DWORD Size;

    DWORD InterleaveSetSize;

    SCM_INTERLEAVED_PD_INFO InterleaveSet[1];

} SCM_LD_INTERLEAVE_SET_INFO, *PSCM_LD_INTERLEAVE_SET_INFO;

typedef enum _SCM_PD_QUERY_TYPE
{
    ScmPhysicalDeviceQuery_Descriptor = 0,
    ScmPhysicalDeviceQuery_IsSupported,

    ScmPhysicalDeviceQuery_Max
} SCM_PD_QUERY_TYPE,
*PSCM_PD_QUERY_TYPE;

typedef enum _SCM_PD_PROPERTY_ID
{

    ScmPhysicalDeviceProperty_DeviceInfo = 0,

    ScmPhysicalDeviceProperty_ManagementStatus,

    ScmPhysicalDeviceProperty_FirmwareInfo,

    ScmPhysicalDeviceProperty_LocationString,

    ScmPhysicalDeviceProperty_DeviceSpecificInfo,

    ScmPhysicalDeviceProperty_DeviceHandle,

    ScmPhysicalDeviceProperty_Max
} SCM_PD_PROPERTY_ID,
*PSCM_PD_PROPERTY_ID;

typedef struct _SCM_PD_PROPERTY_QUERY
{
    DWORD Version;

    DWORD Size;

    SCM_PD_PROPERTY_ID PropertyId;

    SCM_PD_QUERY_TYPE QueryType;

    BYTE AdditionalParameters[1];

} SCM_PD_PROPERTY_QUERY, *PSCM_PD_PROPERTY_QUERY;

typedef struct _SCM_PD_DESCRIPTOR_HEADER
{
    DWORD Version;

    DWORD Size;
} SCM_PD_DESCRIPTOR_HEADER, *PSCM_PD_DESCRIPTOR_HEADER;

typedef struct _SCM_PD_DEVICE_HANDLE
{
    DWORD Version;

    DWORD Size;

    GUID DeviceGuid;

    DWORD DeviceHandle;

} SCM_PD_DEVICE_HANDLE, *PSCM_PD_DEVICE_HANDLE;

typedef struct _SCM_PD_DEVICE_INFO
{
    DWORD Version;

    DWORD Size;

    GUID DeviceGuid;

    DWORD UnsafeShutdownCount;

    DWORD64 PersistentMemorySizeInBytes;

    DWORD64 VolatileMemorySizeInBytes;

    DWORD64 TotalMemorySizeInBytes;

    DWORD SlotNumber;

    DWORD DeviceHandle;

    WORD PhysicalId;

    BYTE NumberOfFormatInterfaceCodes;
    WORD FormatInterfaceCodes[8];

    DWORD VendorId;
    DWORD ProductId;
    DWORD SubsystemDeviceId;
    DWORD SubsystemVendorId;
    BYTE ManufacturingLocation;
    BYTE ManufacturingWeek;
    BYTE ManufacturingYear;
    DWORD SerialNumber4Byte;

    DWORD SerialNumberLengthInChars;
    CHAR SerialNumber[1];
} SCM_PD_DEVICE_INFO, *PSCM_PD_DEVICE_INFO;

typedef struct _SCM_PD_DEVICE_SPECIFIC_PROPERTY
{
    WCHAR Name[128];
    LONGLONG Value;
} SCM_PD_DEVICE_SPECIFIC_PROPERTY, *PSCM_PD_DEVICE_SPECIFIC_PROPERTY;

typedef struct _SCM_PD_DEVICE_SPECIFIC_INFO
{
    DWORD Version;

    DWORD Size;

    DWORD NumberOfProperties;

    SCM_PD_DEVICE_SPECIFIC_PROPERTY DeviceSpecificProperties[1];
} SCM_PD_DEVICE_SPECIFIC_INFO, *PSCM_PD_DEVICE_SPECIFIC_INFO;

typedef struct _SCM_PD_FIRMWARE_SLOT_INFO
{
    DWORD Version;

    DWORD Size;

    BYTE SlotNumber;
    BYTE ReadOnly : 1;
    BYTE Reserved0 : 7;
    BYTE Reserved1[6];

    BYTE Revision[32];

} SCM_PD_FIRMWARE_SLOT_INFO, *PSCM_PD_FIRMWARE_SLOT_INFO;

typedef struct _SCM_PD_FIRMWARE_INFO
{
    DWORD Version;

    DWORD Size;

    BYTE ActiveSlot;

    BYTE NextActiveSlot;

    BYTE SlotCount;

    SCM_PD_FIRMWARE_SLOT_INFO Slots[1];

} SCM_PD_FIRMWARE_INFO, *PSCM_PD_FIRMWARE_INFO;

typedef enum _SCM_PD_HEALTH_STATUS
{
    ScmPhysicalDeviceHealth_Unknown = 0,
    ScmPhysicalDeviceHealth_Unhealthy,
    ScmPhysicalDeviceHealth_Warning,
    ScmPhysicalDeviceHealth_Healthy,

    ScmPhysicalDeviceHealth_Max
} SCM_PD_HEALTH_STATUS,
*PSCM_PD_HEALTH_STATUS;

typedef enum _SCM_PD_OPERATIONAL_STATUS
{
    ScmPhysicalDeviceOpStatus_Unknown = 0,
    ScmPhysicalDeviceOpStatus_Ok,
    ScmPhysicalDeviceOpStatus_PredictingFailure,
    ScmPhysicalDeviceOpStatus_InService,
    ScmPhysicalDeviceOpStatus_HardwareError,
    ScmPhysicalDeviceOpStatus_NotUsable,
    ScmPhysicalDeviceOpStatus_TransientError,
    ScmPhysicalDeviceOpStatus_Missing,

    ScmPhysicalDeviceOpStatus_Max
} SCM_PD_OPERATIONAL_STATUS,
*PSCM_PD_OPERATIONAL_STATUS;

typedef enum _SCM_PD_OPERATIONAL_STATUS_REASON
{
    ScmPhysicalDeviceOpReason_Unknown = 0,
    ScmPhysicalDeviceOpReason_Media,
    ScmPhysicalDeviceOpReason_ThresholdExceeded,
    ScmPhysicalDeviceOpReason_LostData,
    ScmPhysicalDeviceOpReason_EnergySource,
    ScmPhysicalDeviceOpReason_Configuration,
    ScmPhysicalDeviceOpReason_DeviceController,
    ScmPhysicalDeviceOpReason_MediaController,
    ScmPhysicalDeviceOpReason_Component,
    ScmPhysicalDeviceOpReason_BackgroundOperation,
    ScmPhysicalDeviceOpReason_InvalidFirmware,
    ScmPhysicalDeviceOpReason_HealthCheck,
    ScmPhysicalDeviceOpReason_LostDataPersistence,
    ScmPhysicalDeviceOpReason_DisabledByPlatform,
    ScmPhysicalDeviceOpReason_PermanentError,
    ScmPhysicalDeviceOpReason_LostWritePersistence,
    ScmPhysicalDeviceOpReason_FatalError,
    ScmPhysicalDeviceOpReason_DataPersistenceLossImminent,
    ScmPhysicalDeviceOpReason_WritePersistenceLossImminent,
    ScmPhysicalDeviceOpReason_MediaRemainingSpareBlock,
    ScmPhysicalDeviceOpReason_PerformanceDegradation,
    ScmPhysicalDeviceOpReason_ExcessiveTemperature,

    ScmPhysicalDeviceOpReason_Max
} SCM_PD_OPERATIONAL_STATUS_REASON,
*PSCM_PD_OPERATIONAL_STATUS_REASON;

typedef struct _SCM_PD_MANAGEMENT_STATUS
{
    DWORD Version;

    DWORD Size;

    SCM_PD_HEALTH_STATUS Health;

    DWORD NumberOfOperationalStatus;

    DWORD NumberOfAdditionalReasons;

    SCM_PD_OPERATIONAL_STATUS OperationalStatus[16];

    SCM_PD_OPERATIONAL_STATUS_REASON AdditionalReasons[1];

} SCM_PD_MANAGEMENT_STATUS, *PSCM_PD_MANAGEMENT_STATUS;

typedef struct _SCM_PD_LOCATION_STRING
{
    DWORD Version;

    DWORD Size;

    WCHAR Location[1];

} SCM_PD_LOCATION_STRING, *PSCM_PD_LOCATION_STRING;

typedef struct _SCM_PD_FIRMWARE_DOWNLOAD
{
    DWORD Version;

    DWORD Size;

    DWORD Flags;

    BYTE Slot;

    BYTE Reserved[3];

    DWORD64 Offset;

    DWORD FirmwareImageSizeInBytes;

    BYTE FirmwareImage[1];

} SCM_PD_FIRMWARE_DOWNLOAD, *PSCM_PD_FIRMWARE_DOWNLOAD;

typedef struct _SCM_PD_FIRMWARE_ACTIVATE
{
    DWORD Version;

    DWORD Size;

    DWORD Flags;

    BYTE Slot;

} SCM_PD_FIRMWARE_ACTIVATE, *PSCM_PD_FIRMWARE_ACTIVATE;

typedef struct _SCM_PD_PASSTHROUGH_INPUT
{
    DWORD Version;

    DWORD Size;

    GUID ProtocolGuid;

    DWORD DataSize;

    BYTE Data[1];
} SCM_PD_PASSTHROUGH_INPUT, *PSCM_PD_PASSTHROUGH_INPUT;

typedef struct _SCM_PD_PASSTHROUGH_OUTPUT
{
    DWORD Version;

    DWORD Size;

    GUID ProtocolGuid;

    DWORD DataSize;

    BYTE Data[1];
} SCM_PD_PASSTHROUGH_OUTPUT, *PSCM_PD_PASSTHROUGH_OUTPUT;

typedef struct _SCM_PD_PASSTHROUGH_INVDIMM_INPUT
{
    DWORD Opcode;

    DWORD OpcodeParametersLength;

    BYTE OpcodeParameters[1];
} SCM_PD_PASSTHROUGH_INVDIMM_INPUT, *PSCM_PD_PASSTHROUGH_INVDIMM_INPUT;

typedef struct _SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT
{
    WORD GeneralStatus;

    WORD ExtendedStatus;

    DWORD OutputDataLength;

    BYTE OutputData[1];
} SCM_PD_PASSTHROUGH_INVDIMM_OUTPUT, *PSCM_PD_PASSTHROUGH_INVDIMM_OUTPUT;

typedef struct _SCM_PD_REINITIALIZE_MEDIA_INPUT
{
    DWORD Version;

    DWORD Size;

    struct
    {
        DWORD Overwrite : 1;
    } Options;
} SCM_PD_REINITIALIZE_MEDIA_INPUT, *PSCM_PD_REINITIALIZE_MEDIA_INPUT;

typedef enum _SCM_PD_MEDIA_REINITIALIZATION_STATUS
{

    ScmPhysicalDeviceReinit_Success = 0,

    ScmPhysicalDeviceReinit_RebootNeeded,

    ScmPhysicalDeviceReinit_ColdBootNeeded,

    ScmPhysicalDeviceReinit_Max
} SCM_PD_MEDIA_REINITIALIZATION_STATUS,
*PSCM_PD_MEDIA_REINITIALIZATION_STATUS;

typedef struct _SCM_PD_REINITIALIZE_MEDIA_OUTPUT
{
    DWORD Version;

    DWORD Size;

    SCM_PD_MEDIA_REINITIALIZATION_STATUS Status;
} SCM_PD_REINITIALIZE_MEDIA_OUTPUT, *PSCM_PD_REINITIALIZE_MEDIA_OUTPUT;

#pragma warning(pop)

#pragma region Desktop Family or OneCore Family

#pragma warning(push)
#pragma warning(disable : 4201)
#pragma warning(disable : 4214)
#pragma warning(disable : 4820)

typedef enum _MEDIA_TYPE
{
    Unknown,
    F5_1Pt2_512,
    F3_1Pt44_512,
    F3_2Pt88_512,
    F3_20Pt8_512,
    F3_720_512,
    F5_360_512,
    F5_320_512,
    F5_320_1024,
    F5_180_512,
    F5_160_512,
    RemovableMedia,
    FixedMedia,
    F3_120M_512,
    F3_640_512,
    F5_640_512,
    F5_720_512,
    F3_1Pt2_512,
    F3_1Pt23_1024,
    F5_1Pt23_1024,
    F3_128Mb_512,
    F3_230Mb_512,
    F8_256_128,
    F3_200Mb_512,
    F3_240M_512,
    F3_32M_512
} MEDIA_TYPE,
*PMEDIA_TYPE;

typedef struct _FORMAT_PARAMETERS
{
    MEDIA_TYPE MediaType;
    DWORD StartCylinderNumber;
    DWORD EndCylinderNumber;
    DWORD StartHeadNumber;
    DWORD EndHeadNumber;
} FORMAT_PARAMETERS, *PFORMAT_PARAMETERS;

typedef WORD BAD_TRACK_NUMBER;
typedef WORD* PBAD_TRACK_NUMBER;

typedef struct _FORMAT_EX_PARAMETERS
{
    MEDIA_TYPE MediaType;
    DWORD StartCylinderNumber;
    DWORD EndCylinderNumber;
    DWORD StartHeadNumber;
    DWORD EndHeadNumber;
    WORD FormatGapLength;
    WORD SectorsPerTrack;
    WORD SectorNumber[1];
} FORMAT_EX_PARAMETERS, *PFORMAT_EX_PARAMETERS;

typedef struct _DISK_GEOMETRY
{
    LARGE_INTEGER Cylinders;

    MEDIA_TYPE MediaType;

    DWORD TracksPerCylinder;

    DWORD SectorsPerTrack;

    DWORD BytesPerSector;

} DISK_GEOMETRY, *PDISK_GEOMETRY;

typedef struct _PARTITION_INFORMATION
{
    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER PartitionLength;
    DWORD HiddenSectors;
    DWORD PartitionNumber;
    BYTE PartitionType;
    BOOLEAN BootIndicator;
    BOOLEAN RecognizedPartition;
    BOOLEAN RewritePartition;
} PARTITION_INFORMATION, *PPARTITION_INFORMATION;

typedef struct _SET_PARTITION_INFORMATION
{
    BYTE PartitionType;
} SET_PARTITION_INFORMATION, *PSET_PARTITION_INFORMATION;

typedef struct _DRIVE_LAYOUT_INFORMATION
{
    DWORD PartitionCount;
    DWORD Signature;
    PARTITION_INFORMATION PartitionEntry[1];
} DRIVE_LAYOUT_INFORMATION, *PDRIVE_LAYOUT_INFORMATION;

typedef struct _VERIFY_INFORMATION
{
    LARGE_INTEGER StartingOffset;
    DWORD Length;
} VERIFY_INFORMATION, *PVERIFY_INFORMATION;

typedef struct _REASSIGN_BLOCKS
{
    WORD Reserved;
    WORD Count;
    DWORD BlockNumber[1];
} REASSIGN_BLOCKS, *PREASSIGN_BLOCKS;

#pragma warning(disable : 4103)

#pragma pack(push, 1)

typedef struct _REASSIGN_BLOCKS_EX
{
    WORD Reserved;
    WORD Count;
    LARGE_INTEGER BlockNumber[1];
} REASSIGN_BLOCKS_EX, *PREASSIGN_BLOCKS_EX;

#pragma warning(disable : 4103)

#pragma pack(pop)

typedef enum _PARTITION_STYLE
{
    PARTITION_STYLE_MBR,
    PARTITION_STYLE_GPT,
    PARTITION_STYLE_RAW
} PARTITION_STYLE;

typedef struct _PARTITION_INFORMATION_GPT
{
    GUID PartitionType;

    GUID PartitionId;

    DWORD64 Attributes;

    WCHAR Name[36];

} PARTITION_INFORMATION_GPT, *PPARTITION_INFORMATION_GPT;

typedef struct _PARTITION_INFORMATION_MBR
{
    BYTE PartitionType;

    BOOLEAN BootIndicator;

    BOOLEAN RecognizedPartition;

    DWORD HiddenSectors;

    GUID PartitionId;

} PARTITION_INFORMATION_MBR, *PPARTITION_INFORMATION_MBR;

typedef SET_PARTITION_INFORMATION SET_PARTITION_INFORMATION_MBR;
typedef PARTITION_INFORMATION_GPT SET_PARTITION_INFORMATION_GPT;

typedef struct _SET_PARTITION_INFORMATION_EX
{
    PARTITION_STYLE PartitionStyle;
    union
    {
        SET_PARTITION_INFORMATION_MBR Mbr;
        SET_PARTITION_INFORMATION_GPT Gpt;
    };
} SET_PARTITION_INFORMATION_EX, *PSET_PARTITION_INFORMATION_EX;

typedef struct _CREATE_DISK_GPT
{
    GUID DiskId;
    DWORD MaxPartitionCount;
} CREATE_DISK_GPT, *PCREATE_DISK_GPT;

typedef struct _CREATE_DISK_MBR
{
    DWORD Signature;
} CREATE_DISK_MBR, *PCREATE_DISK_MBR;

typedef struct _CREATE_DISK
{
    PARTITION_STYLE PartitionStyle;
    union
    {
        CREATE_DISK_MBR Mbr;
        CREATE_DISK_GPT Gpt;
    };
} CREATE_DISK, *PCREATE_DISK;

typedef struct _GET_LENGTH_INFORMATION
{
    LARGE_INTEGER Length;
} GET_LENGTH_INFORMATION, *PGET_LENGTH_INFORMATION;

typedef struct _PARTITION_INFORMATION_EX
{
    PARTITION_STYLE PartitionStyle;

    LARGE_INTEGER StartingOffset;

    LARGE_INTEGER PartitionLength;

    DWORD PartitionNumber;

    BOOLEAN RewritePartition;

    BOOLEAN IsServicePartition;

    union
    {
        PARTITION_INFORMATION_MBR Mbr;

        PARTITION_INFORMATION_GPT Gpt;
    };

} PARTITION_INFORMATION_EX, *PPARTITION_INFORMATION_EX;

typedef struct _DRIVE_LAYOUT_INFORMATION_GPT
{
    GUID DiskId;

    LARGE_INTEGER StartingUsableOffset;

    LARGE_INTEGER UsableLength;

    DWORD MaxPartitionCount;

} DRIVE_LAYOUT_INFORMATION_GPT, *PDRIVE_LAYOUT_INFORMATION_GPT;

typedef struct _DRIVE_LAYOUT_INFORMATION_MBR
{
    DWORD Signature;

    DWORD CheckSum;

} DRIVE_LAYOUT_INFORMATION_MBR, *PDRIVE_LAYOUT_INFORMATION_MBR;

typedef struct _DRIVE_LAYOUT_INFORMATION_EX
{
    DWORD PartitionStyle;

    DWORD PartitionCount;

    union
    {
        DRIVE_LAYOUT_INFORMATION_MBR Mbr;

        DRIVE_LAYOUT_INFORMATION_GPT Gpt;
    };

    PARTITION_INFORMATION_EX PartitionEntry[1];

} DRIVE_LAYOUT_INFORMATION_EX, *PDRIVE_LAYOUT_INFORMATION_EX;

typedef enum _DETECTION_TYPE
{
    DetectNone,
    DetectInt13,
    DetectExInt13
} DETECTION_TYPE;

typedef struct _DISK_INT13_INFO
{
    WORD DriveSelect;
    DWORD MaxCylinders;
    WORD SectorsPerTrack;
    WORD MaxHeads;
    WORD NumberDrives;
} DISK_INT13_INFO, *PDISK_INT13_INFO;

typedef struct _DISK_EX_INT13_INFO
{
    WORD ExBufferSize;
    WORD ExFlags;
    DWORD ExCylinders;
    DWORD ExHeads;
    DWORD ExSectorsPerTrack;
    DWORD64 ExSectorsPerDrive;
    WORD ExSectorSize;
    WORD ExReserved;
} DISK_EX_INT13_INFO, *PDISK_EX_INT13_INFO;

#pragma warning(push)
#pragma warning(disable : 4201)

typedef struct _DISK_DETECTION_INFO
{
    DWORD SizeOfDetectInfo;
    DETECTION_TYPE DetectionType;
    union
    {
        struct
        {
            DISK_INT13_INFO Int13;

            DISK_EX_INT13_INFO ExInt13;
        };
    };
} DISK_DETECTION_INFO, *PDISK_DETECTION_INFO;

typedef struct _DISK_PARTITION_INFO
{
    DWORD SizeOfPartitionInfo;
    PARTITION_STYLE PartitionStyle;
    union
    {
        struct
        {
            DWORD Signature;
            DWORD CheckSum;
        } Mbr;
        struct
        {
            GUID DiskId;
        } Gpt;
    };
} DISK_PARTITION_INFO, *PDISK_PARTITION_INFO;

#pragma warning(pop)

typedef struct _DISK_GEOMETRY_EX
{
    DISK_GEOMETRY Geometry;
    LARGE_INTEGER DiskSize;
    BYTE Data[1];
} DISK_GEOMETRY_EX, *PDISK_GEOMETRY_EX;

typedef struct _DISK_CONTROLLER_NUMBER
{
    DWORD ControllerNumber;
    DWORD DiskNumber;
} DISK_CONTROLLER_NUMBER, *PDISK_CONTROLLER_NUMBER;

typedef enum
{
    EqualPriority,
    KeepPrefetchedData,
    KeepReadData
} DISK_CACHE_RETENTION_PRIORITY;

typedef struct _DISK_CACHE_INFORMATION
{
    BOOLEAN ParametersSavable;

    BOOLEAN ReadCacheEnabled;
    BOOLEAN WriteCacheEnabled;

    DISK_CACHE_RETENTION_PRIORITY ReadRetentionPriority;
    DISK_CACHE_RETENTION_PRIORITY WriteRetentionPriority;

    WORD DisablePrefetchTransferLength;

    BOOLEAN PrefetchScalar;

    union
    {
        struct
        {
            WORD Minimum;
            WORD Maximum;

            WORD MaximumBlocks;
        } ScalarPrefetch;

        struct
        {
            WORD Minimum;
            WORD Maximum;
        } BlockPrefetch;
    };

} DISK_CACHE_INFORMATION, *PDISK_CACHE_INFORMATION;

typedef struct _DISK_GROW_PARTITION
{
    DWORD PartitionNumber;
    LARGE_INTEGER BytesToGrow;
} DISK_GROW_PARTITION, *PDISK_GROW_PARTITION;

typedef struct _HISTOGRAM_BUCKET
{
    DWORD Reads;
    DWORD Writes;
} HISTOGRAM_BUCKET, *PHISTOGRAM_BUCKET;

typedef struct _DISK_HISTOGRAM
{
    LARGE_INTEGER DiskSize;
    LARGE_INTEGER Start;
    LARGE_INTEGER End;
    LARGE_INTEGER Average;
    LARGE_INTEGER AverageRead;
    LARGE_INTEGER AverageWrite;
    DWORD Granularity;
    DWORD Size;
    DWORD ReadCount;
    DWORD WriteCount;
    PHISTOGRAM_BUCKET Histogram;
} DISK_HISTOGRAM, *PDISK_HISTOGRAM;

typedef struct _DISK_PERFORMANCE
{
    LARGE_INTEGER BytesRead;
    LARGE_INTEGER BytesWritten;
    LARGE_INTEGER ReadTime;
    LARGE_INTEGER WriteTime;
    LARGE_INTEGER IdleTime;
    DWORD ReadCount;
    DWORD WriteCount;
    DWORD QueueDepth;
    DWORD SplitCount;
    LARGE_INTEGER QueryTime;
    DWORD StorageDeviceNumber;
    WCHAR StorageManagerName[8];
} DISK_PERFORMANCE, *PDISK_PERFORMANCE;

typedef struct _DISK_RECORD
{
    LARGE_INTEGER ByteOffset;
    LARGE_INTEGER StartTime;
    LARGE_INTEGER EndTime;
    PVOID VirtualAddress;
    DWORD NumberOfBytes;
    BYTE DeviceNumber;
    BOOLEAN ReadRequest;
} DISK_RECORD, *PDISK_RECORD;

typedef struct _DISK_LOGGING
{
    BYTE Function;
    PVOID BufferAddress;
    DWORD BufferSize;
} DISK_LOGGING, *PDISK_LOGGING;

typedef enum _BIN_TYPES
{
    RequestSize,
    RequestLocation
} BIN_TYPES;

typedef struct _BIN_RANGE
{
    LARGE_INTEGER StartValue;
    LARGE_INTEGER Length;
} BIN_RANGE, *PBIN_RANGE;

typedef struct _PERF_BIN
{
    DWORD NumberOfBins;
    DWORD TypeOfBin;
    BIN_RANGE BinsRanges[1];
} PERF_BIN, *PPERF_BIN;

typedef struct _BIN_COUNT
{
    BIN_RANGE BinRange;
    DWORD BinCount;
} BIN_COUNT, *PBIN_COUNT;

typedef struct _BIN_RESULTS
{
    DWORD NumberOfBins;
    BIN_COUNT BinCounts[1];
} BIN_RESULTS, *PBIN_RESULTS;

#pragma warning(disable : 4103)

#pragma pack(push, 1)

typedef struct _GETVERSIONINPARAMS
{
    BYTE bVersion;
    BYTE bRevision;
    BYTE bReserved;
    BYTE bIDEDeviceMap;
    DWORD fCapabilities;
    DWORD dwReserved[4];
} GETVERSIONINPARAMS, *PGETVERSIONINPARAMS, *LPGETVERSIONINPARAMS;

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(disable : 4103)

#pragma pack(push, 1)

typedef struct _IDEREGS
{
    BYTE bFeaturesReg;
    BYTE bSectorCountReg;
    BYTE bSectorNumberReg;
    BYTE bCylLowReg;
    BYTE bCylHighReg;
    BYTE bDriveHeadReg;
    BYTE bCommandReg;
    BYTE bReserved;
} IDEREGS, *PIDEREGS, *LPIDEREGS;

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(disable : 4103)

#pragma pack(push, 1)

typedef struct _SENDCMDINPARAMS
{
    DWORD cBufferSize;
    IDEREGS irDriveRegs;
    BYTE bDriveNumber;

    BYTE bReserved[3];
    DWORD dwReserved[4];
    BYTE bBuffer[1];
} SENDCMDINPARAMS, *PSENDCMDINPARAMS, *LPSENDCMDINPARAMS;

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(disable : 4103)

#pragma pack(push, 1)

typedef struct _DRIVERSTATUS
{
    BYTE bDriverError;

    BYTE bIDEError;

    BYTE bReserved[2];
    DWORD dwReserved[2];
} DRIVERSTATUS, *PDRIVERSTATUS, *LPDRIVERSTATUS;

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(disable : 4103)

#pragma pack(push, 1)

typedef struct _SENDCMDOUTPARAMS
{
    DWORD cBufferSize;
    DRIVERSTATUS DriverStatus;
    BYTE bBuffer[1];
} SENDCMDOUTPARAMS, *PSENDCMDOUTPARAMS, *LPSENDCMDOUTPARAMS;

#pragma warning(disable : 4103)

#pragma pack(pop)

typedef struct _GET_DISK_ATTRIBUTES
{
    DWORD Version;

    DWORD Reserved1;

    DWORDLONG Attributes;

} GET_DISK_ATTRIBUTES, *PGET_DISK_ATTRIBUTES;

typedef struct _SET_DISK_ATTRIBUTES
{
    DWORD Version;

    BOOLEAN Persist;

    BYTE Reserved1[3];

    DWORDLONG Attributes;

    DWORDLONG AttributesMask;

    DWORD Reserved2[4];

} SET_DISK_ATTRIBUTES, *PSET_DISK_ATTRIBUTES;

#pragma warning(pop)

#pragma endregion

typedef enum _ELEMENT_TYPE
{
    AllElements,
    ChangerTransport,
    ChangerSlot,
    ChangerIEPort,
    ChangerDrive,
    ChangerDoor,
    ChangerKeypad,
    ChangerMaxElement
} ELEMENT_TYPE,
*PELEMENT_TYPE;

typedef struct _CHANGER_ELEMENT
{
    ELEMENT_TYPE ElementType;
    DWORD ElementAddress;
} CHANGER_ELEMENT, *PCHANGER_ELEMENT;

typedef struct _CHANGER_ELEMENT_LIST
{
    CHANGER_ELEMENT Element;
    DWORD NumberOfElements;
} CHANGER_ELEMENT_LIST, *PCHANGER_ELEMENT_LIST;

typedef struct _GET_CHANGER_PARAMETERS
{
    DWORD Size;

    WORD NumberTransportElements;
    WORD NumberStorageElements;
    WORD NumberCleanerSlots;
    WORD NumberIEElements;
    WORD NumberDataTransferElements;

    WORD NumberOfDoors;

    WORD FirstSlotNumber;
    WORD FirstDriveNumber;
    WORD FirstTransportNumber;
    WORD FirstIEPortNumber;
    WORD FirstCleanerSlotAddress;

    WORD MagazineSize;

    DWORD DriveCleanTimeout;

    DWORD Features0;
    DWORD Features1;

    BYTE MoveFromTransport;
    BYTE MoveFromSlot;
    BYTE MoveFromIePort;
    BYTE MoveFromDrive;

    BYTE ExchangeFromTransport;
    BYTE ExchangeFromSlot;
    BYTE ExchangeFromIePort;
    BYTE ExchangeFromDrive;

    BYTE LockUnlockCapabilities;

    BYTE PositionCapabilities;

    BYTE Reserved1[2];
    DWORD Reserved2[2];

} GET_CHANGER_PARAMETERS, *PGET_CHANGER_PARAMETERS;

typedef struct _CHANGER_PRODUCT_DATA
{
    BYTE VendorId[8];

    BYTE ProductId[16];

    BYTE Revision[4];

    BYTE SerialNumber[32];

    BYTE DeviceType;

} CHANGER_PRODUCT_DATA, *PCHANGER_PRODUCT_DATA;

typedef struct _CHANGER_SET_ACCESS
{
    CHANGER_ELEMENT Element;

    DWORD Control;
} CHANGER_SET_ACCESS, *PCHANGER_SET_ACCESS;

typedef struct _CHANGER_READ_ELEMENT_STATUS
{
    CHANGER_ELEMENT_LIST ElementList;

    BOOLEAN VolumeTagInfo;
} CHANGER_READ_ELEMENT_STATUS, *PCHANGER_READ_ELEMENT_STATUS;

typedef struct _CHANGER_ELEMENT_STATUS
{
    CHANGER_ELEMENT Element;

    CHANGER_ELEMENT SrcElementAddress;

    DWORD Flags;

    DWORD ExceptionCode;

    BYTE TargetId;

    BYTE Lun;
    WORD Reserved;

    BYTE PrimaryVolumeID[36];

    BYTE AlternateVolumeID[36];

} CHANGER_ELEMENT_STATUS, *PCHANGER_ELEMENT_STATUS;

typedef struct _CHANGER_ELEMENT_STATUS_EX
{
    CHANGER_ELEMENT Element;

    CHANGER_ELEMENT SrcElementAddress;

    DWORD Flags;

    DWORD ExceptionCode;

    BYTE TargetId;

    BYTE Lun;
    WORD Reserved;

    BYTE PrimaryVolumeID[36];

    BYTE AlternateVolumeID[36];

    BYTE VendorIdentification[8];

    BYTE ProductIdentification[16];

    BYTE SerialNumber[32];

} CHANGER_ELEMENT_STATUS_EX, *PCHANGER_ELEMENT_STATUS_EX;

typedef struct _CHANGER_INITIALIZE_ELEMENT_STATUS
{
    CHANGER_ELEMENT_LIST ElementList;

    BOOLEAN BarCodeScan;
} CHANGER_INITIALIZE_ELEMENT_STATUS, *PCHANGER_INITIALIZE_ELEMENT_STATUS;

typedef struct _CHANGER_SET_POSITION
{
    CHANGER_ELEMENT Transport;

    CHANGER_ELEMENT Destination;

    BOOLEAN Flip;
} CHANGER_SET_POSITION, *PCHANGER_SET_POSITION;

typedef struct _CHANGER_EXCHANGE_MEDIUM
{
    CHANGER_ELEMENT Transport;

    CHANGER_ELEMENT Source;

    CHANGER_ELEMENT Destination1;

    CHANGER_ELEMENT Destination2;

    BOOLEAN Flip1;
    BOOLEAN Flip2;
} CHANGER_EXCHANGE_MEDIUM, *PCHANGER_EXCHANGE_MEDIUM;

typedef struct _CHANGER_MOVE_MEDIUM
{
    CHANGER_ELEMENT Transport;

    CHANGER_ELEMENT Source;

    CHANGER_ELEMENT Destination;

    BOOLEAN Flip;
} CHANGER_MOVE_MEDIUM, *PCHANGER_MOVE_MEDIUM;

typedef struct _CHANGER_SEND_VOLUME_TAG_INFORMATION
{
    CHANGER_ELEMENT StartingElement;

    DWORD ActionCode;

    BYTE VolumeIDTemplate[40];
} CHANGER_SEND_VOLUME_TAG_INFORMATION, *PCHANGER_SEND_VOLUME_TAG_INFORMATION;

typedef struct _READ_ELEMENT_ADDRESS_INFO
{
    DWORD NumberOfElements;

    CHANGER_ELEMENT_STATUS ElementStatus[1];
} READ_ELEMENT_ADDRESS_INFO, *PREAD_ELEMENT_ADDRESS_INFO;

typedef enum _CHANGER_DEVICE_PROBLEM_TYPE
{
    DeviceProblemNone,
    DeviceProblemHardware,
    DeviceProblemCHMError,
    DeviceProblemDoorOpen,
    DeviceProblemCalibrationError,
    DeviceProblemTargetFailure,
    DeviceProblemCHMMoveError,
    DeviceProblemCHMZeroError,
    DeviceProblemCartridgeInsertError,
    DeviceProblemPositionError,
    DeviceProblemSensorError,
    DeviceProblemCartridgeEjectError,
    DeviceProblemGripperError,
    DeviceProblemDriveError
} CHANGER_DEVICE_PROBLEM_TYPE,
*PCHANGER_DEVICE_PROBLEM_TYPE;

typedef struct _PATHNAME_BUFFER
{
    DWORD PathNameLength;
    WCHAR Name[1];

} PATHNAME_BUFFER, *PPATHNAME_BUFFER;

typedef struct _FSCTL_QUERY_FAT_BPB_BUFFER
{
    BYTE First0x24BytesOfBootSector[0x24];

} FSCTL_QUERY_FAT_BPB_BUFFER, *PFSCTL_QUERY_FAT_BPB_BUFFER;

typedef struct
{
    LARGE_INTEGER VolumeSerialNumber;
    LARGE_INTEGER NumberSectors;
    LARGE_INTEGER TotalClusters;
    LARGE_INTEGER FreeClusters;
    LARGE_INTEGER TotalReserved;
    DWORD BytesPerSector;
    DWORD BytesPerCluster;
    DWORD BytesPerFileRecordSegment;
    DWORD ClustersPerFileRecordSegment;
    LARGE_INTEGER MftValidDataLength;
    LARGE_INTEGER MftStartLcn;
    LARGE_INTEGER Mft2StartLcn;
    LARGE_INTEGER MftZoneStart;
    LARGE_INTEGER MftZoneEnd;

} NTFS_VOLUME_DATA_BUFFER, *PNTFS_VOLUME_DATA_BUFFER;

typedef struct
{
    DWORD ByteCount;

    WORD MajorVersion;
    WORD MinorVersion;

    DWORD BytesPerPhysicalSector;

    WORD LfsMajorVersion;
    WORD LfsMinorVersion;

    DWORD MaxDeviceTrimExtentCount;
    DWORD MaxDeviceTrimByteCount;

    DWORD MaxVolumeTrimExtentCount;
    DWORD MaxVolumeTrimByteCount;

} NTFS_EXTENDED_VOLUME_DATA, *PNTFS_EXTENDED_VOLUME_DATA;

typedef struct
{
    DWORD ByteCount;
    DWORD MajorVersion;
    DWORD MinorVersion;

    DWORD BytesPerPhysicalSector;

    LARGE_INTEGER VolumeSerialNumber;
    LARGE_INTEGER NumberSectors;
    LARGE_INTEGER TotalClusters;
    LARGE_INTEGER FreeClusters;
    LARGE_INTEGER TotalReserved;
    DWORD BytesPerSector;
    DWORD BytesPerCluster;
    LARGE_INTEGER MaximumSizeOfResidentFile;

    LARGE_INTEGER Reserved[10];

} REFS_VOLUME_DATA_BUFFER, *PREFS_VOLUME_DATA_BUFFER;

typedef struct
{
    LARGE_INTEGER StartingLcn;

} STARTING_LCN_INPUT_BUFFER, *PSTARTING_LCN_INPUT_BUFFER;

typedef struct
{
    LARGE_INTEGER StartingLcn;
    DWORD Flags;

} STARTING_LCN_INPUT_BUFFER_EX, *PSTARTING_LCN_INPUT_BUFFER_EX;

typedef struct
{
    LARGE_INTEGER StartingLcn;
    LARGE_INTEGER BitmapSize;
    BYTE Buffer[1];

} VOLUME_BITMAP_BUFFER, *PVOLUME_BITMAP_BUFFER;

typedef struct
{
    LARGE_INTEGER StartingVcn;

} STARTING_VCN_INPUT_BUFFER, *PSTARTING_VCN_INPUT_BUFFER;

typedef struct RETRIEVAL_POINTERS_BUFFER
{
    DWORD ExtentCount;
    LARGE_INTEGER StartingVcn;
    struct
    {
        LARGE_INTEGER NextVcn;
        LARGE_INTEGER Lcn;
    } Extents[1];

} RETRIEVAL_POINTERS_BUFFER, *PRETRIEVAL_POINTERS_BUFFER;

typedef struct RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER
{
    DWORD ExtentCount;
    LARGE_INTEGER StartingVcn;
    struct
    {
        LARGE_INTEGER NextVcn;
        LARGE_INTEGER Lcn;
        DWORD ReferenceCount;
    } Extents[1];

} RETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER, *PRETRIEVAL_POINTERS_AND_REFCOUNT_BUFFER;

typedef struct RETRIEVAL_POINTER_COUNT
{
    DWORD ExtentCount;

} RETRIEVAL_POINTER_COUNT, *PRETRIEVAL_POINTER_COUNT;

typedef struct
{
    LARGE_INTEGER FileReferenceNumber;

} NTFS_FILE_RECORD_INPUT_BUFFER, *PNTFS_FILE_RECORD_INPUT_BUFFER;

typedef struct
{
    LARGE_INTEGER FileReferenceNumber;
    DWORD FileRecordLength;
    BYTE FileRecordBuffer[1];

} NTFS_FILE_RECORD_OUTPUT_BUFFER, *PNTFS_FILE_RECORD_OUTPUT_BUFFER;

typedef struct
{
    HANDLE FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    DWORD ClusterCount;

} MOVE_FILE_DATA, *PMOVE_FILE_DATA;

typedef struct
{
    HANDLE FileHandle;
    LARGE_INTEGER SourceFileRecord;
    LARGE_INTEGER TargetFileRecord;

} MOVE_FILE_RECORD_DATA, *PMOVE_FILE_RECORD_DATA;

typedef struct _MOVE_FILE_DATA32
{
    UINT32 FileHandle;
    LARGE_INTEGER StartingVcn;
    LARGE_INTEGER StartingLcn;
    DWORD ClusterCount;

} MOVE_FILE_DATA32, *PMOVE_FILE_DATA32;

typedef struct
{
    DWORD Restart;
    SID Sid;
} FIND_BY_SID_DATA, *PFIND_BY_SID_DATA;

typedef struct
{
    DWORD NextEntryOffset;
    DWORD FileIndex;
    DWORD FileNameLength;
    WCHAR FileName[1];
} FIND_BY_SID_OUTPUT, *PFIND_BY_SID_OUTPUT;

typedef struct
{
    DWORDLONG StartFileReferenceNumber;
    USN LowUsn;
    USN HighUsn;

} MFT_ENUM_DATA_V0, *PMFT_ENUM_DATA_V0;

typedef struct
{
    DWORDLONG StartFileReferenceNumber;
    USN LowUsn;
    USN HighUsn;
    WORD MinMajorVersion;
    WORD MaxMajorVersion;

} MFT_ENUM_DATA_V1, *PMFT_ENUM_DATA_V1;

typedef MFT_ENUM_DATA_V1 MFT_ENUM_DATA, *PMFT_ENUM_DATA;

typedef struct
{
    DWORDLONG MaximumSize;
    DWORDLONG AllocationDelta;

} CREATE_USN_JOURNAL_DATA, *PCREATE_USN_JOURNAL_DATA;

typedef struct
{
    WORD MinMajorVersion;
    WORD MaxMajorVersion;

} READ_FILE_USN_DATA, *PREAD_FILE_USN_DATA;

typedef struct
{
    USN StartUsn;
    DWORD ReasonMask;
    DWORD ReturnOnlyOnClose;
    DWORDLONG Timeout;
    DWORDLONG BytesToWaitFor;
    DWORDLONG UsnJournalID;

} READ_USN_JOURNAL_DATA_V0, *PREAD_USN_JOURNAL_DATA_V0;

typedef struct
{
    USN StartUsn;
    DWORD ReasonMask;
    DWORD ReturnOnlyOnClose;
    DWORDLONG Timeout;
    DWORDLONG BytesToWaitFor;
    DWORDLONG UsnJournalID;
    WORD MinMajorVersion;
    WORD MaxMajorVersion;

} READ_USN_JOURNAL_DATA_V1, *PREAD_USN_JOURNAL_DATA_V1;

typedef READ_USN_JOURNAL_DATA_V1 READ_USN_JOURNAL_DATA, *PREAD_USN_JOURNAL_DATA;

typedef struct
{
    DWORD Flags;
    DWORD Unused;
    DWORDLONG ChunkSize;
    LONGLONG FileSizeThreshold;
} USN_TRACK_MODIFIED_RANGES, *PUSN_TRACK_MODIFIED_RANGES;

typedef struct
{
    USN Usn;
} USN_RANGE_TRACK_OUTPUT, *PUSN_RANGE_TRACK_OUTPUT;

typedef struct
{
    DWORD RecordLength;
    WORD MajorVersion;
    WORD MinorVersion;
    DWORDLONG FileReferenceNumber;
    DWORDLONG ParentFileReferenceNumber;
    USN Usn;
    LARGE_INTEGER TimeStamp;
    DWORD Reason;
    DWORD SourceInfo;
    DWORD SecurityId;
    DWORD FileAttributes;
    WORD FileNameLength;
    WORD FileNameOffset;
    WCHAR FileName[1];

} USN_RECORD_V2, *PUSN_RECORD_V2;

typedef struct
{
    DWORD RecordLength;
    WORD MajorVersion;
    WORD MinorVersion;
    FILE_ID_128 FileReferenceNumber;
    FILE_ID_128 ParentFileReferenceNumber;
    USN Usn;
    LARGE_INTEGER TimeStamp;
    DWORD Reason;
    DWORD SourceInfo;
    DWORD SecurityId;
    DWORD FileAttributes;
    WORD FileNameLength;
    WORD FileNameOffset;
    WCHAR FileName[1];

} USN_RECORD_V3, *PUSN_RECORD_V3;

typedef USN_RECORD_V2 USN_RECORD, *PUSN_RECORD;

typedef struct
{
    DWORD RecordLength;
    WORD MajorVersion;
    WORD MinorVersion;
} USN_RECORD_COMMON_HEADER, *PUSN_RECORD_COMMON_HEADER;

typedef struct
{
    LONGLONG Offset;
    LONGLONG Length;
} USN_RECORD_EXTENT, *PUSN_RECORD_EXTENT;

typedef struct
{
    USN_RECORD_COMMON_HEADER Header;
    FILE_ID_128 FileReferenceNumber;
    FILE_ID_128 ParentFileReferenceNumber;
    USN Usn;
    DWORD Reason;
    DWORD SourceInfo;
    DWORD RemainingExtents;
    WORD NumberOfExtents;
    WORD ExtentSize;
    USN_RECORD_EXTENT Extents[1];
} USN_RECORD_V4, *PUSN_RECORD_V4;

typedef union
{
    USN_RECORD_COMMON_HEADER Header;
    USN_RECORD_V2 V2;
    USN_RECORD_V3 V3;
    USN_RECORD_V4 V4;
} USN_RECORD_UNION, *PUSN_RECORD_UNION;

typedef struct
{
    DWORDLONG UsnJournalID;
    USN FirstUsn;
    USN NextUsn;
    USN LowestValidUsn;
    USN MaxUsn;
    DWORDLONG MaximumSize;
    DWORDLONG AllocationDelta;

} USN_JOURNAL_DATA_V0, *PUSN_JOURNAL_DATA_V0;

typedef struct
{
    DWORDLONG UsnJournalID;
    USN FirstUsn;
    USN NextUsn;
    USN LowestValidUsn;
    USN MaxUsn;
    DWORDLONG MaximumSize;
    DWORDLONG AllocationDelta;
    WORD MinSupportedMajorVersion;
    WORD MaxSupportedMajorVersion;

} USN_JOURNAL_DATA_V1, *PUSN_JOURNAL_DATA_V1;

typedef struct
{
    DWORDLONG UsnJournalID;
    USN FirstUsn;
    USN NextUsn;
    USN LowestValidUsn;
    USN MaxUsn;
    DWORDLONG MaximumSize;
    DWORDLONG AllocationDelta;
    WORD MinSupportedMajorVersion;
    WORD MaxSupportedMajorVersion;
    DWORD Flags;
    DWORDLONG RangeTrackChunkSize;
    LONGLONG RangeTrackFileSizeThreshold;

} USN_JOURNAL_DATA_V2, *PUSN_JOURNAL_DATA_V2;

typedef USN_JOURNAL_DATA_V1 USN_JOURNAL_DATA, *PUSN_JOURNAL_DATA;

typedef struct
{
    DWORDLONG UsnJournalID;
    DWORD DeleteFlags;

} DELETE_USN_JOURNAL_DATA, *PDELETE_USN_JOURNAL_DATA;

#pragma warning(push)
#pragma warning(disable : 4201)

typedef struct
{
    union
    {
        DWORD UsnSourceInfo;
        DWORD CopyNumber;
    };

    HANDLE VolumeHandle;
    DWORD HandleInfo;

} MARK_HANDLE_INFO, *PMARK_HANDLE_INFO;

typedef struct
{
    union
    {
        DWORD UsnSourceInfo;
        DWORD CopyNumber;
    };

    UINT32 VolumeHandle;
    DWORD HandleInfo;

} MARK_HANDLE_INFO32, *PMARK_HANDLE_INFO32;

#pragma warning(pop)

typedef struct
{
    ACCESS_MASK DesiredAccess;
    DWORD SecurityIds[1];

} BULK_SECURITY_TEST_DATA, *PBULK_SECURITY_TEST_DATA;

typedef struct _FILE_PREFETCH
{
    DWORD Type;
    DWORD Count;
    DWORDLONG Prefetch[1];
} FILE_PREFETCH, *PFILE_PREFETCH;

typedef struct _FILE_PREFETCH_EX
{
    DWORD Type;
    DWORD Count;
    PVOID Context;
    DWORDLONG Prefetch[1];
} FILE_PREFETCH_EX, *PFILE_PREFETCH_EX;

typedef struct _FILESYSTEM_STATISTICS
{
    WORD FileSystemType;
    WORD Version;

    DWORD SizeOfCompleteStructure;

    DWORD UserFileReads;
    DWORD UserFileReadBytes;
    DWORD UserDiskReads;
    DWORD UserFileWrites;
    DWORD UserFileWriteBytes;
    DWORD UserDiskWrites;

    DWORD MetaDataReads;
    DWORD MetaDataReadBytes;
    DWORD MetaDataDiskReads;
    DWORD MetaDataWrites;
    DWORD MetaDataWriteBytes;
    DWORD MetaDataDiskWrites;

} FILESYSTEM_STATISTICS, *PFILESYSTEM_STATISTICS;

typedef struct _FAT_STATISTICS
{
    DWORD CreateHits;
    DWORD SuccessfulCreates;
    DWORD FailedCreates;

    DWORD NonCachedReads;
    DWORD NonCachedReadBytes;
    DWORD NonCachedWrites;
    DWORD NonCachedWriteBytes;

    DWORD NonCachedDiskReads;
    DWORD NonCachedDiskWrites;
} FAT_STATISTICS, *PFAT_STATISTICS;

typedef struct _EXFAT_STATISTICS
{
    DWORD CreateHits;
    DWORD SuccessfulCreates;
    DWORD FailedCreates;

    DWORD NonCachedReads;
    DWORD NonCachedReadBytes;
    DWORD NonCachedWrites;
    DWORD NonCachedWriteBytes;

    DWORD NonCachedDiskReads;
    DWORD NonCachedDiskWrites;
} EXFAT_STATISTICS, *PEXFAT_STATISTICS;

typedef struct _NTFS_STATISTICS
{
    DWORD LogFileFullExceptions;
    DWORD OtherExceptions;

    DWORD MftReads;
    DWORD MftReadBytes;
    DWORD MftWrites;
    DWORD MftWriteBytes;
    struct
    {
        WORD Write;
        WORD Create;
        WORD SetInfo;
        WORD Flush;
    } MftWritesUserLevel;

    WORD MftWritesFlushForLogFileFull;
    WORD MftWritesLazyWriter;
    WORD MftWritesUserRequest;

    DWORD Mft2Writes;
    DWORD Mft2WriteBytes;
    struct
    {
        WORD Write;
        WORD Create;
        WORD SetInfo;
        WORD Flush;
    } Mft2WritesUserLevel;

    WORD Mft2WritesFlushForLogFileFull;
    WORD Mft2WritesLazyWriter;
    WORD Mft2WritesUserRequest;

    DWORD RootIndexReads;
    DWORD RootIndexReadBytes;
    DWORD RootIndexWrites;
    DWORD RootIndexWriteBytes;

    DWORD BitmapReads;
    DWORD BitmapReadBytes;
    DWORD BitmapWrites;
    DWORD BitmapWriteBytes;

    WORD BitmapWritesFlushForLogFileFull;
    WORD BitmapWritesLazyWriter;
    WORD BitmapWritesUserRequest;

    struct
    {
        WORD Write;
        WORD Create;
        WORD SetInfo;
    } BitmapWritesUserLevel;

    DWORD MftBitmapReads;
    DWORD MftBitmapReadBytes;
    DWORD MftBitmapWrites;
    DWORD MftBitmapWriteBytes;

    WORD MftBitmapWritesFlushForLogFileFull;
    WORD MftBitmapWritesLazyWriter;
    WORD MftBitmapWritesUserRequest;

    struct
    {
        WORD Write;
        WORD Create;
        WORD SetInfo;
        WORD Flush;
    } MftBitmapWritesUserLevel;

    DWORD UserIndexReads;
    DWORD UserIndexReadBytes;
    DWORD UserIndexWrites;
    DWORD UserIndexWriteBytes;

    DWORD LogFileReads;
    DWORD LogFileReadBytes;
    DWORD LogFileWrites;
    DWORD LogFileWriteBytes;

    struct
    {
        DWORD Calls;
        DWORD Clusters;
        DWORD Hints;

        DWORD RunsReturned;

        DWORD HintsHonored;
        DWORD HintsClusters;
        DWORD Cache;
        DWORD CacheClusters;
        DWORD CacheMiss;
        DWORD CacheMissClusters;
    } Allocate;

    DWORD DiskResourcesExhausted;

} NTFS_STATISTICS, *PNTFS_STATISTICS;

typedef struct _FILESYSTEM_STATISTICS_EX
{
    WORD FileSystemType;
    WORD Version;

    DWORD SizeOfCompleteStructure;

    DWORDLONG UserFileReads;
    DWORDLONG UserFileReadBytes;
    DWORDLONG UserDiskReads;
    DWORDLONG UserFileWrites;
    DWORDLONG UserFileWriteBytes;
    DWORDLONG UserDiskWrites;

    DWORDLONG MetaDataReads;
    DWORDLONG MetaDataReadBytes;
    DWORDLONG MetaDataDiskReads;
    DWORDLONG MetaDataWrites;
    DWORDLONG MetaDataWriteBytes;
    DWORDLONG MetaDataDiskWrites;

} FILESYSTEM_STATISTICS_EX, *PFILESYSTEM_STATISTICS_EX;

typedef struct _NTFS_STATISTICS_EX
{
    DWORD LogFileFullExceptions;
    DWORD OtherExceptions;

    DWORDLONG MftReads;
    DWORDLONG MftReadBytes;
    DWORDLONG MftWrites;
    DWORDLONG MftWriteBytes;
    struct
    {
        DWORD Write;
        DWORD Create;
        DWORD SetInfo;
        DWORD Flush;
    } MftWritesUserLevel;

    DWORD MftWritesFlushForLogFileFull;
    DWORD MftWritesLazyWriter;
    DWORD MftWritesUserRequest;

    DWORDLONG Mft2Writes;
    DWORDLONG Mft2WriteBytes;
    struct
    {
        DWORD Write;
        DWORD Create;
        DWORD SetInfo;
        DWORD Flush;
    } Mft2WritesUserLevel;

    DWORD Mft2WritesFlushForLogFileFull;
    DWORD Mft2WritesLazyWriter;
    DWORD Mft2WritesUserRequest;

    DWORDLONG RootIndexReads;
    DWORDLONG RootIndexReadBytes;
    DWORDLONG RootIndexWrites;
    DWORDLONG RootIndexWriteBytes;

    DWORDLONG BitmapReads;
    DWORDLONG BitmapReadBytes;
    DWORDLONG BitmapWrites;
    DWORDLONG BitmapWriteBytes;

    DWORD BitmapWritesFlushForLogFileFull;
    DWORD BitmapWritesLazyWriter;
    DWORD BitmapWritesUserRequest;

    struct
    {
        DWORD Write;
        DWORD Create;
        DWORD SetInfo;
        DWORD Flush;
    } BitmapWritesUserLevel;

    DWORDLONG MftBitmapReads;
    DWORDLONG MftBitmapReadBytes;
    DWORDLONG MftBitmapWrites;
    DWORDLONG MftBitmapWriteBytes;

    DWORD MftBitmapWritesFlushForLogFileFull;
    DWORD MftBitmapWritesLazyWriter;
    DWORD MftBitmapWritesUserRequest;

    struct
    {
        DWORD Write;
        DWORD Create;
        DWORD SetInfo;
        DWORD Flush;
    } MftBitmapWritesUserLevel;

    DWORDLONG UserIndexReads;
    DWORDLONG UserIndexReadBytes;
    DWORDLONG UserIndexWrites;
    DWORDLONG UserIndexWriteBytes;

    DWORDLONG LogFileReads;
    DWORDLONG LogFileReadBytes;
    DWORDLONG LogFileWrites;
    DWORDLONG LogFileWriteBytes;

    struct
    {
        DWORD Calls;
        DWORD RunsReturned;
        DWORD Hints;
        DWORD HintsHonored;
        DWORD Cache;
        DWORD CacheMiss;

        DWORDLONG Clusters;
        DWORDLONG HintsClusters;
        DWORDLONG CacheClusters;
        DWORDLONG CacheMissClusters;
    } Allocate;

    DWORD DiskResourcesExhausted;

    DWORDLONG VolumeTrimCount;
    DWORDLONG VolumeTrimTime;
    DWORDLONG VolumeTrimByteCount;

    DWORDLONG FileLevelTrimCount;
    DWORDLONG FileLevelTrimTime;
    DWORDLONG FileLevelTrimByteCount;

    DWORDLONG VolumeTrimSkippedCount;
    DWORDLONG VolumeTrimSkippedByteCount;

    DWORDLONG NtfsFillStatInfoFromMftRecordCalledCount;
    DWORDLONG NtfsFillStatInfoFromMftRecordBailedBecauseOfAttributeListCount;
    DWORDLONG NtfsFillStatInfoFromMftRecordBailedBecauseOfNonResReparsePointCount;

} NTFS_STATISTICS_EX, *PNTFS_STATISTICS_EX;

#pragma warning(push)
#pragma warning(disable : 4201)

typedef struct _FILE_OBJECTID_BUFFER
{
    BYTE ObjectId[16];

    union
    {
        struct
        {
            BYTE BirthVolumeId[16];
            BYTE BirthObjectId[16];
            BYTE DomainId[16];
        };
        BYTE ExtendedInfo[48];
    };

} FILE_OBJECTID_BUFFER, *PFILE_OBJECTID_BUFFER;

#pragma warning(pop)

typedef struct _FILE_SET_SPARSE_BUFFER
{
    BOOLEAN SetSparse;
} FILE_SET_SPARSE_BUFFER, *PFILE_SET_SPARSE_BUFFER;

typedef struct _FILE_ZERO_DATA_INFORMATION
{
    LARGE_INTEGER FileOffset;
    LARGE_INTEGER BeyondFinalZero;

} FILE_ZERO_DATA_INFORMATION, *PFILE_ZERO_DATA_INFORMATION;

typedef struct _FILE_ZERO_DATA_INFORMATION_EX
{
    LARGE_INTEGER FileOffset;
    LARGE_INTEGER BeyondFinalZero;
    DWORD Flags;

} FILE_ZERO_DATA_INFORMATION_EX, *PFILE_ZERO_DATA_INFORMATION_EX;

typedef struct _FILE_ALLOCATED_RANGE_BUFFER
{
    LARGE_INTEGER FileOffset;
    LARGE_INTEGER Length;

} FILE_ALLOCATED_RANGE_BUFFER, *PFILE_ALLOCATED_RANGE_BUFFER;

typedef struct _ENCRYPTION_BUFFER
{
    DWORD EncryptionOperation;
    BYTE Private[1];

} ENCRYPTION_BUFFER, *PENCRYPTION_BUFFER;

typedef struct _DECRYPTION_STATUS_BUFFER
{
    BOOLEAN NoEncryptedStreams;

} DECRYPTION_STATUS_BUFFER, *PDECRYPTION_STATUS_BUFFER;

typedef struct _REQUEST_RAW_ENCRYPTED_DATA
{
    LONGLONG FileOffset;
    DWORD Length;

} REQUEST_RAW_ENCRYPTED_DATA, *PREQUEST_RAW_ENCRYPTED_DATA;

typedef struct _ENCRYPTED_DATA_INFO
{
    DWORDLONG StartingFileOffset;

    DWORD OutputBufferOffset;

    DWORD BytesWithinFileSize;

    DWORD BytesWithinValidDataLength;

    WORD CompressionFormat;

    BYTE DataUnitShift;
    BYTE ChunkShift;
    BYTE ClusterShift;

    BYTE EncryptionFormat;

    WORD NumberOfDataBlocks;

    DWORD DataBlockSize[1];

} ENCRYPTED_DATA_INFO, *PENCRYPTED_DATA_INFO;

typedef struct _EXTENDED_ENCRYPTED_DATA_INFO
{
    DWORD ExtendedCode;

    DWORD Length;

    DWORD Flags;
    DWORD Reserved;

} EXTENDED_ENCRYPTED_DATA_INFO, *PEXTENDED_ENCRYPTED_DATA_INFO;

typedef struct _PLEX_READ_DATA_REQUEST
{
    LARGE_INTEGER ByteOffset;
    DWORD ByteLength;
    DWORD PlexNumber;

} PLEX_READ_DATA_REQUEST, *PPLEX_READ_DATA_REQUEST;

typedef struct _SI_COPYFILE
{
    DWORD SourceFileNameLength;
    DWORD DestinationFileNameLength;
    DWORD Flags;
    WCHAR FileNameBuffer[1];
} SI_COPYFILE, *PSI_COPYFILE;

typedef struct _FILE_MAKE_COMPATIBLE_BUFFER
{
    BOOLEAN CloseDisc;
} FILE_MAKE_COMPATIBLE_BUFFER, *PFILE_MAKE_COMPATIBLE_BUFFER;

typedef struct _FILE_SET_DEFECT_MGMT_BUFFER
{
    BOOLEAN Disable;
} FILE_SET_DEFECT_MGMT_BUFFER, *PFILE_SET_DEFECT_MGMT_BUFFER;

typedef struct _FILE_QUERY_SPARING_BUFFER
{
    DWORD SparingUnitBytes;
    BOOLEAN SoftwareSparing;
    DWORD TotalSpareBlocks;
    DWORD FreeSpareBlocks;
} FILE_QUERY_SPARING_BUFFER, *PFILE_QUERY_SPARING_BUFFER;

typedef struct _FILE_QUERY_ON_DISK_VOL_INFO_BUFFER
{
    LARGE_INTEGER DirectoryCount;
    LARGE_INTEGER FileCount;
    WORD FsFormatMajVersion;
    WORD FsFormatMinVersion;
    WCHAR FsFormatName[12];
    LARGE_INTEGER FormatTime;
    LARGE_INTEGER LastUpdateTime;
    WCHAR CopyrightInfo[34];
    WCHAR AbstractInfo[34];
    WCHAR FormattingImplementationInfo[34];
    WCHAR LastModifyingImplementationInfo[34];
} FILE_QUERY_ON_DISK_VOL_INFO_BUFFER, *PFILE_QUERY_ON_DISK_VOL_INFO_BUFFER;

typedef DWORDLONG CLSN;

typedef struct _FILE_INITIATE_REPAIR_OUTPUT_BUFFER
{
    DWORDLONG Hint1;
    DWORDLONG Hint2;
    CLSN Clsn;
    DWORD Status;
} FILE_INITIATE_REPAIR_OUTPUT_BUFFER, *PFILE_INITIATE_REPAIR_OUTPUT_BUFFER;

typedef enum _SHRINK_VOLUME_REQUEST_TYPES
{
    ShrinkPrepare = 1,
    ShrinkCommit,
    ShrinkAbort

} SHRINK_VOLUME_REQUEST_TYPES,
*PSHRINK_VOLUME_REQUEST_TYPES;

typedef struct _SHRINK_VOLUME_INFORMATION
{
    SHRINK_VOLUME_REQUEST_TYPES ShrinkRequestType;
    DWORDLONG Flags;
    LONGLONG NewNumberOfSectors;

} SHRINK_VOLUME_INFORMATION, *PSHRINK_VOLUME_INFORMATION;

typedef struct _TXFS_MODIFY_RM
{
    DWORD Flags;

    DWORD LogContainerCountMax;

    DWORD LogContainerCountMin;

    DWORD LogContainerCount;

    DWORD LogGrowthIncrement;

    DWORD LogAutoShrinkPercentage;

    DWORDLONG Reserved;

    WORD LoggingMode;

} TXFS_MODIFY_RM, *PTXFS_MODIFY_RM;

typedef struct _TXFS_QUERY_RM_INFORMATION
{
    DWORD BytesRequired;

    DWORDLONG TailLsn;

    DWORDLONG CurrentLsn;

    DWORDLONG ArchiveTailLsn;

    DWORDLONG LogContainerSize;

    LARGE_INTEGER HighestVirtualClock;

    DWORD LogContainerCount;

    DWORD LogContainerCountMax;

    DWORD LogContainerCountMin;

    DWORD LogGrowthIncrement;

    DWORD LogAutoShrinkPercentage;

    DWORD Flags;

    WORD LoggingMode;

    WORD Reserved;

    DWORD RmState;

    DWORDLONG LogCapacity;

    DWORDLONG LogFree;

    DWORDLONG TopsSize;

    DWORDLONG TopsUsed;

    DWORDLONG TransactionCount;

    DWORDLONG OnePCCount;

    DWORDLONG TwoPCCount;

    DWORDLONG NumberLogFileFull;

    DWORDLONG OldestTransactionAge;

    GUID RMName;

    DWORD TmLogPathOffset;

} TXFS_QUERY_RM_INFORMATION, *PTXFS_QUERY_RM_INFORMATION;

typedef struct _TXFS_ROLLFORWARD_REDO_INFORMATION
{
    LARGE_INTEGER LastVirtualClock;
    DWORDLONG LastRedoLsn;
    DWORDLONG HighestRecoveryLsn;
    DWORD Flags;
} TXFS_ROLLFORWARD_REDO_INFORMATION, *PTXFS_ROLLFORWARD_REDO_INFORMATION;

#pragma deprecated(TXFS_ROLLFORWARD_REDO_INFORMATION)
#pragma deprecated(PTXFS_ROLLFORWARD_REDO_INFORMATION)

typedef struct _TXFS_START_RM_INFORMATION
{
    DWORD Flags;

    DWORDLONG LogContainerSize;

    DWORD LogContainerCountMin;

    DWORD LogContainerCountMax;

    DWORD LogGrowthIncrement;

    DWORD LogAutoShrinkPercentage;

    DWORD TmLogPathOffset;

    WORD TmLogPathLength;

    WORD LoggingMode;

    WORD LogPathLength;

    WORD Reserved;

    WCHAR LogPath[1];

} TXFS_START_RM_INFORMATION, *PTXFS_START_RM_INFORMATION;

#pragma deprecated(TXFS_START_RM_INFORMATION)
#pragma deprecated(PTXFS_START_RM_INFORMATION)

typedef struct _TXFS_GET_METADATA_INFO_OUT
{
    struct
    {
        LONGLONG LowPart;
        LONGLONG HighPart;
    } TxfFileId;

    GUID LockingTransaction;

    DWORDLONG LastLsn;

    DWORD TransactionState;

} TXFS_GET_METADATA_INFO_OUT, *PTXFS_GET_METADATA_INFO_OUT;

typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY
{
    DWORDLONG Offset;

    DWORD NameFlags;

    LONGLONG FileId;

    DWORD Reserved1;
    DWORD Reserved2;
    LONGLONG Reserved3;

    WCHAR FileName[1];
} TXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY, *PTXFS_LIST_TRANSACTION_LOCKED_FILES_ENTRY;

typedef struct _TXFS_LIST_TRANSACTION_LOCKED_FILES
{
    GUID KtmTransaction;

    DWORDLONG NumberOfFiles;

    DWORDLONG BufferSizeRequired;

    DWORDLONG Offset;
} TXFS_LIST_TRANSACTION_LOCKED_FILES, *PTXFS_LIST_TRANSACTION_LOCKED_FILES;

typedef struct _TXFS_LIST_TRANSACTIONS_ENTRY
{
    GUID TransactionId;

    DWORD TransactionState;

    DWORD Reserved1;
    DWORD Reserved2;
    LONGLONG Reserved3;
} TXFS_LIST_TRANSACTIONS_ENTRY, *PTXFS_LIST_TRANSACTIONS_ENTRY;

typedef struct _TXFS_LIST_TRANSACTIONS
{
    DWORDLONG NumberOfTransactions;

    DWORDLONG BufferSizeRequired;
} TXFS_LIST_TRANSACTIONS, *PTXFS_LIST_TRANSACTIONS;

#pragma warning(push)
#pragma warning(disable : 4201)

typedef struct _TXFS_READ_BACKUP_INFORMATION_OUT
{
    union
    {
        DWORD BufferLength;

        BYTE Buffer[1];
    };
} TXFS_READ_BACKUP_INFORMATION_OUT, *PTXFS_READ_BACKUP_INFORMATION_OUT;

#pragma warning(pop)

typedef struct _TXFS_WRITE_BACKUP_INFORMATION
{
    BYTE Buffer[1];
} TXFS_WRITE_BACKUP_INFORMATION, *PTXFS_WRITE_BACKUP_INFORMATION;

typedef struct _TXFS_GET_TRANSACTED_VERSION
{
    DWORD ThisBaseVersion;

    DWORD LatestVersion;

    WORD ThisMiniVersion;

    WORD FirstMiniVersion;

    WORD LatestMiniVersion;

} TXFS_GET_TRANSACTED_VERSION, *PTXFS_GET_TRANSACTED_VERSION;

typedef struct _TXFS_SAVEPOINT_INFORMATION
{
    HANDLE KtmTransaction;

    DWORD ActionCode;

    DWORD SavepointId;

} TXFS_SAVEPOINT_INFORMATION, *PTXFS_SAVEPOINT_INFORMATION;

#pragma deprecated(TXFS_SAVEPOINT_INFORMATION)
#pragma deprecated(PTXFS_SAVEPOINT_INFORMATION)

typedef struct _TXFS_CREATE_MINIVERSION_INFO
{
    WORD StructureVersion;

    WORD StructureLength;

    DWORD BaseVersion;

    WORD MiniVersion;

} TXFS_CREATE_MINIVERSION_INFO, *PTXFS_CREATE_MINIVERSION_INFO;

#pragma deprecated(TXFS_CREATE_MINIVERSION_INFO)
#pragma deprecated(PTXFS_CREATE_MINIVERSION_INFO)

typedef struct _TXFS_TRANSACTION_ACTIVE_INFO
{
    BOOLEAN TransactionsActiveAtSnapshot;

} TXFS_TRANSACTION_ACTIVE_INFO, *PTXFS_TRANSACTION_ACTIVE_INFO;

typedef struct _BOOT_AREA_INFO
{
    DWORD BootSectorCount;
    struct
    {
        LARGE_INTEGER Offset;
    } BootSectors[2];

} BOOT_AREA_INFO, *PBOOT_AREA_INFO;

typedef struct _RETRIEVAL_POINTER_BASE
{
    LARGE_INTEGER FileAreaOffset;
} RETRIEVAL_POINTER_BASE, *PRETRIEVAL_POINTER_BASE;

typedef struct _FILE_FS_PERSISTENT_VOLUME_INFORMATION
{
    DWORD VolumeFlags;
    DWORD FlagMask;
    DWORD Version;
    DWORD Reserved;

} FILE_FS_PERSISTENT_VOLUME_INFORMATION, *PFILE_FS_PERSISTENT_VOLUME_INFORMATION;

typedef struct _FILE_SYSTEM_RECOGNITION_INFORMATION
{
    CHAR FileSystem[9];

} FILE_SYSTEM_RECOGNITION_INFORMATION, *PFILE_SYSTEM_RECOGNITION_INFORMATION;

typedef struct _REQUEST_OPLOCK_INPUT_BUFFER
{
    WORD StructureVersion;

    WORD StructureLength;

    DWORD RequestedOplockLevel;

    DWORD Flags;

} REQUEST_OPLOCK_INPUT_BUFFER, *PREQUEST_OPLOCK_INPUT_BUFFER;

typedef struct _REQUEST_OPLOCK_OUTPUT_BUFFER
{
    WORD StructureVersion;

    WORD StructureLength;

    DWORD OriginalOplockLevel;

    DWORD NewOplockLevel;

    DWORD Flags;

    ACCESS_MASK AccessMode;

    WORD ShareMode;

} REQUEST_OPLOCK_OUTPUT_BUFFER, *PREQUEST_OPLOCK_OUTPUT_BUFFER;

typedef struct _VIRTUAL_STORAGE_TYPE
{
    DWORD DeviceId;
    GUID VendorId;
} VIRTUAL_STORAGE_TYPE, *PVIRTUAL_STORAGE_TYPE;

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST
{
    DWORD RequestLevel;
    DWORD RequestFlags;
} STORAGE_QUERY_DEPENDENT_VOLUME_REQUEST, *PSTORAGE_QUERY_DEPENDENT_VOLUME_REQUEST;

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY
{
    DWORD EntryLength;
    DWORD DependencyTypeFlags;
    DWORD ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
} STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY, *PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY;

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY
{
    DWORD EntryLength;
    DWORD DependencyTypeFlags;
    DWORD ProviderSpecificFlags;
    VIRTUAL_STORAGE_TYPE VirtualStorageType;
    DWORD AncestorLevel;
    DWORD HostVolumeNameOffset;
    DWORD HostVolumeNameSize;
    DWORD DependentVolumeNameOffset;
    DWORD DependentVolumeNameSize;
    DWORD RelativePathOffset;
    DWORD RelativePathSize;
    DWORD DependentDeviceNameOffset;
    DWORD DependentDeviceNameSize;
} STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY, *PSTORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY;

#pragma warning(push)
#pragma warning(disable : 4200)

typedef struct _STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE
{
    DWORD ResponseLevel;
    DWORD NumberEntries;
    union
    {
        STORAGE_QUERY_DEPENDENT_VOLUME_LEV1_ENTRY Lev1Depends[];
        STORAGE_QUERY_DEPENDENT_VOLUME_LEV2_ENTRY Lev2Depends[];
    };
} STORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE, *PSTORAGE_QUERY_DEPENDENT_VOLUME_RESPONSE;

#pragma warning(pop)

typedef struct _SD_CHANGE_MACHINE_SID_INPUT
{
    WORD CurrentMachineSIDOffset;
    WORD CurrentMachineSIDLength;

    WORD NewMachineSIDOffset;
    WORD NewMachineSIDLength;

} SD_CHANGE_MACHINE_SID_INPUT, *PSD_CHANGE_MACHINE_SID_INPUT;

typedef struct _SD_CHANGE_MACHINE_SID_OUTPUT
{
    DWORDLONG NumSDChangedSuccess;

    DWORDLONG NumSDChangedFail;

    DWORDLONG NumSDUnused;

    DWORDLONG NumSDTotal;

    DWORDLONG NumMftSDChangedSuccess;

    DWORDLONG NumMftSDChangedFail;

    DWORDLONG NumMftSDTotal;

} SD_CHANGE_MACHINE_SID_OUTPUT, *PSD_CHANGE_MACHINE_SID_OUTPUT;

typedef struct _SD_QUERY_STATS_INPUT
{
    DWORD Reserved;

} SD_QUERY_STATS_INPUT, *PSD_QUERY_STATS_INPUT;

typedef struct _SD_QUERY_STATS_OUTPUT
{
    DWORDLONG SdsStreamSize;
    DWORDLONG SdsAllocationSize;

    DWORDLONG SiiStreamSize;
    DWORDLONG SiiAllocationSize;

    DWORDLONG SdhStreamSize;
    DWORDLONG SdhAllocationSize;

    DWORDLONG NumSDTotal;

    DWORDLONG NumSDUnused;

} SD_QUERY_STATS_OUTPUT, *PSD_QUERY_STATS_OUTPUT;

typedef struct _SD_ENUM_SDS_INPUT
{
    DWORDLONG StartingOffset;

    DWORDLONG MaxSDEntriesToReturn;

} SD_ENUM_SDS_INPUT, *PSD_ENUM_SDS_INPUT;

typedef struct _SD_ENUM_SDS_ENTRY
{
    DWORD Hash;

    DWORD SecurityId;

    DWORDLONG Offset;

    DWORD Length;

    BYTE Descriptor[1];

} SD_ENUM_SDS_ENTRY, *PSD_ENUM_SDS_ENTRY;

typedef struct _SD_ENUM_SDS_OUTPUT
{
    DWORDLONG NextOffset;

    DWORDLONG NumSDEntriesReturned;

    DWORDLONG NumSDBytesReturned;

    SD_ENUM_SDS_ENTRY SDEntry[1];

} SD_ENUM_SDS_OUTPUT, *PSD_ENUM_SDS_OUTPUT;

#pragma warning(push)
#pragma warning(disable : 4201)

typedef struct _SD_GLOBAL_CHANGE_INPUT
{
    DWORD Flags;

    DWORD ChangeType;

    union
    {
        SD_CHANGE_MACHINE_SID_INPUT SdChange;
        SD_QUERY_STATS_INPUT SdQueryStats;
        SD_ENUM_SDS_INPUT SdEnumSds;
    };

} SD_GLOBAL_CHANGE_INPUT, *PSD_GLOBAL_CHANGE_INPUT;

typedef struct _SD_GLOBAL_CHANGE_OUTPUT
{
    DWORD Flags;

    DWORD ChangeType;

    union
    {
        SD_CHANGE_MACHINE_SID_OUTPUT SdChange;
        SD_QUERY_STATS_OUTPUT SdQueryStats;
        SD_ENUM_SDS_OUTPUT SdEnumSds;
    };

} SD_GLOBAL_CHANGE_OUTPUT, *PSD_GLOBAL_CHANGE_OUTPUT;

#pragma warning(pop)

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_INPUT
{
    DWORD Flags;

    DWORD NumberOfClusters;

    LARGE_INTEGER Cluster[1];
} LOOKUP_STREAM_FROM_CLUSTER_INPUT, *PLOOKUP_STREAM_FROM_CLUSTER_INPUT;

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_OUTPUT
{
    DWORD Offset;

    DWORD NumberOfMatches;

    DWORD BufferSizeRequired;
} LOOKUP_STREAM_FROM_CLUSTER_OUTPUT, *PLOOKUP_STREAM_FROM_CLUSTER_OUTPUT;

typedef struct _LOOKUP_STREAM_FROM_CLUSTER_ENTRY
{
    DWORD OffsetToNext;

    DWORD Flags;

    LARGE_INTEGER Reserved;

    LARGE_INTEGER Cluster;

    WCHAR FileName[1];
} LOOKUP_STREAM_FROM_CLUSTER_ENTRY, *PLOOKUP_STREAM_FROM_CLUSTER_ENTRY;

typedef struct _FILE_TYPE_NOTIFICATION_INPUT
{
    DWORD Flags;

    DWORD NumFileTypeIDs;

    GUID FileTypeID[1];

} FILE_TYPE_NOTIFICATION_INPUT, *PFILE_TYPE_NOTIFICATION_INPUT;

extern "C" const GUID FILE_TYPE_NOTIFICATION_GUID_PAGE_FILE;
extern "C" const GUID FILE_TYPE_NOTIFICATION_GUID_HIBERNATION_FILE;
extern "C" const GUID FILE_TYPE_NOTIFICATION_GUID_CRASHDUMP_FILE;

typedef struct _CSV_MGMT_LOCK
{
    DWORD Flags;
} CSV_MGMT_LOCK, *PCSV_MGMT_LOCK;

typedef struct _CSV_NAMESPACE_INFO
{
    DWORD Version;
    DWORD DeviceNumber;
    LARGE_INTEGER StartingOffset;
    DWORD SectorSize;

} CSV_NAMESPACE_INFO, *PCSV_NAMESPACE_INFO;

typedef enum _CSV_CONTROL_OP
{
    CsvControlStartRedirectFile = 0x02,
    CsvControlStopRedirectFile = 0x03,
    CsvControlQueryRedirectState = 0x04,
    CsvControlQueryFileRevision = 0x06,
    CsvControlQueryMdsPath = 0x08,
    CsvControlQueryFileRevisionFileId128 = 0x09,
    CsvControlQueryVolumeRedirectState = 0x0a,
    CsvControlEnableUSNRangeModificationTracking = 0x0d,
    CsvControlMarkHandleLocalVolumeMount = 0x0e,
    CsvControlUnmarkHandleLocalVolumeMount = 0x0f,
    CsvControlGetCsvFsMdsPathV2 = 0x12,
    CsvControlDisableCaching = 0x13,
    CsvControlEnableCaching = 0x14,
} CSV_CONTROL_OP,
*PCSV_CONTROL_OP;

typedef struct _CSV_CONTROL_PARAM
{
    CSV_CONTROL_OP Operation;
    LONGLONG Unused;
} CSV_CONTROL_PARAM, *PCSV_CONTROL_PARAM;

typedef struct _CSV_QUERY_REDIRECT_STATE
{
    DWORD MdsNodeId;
    DWORD DsNodeId;
    BOOLEAN FileRedirected;
} CSV_QUERY_REDIRECT_STATE, *PCSV_QUERY_REDIRECT_STATE;

typedef struct _CSV_QUERY_FILE_REVISION
{
    LONGLONG FileId;

    LONGLONG FileRevision[3];

} CSV_QUERY_FILE_REVISION, *PCSV_QUERY_FILE_REVISION;

typedef struct _CSV_QUERY_FILE_REVISION_FILE_ID_128
{
    FILE_ID_128 FileId;

    LONGLONG FileRevision[3];

} CSV_QUERY_FILE_REVISION_FILE_ID_128, *PCSV_QUERY_FILE_REVISION_FILE_ID_128;

typedef struct _CSV_QUERY_MDS_PATH
{
    DWORD MdsNodeId;
    DWORD DsNodeId;
    DWORD PathLength;
    WCHAR Path[1];
} CSV_QUERY_MDS_PATH, *PCSV_QUERY_MDS_PATH;

typedef enum _CSVFS_DISK_CONNECTIVITY
{
    CsvFsDiskConnectivityNone = 0,
    CsvFsDiskConnectivityMdsNodeOnly = 1,
    CsvFsDiskConnectivitySubsetOfNodes = 2,
    CsvFsDiskConnectivityAllNodes = 3
} CSVFS_DISK_CONNECTIVITY,
*PCSVFS_DISK_CONNECTIVITY;

typedef struct _CSV_QUERY_VOLUME_REDIRECT_STATE
{
    DWORD MdsNodeId;
    DWORD DsNodeId;
    BOOLEAN IsDiskConnected;
    BOOLEAN ClusterEnableDirectIo;
    CSVFS_DISK_CONNECTIVITY DiskConnectivity;
} CSV_QUERY_VOLUME_REDIRECT_STATE, *PCSV_QUERY_VOLUME_REDIRECT_STATE;

typedef struct _CSV_QUERY_MDS_PATH_V2
{
    LONGLONG Version;

    DWORD RequiredSize;

    DWORD MdsNodeId;
    DWORD DsNodeId;

    DWORD Flags;

    CSVFS_DISK_CONNECTIVITY DiskConnectivity;

    GUID VolumeId;

    DWORD IpAddressOffset;
    DWORD IpAddressLength;

    DWORD PathOffset;
    DWORD PathLength;

} CSV_QUERY_MDS_PATH_V2, *PCSV_QUERY_MDS_PATH_V2;

typedef struct _CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT
{
    DWORDLONG VetoedFromAltitudeIntegral;
    DWORDLONG VetoedFromAltitudeDecimal;
    WCHAR Reason[256];
} CSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT, *PCSV_QUERY_VETO_FILE_DIRECT_IO_OUTPUT;

typedef enum _STORAGE_RESERVE_ID
{

    StorageReserveIdNone = 0,
    StorageReserveIdHard,
    StorageReserveIdSoft,

    StorageReserveIdMax

} STORAGE_RESERVE_ID,
*PSTORAGE_RESERVE_ID;

typedef struct _CSV_IS_OWNED_BY_CSVFS
{
    BOOLEAN OwnedByCSVFS;
} CSV_IS_OWNED_BY_CSVFS, *PCSV_IS_OWNED_BY_CSVFS;

typedef struct _FILE_LEVEL_TRIM_RANGE
{
    DWORDLONG Offset;

    DWORDLONG Length;
} FILE_LEVEL_TRIM_RANGE, *PFILE_LEVEL_TRIM_RANGE;

typedef struct _FILE_LEVEL_TRIM
{
    DWORD Key;

    DWORD NumRanges;

    FILE_LEVEL_TRIM_RANGE Ranges[1];

} FILE_LEVEL_TRIM, *PFILE_LEVEL_TRIM;

typedef struct _FILE_LEVEL_TRIM_OUTPUT
{
    DWORD NumRangesProcessed;

} FILE_LEVEL_TRIM_OUTPUT, *PFILE_LEVEL_TRIM_OUTPUT;

typedef enum _QUERY_FILE_LAYOUT_FILTER_TYPE
{

    QUERY_FILE_LAYOUT_FILTER_TYPE_NONE = 0,
    QUERY_FILE_LAYOUT_FILTER_TYPE_CLUSTERS = 1,
    QUERY_FILE_LAYOUT_FILTER_TYPE_FILEID = 2,

    QUERY_FILE_LAYOUT_FILTER_TYPE_STORAGE_RESERVE_ID = 3,

    QUERY_FILE_LAYOUT_NUM_FILTER_TYPES

} QUERY_FILE_LAYOUT_FILTER_TYPE;

typedef struct _CLUSTER_RANGE
{
    LARGE_INTEGER StartingCluster;

    LARGE_INTEGER ClusterCount;

} CLUSTER_RANGE, *PCLUSTER_RANGE;

typedef struct _FILE_REFERENCE_RANGE
{
    DWORDLONG StartingFileReferenceNumber;

    DWORDLONG EndingFileReferenceNumber;

} FILE_REFERENCE_RANGE, *PFILE_REFERENCE_RANGE;

typedef struct _QUERY_FILE_LAYOUT_INPUT
{
    union
    {
        DWORD FilterEntryCount;
        DWORD NumberOfPairs;
    };

    DWORD Flags;

    QUERY_FILE_LAYOUT_FILTER_TYPE FilterType;

    DWORD Reserved;

    union
    {
        CLUSTER_RANGE ClusterRanges[1];

        FILE_REFERENCE_RANGE FileReferenceRanges[1];

        STORAGE_RESERVE_ID StorageReserveIds[1];

    } Filter;

} QUERY_FILE_LAYOUT_INPUT, *PQUERY_FILE_LAYOUT_INPUT;

typedef struct _QUERY_FILE_LAYOUT_OUTPUT
{
    DWORD FileEntryCount;

    DWORD FirstFileOffset;

    DWORD Flags;

    DWORD Reserved;

} QUERY_FILE_LAYOUT_OUTPUT, *PQUERY_FILE_LAYOUT_OUTPUT;

typedef struct _FILE_LAYOUT_ENTRY
{
    DWORD Version;

    DWORD NextFileOffset;

    DWORD Flags;

    DWORD FileAttributes;

    DWORDLONG FileReferenceNumber;

    DWORD FirstNameOffset;

    DWORD FirstStreamOffset;

    DWORD ExtraInfoOffset;

    DWORD ExtraInfoLength;

} FILE_LAYOUT_ENTRY, *PFILE_LAYOUT_ENTRY;

typedef struct _FILE_LAYOUT_NAME_ENTRY
{
    DWORD NextNameOffset;

    DWORD Flags;

    DWORDLONG ParentFileReferenceNumber;

    DWORD FileNameLength;

    DWORD Reserved;

    WCHAR FileName[1];

} FILE_LAYOUT_NAME_ENTRY, *PFILE_LAYOUT_NAME_ENTRY;

typedef struct _FILE_LAYOUT_INFO_ENTRY
{
    struct
    {
        LARGE_INTEGER CreationTime;
        LARGE_INTEGER LastAccessTime;
        LARGE_INTEGER LastWriteTime;
        LARGE_INTEGER ChangeTime;
        DWORD FileAttributes;
    } BasicInformation;

    DWORD OwnerId;

    DWORD SecurityId;

    USN Usn;

    STORAGE_RESERVE_ID StorageReserveId;

} FILE_LAYOUT_INFO_ENTRY, *PFILE_LAYOUT_INFO_ENTRY;

typedef struct _STREAM_LAYOUT_ENTRY
{
    DWORD Version;

    DWORD NextStreamOffset;

    DWORD Flags;

    DWORD ExtentInformationOffset;

    LARGE_INTEGER AllocationSize;

    LARGE_INTEGER EndOfFile;

    DWORD StreamInformationOffset;

    DWORD AttributeTypeCode;

    DWORD AttributeFlags;

    DWORD StreamIdentifierLength;

    WCHAR StreamIdentifier[1];

} STREAM_LAYOUT_ENTRY, *PSTREAM_LAYOUT_ENTRY;

typedef struct _STREAM_EXTENT_ENTRY
{
    DWORD Flags;

    union
    {
        RETRIEVAL_POINTERS_BUFFER RetrievalPointers;

    } ExtentInformation;

} STREAM_EXTENT_ENTRY, *PSTREAM_EXTENT_ENTRY;

typedef struct _FSCTL_GET_INTEGRITY_INFORMATION_BUFFER
{
    WORD ChecksumAlgorithm;
    WORD Reserved;
    DWORD Flags;
    DWORD ChecksumChunkSizeInBytes;
    DWORD ClusterSizeInBytes;
} FSCTL_GET_INTEGRITY_INFORMATION_BUFFER, *PFSCTL_GET_INTEGRITY_INFORMATION_BUFFER;

typedef struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER
{
    WORD ChecksumAlgorithm;
    WORD Reserved;
    DWORD Flags;
} FSCTL_SET_INTEGRITY_INFORMATION_BUFFER, *PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER;

typedef struct _FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX
{
    BYTE EnableIntegrity;
    BYTE KeepIntegrityStateUnchanged;
    WORD Reserved;
    DWORD Flags;
    BYTE Version;
    BYTE Reserved2[7];
} FSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX, *PFSCTL_SET_INTEGRITY_INFORMATION_BUFFER_EX;

typedef struct _FSCTL_OFFLOAD_READ_INPUT
{
    DWORD Size;
    DWORD Flags;
    DWORD TokenTimeToLive;
    DWORD Reserved;
    DWORDLONG FileOffset;
    DWORDLONG CopyLength;
} FSCTL_OFFLOAD_READ_INPUT, *PFSCTL_OFFLOAD_READ_INPUT;

typedef struct _FSCTL_OFFLOAD_READ_OUTPUT
{
    DWORD Size;
    DWORD Flags;
    DWORDLONG TransferLength;
    BYTE Token[512];
} FSCTL_OFFLOAD_READ_OUTPUT, *PFSCTL_OFFLOAD_READ_OUTPUT;

typedef struct _FSCTL_OFFLOAD_WRITE_INPUT
{
    DWORD Size;
    DWORD Flags;
    DWORDLONG FileOffset;
    DWORDLONG CopyLength;
    DWORDLONG TransferOffset;
    BYTE Token[512];
} FSCTL_OFFLOAD_WRITE_INPUT, *PFSCTL_OFFLOAD_WRITE_INPUT;

typedef struct _FSCTL_OFFLOAD_WRITE_OUTPUT
{
    DWORD Size;
    DWORD Flags;
    DWORDLONG LengthWritten;
} FSCTL_OFFLOAD_WRITE_OUTPUT, *PFSCTL_OFFLOAD_WRITE_OUTPUT;

typedef struct _SET_PURGE_FAILURE_MODE_INPUT
{
    DWORD Flags;
} SET_PURGE_FAILURE_MODE_INPUT, *PSET_PURGE_FAILURE_MODE_INPUT;

typedef struct _REPAIR_COPIES_INPUT
{
    DWORD Size;

    DWORD Flags;

    LARGE_INTEGER FileOffset;

    DWORD Length;

    DWORD SourceCopy;

    DWORD NumberOfRepairCopies;

    DWORD RepairCopies[1];

} REPAIR_COPIES_INPUT, *PREPAIR_COPIES_INPUT;

typedef struct _REPAIR_COPIES_OUTPUT
{
    DWORD Size;

    DWORD Status;

    LARGE_INTEGER ResumeFileOffset;

} REPAIR_COPIES_OUTPUT, *PREPAIR_COPIES_OUTPUT;

typedef struct _FILE_REGION_INFO
{
    LONGLONG FileOffset;
    LONGLONG Length;
    DWORD Usage;
    DWORD Reserved;
} FILE_REGION_INFO, *PFILE_REGION_INFO;

typedef struct _FILE_REGION_OUTPUT
{
    DWORD Flags;
    DWORD TotalRegionEntryCount;
    DWORD RegionEntryCount;
    DWORD Reserved;
    FILE_REGION_INFO Region[1];
} FILE_REGION_OUTPUT, *PFILE_REGION_OUTPUT;

typedef struct _FILE_REGION_INPUT
{
    LONGLONG FileOffset;
    LONGLONG Length;
    DWORD DesiredUsage;

} FILE_REGION_INPUT, *PFILE_REGION_INPUT;

typedef struct _WRITE_USN_REASON_INPUT
{
    DWORD Flags;
    DWORD UsnReasonToWrite;

} WRITE_USN_REASON_INPUT, *PWRITE_USN_REASON_INPUT;

typedef enum _FILE_STORAGE_TIER_MEDIA_TYPE
{

    FileStorageTierMediaTypeUnspecified = 0,
    FileStorageTierMediaTypeDisk = 1,
    FileStorageTierMediaTypeSsd = 2,
    FileStorageTierMediaTypeScm = 4,
    FileStorageTierMediaTypeMax

} FILE_STORAGE_TIER_MEDIA_TYPE,
*PFILE_STORAGE_TIER_MEDIA_TYPE;

typedef enum _FILE_STORAGE_TIER_CLASS
{

    FileStorageTierClassUnspecified = 0,
    FileStorageTierClassCapacity,
    FileStorageTierClassPerformance,
    FileStorageTierClassMax

} FILE_STORAGE_TIER_CLASS,
*PFILE_STORAGE_TIER_CLASS;

typedef struct _FILE_STORAGE_TIER
{
    GUID Id;

    WCHAR Name[(256)];

    WCHAR Description[(256)];

    DWORDLONG Flags;

    DWORDLONG ProvisionedCapacity;

    FILE_STORAGE_TIER_MEDIA_TYPE MediaType;

    FILE_STORAGE_TIER_CLASS Class;

} FILE_STORAGE_TIER, *PFILE_STORAGE_TIER;

typedef struct _FSCTL_QUERY_STORAGE_CLASSES_OUTPUT
{
    DWORD Version;

    DWORD Size;

    DWORD Flags;

    DWORD TotalNumberOfTiers;

    DWORD NumberOfTiersReturned;

    FILE_STORAGE_TIER Tiers[1];

} FSCTL_QUERY_STORAGE_CLASSES_OUTPUT, *PFSCTL_QUERY_STORAGE_CLASSES_OUTPUT;

typedef struct _STREAM_INFORMATION_ENTRY
{
    DWORD Version;

    DWORD Flags;

    union _StreamInformation
    {
        struct _DesiredStorageClass
        {
            FILE_STORAGE_TIER_CLASS Class;

            DWORD Flags;

        } DesiredStorageClass;

    } StreamInformation;

} STREAM_INFORMATION_ENTRY, *PSTREAM_INFORMATION_ENTRY;

typedef struct _FSCTL_QUERY_REGION_INFO_INPUT
{
    DWORD Version;
    DWORD Size;

    DWORD Flags;

    DWORD NumberOfTierIds;
    GUID TierIds[1];

} FSCTL_QUERY_REGION_INFO_INPUT, *PFSCTL_QUERY_REGION_INFO_INPUT;

typedef struct _FILE_STORAGE_TIER_REGION
{
    GUID TierId;

    DWORDLONG Offset;
    DWORDLONG Length;

} FILE_STORAGE_TIER_REGION, *PFILE_STORAGE_TIER_REGION;

typedef struct _FSCTL_QUERY_REGION_INFO_OUTPUT
{
    DWORD Version;
    DWORD Size;

    DWORD Flags;
    DWORD Reserved;

    DWORDLONG Alignment;

    DWORD TotalNumberOfRegions;
    DWORD NumberOfRegionsReturned;

    FILE_STORAGE_TIER_REGION Regions[1];

} FSCTL_QUERY_REGION_INFO_OUTPUT, *PFSCTL_QUERY_REGION_INFO_OUTPUT;

typedef struct _FILE_DESIRED_STORAGE_CLASS_INFORMATION
{
    FILE_STORAGE_TIER_CLASS Class;

    DWORD Flags;

} FILE_DESIRED_STORAGE_CLASS_INFORMATION, *PFILE_DESIRED_STORAGE_CLASS_INFORMATION;

typedef struct _DUPLICATE_EXTENTS_DATA
{
    HANDLE FileHandle;
    LARGE_INTEGER SourceFileOffset;
    LARGE_INTEGER TargetFileOffset;
    LARGE_INTEGER ByteCount;
} DUPLICATE_EXTENTS_DATA, *PDUPLICATE_EXTENTS_DATA;

typedef struct _DUPLICATE_EXTENTS_DATA32
{
    UINT32 FileHandle;
    LARGE_INTEGER SourceFileOffset;
    LARGE_INTEGER TargetFileOffset;
    LARGE_INTEGER ByteCount;
} DUPLICATE_EXTENTS_DATA32, *PDUPLICATE_EXTENTS_DATA32;

typedef struct _DUPLICATE_EXTENTS_DATA_EX
{
    SIZE_T Size;
    HANDLE FileHandle;
    LARGE_INTEGER SourceFileOffset;
    LARGE_INTEGER TargetFileOffset;
    LARGE_INTEGER ByteCount;
    DWORD Flags;
} DUPLICATE_EXTENTS_DATA_EX, *PDUPLICATE_EXTENTS_DATA_EX;

typedef struct _DUPLICATE_EXTENTS_DATA_EX32
{
    DWORD32 Size;
    DWORD32 FileHandle;
    LARGE_INTEGER SourceFileOffset;
    LARGE_INTEGER TargetFileOffset;
    LARGE_INTEGER ByteCount;
    DWORD Flags;
} DUPLICATE_EXTENTS_DATA_EX32, *PDUPLICATE_EXTENTS_DATA_EX32;

typedef enum _REFS_SMR_VOLUME_GC_STATE
{

    SmrGcStateInactive = 0,
    SmrGcStatePaused = 1,
    SmrGcStateActive = 2,
    SmrGcStateActiveFullSpeed = 3,

} REFS_SMR_VOLUME_GC_STATE,
*PREFS_SMR_VOLUME_GC_STATE;

typedef struct _REFS_SMR_VOLUME_INFO_OUTPUT
{
    DWORD Version;
    DWORD Flags;

    LARGE_INTEGER SizeOfRandomlyWritableTier;
    LARGE_INTEGER FreeSpaceInRandomlyWritableTier;
    LARGE_INTEGER SizeofSMRTier;
    LARGE_INTEGER FreeSpaceInSMRTier;
    LARGE_INTEGER UsableFreeSpaceInSMRTier;

    REFS_SMR_VOLUME_GC_STATE VolumeGcState;
    DWORD VolumeGcLastStatus;

    DWORDLONG Unused[7];

} REFS_SMR_VOLUME_INFO_OUTPUT, *PREFS_SMR_VOLUME_INFO_OUTPUT;

typedef enum _REFS_SMR_VOLUME_GC_ACTION
{

    SmrGcActionStart = 1,
    SmrGcActionStartFullSpeed = 2,
    SmrGcActionPause = 3,
    SmrGcActionStop = 4,

} REFS_SMR_VOLUME_GC_ACTION,
*PREFS_SMR_VOLUME_GC_ACTION;

typedef enum _REFS_SMR_VOLUME_GC_METHOD
{

    SmrGcMethodCompaction = 1,
    SmrGcMethodCompression = 2,
    SmrGcMethodRotation = 3,

} REFS_SMR_VOLUME_GC_METHOD,
*PREFS_SMR_VOLUME_GC_METHOD;

typedef struct _REFS_SMR_VOLUME_GC_PARAMETERS
{
    DWORD Version;
    DWORD Flags;

    REFS_SMR_VOLUME_GC_ACTION Action;
    REFS_SMR_VOLUME_GC_METHOD Method;

    DWORD IoGranularity;
    DWORD CompressionFormat;

    DWORDLONG Unused[8];

} REFS_SMR_VOLUME_GC_PARAMETERS, *PREFS_SMR_VOLUME_GC_PARAMETERS;

typedef struct _STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER
{
    DWORD OptimalWriteSize;
    DWORD StreamGranularitySize;
    DWORD StreamIdMin;
    DWORD StreamIdMax;

} STREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER, *PSTREAMS_QUERY_PARAMETERS_OUTPUT_BUFFER;

typedef struct _STREAMS_ASSOCIATE_ID_INPUT_BUFFER
{
    DWORD Flags;
    DWORD StreamId;

} STREAMS_ASSOCIATE_ID_INPUT_BUFFER, *PSTREAMS_ASSOCIATE_ID_INPUT_BUFFER;

typedef struct _STREAMS_QUERY_ID_OUTPUT_BUFFER
{
    DWORD StreamId;

} STREAMS_QUERY_ID_OUTPUT_BUFFER, *PSTREAMS_QUERY_ID_OUTPUT_BUFFER;

typedef struct _QUERY_BAD_RANGES_INPUT_RANGE
{
    DWORDLONG StartOffset;

    DWORDLONG LengthInBytes;

} QUERY_BAD_RANGES_INPUT_RANGE, *PQUERY_BAD_RANGES_INPUT_RANGE;

typedef struct _QUERY_BAD_RANGES_INPUT
{
    DWORD Flags;

    DWORD NumRanges;

    QUERY_BAD_RANGES_INPUT_RANGE Ranges[1];

} QUERY_BAD_RANGES_INPUT, *PQUERY_BAD_RANGES_INPUT;

typedef struct _QUERY_BAD_RANGES_OUTPUT_RANGE
{
    DWORD Flags;

    DWORD Reserved;

    DWORDLONG StartOffset;

    DWORDLONG LengthInBytes;

} QUERY_BAD_RANGES_OUTPUT_RANGE, *PQUERY_BAD_RANGES_OUTPUT_RANGE;

typedef struct _QUERY_BAD_RANGES_OUTPUT
{
    DWORD Flags;

    DWORD NumBadRanges;

    DWORDLONG NextOffsetToLookUp;

    QUERY_BAD_RANGES_OUTPUT_RANGE BadRanges[1];

} QUERY_BAD_RANGES_OUTPUT, *PQUERY_BAD_RANGES_OUTPUT;

typedef struct _SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT
{
    DWORD Flags;

    DWORD AlignmentShift;

    DWORDLONG FileOffsetToAlign;

    DWORD FallbackAlignmentShift;

} SET_DAX_ALLOC_ALIGNMENT_HINT_INPUT, *PSET_DAX_ALLOC_ALIGNMENT_HINT_INPUT;

typedef enum _VIRTUAL_STORAGE_BEHAVIOR_CODE
{

    VirtualStorageBehaviorUndefined = 0,
    VirtualStorageBehaviorCacheWriteThrough = 1,
    VirtualStorageBehaviorCacheWriteBack = 2

} VIRTUAL_STORAGE_BEHAVIOR_CODE,
*PVIRTUAL_STORAGE_BEHAVIOR_CODE;

typedef struct _VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT
{
    DWORD Size;
    VIRTUAL_STORAGE_BEHAVIOR_CODE BehaviorCode;

} VIRTUAL_STORAGE_SET_BEHAVIOR_INPUT, *PVIRTUAL_STORAGE_SET_BEHAVIOR_INPUT;

typedef struct _ENCRYPTION_KEY_CTRL_INPUT
{
    DWORD HeaderSize;

    DWORD StructureSize;

    WORD KeyOffset;

    WORD KeySize;

    DWORD DplLock;

    DWORDLONG DplUserId;

    DWORDLONG DplCredentialId;

} ENCRYPTION_KEY_CTRL_INPUT, *PENCRYPTION_KEY_CTRL_INPUT;

typedef struct _WOF_EXTERNAL_INFO
{
    DWORD Version;
    DWORD Provider;
} WOF_EXTERNAL_INFO, *PWOF_EXTERNAL_INFO;

typedef struct _WOF_EXTERNAL_FILE_ID
{
    FILE_ID_128 FileId;
} WOF_EXTERNAL_FILE_ID, *PWOF_EXTERNAL_FILE_ID;

typedef struct _WOF_VERSION_INFO
{
    DWORD WofVersion;
} WOF_VERSION_INFO, *PWOF_VERSION_INFO;

typedef struct _WIM_PROVIDER_EXTERNAL_INFO
{
    DWORD Version;
    DWORD Flags;
    LARGE_INTEGER DataSourceId;
    BYTE ResourceHash[20];
} WIM_PROVIDER_EXTERNAL_INFO, *PWIM_PROVIDER_EXTERNAL_INFO;

typedef struct _WIM_PROVIDER_ADD_OVERLAY_INPUT
{
    DWORD WimType;
    DWORD WimIndex;
    DWORD WimFileNameOffset;
    DWORD WimFileNameLength;
} WIM_PROVIDER_ADD_OVERLAY_INPUT, *PWIM_PROVIDER_ADD_OVERLAY_INPUT;

typedef struct _WIM_PROVIDER_UPDATE_OVERLAY_INPUT
{
    LARGE_INTEGER DataSourceId;
    DWORD WimFileNameOffset;
    DWORD WimFileNameLength;
} WIM_PROVIDER_UPDATE_OVERLAY_INPUT, *PWIM_PROVIDER_UPDATE_OVERLAY_INPUT;

typedef struct _WIM_PROVIDER_REMOVE_OVERLAY_INPUT
{
    LARGE_INTEGER DataSourceId;
} WIM_PROVIDER_REMOVE_OVERLAY_INPUT, *PWIM_PROVIDER_REMOVE_OVERLAY_INPUT;

typedef struct _WIM_PROVIDER_SUSPEND_OVERLAY_INPUT
{
    LARGE_INTEGER DataSourceId;
} WIM_PROVIDER_SUSPEND_OVERLAY_INPUT, *PWIM_PROVIDER_SUSPEND_OVERLAY_INPUT;

typedef struct _WIM_PROVIDER_OVERLAY_ENTRY
{
    DWORD NextEntryOffset;
    LARGE_INTEGER DataSourceId;
    GUID WimGuid;
    DWORD WimFileNameOffset;
    DWORD WimType;
    DWORD WimIndex;
    DWORD Flags;
} WIM_PROVIDER_OVERLAY_ENTRY, *PWIM_PROVIDER_OVERLAY_ENTRY;

typedef struct _FILE_PROVIDER_EXTERNAL_INFO_V0
{
    DWORD Version;
    DWORD Algorithm;
} FILE_PROVIDER_EXTERNAL_INFO_V0, *PFILE_PROVIDER_EXTERNAL_INFO_V0;

typedef struct _FILE_PROVIDER_EXTERNAL_INFO_V1
{
    DWORD Version;
    DWORD Algorithm;
    DWORD Flags;
} FILE_PROVIDER_EXTERNAL_INFO_V1, *PFILE_PROVIDER_EXTERNAL_INFO_V1;

typedef FILE_PROVIDER_EXTERNAL_INFO_V1 FILE_PROVIDER_EXTERNAL_INFO;
typedef PFILE_PROVIDER_EXTERNAL_INFO_V1 PFILE_PROVIDER_EXTERNAL_INFO;

typedef struct _CONTAINER_VOLUME_STATE
{
    DWORD Flags;
} CONTAINER_VOLUME_STATE, *PCONTAINER_VOLUME_STATE;

typedef struct _CONTAINER_ROOT_INFO_INPUT
{
    DWORD Flags;
} CONTAINER_ROOT_INFO_INPUT, *PCONTAINER_ROOT_INFO_INPUT;

typedef struct _CONTAINER_ROOT_INFO_OUTPUT
{
    WORD ContainerRootIdLength;
    BYTE ContainerRootId[1];
} CONTAINER_ROOT_INFO_OUTPUT, *PCONTAINER_ROOT_INFO_OUTPUT;

typedef struct _VIRTUALIZATION_INSTANCE_INFO_INPUT
{
    DWORD NumberOfWorkerThreads;
    DWORD Flags;
} VIRTUALIZATION_INSTANCE_INFO_INPUT, *PVIRTUALIZATION_INSTANCE_INFO_INPUT;

typedef struct _VIRTUALIZATION_INSTANCE_INFO_INPUT_EX
{
    WORD HeaderSize;
    DWORD Flags;
    DWORD NotificationInfoSize;
    WORD NotificationInfoOffset;
    WORD ProviderMajorVersion;
} VIRTUALIZATION_INSTANCE_INFO_INPUT_EX, *PVIRTUALIZATION_INSTANCE_INFO_INPUT_EX;

typedef struct _VIRTUALIZATION_INSTANCE_INFO_OUTPUT
{
    GUID VirtualizationInstanceID;
} VIRTUALIZATION_INSTANCE_INFO_OUTPUT, *PVIRTUALIZATION_INSTANCE_INFO_OUTPUT;

typedef struct _GET_FILTER_FILE_IDENTIFIER_INPUT
{
    WORD AltitudeLength;
    WCHAR Altitude[1];
} GET_FILTER_FILE_IDENTIFIER_INPUT, *PGET_FILTER_FILE_IDENTIFIER_INPUT;

typedef struct _GET_FILTER_FILE_IDENTIFIER_OUTPUT
{
    WORD FilterFileIdentifierLength;
    BYTE FilterFileIdentifier[1];
} GET_FILTER_FILE_IDENTIFIER_OUTPUT, *PGET_FILTER_FILE_IDENTIFIER_OUTPUT;

typedef struct _DISK_EXTENT
{
    DWORD DiskNumber;

    LARGE_INTEGER StartingOffset;
    LARGE_INTEGER ExtentLength;

} DISK_EXTENT, *PDISK_EXTENT;

typedef struct _VOLUME_DISK_EXTENTS
{
    DWORD NumberOfDiskExtents;
    DISK_EXTENT Extents[1];

} VOLUME_DISK_EXTENTS, *PVOLUME_DISK_EXTENTS;

typedef struct _VOLUME_GET_GPT_ATTRIBUTES_INFORMATION
{
    DWORDLONG GptAttributes;

} VOLUME_GET_GPT_ATTRIBUTES_INFORMATION, *PVOLUME_GET_GPT_ATTRIBUTES_INFORMATION;

struct _IO_IRP_EXT_TRACK_OFFSET_HEADER;

typedef void (*PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK)(struct _IO_IRP_EXT_TRACK_OFFSET_HEADER* SourceContext,
                                                            struct _IO_IRP_EXT_TRACK_OFFSET_HEADER* TargetContext,
                                                            LONGLONG RelativeOffset);

typedef struct _IO_IRP_EXT_TRACK_OFFSET_HEADER
{
    WORD Validation;

    WORD Flags;

    PIO_IRP_EXT_PROCESS_TRACKED_OFFSET_CALLBACK TrackedOffsetCallback;

} IO_IRP_EXT_TRACK_OFFSET_HEADER, *PIO_IRP_EXT_TRACK_OFFSET_HEADER;

#pragma warning(pop)

#pragma once

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

    typedef DWORD ULONG;
    typedef WORD UWORD;
    typedef BYTE UCHAR;

    extern "C" const GUID GUID_DEVINTERFACE_SMARTCARD_READER;

    typedef struct _SCARD_IO_REQUEST
    {
        DWORD dwProtocol;
        DWORD cbPciLength;
    } SCARD_IO_REQUEST, *PSCARD_IO_REQUEST, *LPSCARD_IO_REQUEST;
    typedef const SCARD_IO_REQUEST* LPCSCARD_IO_REQUEST;

    typedef struct _SCARD_T0_COMMAND
    {
        BYTE bCla, bIns, bP1, bP2, bP3;
    } SCARD_T0_COMMAND, *LPSCARD_T0_COMMAND;

    typedef struct _SCARD_T0_REQUEST
    {
        SCARD_IO_REQUEST ioRequest;
        BYTE bSw1, bSw2;
#pragma warning(push)
#pragma warning(disable : 4201)
        union
        {
            SCARD_T0_COMMAND CmdBytes;
            BYTE rgbHeader[5];
        };
#pragma warning(pop)
    } SCARD_T0_REQUEST;

    typedef SCARD_T0_REQUEST *PSCARD_T0_REQUEST, *LPSCARD_T0_REQUEST;

    typedef struct _SCARD_T1_REQUEST
    {
        SCARD_IO_REQUEST ioRequest;
    } SCARD_T1_REQUEST;
    typedef SCARD_T1_REQUEST *PSCARD_T1_REQUEST, *LPSCARD_T1_REQUEST;

#pragma warning(pop)
}

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

#pragma region Desktop Family

    typedef const BYTE* LPCBYTE;

    typedef const void* LPCVOID;

    __declspec(dllimport) extern const SCARD_IO_REQUEST g_rgSCardT0Pci, g_rgSCardT1Pci, g_rgSCardRawPci;

    typedef ULONG_PTR SCARDCONTEXT;
    typedef SCARDCONTEXT *PSCARDCONTEXT, *LPSCARDCONTEXT;

    typedef ULONG_PTR SCARDHANDLE;
    typedef SCARDHANDLE *PSCARDHANDLE, *LPSCARDHANDLE;

    extern LONG __stdcall SCardEstablishContext(DWORD dwScope, LPCVOID pvReserved1, LPCVOID pvReserved2, LPSCARDCONTEXT phContext);

    extern LONG __stdcall SCardReleaseContext(SCARDCONTEXT hContext);

    extern LONG __stdcall SCardIsValidContext(SCARDCONTEXT hContext);

    extern LONG __stdcall SCardListReaderGroupsA(SCARDCONTEXT hContext, LPSTR mszGroups, LPDWORD pcchGroups);
    extern LONG __stdcall SCardListReaderGroupsW(SCARDCONTEXT hContext, LPWSTR mszGroups, LPDWORD pcchGroups);

    extern LONG __stdcall SCardListReadersA(SCARDCONTEXT hContext,
                                            LPCSTR mszGroups,

                                            LPSTR mszReaders,
                                            LPDWORD pcchReaders);

    extern LONG __stdcall SCardListReadersW(SCARDCONTEXT hContext,
                                            LPCWSTR mszGroups,

                                            LPWSTR mszReaders,
                                            LPDWORD pcchReaders);

    extern LONG __stdcall SCardListCardsA(SCARDCONTEXT hContext,
                                          LPCBYTE pbAtr,
                                          LPCGUID rgquidInterfaces,
                                          DWORD cguidInterfaceCount,

                                          CHAR* mszCards,
                                          LPDWORD pcchCards);

    extern LONG __stdcall SCardListCardsW(SCARDCONTEXT hContext,
                                          LPCBYTE pbAtr,
                                          LPCGUID rgquidInterfaces,
                                          DWORD cguidInterfaceCount,

                                          WCHAR* mszCards,
                                          LPDWORD pcchCards);

    extern LONG __stdcall SCardListInterfacesA(SCARDCONTEXT hContext, LPCSTR szCard, LPGUID pguidInterfaces, LPDWORD pcguidInterfaces);
    extern LONG __stdcall SCardListInterfacesW(SCARDCONTEXT hContext, LPCWSTR szCard, LPGUID pguidInterfaces, LPDWORD pcguidInterfaces);

    extern LONG __stdcall SCardGetProviderIdA(SCARDCONTEXT hContext, LPCSTR szCard, LPGUID pguidProviderId);
    extern LONG __stdcall SCardGetProviderIdW(SCARDCONTEXT hContext, LPCWSTR szCard, LPGUID pguidProviderId);

    extern LONG __stdcall SCardGetCardTypeProviderNameA(SCARDCONTEXT hContext,
                                                        LPCSTR szCardName,
                                                        DWORD dwProviderId,

                                                        CHAR* szProvider,
                                                        LPDWORD pcchProvider);

    extern LONG __stdcall SCardGetCardTypeProviderNameW(SCARDCONTEXT hContext,
                                                        LPCWSTR szCardName,
                                                        DWORD dwProviderId,

                                                        WCHAR* szProvider,
                                                        LPDWORD pcchProvider);

    extern LONG __stdcall SCardIntroduceReaderGroupA(SCARDCONTEXT hContext, LPCSTR szGroupName);
    extern LONG __stdcall SCardIntroduceReaderGroupW(SCARDCONTEXT hContext, LPCWSTR szGroupName);

    extern LONG __stdcall SCardForgetReaderGroupA(SCARDCONTEXT hContext, LPCSTR szGroupName);
    extern LONG __stdcall SCardForgetReaderGroupW(SCARDCONTEXT hContext, LPCWSTR szGroupName);

    extern LONG __stdcall SCardIntroduceReaderA(SCARDCONTEXT hContext, LPCSTR szReaderName, LPCSTR szDeviceName);
    extern LONG __stdcall SCardIntroduceReaderW(SCARDCONTEXT hContext, LPCWSTR szReaderName, LPCWSTR szDeviceName);

    extern LONG __stdcall SCardForgetReaderA(SCARDCONTEXT hContext, LPCSTR szReaderName);
    extern LONG __stdcall SCardForgetReaderW(SCARDCONTEXT hContext, LPCWSTR szReaderName);

    extern LONG __stdcall SCardAddReaderToGroupA(SCARDCONTEXT hContext, LPCSTR szReaderName, LPCSTR szGroupName);
    extern LONG __stdcall SCardAddReaderToGroupW(SCARDCONTEXT hContext, LPCWSTR szReaderName, LPCWSTR szGroupName);

    extern LONG __stdcall SCardRemoveReaderFromGroupA(SCARDCONTEXT hContext, LPCSTR szReaderName, LPCSTR szGroupName);
    extern LONG __stdcall SCardRemoveReaderFromGroupW(SCARDCONTEXT hContext, LPCWSTR szReaderName, LPCWSTR szGroupName);

    extern LONG __stdcall SCardIntroduceCardTypeA(SCARDCONTEXT hContext,
                                                  LPCSTR szCardName,
                                                  LPCGUID pguidPrimaryProvider,
                                                  LPCGUID rgguidInterfaces,
                                                  DWORD dwInterfaceCount,
                                                  LPCBYTE pbAtr,
                                                  LPCBYTE pbAtrMask,
                                                  DWORD cbAtrLen);
    extern LONG __stdcall SCardIntroduceCardTypeW(SCARDCONTEXT hContext,
                                                  LPCWSTR szCardName,
                                                  LPCGUID pguidPrimaryProvider,
                                                  LPCGUID rgguidInterfaces,
                                                  DWORD dwInterfaceCount,
                                                  LPCBYTE pbAtr,
                                                  LPCBYTE pbAtrMask,
                                                  DWORD cbAtrLen);

    extern LONG __stdcall SCardSetCardTypeProviderNameA(SCARDCONTEXT hContext, LPCSTR szCardName, DWORD dwProviderId, LPCSTR szProvider);
    extern LONG __stdcall SCardSetCardTypeProviderNameW(SCARDCONTEXT hContext, LPCWSTR szCardName, DWORD dwProviderId, LPCWSTR szProvider);

    extern LONG __stdcall SCardForgetCardTypeA(SCARDCONTEXT hContext, LPCSTR szCardName);
    extern LONG __stdcall SCardForgetCardTypeW(SCARDCONTEXT hContext, LPCWSTR szCardName);

    extern LONG __stdcall SCardFreeMemory(SCARDCONTEXT hContext, LPCVOID pvMem);

    extern HANDLE __stdcall SCardAccessStartedEvent(void);

    extern void __stdcall SCardReleaseStartedEvent(void);

    typedef struct
    {
        LPCSTR szReader;
        LPVOID pvUserData;
        DWORD dwCurrentState;
        DWORD dwEventState;
        DWORD cbAtr;
        BYTE rgbAtr[36];
    } SCARD_READERSTATEA, *PSCARD_READERSTATEA, *LPSCARD_READERSTATEA;
    typedef struct
    {
        LPCWSTR szReader;
        LPVOID pvUserData;
        DWORD dwCurrentState;
        DWORD dwEventState;
        DWORD cbAtr;
        BYTE rgbAtr[36];
    } SCARD_READERSTATEW, *PSCARD_READERSTATEW, *LPSCARD_READERSTATEW;

    typedef SCARD_READERSTATEA SCARD_READERSTATE;
    typedef PSCARD_READERSTATEA PSCARD_READERSTATE;
    typedef LPSCARD_READERSTATEA LPSCARD_READERSTATE;

    extern LONG __stdcall SCardLocateCardsA(SCARDCONTEXT hContext, LPCSTR mszCards, LPSCARD_READERSTATEA rgReaderStates, DWORD cReaders);
    extern LONG __stdcall SCardLocateCardsW(SCARDCONTEXT hContext, LPCWSTR mszCards, LPSCARD_READERSTATEW rgReaderStates, DWORD cReaders);

    typedef struct _SCARD_ATRMASK
    {
        DWORD cbAtr;
        BYTE rgbAtr[36];
        BYTE rgbMask[36];
    } SCARD_ATRMASK, *PSCARD_ATRMASK, *LPSCARD_ATRMASK;

    extern LONG __stdcall SCardLocateCardsByATRA(
    SCARDCONTEXT hContext, LPSCARD_ATRMASK rgAtrMasks, DWORD cAtrs, LPSCARD_READERSTATEA rgReaderStates, DWORD cReaders);
    extern LONG __stdcall SCardLocateCardsByATRW(
    SCARDCONTEXT hContext, LPSCARD_ATRMASK rgAtrMasks, DWORD cAtrs, LPSCARD_READERSTATEW rgReaderStates, DWORD cReaders);

    extern LONG __stdcall SCardGetStatusChangeA(SCARDCONTEXT hContext, DWORD dwTimeout, LPSCARD_READERSTATEA rgReaderStates, DWORD cReaders);
    extern LONG __stdcall SCardGetStatusChangeW(SCARDCONTEXT hContext, DWORD dwTimeout, LPSCARD_READERSTATEW rgReaderStates, DWORD cReaders);

    extern LONG __stdcall SCardCancel(SCARDCONTEXT hContext);

    extern LONG __stdcall SCardConnectA(
    SCARDCONTEXT hContext, LPCSTR szReader, DWORD dwShareMode, DWORD dwPreferredProtocols, LPSCARDHANDLE phCard, LPDWORD pdwActiveProtocol);
    extern LONG __stdcall SCardConnectW(
    SCARDCONTEXT hContext, LPCWSTR szReader, DWORD dwShareMode, DWORD dwPreferredProtocols, LPSCARDHANDLE phCard, LPDWORD pdwActiveProtocol);

    extern LONG __stdcall SCardReconnect(SCARDHANDLE hCard, DWORD dwShareMode, DWORD dwPreferredProtocols, DWORD dwInitialization, LPDWORD pdwActiveProtocol);

    extern LONG __stdcall SCardDisconnect(SCARDHANDLE hCard, DWORD dwDisposition);

    extern LONG __stdcall SCardBeginTransaction(SCARDHANDLE hCard);

    extern LONG __stdcall SCardEndTransaction(SCARDHANDLE hCard, DWORD dwDisposition);

    extern LONG __stdcall SCardCancelTransaction(SCARDHANDLE hCard);

    extern LONG __stdcall SCardState(SCARDHANDLE hCard, LPDWORD pdwState, LPDWORD pdwProtocol, LPBYTE pbAtr, LPDWORD pcbAtrLen);

    extern LONG __stdcall SCardStatusA(SCARDHANDLE hCard,

                                       LPSTR mszReaderNames,
                                       LPDWORD pcchReaderLen,
                                       LPDWORD pdwState,
                                       LPDWORD pdwProtocol,

                                       LPBYTE pbAtr,
                                       LPDWORD pcbAtrLen);
    extern LONG __stdcall SCardStatusW(SCARDHANDLE hCard,

                                       LPWSTR mszReaderNames,
                                       LPDWORD pcchReaderLen,
                                       LPDWORD pdwState,
                                       LPDWORD pdwProtocol,

                                       LPBYTE pbAtr,
                                       LPDWORD pcbAtrLen);

    extern LONG __stdcall SCardTransmit(SCARDHANDLE hCard,
                                        LPCSCARD_IO_REQUEST pioSendPci,
                                        LPCBYTE pbSendBuffer,
                                        DWORD cbSendLength,
                                        LPSCARD_IO_REQUEST pioRecvPci,
                                        LPBYTE pbRecvBuffer,
                                        LPDWORD pcbRecvLength);

    extern LONG __stdcall SCardGetTransmitCount(SCARDHANDLE hCard, LPDWORD pcTransmitCount);

    extern LONG __stdcall SCardControl(SCARDHANDLE hCard,
                                       DWORD dwControlCode,
                                       LPCVOID lpInBuffer,
                                       DWORD cbInBufferSize,
                                       LPVOID lpOutBuffer,
                                       DWORD cbOutBufferSize,
                                       LPDWORD lpBytesReturned);

    extern LONG __stdcall SCardGetAttrib(SCARDHANDLE hCard, DWORD dwAttrId, LPBYTE pbAttr, LPDWORD pcbAttrLen);

    extern LONG __stdcall SCardSetAttrib(SCARDHANDLE hCard, DWORD dwAttrId, LPCBYTE pbAttr, DWORD cbAttrLen);

    typedef SCARDHANDLE(__stdcall* LPOCNCONNPROCA)(SCARDCONTEXT, LPSTR, LPSTR, PVOID);
    typedef SCARDHANDLE(__stdcall* LPOCNCONNPROCW)(SCARDCONTEXT, LPWSTR, LPWSTR, PVOID);

    typedef BOOL(__stdcall* LPOCNCHKPROC)(SCARDCONTEXT, SCARDHANDLE, PVOID);
    typedef void(__stdcall* LPOCNDSCPROC)(SCARDCONTEXT, SCARDHANDLE, PVOID);

    typedef struct
    {
        DWORD dwStructSize;
        LPSTR lpstrGroupNames;
        DWORD nMaxGroupNames;

        LPCGUID rgguidInterfaces;
        DWORD cguidInterfaces;
        LPSTR lpstrCardNames;
        DWORD nMaxCardNames;
        LPOCNCHKPROC lpfnCheck;
        LPOCNCONNPROCA lpfnConnect;
        LPOCNDSCPROC lpfnDisconnect;
        LPVOID pvUserData;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;
    } OPENCARD_SEARCH_CRITERIAA, *POPENCARD_SEARCH_CRITERIAA, *LPOPENCARD_SEARCH_CRITERIAA;
    typedef struct
    {
        DWORD dwStructSize;
        LPWSTR lpstrGroupNames;
        DWORD nMaxGroupNames;

        LPCGUID rgguidInterfaces;
        DWORD cguidInterfaces;
        LPWSTR lpstrCardNames;
        DWORD nMaxCardNames;
        LPOCNCHKPROC lpfnCheck;
        LPOCNCONNPROCW lpfnConnect;
        LPOCNDSCPROC lpfnDisconnect;
        LPVOID pvUserData;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;
    } OPENCARD_SEARCH_CRITERIAW, *POPENCARD_SEARCH_CRITERIAW, *LPOPENCARD_SEARCH_CRITERIAW;

    typedef OPENCARD_SEARCH_CRITERIAA OPENCARD_SEARCH_CRITERIA;
    typedef POPENCARD_SEARCH_CRITERIAA POPENCARD_SEARCH_CRITERIA;
    typedef LPOPENCARD_SEARCH_CRITERIAA LPOPENCARD_SEARCH_CRITERIA;

    typedef struct
    {
        DWORD dwStructSize;
        SCARDCONTEXT hSCardContext;
        HWND hwndOwner;
        DWORD dwFlags;
        LPCSTR lpstrTitle;
        LPCSTR lpstrSearchDesc;
        HICON hIcon;
        POPENCARD_SEARCH_CRITERIAA pOpenCardSearchCriteria;
        LPOCNCONNPROCA lpfnConnect;
        LPVOID pvUserData;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;

        LPSTR lpstrRdr;
        DWORD nMaxRdr;
        LPSTR lpstrCard;
        DWORD nMaxCard;
        DWORD dwActiveProtocol;
        SCARDHANDLE hCardHandle;
    } OPENCARDNAME_EXA, *POPENCARDNAME_EXA, *LPOPENCARDNAME_EXA;
    typedef struct
    {
        DWORD dwStructSize;
        SCARDCONTEXT hSCardContext;
        HWND hwndOwner;
        DWORD dwFlags;
        LPCWSTR lpstrTitle;
        LPCWSTR lpstrSearchDesc;
        HICON hIcon;
        POPENCARD_SEARCH_CRITERIAW pOpenCardSearchCriteria;
        LPOCNCONNPROCW lpfnConnect;
        LPVOID pvUserData;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;

        LPWSTR lpstrRdr;
        DWORD nMaxRdr;
        LPWSTR lpstrCard;
        DWORD nMaxCard;
        DWORD dwActiveProtocol;
        SCARDHANDLE hCardHandle;
    } OPENCARDNAME_EXW, *POPENCARDNAME_EXW, *LPOPENCARDNAME_EXW;

    typedef OPENCARDNAME_EXA OPENCARDNAME_EX;
    typedef POPENCARDNAME_EXA POPENCARDNAME_EX;
    typedef LPOPENCARDNAME_EXA LPOPENCARDNAME_EX;

    typedef enum
    {
        RSR_MATCH_TYPE_READER_AND_CONTAINER = 1,
        RSR_MATCH_TYPE_SERIAL_NUMBER,
        RSR_MATCH_TYPE_ALL_CARDS
    } READER_SEL_REQUEST_MATCH_TYPE;

    typedef struct
    {
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;
        READER_SEL_REQUEST_MATCH_TYPE MatchType;
#pragma warning(push)
#pragma warning(disable : 4201)
        union
        {
            struct
            {
                DWORD cbReaderNameOffset;
                DWORD cchReaderNameLength;
                DWORD cbContainerNameOffset;
                DWORD cchContainerNameLength;
                DWORD dwDesiredCardModuleVersion;
                DWORD dwCspFlags;
            } ReaderAndContainerParameter;
            struct
            {
                DWORD cbSerialNumberOffset;
                DWORD cbSerialNumberLength;
                DWORD dwDesiredCardModuleVersion;
            } SerialNumberParameter;
        };
#pragma warning(pop)
    } READER_SEL_REQUEST, *PREADER_SEL_REQUEST;

    typedef struct
    {
        DWORD cbReaderNameOffset;
        DWORD cchReaderNameLength;
        DWORD cbCardNameOffset;
        DWORD cchCardNameLength;
    } READER_SEL_RESPONSE, *PREADER_SEL_RESPONSE;

    extern LONG __stdcall SCardUIDlgSelectCardA(LPOPENCARDNAME_EXA);
    extern LONG __stdcall SCardUIDlgSelectCardW(LPOPENCARDNAME_EXW);

    typedef struct
    {
        DWORD dwStructSize;
        HWND hwndOwner;
        SCARDCONTEXT hSCardContext;
        LPSTR lpstrGroupNames;
        DWORD nMaxGroupNames;
        LPSTR lpstrCardNames;
        DWORD nMaxCardNames;
        LPCGUID rgguidInterfaces;
        DWORD cguidInterfaces;
        LPSTR lpstrRdr;
        DWORD nMaxRdr;
        LPSTR lpstrCard;
        DWORD nMaxCard;
        LPCSTR lpstrTitle;
        DWORD dwFlags;
        LPVOID pvUserData;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;
        DWORD dwActiveProtocol;
        LPOCNCONNPROCA lpfnConnect;
        LPOCNCHKPROC lpfnCheck;
        LPOCNDSCPROC lpfnDisconnect;
        SCARDHANDLE hCardHandle;
    } OPENCARDNAMEA, *POPENCARDNAMEA, *LPOPENCARDNAMEA;
    typedef struct
    {
        DWORD dwStructSize;
        HWND hwndOwner;
        SCARDCONTEXT hSCardContext;
        LPWSTR lpstrGroupNames;
        DWORD nMaxGroupNames;
        LPWSTR lpstrCardNames;
        DWORD nMaxCardNames;
        LPCGUID rgguidInterfaces;
        DWORD cguidInterfaces;
        LPWSTR lpstrRdr;
        DWORD nMaxRdr;
        LPWSTR lpstrCard;
        DWORD nMaxCard;
        LPCWSTR lpstrTitle;
        DWORD dwFlags;
        LPVOID pvUserData;
        DWORD dwShareMode;
        DWORD dwPreferredProtocols;
        DWORD dwActiveProtocol;
        LPOCNCONNPROCW lpfnConnect;
        LPOCNCHKPROC lpfnCheck;
        LPOCNDSCPROC lpfnDisconnect;
        SCARDHANDLE hCardHandle;
    } OPENCARDNAMEW, *POPENCARDNAMEW, *LPOPENCARDNAMEW;

    typedef OPENCARDNAMEA OPENCARDNAME;
    typedef POPENCARDNAMEA POPENCARDNAME;
    typedef LPOPENCARDNAMEA LPOPENCARDNAME;

    extern LONG __stdcall GetOpenCardNameA(LPOPENCARDNAMEA);
    extern LONG __stdcall GetOpenCardNameW(LPOPENCARDNAMEW);

    extern LONG __stdcall SCardDlgExtendedError(void);

    extern LONG __stdcall SCardReadCacheA(
    SCARDCONTEXT hContext, UUID* CardIdentifier, DWORD FreshnessCounter, LPSTR LookupName, PBYTE Data, DWORD* DataLen);
    extern LONG __stdcall SCardReadCacheW(
    SCARDCONTEXT hContext, UUID* CardIdentifier, DWORD FreshnessCounter, LPWSTR LookupName, PBYTE Data, DWORD* DataLen);

    extern LONG __stdcall SCardWriteCacheA(
    SCARDCONTEXT hContext, UUID* CardIdentifier, DWORD FreshnessCounter, LPSTR LookupName, PBYTE Data, DWORD DataLen);
    extern LONG __stdcall SCardWriteCacheW(
    SCARDCONTEXT hContext, UUID* CardIdentifier, DWORD FreshnessCounter, LPWSTR LookupName, PBYTE Data, DWORD DataLen);

    extern LONG __stdcall SCardGetReaderIconA(SCARDCONTEXT hContext,
                                              LPCSTR szReaderName,

                                              LPBYTE pbIcon,
                                              LPDWORD pcbIcon);

    extern LONG __stdcall SCardGetReaderIconW(SCARDCONTEXT hContext,
                                              LPCWSTR szReaderName,

                                              LPBYTE pbIcon,
                                              LPDWORD pcbIcon);

    extern LONG __stdcall SCardGetDeviceTypeIdA(SCARDCONTEXT hContext, LPCSTR szReaderName, LPDWORD pdwDeviceTypeId);

    extern LONG __stdcall SCardGetDeviceTypeIdW(SCARDCONTEXT hContext, LPCWSTR szReaderName, LPDWORD pdwDeviceTypeId);

    extern LONG __stdcall SCardGetReaderDeviceInstanceIdA(SCARDCONTEXT hContext,
                                                          LPCSTR szReaderName,

                                                          LPSTR szDeviceInstanceId,
                                                          LPDWORD pcchDeviceInstanceId);

    extern LONG __stdcall SCardGetReaderDeviceInstanceIdW(SCARDCONTEXT hContext,
                                                          LPCWSTR szReaderName,

                                                          LPWSTR szDeviceInstanceId,
                                                          LPDWORD pcchDeviceInstanceId);

    extern LONG __stdcall SCardListReadersWithDeviceInstanceIdA(SCARDCONTEXT hContext,
                                                                LPCSTR szDeviceInstanceId,

                                                                LPSTR mszReaders,
                                                                LPDWORD pcchReaders);

    extern LONG __stdcall SCardListReadersWithDeviceInstanceIdW(SCARDCONTEXT hContext,
                                                                LPCWSTR szDeviceInstanceId,

                                                                LPWSTR mszReaders,
                                                                LPDWORD pcchReaders);

    extern LONG __stdcall SCardAudit(SCARDCONTEXT hContext, DWORD dwEvent);

#pragma endregion

#pragma warning(pop)
}

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4820)

#pragma warning(disable : 4103)

#pragma pack(push, 8)

extern "C"
{
#pragma region Desktop Family

    struct _PSP;
    typedef struct _PSP* HPROPSHEETPAGE;

    struct _PROPSHEETPAGEA;
    struct _PROPSHEETPAGEW;

    typedef UINT(__stdcall* LPFNPSPCALLBACKA)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEA* ppsp);
    typedef UINT(__stdcall* LPFNPSPCALLBACKW)(HWND hwnd, UINT uMsg, struct _PROPSHEETPAGEW* ppsp);

    typedef LPCDLGTEMPLATE PROPSHEETPAGE_RESOURCE;

    typedef struct _PROPSHEETPAGEA_V1
    {
        DWORD dwSize;
        DWORD dwFlags;
        HINSTANCE hInstance;
        union
        {
            LPCSTR pszTemplate;
            PROPSHEETPAGE_RESOURCE pResource;
        };
        union
        {
            HICON hIcon;
            LPCSTR pszIcon;
        };
        LPCSTR pszTitle;
        DLGPROC pfnDlgProc;
        LPARAM lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT* pcRefParent;
    } PROPSHEETPAGEA_V1, *LPPROPSHEETPAGEA_V1;
    typedef const PROPSHEETPAGEA_V1* LPCPROPSHEETPAGEA_V1;

    typedef struct _PROPSHEETPAGEA_V2
    {
        DWORD dwSize;
        DWORD dwFlags;
        HINSTANCE hInstance;
        union
        {
            LPCSTR pszTemplate;
            PROPSHEETPAGE_RESOURCE pResource;
        };
        union
        {
            HICON hIcon;
            LPCSTR pszIcon;
        };
        LPCSTR pszTitle;
        DLGPROC pfnDlgProc;
        LPARAM lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT* pcRefParent;

        LPCSTR pszHeaderTitle;
        LPCSTR pszHeaderSubTitle;
    } PROPSHEETPAGEA_V2, *LPPROPSHEETPAGEA_V2;
    typedef const PROPSHEETPAGEA_V2* LPCPROPSHEETPAGEA_V2;

    typedef struct _PROPSHEETPAGEA_V3
    {
        DWORD dwSize;
        DWORD dwFlags;
        HINSTANCE hInstance;
        union
        {
            LPCSTR pszTemplate;
            PROPSHEETPAGE_RESOURCE pResource;
        };
        union
        {
            HICON hIcon;
            LPCSTR pszIcon;
        };
        LPCSTR pszTitle;
        DLGPROC pfnDlgProc;
        LPARAM lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT* pcRefParent;

        LPCSTR pszHeaderTitle;
        LPCSTR pszHeaderSubTitle;

        HANDLE hActCtx;
    } PROPSHEETPAGEA_V3, *LPPROPSHEETPAGEA_V3;
    typedef const PROPSHEETPAGEA_V3* LPCPROPSHEETPAGEA_V3;

    typedef struct _PROPSHEETPAGEA
    {
        DWORD dwSize;
        DWORD dwFlags;
        HINSTANCE hInstance;
        union
        {
            LPCSTR pszTemplate;
            PROPSHEETPAGE_RESOURCE pResource;
        };
        union
        {
            HICON hIcon;
            LPCSTR pszIcon;
        };
        LPCSTR pszTitle;
        DLGPROC pfnDlgProc;
        LPARAM lParam;
        LPFNPSPCALLBACKA pfnCallback;
        UINT* pcRefParent;

        LPCSTR pszHeaderTitle;
        LPCSTR pszHeaderSubTitle;

        HANDLE hActCtx;

        union
        {
            HBITMAP hbmHeader;
            LPCSTR pszbmHeader;
        };

    } PROPSHEETPAGEA_V4, *LPPROPSHEETPAGEA_V4;
    typedef const PROPSHEETPAGEA_V4* LPCPROPSHEETPAGEA_V4;

    typedef struct _PROPSHEETPAGEW_V1
    {
        DWORD dwSize;
        DWORD dwFlags;
        HINSTANCE hInstance;
        union
        {
            LPCWSTR pszTemplate;
            PROPSHEETPAGE_RESOURCE pResource;
        };
        union
        {
            HICON hIcon;
            LPCWSTR pszIcon;
        };
        LPCWSTR pszTitle;
        DLGPROC pfnDlgProc;
        LPARAM lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT* pcRefParent;
    } PROPSHEETPAGEW_V1, *LPPROPSHEETPAGEW_V1;
    typedef const PROPSHEETPAGEW_V1* LPCPROPSHEETPAGEW_V1;

    typedef struct _PROPSHEETPAGEW_V2
    {
        DWORD dwSize;
        DWORD dwFlags;
        HINSTANCE hInstance;
        union
        {
            LPCWSTR pszTemplate;
            PROPSHEETPAGE_RESOURCE pResource;
        };
        union
        {
            HICON hIcon;
            LPCWSTR pszIcon;
        };
        LPCWSTR pszTitle;
        DLGPROC pfnDlgProc;
        LPARAM lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT* pcRefParent;

        LPCWSTR pszHeaderTitle;
        LPCWSTR pszHeaderSubTitle;
    } PROPSHEETPAGEW_V2, *LPPROPSHEETPAGEW_V2;
    typedef const PROPSHEETPAGEW_V2* LPCPROPSHEETPAGEW_V2;

    typedef struct _PROPSHEETPAGEW_V3
    {
        DWORD dwSize;
        DWORD dwFlags;
        HINSTANCE hInstance;
        union
        {
            LPCWSTR pszTemplate;
            PROPSHEETPAGE_RESOURCE pResource;
        };
        union
        {
            HICON hIcon;
            LPCWSTR pszIcon;
        };
        LPCWSTR pszTitle;
        DLGPROC pfnDlgProc;
        LPARAM lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT* pcRefParent;

        LPCWSTR pszHeaderTitle;
        LPCWSTR pszHeaderSubTitle;

        HANDLE hActCtx;
    } PROPSHEETPAGEW_V3, *LPPROPSHEETPAGEW_V3;
    typedef const PROPSHEETPAGEW_V3* LPCPROPSHEETPAGEW_V3;

    typedef struct _PROPSHEETPAGEW
    {
        DWORD dwSize;
        DWORD dwFlags;
        HINSTANCE hInstance;
        union
        {
            LPCWSTR pszTemplate;
            PROPSHEETPAGE_RESOURCE pResource;
        };
        union
        {
            HICON hIcon;
            LPCWSTR pszIcon;
        };
        LPCWSTR pszTitle;
        DLGPROC pfnDlgProc;
        LPARAM lParam;
        LPFNPSPCALLBACKW pfnCallback;
        UINT* pcRefParent;

        LPCWSTR pszHeaderTitle;
        LPCWSTR pszHeaderSubTitle;

        HANDLE hActCtx;

        union
        {
            HBITMAP hbmHeader;
            LPCWSTR pszbmHeader;
        };

    } PROPSHEETPAGEW_V4, *LPPROPSHEETPAGEW_V4;
    typedef const PROPSHEETPAGEW_V4* LPCPROPSHEETPAGEW_V4;

    typedef PROPSHEETPAGEA_V4 PROPSHEETPAGEA_LATEST;
    typedef PROPSHEETPAGEW_V4 PROPSHEETPAGEW_LATEST;
    typedef LPPROPSHEETPAGEA_V4 LPPROPSHEETPAGEA_LATEST;
    typedef LPPROPSHEETPAGEW_V4 LPPROPSHEETPAGEW_LATEST;
    typedef LPCPROPSHEETPAGEA_V4 LPCPROPSHEETPAGEA_LATEST;
    typedef LPCPROPSHEETPAGEW_V4 LPCPROPSHEETPAGEW_LATEST;

    typedef PROPSHEETPAGEA_V4 PROPSHEETPAGEA;
    typedef PROPSHEETPAGEW_V4 PROPSHEETPAGEW;
    typedef LPPROPSHEETPAGEA_V4 LPPROPSHEETPAGEA;
    typedef LPPROPSHEETPAGEW_V4 LPPROPSHEETPAGEW;
    typedef LPCPROPSHEETPAGEA_V4 LPCPROPSHEETPAGEA;
    typedef LPCPROPSHEETPAGEW_V4 LPCPROPSHEETPAGEW;

    typedef int(__stdcall* PFNPROPSHEETCALLBACK)(HWND, UINT, LPARAM);

    typedef struct _PROPSHEETHEADERA_V1
    {
        DWORD dwSize;
        DWORD dwFlags;
        HWND hwndParent;
        HINSTANCE hInstance;
        union
        {
            HICON hIcon;
            LPCSTR pszIcon;
        };
        LPCSTR pszCaption;
        UINT nPages;
        union
        {
            UINT nStartPage;
            LPCSTR pStartPage;
        };
        union
        {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE* phpage;
        };
        PFNPROPSHEETCALLBACK pfnCallback;
    } PROPSHEETHEADERA_V1, *LPPROPSHEETHEADERA_V1;
    typedef const PROPSHEETHEADERA_V1* LPCPROPSHEETHEADERA_V1;

    typedef struct _PROPSHEETHEADERA_V2
    {
        DWORD dwSize;
        DWORD dwFlags;
        HWND hwndParent;
        HINSTANCE hInstance;
        union
        {
            HICON hIcon;
            LPCSTR pszIcon;
        };
        LPCSTR pszCaption;
        UINT nPages;
        union
        {
            UINT nStartPage;
            LPCSTR pStartPage;
        };
        union
        {
            LPCPROPSHEETPAGEA ppsp;
            HPROPSHEETPAGE* phpage;
        };
        PFNPROPSHEETCALLBACK pfnCallback;
        union
        {
            HBITMAP hbmWatermark;
            LPCSTR pszbmWatermark;
        };
        HPALETTE hplWatermark;
        union
        {
            HBITMAP hbmHeader;
            LPCSTR pszbmHeader;
        };
    } PROPSHEETHEADERA_V2, *LPPROPSHEETHEADERA_V2;
    typedef const PROPSHEETHEADERA_V2* LPCPROPSHEETHEADERA_V2;

    typedef struct _PROPSHEETHEADERW_V1
    {
        DWORD dwSize;
        DWORD dwFlags;
        HWND hwndParent;
        HINSTANCE hInstance;
        union
        {
            HICON hIcon;
            LPCWSTR pszIcon;
        };
        LPCWSTR pszCaption;
        UINT nPages;
        union
        {
            UINT nStartPage;
            LPCWSTR pStartPage;
        };
        union
        {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE* phpage;
        };
        PFNPROPSHEETCALLBACK pfnCallback;
    } PROPSHEETHEADERW_V1, *LPPROPSHEETHEADERW_V1;
    typedef const PROPSHEETHEADERW_V1* LPCPROPSHEETHEADERW_V1;

    typedef struct _PROPSHEETHEADERW_V2
    {
        DWORD dwSize;
        DWORD dwFlags;
        HWND hwndParent;
        HINSTANCE hInstance;
        union
        {
            HICON hIcon;
            LPCWSTR pszIcon;
        };
        LPCWSTR pszCaption;
        UINT nPages;
        union
        {
            UINT nStartPage;
            LPCWSTR pStartPage;
        };
        union
        {
            LPCPROPSHEETPAGEW ppsp;
            HPROPSHEETPAGE* phpage;
        };
        PFNPROPSHEETCALLBACK pfnCallback;
        union
        {
            HBITMAP hbmWatermark;
            LPCWSTR pszbmWatermark;
        };
        HPALETTE hplWatermark;
        union
        {
            HBITMAP hbmHeader;
            LPCWSTR pszbmHeader;
        };
    } PROPSHEETHEADERW_V2, *LPPROPSHEETHEADERW_V2;
    typedef const PROPSHEETHEADERW_V2* LPCPROPSHEETHEADERW_V2;

    typedef PROPSHEETHEADERA_V2 PROPSHEETHEADERA;
    typedef PROPSHEETHEADERW_V2 PROPSHEETHEADERW;
    typedef LPPROPSHEETHEADERA_V2 LPPROPSHEETHEADERA;
    typedef LPPROPSHEETHEADERW_V2 LPPROPSHEETHEADERW;
    typedef LPCPROPSHEETHEADERA_V2 LPCPROPSHEETHEADERA;
    typedef LPCPROPSHEETHEADERW_V2 LPCPROPSHEETHEADERW;

    __declspec(dllimport) HPROPSHEETPAGE __stdcall CreatePropertySheetPageA(LPCPROPSHEETPAGEA constPropSheetPagePointer);
    __declspec(dllimport) HPROPSHEETPAGE __stdcall CreatePropertySheetPageW(LPCPROPSHEETPAGEW constPropSheetPagePointer);
    __declspec(dllimport) BOOL __stdcall DestroyPropertySheetPage(HPROPSHEETPAGE);

    __declspec(dllimport) INT_PTR __stdcall PropertySheetA(LPCPROPSHEETHEADERA);

    __declspec(dllimport) INT_PTR __stdcall PropertySheetW(LPCPROPSHEETHEADERW);

    typedef BOOL(__stdcall* LPFNADDPROPSHEETPAGE)(HPROPSHEETPAGE, LPARAM);
    typedef BOOL(__stdcall* LPFNADDPROPSHEETPAGES)(LPVOID, LPFNADDPROPSHEETPAGE, LPARAM);

    typedef struct _PSHNOTIFY
    {
        NMHDR hdr;
        LPARAM lParam;
    } PSHNOTIFY, *LPPSHNOTIFY;

#pragma endregion
}

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(pop)

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

#pragma region Desktop Family

    typedef struct _PRINTER_INFO_1A
    {
        DWORD Flags;
        LPSTR pDescription;
        LPSTR pName;
        LPSTR pComment;
    } PRINTER_INFO_1A, *PPRINTER_INFO_1A, *LPPRINTER_INFO_1A;
    typedef struct _PRINTER_INFO_1W
    {
        DWORD Flags;
        LPWSTR pDescription;
        LPWSTR pName;
        LPWSTR pComment;
    } PRINTER_INFO_1W, *PPRINTER_INFO_1W, *LPPRINTER_INFO_1W;

    typedef PRINTER_INFO_1A PRINTER_INFO_1;
    typedef PPRINTER_INFO_1A PPRINTER_INFO_1;
    typedef LPPRINTER_INFO_1A LPPRINTER_INFO_1;

    typedef struct _PRINTER_INFO_2A
    {
        LPSTR pServerName;
        LPSTR pPrinterName;
        LPSTR pShareName;
        LPSTR pPortName;
        LPSTR pDriverName;
        LPSTR pComment;
        LPSTR pLocation;
        LPDEVMODEA pDevMode;
        LPSTR pSepFile;
        LPSTR pPrintProcessor;
        LPSTR pDatatype;
        LPSTR pParameters;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        DWORD Attributes;
        DWORD Priority;
        DWORD DefaultPriority;
        DWORD StartTime;
        DWORD UntilTime;
        DWORD Status;
        DWORD cJobs;
        DWORD AveragePPM;
    } PRINTER_INFO_2A, *PPRINTER_INFO_2A, *LPPRINTER_INFO_2A;
    typedef struct _PRINTER_INFO_2W
    {
        LPWSTR pServerName;
        LPWSTR pPrinterName;
        LPWSTR pShareName;
        LPWSTR pPortName;
        LPWSTR pDriverName;
        LPWSTR pComment;
        LPWSTR pLocation;
        LPDEVMODEW pDevMode;
        LPWSTR pSepFile;
        LPWSTR pPrintProcessor;
        LPWSTR pDatatype;
        LPWSTR pParameters;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        DWORD Attributes;
        DWORD Priority;
        DWORD DefaultPriority;
        DWORD StartTime;
        DWORD UntilTime;
        DWORD Status;
        DWORD cJobs;
        DWORD AveragePPM;
    } PRINTER_INFO_2W, *PPRINTER_INFO_2W, *LPPRINTER_INFO_2W;

    typedef PRINTER_INFO_2A PRINTER_INFO_2;
    typedef PPRINTER_INFO_2A PPRINTER_INFO_2;
    typedef LPPRINTER_INFO_2A LPPRINTER_INFO_2;

    typedef struct _PRINTER_INFO_3
    {
        PSECURITY_DESCRIPTOR pSecurityDescriptor;
    } PRINTER_INFO_3, *PPRINTER_INFO_3, *LPPRINTER_INFO_3;

    typedef struct _PRINTER_INFO_4A
    {
        LPSTR pPrinterName;
        LPSTR pServerName;
        DWORD Attributes;
    } PRINTER_INFO_4A, *PPRINTER_INFO_4A, *LPPRINTER_INFO_4A;
    typedef struct _PRINTER_INFO_4W
    {
        LPWSTR pPrinterName;
        LPWSTR pServerName;
        DWORD Attributes;
    } PRINTER_INFO_4W, *PPRINTER_INFO_4W, *LPPRINTER_INFO_4W;

    typedef PRINTER_INFO_4A PRINTER_INFO_4;
    typedef PPRINTER_INFO_4A PPRINTER_INFO_4;
    typedef LPPRINTER_INFO_4A LPPRINTER_INFO_4;

    typedef struct _PRINTER_INFO_5A
    {
        LPSTR pPrinterName;
        LPSTR pPortName;
        DWORD Attributes;
        DWORD DeviceNotSelectedTimeout;
        DWORD TransmissionRetryTimeout;
    } PRINTER_INFO_5A, *PPRINTER_INFO_5A, *LPPRINTER_INFO_5A;
    typedef struct _PRINTER_INFO_5W
    {
        LPWSTR pPrinterName;
        LPWSTR pPortName;
        DWORD Attributes;
        DWORD DeviceNotSelectedTimeout;
        DWORD TransmissionRetryTimeout;
    } PRINTER_INFO_5W, *PPRINTER_INFO_5W, *LPPRINTER_INFO_5W;

    typedef PRINTER_INFO_5A PRINTER_INFO_5;
    typedef PPRINTER_INFO_5A PPRINTER_INFO_5;
    typedef LPPRINTER_INFO_5A LPPRINTER_INFO_5;

    typedef struct _PRINTER_INFO_6
    {
        DWORD dwStatus;
    } PRINTER_INFO_6, *PPRINTER_INFO_6, *LPPRINTER_INFO_6;

    typedef struct _PRINTER_INFO_7A
    {
        LPSTR pszObjectGUID;
        DWORD dwAction;
    } PRINTER_INFO_7A, *PPRINTER_INFO_7A, *LPPRINTER_INFO_7A;
    typedef struct _PRINTER_INFO_7W
    {
        LPWSTR pszObjectGUID;
        DWORD dwAction;
    } PRINTER_INFO_7W, *PPRINTER_INFO_7W, *LPPRINTER_INFO_7W;

    typedef PRINTER_INFO_7A PRINTER_INFO_7;
    typedef PPRINTER_INFO_7A PPRINTER_INFO_7;
    typedef LPPRINTER_INFO_7A LPPRINTER_INFO_7;

    typedef struct _PRINTER_INFO_8A
    {
        LPDEVMODEA pDevMode;
    } PRINTER_INFO_8A, *PPRINTER_INFO_8A, *LPPRINTER_INFO_8A;
    typedef struct _PRINTER_INFO_8W
    {
        LPDEVMODEW pDevMode;
    } PRINTER_INFO_8W, *PPRINTER_INFO_8W, *LPPRINTER_INFO_8W;

    typedef PRINTER_INFO_8A PRINTER_INFO_8;
    typedef PPRINTER_INFO_8A PPRINTER_INFO_8;
    typedef LPPRINTER_INFO_8A LPPRINTER_INFO_8;

    typedef struct _PRINTER_INFO_9A
    {
        LPDEVMODEA pDevMode;
    } PRINTER_INFO_9A, *PPRINTER_INFO_9A, *LPPRINTER_INFO_9A;
    typedef struct _PRINTER_INFO_9W
    {
        LPDEVMODEW pDevMode;
    } PRINTER_INFO_9W, *PPRINTER_INFO_9W, *LPPRINTER_INFO_9W;

    typedef PRINTER_INFO_9A PRINTER_INFO_9;
    typedef PPRINTER_INFO_9A PPRINTER_INFO_9;
    typedef LPPRINTER_INFO_9A LPPRINTER_INFO_9;

    typedef struct _JOB_INFO_1A
    {
        DWORD JobId;
        LPSTR pPrinterName;
        LPSTR pMachineName;
        LPSTR pUserName;
        LPSTR pDocument;
        LPSTR pDatatype;
        LPSTR pStatus;
        DWORD Status;
        DWORD Priority;
        DWORD Position;
        DWORD TotalPages;
        DWORD PagesPrinted;
        SYSTEMTIME Submitted;
    } JOB_INFO_1A, *PJOB_INFO_1A, *LPJOB_INFO_1A;
    typedef struct _JOB_INFO_1W
    {
        DWORD JobId;
        LPWSTR pPrinterName;
        LPWSTR pMachineName;
        LPWSTR pUserName;
        LPWSTR pDocument;
        LPWSTR pDatatype;
        LPWSTR pStatus;
        DWORD Status;
        DWORD Priority;
        DWORD Position;
        DWORD TotalPages;
        DWORD PagesPrinted;
        SYSTEMTIME Submitted;
    } JOB_INFO_1W, *PJOB_INFO_1W, *LPJOB_INFO_1W;

    typedef JOB_INFO_1A JOB_INFO_1;
    typedef PJOB_INFO_1A PJOB_INFO_1;
    typedef LPJOB_INFO_1A LPJOB_INFO_1;

    typedef struct _JOB_INFO_2A
    {
        DWORD JobId;
        LPSTR pPrinterName;
        LPSTR pMachineName;
        LPSTR pUserName;
        LPSTR pDocument;
        LPSTR pNotifyName;
        LPSTR pDatatype;
        LPSTR pPrintProcessor;
        LPSTR pParameters;
        LPSTR pDriverName;
        LPDEVMODEA pDevMode;
        LPSTR pStatus;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        DWORD Status;
        DWORD Priority;
        DWORD Position;
        DWORD StartTime;
        DWORD UntilTime;
        DWORD TotalPages;
        DWORD Size;
        SYSTEMTIME Submitted;
        DWORD Time;
        DWORD PagesPrinted;
    } JOB_INFO_2A, *PJOB_INFO_2A, *LPJOB_INFO_2A;
    typedef struct _JOB_INFO_2W
    {
        DWORD JobId;
        LPWSTR pPrinterName;
        LPWSTR pMachineName;
        LPWSTR pUserName;
        LPWSTR pDocument;
        LPWSTR pNotifyName;
        LPWSTR pDatatype;
        LPWSTR pPrintProcessor;
        LPWSTR pParameters;
        LPWSTR pDriverName;
        LPDEVMODEW pDevMode;
        LPWSTR pStatus;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        DWORD Status;
        DWORD Priority;
        DWORD Position;
        DWORD StartTime;
        DWORD UntilTime;
        DWORD TotalPages;
        DWORD Size;
        SYSTEMTIME Submitted;
        DWORD Time;
        DWORD PagesPrinted;
    } JOB_INFO_2W, *PJOB_INFO_2W, *LPJOB_INFO_2W;

    typedef JOB_INFO_2A JOB_INFO_2;
    typedef PJOB_INFO_2A PJOB_INFO_2;
    typedef LPJOB_INFO_2A LPJOB_INFO_2;

    typedef struct _JOB_INFO_3
    {
        DWORD JobId;
        DWORD NextJobId;
        DWORD Reserved;
    } JOB_INFO_3, *PJOB_INFO_3, *LPJOB_INFO_3;

    typedef struct _JOB_INFO_4A
    {
        DWORD JobId;
        LPSTR pPrinterName;
        LPSTR pMachineName;
        LPSTR pUserName;
        LPSTR pDocument;
        LPSTR pNotifyName;
        LPSTR pDatatype;
        LPSTR pPrintProcessor;
        LPSTR pParameters;
        LPSTR pDriverName;
        LPDEVMODEA pDevMode;
        LPSTR pStatus;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        DWORD Status;
        DWORD Priority;
        DWORD Position;
        DWORD StartTime;
        DWORD UntilTime;
        DWORD TotalPages;
        DWORD Size;
        SYSTEMTIME Submitted;
        DWORD Time;
        DWORD PagesPrinted;
        LONG SizeHigh;
    } JOB_INFO_4A, *PJOB_INFO_4A, *LPJOB_INFO_4A;
    typedef struct _JOB_INFO_4W
    {
        DWORD JobId;
        LPWSTR pPrinterName;
        LPWSTR pMachineName;
        LPWSTR pUserName;
        LPWSTR pDocument;
        LPWSTR pNotifyName;
        LPWSTR pDatatype;
        LPWSTR pPrintProcessor;
        LPWSTR pParameters;
        LPWSTR pDriverName;
        LPDEVMODEW pDevMode;
        LPWSTR pStatus;
        PSECURITY_DESCRIPTOR pSecurityDescriptor;
        DWORD Status;
        DWORD Priority;
        DWORD Position;
        DWORD StartTime;
        DWORD UntilTime;
        DWORD TotalPages;
        DWORD Size;
        SYSTEMTIME Submitted;
        DWORD Time;
        DWORD PagesPrinted;
        LONG SizeHigh;
    } JOB_INFO_4W, *PJOB_INFO_4W, *LPJOB_INFO_4W;

    typedef JOB_INFO_4A JOB_INFO_4;
    typedef PJOB_INFO_4A PJOB_INFO_4;
    typedef LPJOB_INFO_4A LPJOB_INFO_4;

    typedef struct _ADDJOB_INFO_1A
    {
        LPSTR Path;
        DWORD JobId;
    } ADDJOB_INFO_1A, *PADDJOB_INFO_1A, *LPADDJOB_INFO_1A;
    typedef struct _ADDJOB_INFO_1W
    {
        LPWSTR Path;
        DWORD JobId;
    } ADDJOB_INFO_1W, *PADDJOB_INFO_1W, *LPADDJOB_INFO_1W;

    typedef ADDJOB_INFO_1A ADDJOB_INFO_1;
    typedef PADDJOB_INFO_1A PADDJOB_INFO_1;
    typedef LPADDJOB_INFO_1A LPADDJOB_INFO_1;

    typedef struct _DRIVER_INFO_1A
    {
        LPSTR pName;
    } DRIVER_INFO_1A, *PDRIVER_INFO_1A, *LPDRIVER_INFO_1A;
    typedef struct _DRIVER_INFO_1W
    {
        LPWSTR pName;
    } DRIVER_INFO_1W, *PDRIVER_INFO_1W, *LPDRIVER_INFO_1W;

    typedef DRIVER_INFO_1A DRIVER_INFO_1;
    typedef PDRIVER_INFO_1A PDRIVER_INFO_1;
    typedef LPDRIVER_INFO_1A LPDRIVER_INFO_1;

    typedef struct _DRIVER_INFO_2A
    {
        DWORD cVersion;
        LPSTR pName;
        LPSTR pEnvironment;
        LPSTR pDriverPath;
        LPSTR pDataFile;
        LPSTR pConfigFile;
    } DRIVER_INFO_2A, *PDRIVER_INFO_2A, *LPDRIVER_INFO_2A;
    typedef struct _DRIVER_INFO_2W
    {
        DWORD cVersion;
        LPWSTR pName;
        LPWSTR pEnvironment;
        LPWSTR pDriverPath;
        LPWSTR pDataFile;
        LPWSTR pConfigFile;
    } DRIVER_INFO_2W, *PDRIVER_INFO_2W, *LPDRIVER_INFO_2W;

    typedef DRIVER_INFO_2A DRIVER_INFO_2;
    typedef PDRIVER_INFO_2A PDRIVER_INFO_2;
    typedef LPDRIVER_INFO_2A LPDRIVER_INFO_2;

    typedef struct _DRIVER_INFO_3A
    {
        DWORD cVersion;
        LPSTR pName;
        LPSTR pEnvironment;
        LPSTR pDriverPath;
        LPSTR pDataFile;
        LPSTR pConfigFile;
        LPSTR pHelpFile;
        LPSTR pDependentFiles;
        LPSTR pMonitorName;
        LPSTR pDefaultDataType;
    } DRIVER_INFO_3A, *PDRIVER_INFO_3A, *LPDRIVER_INFO_3A;
    typedef struct _DRIVER_INFO_3W
    {
        DWORD cVersion;
        LPWSTR pName;
        LPWSTR pEnvironment;
        LPWSTR pDriverPath;
        LPWSTR pDataFile;
        LPWSTR pConfigFile;
        LPWSTR pHelpFile;
        LPWSTR pDependentFiles;
        LPWSTR pMonitorName;
        LPWSTR pDefaultDataType;
    } DRIVER_INFO_3W, *PDRIVER_INFO_3W, *LPDRIVER_INFO_3W;

    typedef DRIVER_INFO_3A DRIVER_INFO_3;
    typedef PDRIVER_INFO_3A PDRIVER_INFO_3;
    typedef LPDRIVER_INFO_3A LPDRIVER_INFO_3;

    typedef struct _DRIVER_INFO_4A
    {
        DWORD cVersion;
        LPSTR pName;
        LPSTR pEnvironment;
        LPSTR pDriverPath;
        LPSTR pDataFile;
        LPSTR pConfigFile;
        LPSTR pHelpFile;
        LPSTR pDependentFiles;
        LPSTR pMonitorName;
        LPSTR pDefaultDataType;
        LPSTR pszzPreviousNames;
    } DRIVER_INFO_4A, *PDRIVER_INFO_4A, *LPDRIVER_INFO_4A;
    typedef struct _DRIVER_INFO_4W
    {
        DWORD cVersion;
        LPWSTR pName;
        LPWSTR pEnvironment;
        LPWSTR pDriverPath;
        LPWSTR pDataFile;
        LPWSTR pConfigFile;
        LPWSTR pHelpFile;
        LPWSTR pDependentFiles;
        LPWSTR pMonitorName;
        LPWSTR pDefaultDataType;
        LPWSTR pszzPreviousNames;
    } DRIVER_INFO_4W, *PDRIVER_INFO_4W, *LPDRIVER_INFO_4W;

    typedef DRIVER_INFO_4A DRIVER_INFO_4;
    typedef PDRIVER_INFO_4A PDRIVER_INFO_4;
    typedef LPDRIVER_INFO_4A LPDRIVER_INFO_4;

    typedef struct _DRIVER_INFO_5A
    {
        DWORD cVersion;
        LPSTR pName;
        LPSTR pEnvironment;
        LPSTR pDriverPath;
        LPSTR pDataFile;
        LPSTR pConfigFile;
        DWORD dwDriverAttributes;
        DWORD dwConfigVersion;
        DWORD dwDriverVersion;
    } DRIVER_INFO_5A, *PDRIVER_INFO_5A, *LPDRIVER_INFO_5A;
    typedef struct _DRIVER_INFO_5W
    {
        DWORD cVersion;
        LPWSTR pName;
        LPWSTR pEnvironment;
        LPWSTR pDriverPath;
        LPWSTR pDataFile;
        LPWSTR pConfigFile;
        DWORD dwDriverAttributes;
        DWORD dwConfigVersion;
        DWORD dwDriverVersion;
    } DRIVER_INFO_5W, *PDRIVER_INFO_5W, *LPDRIVER_INFO_5W;

    typedef DRIVER_INFO_5A DRIVER_INFO_5;
    typedef PDRIVER_INFO_5A PDRIVER_INFO_5;
    typedef LPDRIVER_INFO_5A LPDRIVER_INFO_5;

    typedef struct _DRIVER_INFO_6A
    {
        DWORD cVersion;
        LPSTR pName;
        LPSTR pEnvironment;
        LPSTR pDriverPath;
        LPSTR pDataFile;
        LPSTR pConfigFile;
        LPSTR pHelpFile;
        LPSTR pDependentFiles;
        LPSTR pMonitorName;
        LPSTR pDefaultDataType;
        LPSTR pszzPreviousNames;
        FILETIME ftDriverDate;
        DWORDLONG dwlDriverVersion;
        LPSTR pszMfgName;
        LPSTR pszOEMUrl;
        LPSTR pszHardwareID;
        LPSTR pszProvider;
    } DRIVER_INFO_6A, *PDRIVER_INFO_6A, *LPDRIVER_INFO_6A;
    typedef struct _DRIVER_INFO_6W
    {
        DWORD cVersion;
        LPWSTR pName;
        LPWSTR pEnvironment;
        LPWSTR pDriverPath;
        LPWSTR pDataFile;
        LPWSTR pConfigFile;
        LPWSTR pHelpFile;
        LPWSTR pDependentFiles;
        LPWSTR pMonitorName;
        LPWSTR pDefaultDataType;
        LPWSTR pszzPreviousNames;
        FILETIME ftDriverDate;
        DWORDLONG dwlDriverVersion;
        LPWSTR pszMfgName;
        LPWSTR pszOEMUrl;
        LPWSTR pszHardwareID;
        LPWSTR pszProvider;
    } DRIVER_INFO_6W, *PDRIVER_INFO_6W, *LPDRIVER_INFO_6W;

    typedef DRIVER_INFO_6A DRIVER_INFO_6;
    typedef PDRIVER_INFO_6A PDRIVER_INFO_6;
    typedef LPDRIVER_INFO_6A LPDRIVER_INFO_6;

    typedef struct _DRIVER_INFO_8A
    {
        DWORD cVersion;
        LPSTR pName;
        LPSTR pEnvironment;
        LPSTR pDriverPath;
        LPSTR pDataFile;
        LPSTR pConfigFile;
        LPSTR pHelpFile;
        LPSTR pDependentFiles;
        LPSTR pMonitorName;
        LPSTR pDefaultDataType;
        LPSTR pszzPreviousNames;
        FILETIME ftDriverDate;
        DWORDLONG dwlDriverVersion;
        LPSTR pszMfgName;
        LPSTR pszOEMUrl;
        LPSTR pszHardwareID;
        LPSTR pszProvider;
        LPSTR pszPrintProcessor;
        LPSTR pszVendorSetup;
        LPSTR pszzColorProfiles;
        LPSTR pszInfPath;
        DWORD dwPrinterDriverAttributes;
        LPSTR pszzCoreDriverDependencies;
        FILETIME ftMinInboxDriverVerDate;
        DWORDLONG dwlMinInboxDriverVerVersion;
    } DRIVER_INFO_8A, *PDRIVER_INFO_8A, *LPDRIVER_INFO_8A;
    typedef struct _DRIVER_INFO_8W
    {
        DWORD cVersion;
        LPWSTR pName;
        LPWSTR pEnvironment;
        LPWSTR pDriverPath;
        LPWSTR pDataFile;
        LPWSTR pConfigFile;
        LPWSTR pHelpFile;
        LPWSTR pDependentFiles;
        LPWSTR pMonitorName;
        LPWSTR pDefaultDataType;
        LPWSTR pszzPreviousNames;
        FILETIME ftDriverDate;
        DWORDLONG dwlDriverVersion;
        LPWSTR pszMfgName;
        LPWSTR pszOEMUrl;
        LPWSTR pszHardwareID;
        LPWSTR pszProvider;
        LPWSTR pszPrintProcessor;
        LPWSTR pszVendorSetup;
        LPWSTR pszzColorProfiles;
        LPWSTR pszInfPath;
        DWORD dwPrinterDriverAttributes;
        LPWSTR pszzCoreDriverDependencies;
        FILETIME ftMinInboxDriverVerDate;
        DWORDLONG dwlMinInboxDriverVerVersion;
    } DRIVER_INFO_8W, *PDRIVER_INFO_8W, *LPDRIVER_INFO_8W;

    typedef DRIVER_INFO_8A DRIVER_INFO_8;
    typedef PDRIVER_INFO_8A PDRIVER_INFO_8;
    typedef LPDRIVER_INFO_8A LPDRIVER_INFO_8;

    typedef struct _DOC_INFO_1A
    {
        LPSTR pDocName;
        LPSTR pOutputFile;
        LPSTR pDatatype;
    } DOC_INFO_1A, *PDOC_INFO_1A, *LPDOC_INFO_1A;
    typedef struct _DOC_INFO_1W
    {
        LPWSTR pDocName;
        LPWSTR pOutputFile;
        LPWSTR pDatatype;
    } DOC_INFO_1W, *PDOC_INFO_1W, *LPDOC_INFO_1W;

    typedef DOC_INFO_1A DOC_INFO_1;
    typedef PDOC_INFO_1A PDOC_INFO_1;
    typedef LPDOC_INFO_1A LPDOC_INFO_1;

    typedef struct _FORM_INFO_1A
    {
        DWORD Flags;
        LPSTR pName;
        SIZEL Size;
        RECTL ImageableArea;
    } FORM_INFO_1A, *PFORM_INFO_1A, *LPFORM_INFO_1A;
    typedef struct _FORM_INFO_1W
    {
        DWORD Flags;
        LPWSTR pName;
        SIZEL Size;
        RECTL ImageableArea;
    } FORM_INFO_1W, *PFORM_INFO_1W, *LPFORM_INFO_1W;

    typedef FORM_INFO_1A FORM_INFO_1;
    typedef PFORM_INFO_1A PFORM_INFO_1;
    typedef LPFORM_INFO_1A LPFORM_INFO_1;

    typedef struct _FORM_INFO_2A
    {
        DWORD Flags;
        LPCSTR pName;
        SIZEL Size;
        RECTL ImageableArea;
        LPCSTR pKeyword;
        DWORD StringType;
        LPCSTR pMuiDll;
        DWORD dwResourceId;
        LPCSTR pDisplayName;
        LANGID wLangId;
    } FORM_INFO_2A, *PFORM_INFO_2A, *LPFORM_INFO_2A;
    typedef struct _FORM_INFO_2W
    {
        DWORD Flags;
        LPCWSTR pName;
        SIZEL Size;
        RECTL ImageableArea;
        LPCSTR pKeyword;
        DWORD StringType;
        LPCWSTR pMuiDll;
        DWORD dwResourceId;
        LPCWSTR pDisplayName;
        LANGID wLangId;
    } FORM_INFO_2W, *PFORM_INFO_2W, *LPFORM_INFO_2W;

    typedef FORM_INFO_2A FORM_INFO_2;
    typedef PFORM_INFO_2A PFORM_INFO_2;
    typedef LPFORM_INFO_2A LPFORM_INFO_2;

    typedef struct _DOC_INFO_2A
    {
        LPSTR pDocName;
        LPSTR pOutputFile;
        LPSTR pDatatype;
        DWORD dwMode;
        DWORD JobId;
    } DOC_INFO_2A, *PDOC_INFO_2A, *LPDOC_INFO_2A;
    typedef struct _DOC_INFO_2W
    {
        LPWSTR pDocName;
        LPWSTR pOutputFile;
        LPWSTR pDatatype;
        DWORD dwMode;
        DWORD JobId;
    } DOC_INFO_2W, *PDOC_INFO_2W, *LPDOC_INFO_2W;

    typedef DOC_INFO_2A DOC_INFO_2;
    typedef PDOC_INFO_2A PDOC_INFO_2;
    typedef LPDOC_INFO_2A LPDOC_INFO_2;

    typedef struct _DOC_INFO_3A
    {
        LPSTR pDocName;
        LPSTR pOutputFile;
        LPSTR pDatatype;
        DWORD dwFlags;
    } DOC_INFO_3A, *PDOC_INFO_3A, *LPDOC_INFO_3A;
    typedef struct _DOC_INFO_3W
    {
        LPWSTR pDocName;
        LPWSTR pOutputFile;
        LPWSTR pDatatype;
        DWORD dwFlags;
    } DOC_INFO_3W, *PDOC_INFO_3W, *LPDOC_INFO_3W;

    typedef DOC_INFO_3A DOC_INFO_3;
    typedef PDOC_INFO_3A PDOC_INFO_3;
    typedef LPDOC_INFO_3A LPDOC_INFO_3;

    typedef struct _PRINTPROCESSOR_INFO_1A
    {
        LPSTR pName;
    } PRINTPROCESSOR_INFO_1A, *PPRINTPROCESSOR_INFO_1A, *LPPRINTPROCESSOR_INFO_1A;
    typedef struct _PRINTPROCESSOR_INFO_1W
    {
        LPWSTR pName;
    } PRINTPROCESSOR_INFO_1W, *PPRINTPROCESSOR_INFO_1W, *LPPRINTPROCESSOR_INFO_1W;

    typedef PRINTPROCESSOR_INFO_1A PRINTPROCESSOR_INFO_1;
    typedef PPRINTPROCESSOR_INFO_1A PPRINTPROCESSOR_INFO_1;
    typedef LPPRINTPROCESSOR_INFO_1A LPPRINTPROCESSOR_INFO_1;

    typedef struct _PRINTPROCESSOR_CAPS_1
    {
        DWORD dwLevel;
        DWORD dwNupOptions;
        DWORD dwPageOrderFlags;
        DWORD dwNumberOfCopies;
    } PRINTPROCESSOR_CAPS_1, *PPRINTPROCESSOR_CAPS_1;

    typedef struct _PRINTPROCESSOR_CAPS_2
    {
        DWORD dwLevel;
        DWORD dwNupOptions;
        DWORD dwPageOrderFlags;
        DWORD dwNumberOfCopies;

        DWORD dwDuplexHandlingCaps;
        DWORD dwNupDirectionCaps;
        DWORD dwNupBorderCaps;
        DWORD dwBookletHandlingCaps;
        DWORD dwScalingCaps;

    } PRINTPROCESSOR_CAPS_2, *PPRINTPROCESSOR_CAPS_2;

    typedef struct _PORT_INFO_1A
    {
        LPSTR pName;
    } PORT_INFO_1A, *PPORT_INFO_1A, *LPPORT_INFO_1A;
    typedef struct _PORT_INFO_1W
    {
        LPWSTR pName;
    } PORT_INFO_1W, *PPORT_INFO_1W, *LPPORT_INFO_1W;

    typedef PORT_INFO_1A PORT_INFO_1;
    typedef PPORT_INFO_1A PPORT_INFO_1;
    typedef LPPORT_INFO_1A LPPORT_INFO_1;

    typedef struct _PORT_INFO_2A
    {
        LPSTR pPortName;
        LPSTR pMonitorName;
        LPSTR pDescription;
        DWORD fPortType;
        DWORD Reserved;
    } PORT_INFO_2A, *PPORT_INFO_2A, *LPPORT_INFO_2A;
    typedef struct _PORT_INFO_2W
    {
        LPWSTR pPortName;
        LPWSTR pMonitorName;
        LPWSTR pDescription;
        DWORD fPortType;
        DWORD Reserved;
    } PORT_INFO_2W, *PPORT_INFO_2W, *LPPORT_INFO_2W;

    typedef PORT_INFO_2A PORT_INFO_2;
    typedef PPORT_INFO_2A PPORT_INFO_2;
    typedef LPPORT_INFO_2A LPPORT_INFO_2;

    typedef struct _PORT_INFO_3A
    {
        DWORD dwStatus;
        LPSTR pszStatus;
        DWORD dwSeverity;
    } PORT_INFO_3A, *PPORT_INFO_3A, *LPPORT_INFO_3A;
    typedef struct _PORT_INFO_3W
    {
        DWORD dwStatus;
        LPWSTR pszStatus;
        DWORD dwSeverity;
    } PORT_INFO_3W, *PPORT_INFO_3W, *LPPORT_INFO_3W;

    typedef PORT_INFO_3A PORT_INFO_3;
    typedef PPORT_INFO_3A PPORT_INFO_3;
    typedef LPPORT_INFO_3A LPPORT_INFO_3;

    typedef struct _MONITOR_INFO_1A
    {
        LPSTR pName;
    } MONITOR_INFO_1A, *PMONITOR_INFO_1A, *LPMONITOR_INFO_1A;
    typedef struct _MONITOR_INFO_1W
    {
        LPWSTR pName;
    } MONITOR_INFO_1W, *PMONITOR_INFO_1W, *LPMONITOR_INFO_1W;

    typedef MONITOR_INFO_1A MONITOR_INFO_1;
    typedef PMONITOR_INFO_1A PMONITOR_INFO_1;
    typedef LPMONITOR_INFO_1A LPMONITOR_INFO_1;

    typedef struct _MONITOR_INFO_2A
    {
        LPSTR pName;
        LPSTR pEnvironment;
        LPSTR pDLLName;
    } MONITOR_INFO_2A, *PMONITOR_INFO_2A, *LPMONITOR_INFO_2A;
    typedef struct _MONITOR_INFO_2W
    {
        LPWSTR pName;
        LPWSTR pEnvironment;
        LPWSTR pDLLName;
    } MONITOR_INFO_2W, *PMONITOR_INFO_2W, *LPMONITOR_INFO_2W;

    typedef MONITOR_INFO_2A MONITOR_INFO_2;
    typedef PMONITOR_INFO_2A PMONITOR_INFO_2;
    typedef LPMONITOR_INFO_2A LPMONITOR_INFO_2;

    typedef struct _DATATYPES_INFO_1A
    {
        LPSTR pName;
    } DATATYPES_INFO_1A, *PDATATYPES_INFO_1A, *LPDATATYPES_INFO_1A;
    typedef struct _DATATYPES_INFO_1W
    {
        LPWSTR pName;
    } DATATYPES_INFO_1W, *PDATATYPES_INFO_1W, *LPDATATYPES_INFO_1W;

    typedef DATATYPES_INFO_1A DATATYPES_INFO_1;
    typedef PDATATYPES_INFO_1A PDATATYPES_INFO_1;
    typedef LPDATATYPES_INFO_1A LPDATATYPES_INFO_1;

    typedef struct _PRINTER_DEFAULTSA
    {
        LPSTR pDatatype;
        LPDEVMODEA pDevMode;
        ACCESS_MASK DesiredAccess;
    } PRINTER_DEFAULTSA, *PPRINTER_DEFAULTSA, *LPPRINTER_DEFAULTSA;
    typedef struct _PRINTER_DEFAULTSW
    {
        LPWSTR pDatatype;
        LPDEVMODEW pDevMode;
        ACCESS_MASK DesiredAccess;
    } PRINTER_DEFAULTSW, *PPRINTER_DEFAULTSW, *LPPRINTER_DEFAULTSW;

    typedef PRINTER_DEFAULTSA PRINTER_DEFAULTS;
    typedef PPRINTER_DEFAULTSA PPRINTER_DEFAULTS;
    typedef LPPRINTER_DEFAULTSA LPPRINTER_DEFAULTS;

    typedef struct _PRINTER_ENUM_VALUESA
    {
        LPSTR pValueName;
        DWORD cbValueName;
        DWORD dwType;
        LPBYTE pData;
        DWORD cbData;
    } PRINTER_ENUM_VALUESA, *PPRINTER_ENUM_VALUESA, *LPPRINTER_ENUM_VALUESA;
    typedef struct _PRINTER_ENUM_VALUESW
    {
        LPWSTR pValueName;
        DWORD cbValueName;
        DWORD dwType;
        LPBYTE pData;
        DWORD cbData;
    } PRINTER_ENUM_VALUESW, *PPRINTER_ENUM_VALUESW, *LPPRINTER_ENUM_VALUESW;

    typedef PRINTER_ENUM_VALUESA PRINTER_ENUM_VALUES;
    typedef PPRINTER_ENUM_VALUESA PPRINTER_ENUM_VALUES;
    typedef LPPRINTER_ENUM_VALUESA LPPRINTER_ENUM_VALUES;

    BOOL __stdcall EnumPrintersA(DWORD Flags,
                                 LPSTR Name,
                                 DWORD Level,

                                 LPBYTE pPrinterEnum,
                                 DWORD cbBuf,
                                 LPDWORD pcbNeeded,
                                 LPDWORD pcReturned);

    BOOL __stdcall EnumPrintersW(DWORD Flags,
                                 LPWSTR Name,
                                 DWORD Level,

                                 LPBYTE pPrinterEnum,
                                 DWORD cbBuf,
                                 LPDWORD pcbNeeded,
                                 LPDWORD pcReturned);

    HANDLE
    __stdcall GetSpoolFileHandle(HANDLE hPrinter);

    HANDLE
    __stdcall CommitSpoolData(HANDLE hPrinter, HANDLE hSpoolFile, DWORD cbCommit);

    BOOL __stdcall CloseSpoolFileHandle(HANDLE hPrinter, HANDLE hSpoolFile);

    BOOL __stdcall OpenPrinterA(LPSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSA pDefault);
    BOOL __stdcall OpenPrinterW(LPWSTR pPrinterName, LPHANDLE phPrinter, LPPRINTER_DEFAULTSW pDefault);

    BOOL __stdcall ResetPrinterA(HANDLE hPrinter, LPPRINTER_DEFAULTSA pDefault);
    BOOL __stdcall ResetPrinterW(HANDLE hPrinter, LPPRINTER_DEFAULTSW pDefault);

    BOOL __stdcall SetJobA(HANDLE hPrinter,
                           DWORD JobId,
                           DWORD Level,

                           LPBYTE pJob,
                           DWORD Command);
    BOOL __stdcall SetJobW(HANDLE hPrinter,
                           DWORD JobId,
                           DWORD Level,

                           LPBYTE pJob,
                           DWORD Command);

    BOOL __stdcall GetJobA(HANDLE hPrinter,
                           DWORD JobId,
                           DWORD Level,

                           LPBYTE pJob,
                           DWORD cbBuf,
                           LPDWORD pcbNeeded);
    BOOL __stdcall GetJobW(HANDLE hPrinter,
                           DWORD JobId,
                           DWORD Level,

                           LPBYTE pJob,
                           DWORD cbBuf,
                           LPDWORD pcbNeeded);

    BOOL __stdcall EnumJobsA(HANDLE hPrinter,
                             DWORD FirstJob,
                             DWORD NoJobs,
                             DWORD Level,

                             LPBYTE pJob,
                             DWORD cbBuf,
                             LPDWORD pcbNeeded,
                             LPDWORD pcReturned);
    BOOL __stdcall EnumJobsW(HANDLE hPrinter,
                             DWORD FirstJob,
                             DWORD NoJobs,
                             DWORD Level,

                             LPBYTE pJob,
                             DWORD cbBuf,
                             LPDWORD pcbNeeded,
                             LPDWORD pcReturned);

    HANDLE
    __stdcall AddPrinterA(LPSTR pName,

                          DWORD Level,

                          LPBYTE pPrinter);
    HANDLE
    __stdcall AddPrinterW(LPWSTR pName,

                          DWORD Level,

                          LPBYTE pPrinter);

    BOOL __stdcall DeletePrinter(HANDLE hPrinter);

    BOOL __stdcall SetPrinterA(HANDLE hPrinter,
                               DWORD Level,

                               LPBYTE pPrinter,
                               DWORD Command);
    BOOL __stdcall SetPrinterW(HANDLE hPrinter,
                               DWORD Level,

                               LPBYTE pPrinter,
                               DWORD Command);

    BOOL __stdcall GetPrinterA(HANDLE hPrinter,
                               DWORD Level,

                               LPBYTE pPrinter,
                               DWORD cbBuf,
                               LPDWORD pcbNeeded);
    BOOL __stdcall GetPrinterW(HANDLE hPrinter,
                               DWORD Level,

                               LPBYTE pPrinter,
                               DWORD cbBuf,
                               LPDWORD pcbNeeded);

    BOOL __stdcall AddPrinterDriverA(LPSTR pName, DWORD Level, LPBYTE pDriverInfo);
    BOOL __stdcall AddPrinterDriverW(LPWSTR pName, DWORD Level, LPBYTE pDriverInfo);

    BOOL __stdcall AddPrinterDriverExA(LPSTR pName,
                                       DWORD Level,

                                       PBYTE lpbDriverInfo,
                                       DWORD dwFileCopyFlags);
    BOOL __stdcall AddPrinterDriverExW(LPWSTR pName,
                                       DWORD Level,

                                       PBYTE lpbDriverInfo,
                                       DWORD dwFileCopyFlags);

    BOOL __stdcall EnumPrinterDriversA(LPSTR pName,
                                       LPSTR pEnvironment,
                                       DWORD Level,

                                       LPBYTE pDriverInfo,
                                       DWORD cbBuf,
                                       LPDWORD pcbNeeded,
                                       LPDWORD pcReturned);
    BOOL __stdcall EnumPrinterDriversW(LPWSTR pName,
                                       LPWSTR pEnvironment,
                                       DWORD Level,

                                       LPBYTE pDriverInfo,
                                       DWORD cbBuf,
                                       LPDWORD pcbNeeded,
                                       LPDWORD pcReturned);

    BOOL __stdcall GetPrinterDriverA(HANDLE hPrinter,
                                     LPSTR pEnvironment,
                                     DWORD Level,

                                     LPBYTE pDriverInfo,
                                     DWORD cbBuf,
                                     LPDWORD pcbNeeded);
    BOOL __stdcall GetPrinterDriverW(HANDLE hPrinter,
                                     LPWSTR pEnvironment,
                                     DWORD Level,

                                     LPBYTE pDriverInfo,
                                     DWORD cbBuf,
                                     LPDWORD pcbNeeded);

    BOOL __stdcall GetPrinterDriverDirectoryA(LPSTR pName,
                                              LPSTR pEnvironment,
                                              DWORD Level,

                                              LPBYTE pDriverDirectory,
                                              DWORD cbBuf,
                                              LPDWORD pcbNeeded);
    BOOL __stdcall GetPrinterDriverDirectoryW(LPWSTR pName,
                                              LPWSTR pEnvironment,
                                              DWORD Level,

                                              LPBYTE pDriverDirectory,
                                              DWORD cbBuf,
                                              LPDWORD pcbNeeded);

    BOOL __stdcall DeletePrinterDriverA(LPSTR pName, LPSTR pEnvironment, LPSTR pDriverName);
    BOOL __stdcall DeletePrinterDriverW(LPWSTR pName, LPWSTR pEnvironment, LPWSTR pDriverName);

    BOOL __stdcall DeletePrinterDriverExA(LPSTR pName, LPSTR pEnvironment, LPSTR pDriverName, DWORD dwDeleteFlag, DWORD dwVersionFlag);
    BOOL __stdcall DeletePrinterDriverExW(LPWSTR pName, LPWSTR pEnvironment, LPWSTR pDriverName, DWORD dwDeleteFlag, DWORD dwVersionFlag);

    BOOL __stdcall AddPrintProcessorA(LPSTR pName, LPSTR pEnvironment, LPSTR pPathName, LPSTR pPrintProcessorName);
    BOOL __stdcall AddPrintProcessorW(LPWSTR pName, LPWSTR pEnvironment, LPWSTR pPathName, LPWSTR pPrintProcessorName);

    BOOL __stdcall EnumPrintProcessorsA(LPSTR pName,
                                        LPSTR pEnvironment,
                                        DWORD Level,

                                        LPBYTE pPrintProcessorInfo,
                                        DWORD cbBuf,
                                        LPDWORD pcbNeeded,
                                        LPDWORD pcReturned);
    BOOL __stdcall EnumPrintProcessorsW(LPWSTR pName,
                                        LPWSTR pEnvironment,
                                        DWORD Level,

                                        LPBYTE pPrintProcessorInfo,
                                        DWORD cbBuf,
                                        LPDWORD pcbNeeded,
                                        LPDWORD pcReturned);

    BOOL __stdcall GetPrintProcessorDirectoryA(LPSTR pName,
                                               LPSTR pEnvironment,
                                               DWORD Level,

                                               LPBYTE pPrintProcessorInfo,
                                               DWORD cbBuf,
                                               LPDWORD pcbNeeded);
    BOOL __stdcall GetPrintProcessorDirectoryW(LPWSTR pName,
                                               LPWSTR pEnvironment,
                                               DWORD Level,

                                               LPBYTE pPrintProcessorInfo,
                                               DWORD cbBuf,
                                               LPDWORD pcbNeeded);

    BOOL __stdcall EnumPrintProcessorDatatypesA(LPSTR pName,
                                                LPSTR pPrintProcessorName,
                                                DWORD Level,

                                                LPBYTE pDatatypes,
                                                DWORD cbBuf,
                                                LPDWORD pcbNeeded,
                                                LPDWORD pcReturned);

    BOOL __stdcall EnumPrintProcessorDatatypesW(LPWSTR pName,
                                                LPWSTR pPrintProcessorName,
                                                DWORD Level,

                                                LPBYTE pDatatypes,
                                                DWORD cbBuf,
                                                LPDWORD pcbNeeded,
                                                LPDWORD pcReturned);

    BOOL __stdcall DeletePrintProcessorA(LPSTR pName, LPSTR pEnvironment, LPSTR pPrintProcessorName);
    BOOL __stdcall DeletePrintProcessorW(LPWSTR pName, LPWSTR pEnvironment, LPWSTR pPrintProcessorName);

    DWORD
    __stdcall StartDocPrinterA(HANDLE hPrinter,
                               DWORD Level,

                               LPBYTE pDocInfo);
    DWORD
    __stdcall StartDocPrinterW(HANDLE hPrinter,
                               DWORD Level,

                               LPBYTE pDocInfo);

    BOOL __stdcall StartPagePrinter(HANDLE hPrinter);

    BOOL __stdcall WritePrinter(HANDLE hPrinter,

                                LPVOID pBuf,
                                DWORD cbBuf,
                                LPDWORD pcWritten);

    BOOL __stdcall FlushPrinter(HANDLE hPrinter,

                                LPVOID pBuf,
                                DWORD cbBuf,
                                LPDWORD pcWritten,
                                DWORD cSleep);

    BOOL __stdcall EndPagePrinter(HANDLE hPrinter);

    BOOL __stdcall AbortPrinter(HANDLE hPrinter);

    BOOL __stdcall ReadPrinter(HANDLE hPrinter,

                               LPVOID pBuf,
                               DWORD cbBuf,
                               LPDWORD pNoBytesRead);

    BOOL __stdcall EndDocPrinter(HANDLE hPrinter);

    BOOL __stdcall AddJobA(HANDLE hPrinter,
                           DWORD Level,

                           LPBYTE pData,
                           DWORD cbBuf,
                           LPDWORD pcbNeeded);
    BOOL __stdcall AddJobW(HANDLE hPrinter,
                           DWORD Level,

                           LPBYTE pData,
                           DWORD cbBuf,
                           LPDWORD pcbNeeded);

    BOOL __stdcall ScheduleJob(HANDLE hPrinter, DWORD JobId);

    BOOL __stdcall PrinterProperties(HWND hWnd, HANDLE hPrinter);

    LONG __stdcall DocumentPropertiesA(HWND hWnd, HANDLE hPrinter, LPSTR pDeviceName, PDEVMODEA pDevModeOutput, PDEVMODEA pDevModeInput, DWORD fMode);

    LONG __stdcall DocumentPropertiesW(HWND hWnd, HANDLE hPrinter, LPWSTR pDeviceName, PDEVMODEW pDevModeOutput, PDEVMODEW pDevModeInput, DWORD fMode);

    LONG __stdcall AdvancedDocumentPropertiesA(HWND hWnd, HANDLE hPrinter, LPSTR pDeviceName, PDEVMODEA pDevModeOutput, PDEVMODEA pDevModeInput);
    LONG __stdcall AdvancedDocumentPropertiesW(HWND hWnd, HANDLE hPrinter, LPWSTR pDeviceName, PDEVMODEW pDevModeOutput, PDEVMODEW pDevModeInput);

    LONG ExtDeviceMode(HWND hWnd, HANDLE hInst, LPDEVMODEA pDevModeOutput, LPSTR pDeviceName, LPSTR pPort, LPDEVMODEA pDevModeInput, LPSTR pProfile, DWORD fMode);

    DWORD
    __stdcall GetPrinterDataA(HANDLE hPrinter,
                              LPSTR pValueName,
                              LPDWORD pType,

                              LPBYTE pData,
                              DWORD nSize,
                              LPDWORD pcbNeeded);
    DWORD
    __stdcall GetPrinterDataW(HANDLE hPrinter,
                              LPWSTR pValueName,
                              LPDWORD pType,

                              LPBYTE pData,
                              DWORD nSize,
                              LPDWORD pcbNeeded);

    DWORD
    __stdcall GetPrinterDataExA(HANDLE hPrinter,
                                LPCSTR pKeyName,
                                LPCSTR pValueName,
                                LPDWORD pType,

                                LPBYTE pData,
                                DWORD nSize,
                                LPDWORD pcbNeeded);
    DWORD
    __stdcall GetPrinterDataExW(HANDLE hPrinter,
                                LPCWSTR pKeyName,
                                LPCWSTR pValueName,
                                LPDWORD pType,

                                LPBYTE pData,
                                DWORD nSize,
                                LPDWORD pcbNeeded);

    DWORD
    __stdcall EnumPrinterDataA(HANDLE hPrinter,
                               DWORD dwIndex,

                               LPSTR pValueName,
                               DWORD cbValueName,
                               LPDWORD pcbValueName,
                               LPDWORD pType,

                               LPBYTE pData,
                               DWORD cbData,

                               LPDWORD pcbData);
    DWORD
    __stdcall EnumPrinterDataW(HANDLE hPrinter,
                               DWORD dwIndex,

                               LPWSTR pValueName,
                               DWORD cbValueName,
                               LPDWORD pcbValueName,
                               LPDWORD pType,

                               LPBYTE pData,
                               DWORD cbData,

                               LPDWORD pcbData);

    DWORD
    __stdcall EnumPrinterDataExA(HANDLE hPrinter,
                                 LPCSTR pKeyName,

                                 LPBYTE pEnumValues,
                                 DWORD cbEnumValues,
                                 LPDWORD pcbEnumValues,
                                 LPDWORD pnEnumValues);
    DWORD
    __stdcall EnumPrinterDataExW(HANDLE hPrinter,
                                 LPCWSTR pKeyName,

                                 LPBYTE pEnumValues,
                                 DWORD cbEnumValues,
                                 LPDWORD pcbEnumValues,
                                 LPDWORD pnEnumValues);

    DWORD
    __stdcall EnumPrinterKeyA(HANDLE hPrinter,
                              LPCSTR pKeyName,

                              LPSTR pSubkey,
                              DWORD cbSubkey,
                              LPDWORD pcbSubkey);
    DWORD
    __stdcall EnumPrinterKeyW(HANDLE hPrinter,
                              LPCWSTR pKeyName,

                              LPWSTR pSubkey,
                              DWORD cbSubkey,
                              LPDWORD pcbSubkey);

    DWORD
    __stdcall SetPrinterDataA(HANDLE hPrinter,
                              LPSTR pValueName,
                              DWORD Type,

                              LPBYTE pData,
                              DWORD cbData);
    DWORD
    __stdcall SetPrinterDataW(HANDLE hPrinter,
                              LPWSTR pValueName,
                              DWORD Type,

                              LPBYTE pData,
                              DWORD cbData);

    DWORD
    __stdcall SetPrinterDataExA(HANDLE hPrinter,
                                LPCSTR pKeyName,
                                LPCSTR pValueName,
                                DWORD Type,

                                LPBYTE pData,
                                DWORD cbData);
    DWORD
    __stdcall SetPrinterDataExW(HANDLE hPrinter,
                                LPCWSTR pKeyName,
                                LPCWSTR pValueName,
                                DWORD Type,

                                LPBYTE pData,
                                DWORD cbData);

    DWORD
    __stdcall DeletePrinterDataA(HANDLE hPrinter, LPSTR pValueName);
    DWORD
    __stdcall DeletePrinterDataW(HANDLE hPrinter, LPWSTR pValueName);

    DWORD
    __stdcall DeletePrinterDataExA(HANDLE hPrinter, LPCSTR pKeyName, LPCSTR pValueName);
    DWORD
    __stdcall DeletePrinterDataExW(HANDLE hPrinter, LPCWSTR pKeyName, LPCWSTR pValueName);

    DWORD
    __stdcall DeletePrinterKeyA(HANDLE hPrinter, LPCSTR pKeyName);
    DWORD
    __stdcall DeletePrinterKeyW(HANDLE hPrinter, LPCWSTR pKeyName);

    typedef struct _PRINTER_NOTIFY_OPTIONS_TYPE
    {
        WORD Type;
        WORD Reserved0;
        DWORD Reserved1;
        DWORD Reserved2;
        DWORD Count;
        PWORD pFields;
    } PRINTER_NOTIFY_OPTIONS_TYPE, *PPRINTER_NOTIFY_OPTIONS_TYPE, *LPPRINTER_NOTIFY_OPTIONS_TYPE;

    typedef struct _PRINTER_NOTIFY_OPTIONS
    {
        DWORD Version;
        DWORD Flags;
        DWORD Count;
        PPRINTER_NOTIFY_OPTIONS_TYPE pTypes;
    } PRINTER_NOTIFY_OPTIONS, *PPRINTER_NOTIFY_OPTIONS, *LPPRINTER_NOTIFY_OPTIONS;

    typedef struct _PRINTER_NOTIFY_INFO_DATA
    {
        WORD Type;
        WORD Field;
        DWORD Reserved;
        DWORD Id;
        union
        {
            DWORD adwData[2];
            struct
            {
                DWORD cbBuf;
                LPVOID pBuf;
            } Data;
        } NotifyData;
    } PRINTER_NOTIFY_INFO_DATA, *PPRINTER_NOTIFY_INFO_DATA, *LPPRINTER_NOTIFY_INFO_DATA;

    typedef struct _PRINTER_NOTIFY_INFO
    {
        DWORD Version;
        DWORD Flags;
        DWORD Count;
        PRINTER_NOTIFY_INFO_DATA aData[1];
    } PRINTER_NOTIFY_INFO, *PPRINTER_NOTIFY_INFO, *LPPRINTER_NOTIFY_INFO;

    typedef struct _BINARY_CONTAINER
    {
        DWORD cbBuf;
        LPBYTE pData;
    } BINARY_CONTAINER, *PBINARY_CONTAINER;

    typedef struct _BIDI_DATA
    {
        DWORD dwBidiType;
        union
        {
            BOOL bData;
            LONG iData;
            LPWSTR sData;
            FLOAT fData;
            BINARY_CONTAINER biData;
        } u;
    } BIDI_DATA, *PBIDI_DATA, *LPBIDI_DATA;

    typedef struct _BIDI_REQUEST_DATA
    {
        DWORD dwReqNumber;
        LPWSTR pSchema;
        BIDI_DATA data;
    } BIDI_REQUEST_DATA, *PBIDI_REQUEST_DATA, *LPBIDI_REQUEST_DATA;

    typedef struct _BIDI_REQUEST_CONTAINER
    {
        DWORD Version;
        DWORD Flags;
        DWORD Count;
        BIDI_REQUEST_DATA aData[1];
    } BIDI_REQUEST_CONTAINER, *PBIDI_REQUEST_CONTAINER, *LPBIDI_REQUEST_CONTAINER;

    typedef struct _BIDI_RESPONSE_DATA
    {
        DWORD dwResult;
        DWORD dwReqNumber;
        LPWSTR pSchema;
        BIDI_DATA data;
    } BIDI_RESPONSE_DATA, *PBIDI_RESPONSE_DATA, *LPBIDI_RESPONSE_DATA;

    typedef struct _BIDI_RESPONSE_CONTAINER
    {
        DWORD Version;
        DWORD Flags;
        DWORD Count;
        BIDI_RESPONSE_DATA aData[1];
    } BIDI_RESPONSE_CONTAINER, *PBIDI_RESPONSE_CONTAINER, *LPBIDI_RESPONSE_CONTAINER;

    typedef enum
    {
        BIDI_NULL = 0,
        BIDI_INT = 1,
        BIDI_FLOAT = 2,
        BIDI_BOOL = 3,
        BIDI_STRING = 4,
        BIDI_TEXT = 5,
        BIDI_ENUM = 6,
        BIDI_BLOB = 7
    } BIDI_TYPE;

    DWORD
    __stdcall WaitForPrinterChange(HANDLE hPrinter, DWORD Flags);

    HANDLE
    __stdcall FindFirstPrinterChangeNotification(HANDLE hPrinter, DWORD fdwFilter, DWORD fdwOptions, PVOID pPrinterNotifyOptions);

    BOOL __stdcall FindNextPrinterChangeNotification(HANDLE hChange, PDWORD pdwChange, LPVOID pvReserved, LPVOID* ppPrinterNotifyInfo);

    BOOL __stdcall FreePrinterNotifyInfo(PPRINTER_NOTIFY_INFO pPrinterNotifyInfo);

    BOOL __stdcall FindClosePrinterChangeNotification(HANDLE hChange);

    DWORD
    __stdcall PrinterMessageBoxA(HANDLE hPrinter, DWORD Error, HWND hWnd, LPSTR pText, LPSTR pCaption, DWORD dwType);
    DWORD
    __stdcall PrinterMessageBoxW(HANDLE hPrinter, DWORD Error, HWND hWnd, LPWSTR pText, LPWSTR pCaption, DWORD dwType);

    BOOL __stdcall ClosePrinter(HANDLE hPrinter);

    BOOL __stdcall AddFormA(HANDLE hPrinter,
                            DWORD Level,

                            LPBYTE pForm);
    BOOL __stdcall AddFormW(HANDLE hPrinter,
                            DWORD Level,

                            LPBYTE pForm);

    BOOL __stdcall DeleteFormA(HANDLE hPrinter, LPSTR pFormName);
    BOOL __stdcall DeleteFormW(HANDLE hPrinter, LPWSTR pFormName);

    BOOL __stdcall GetFormA(HANDLE hPrinter,
                            LPSTR pFormName,
                            DWORD Level,

                            LPBYTE pForm,
                            DWORD cbBuf,
                            LPDWORD pcbNeeded);
    BOOL __stdcall GetFormW(HANDLE hPrinter,
                            LPWSTR pFormName,
                            DWORD Level,

                            LPBYTE pForm,
                            DWORD cbBuf,
                            LPDWORD pcbNeeded);

    BOOL __stdcall SetFormA(HANDLE hPrinter,
                            LPSTR pFormName,
                            DWORD Level,

                            LPBYTE pForm);
    BOOL __stdcall SetFormW(HANDLE hPrinter,
                            LPWSTR pFormName,
                            DWORD Level,

                            LPBYTE pForm);

    BOOL __stdcall EnumFormsA(HANDLE hPrinter,
                              DWORD Level,

                              LPBYTE pForm,
                              DWORD cbBuf,
                              LPDWORD pcbNeeded,
                              LPDWORD pcReturned);
    BOOL __stdcall EnumFormsW(HANDLE hPrinter,
                              DWORD Level,

                              LPBYTE pForm,
                              DWORD cbBuf,
                              LPDWORD pcbNeeded,
                              LPDWORD pcReturned);

    BOOL __stdcall EnumMonitorsA(LPSTR pName,
                                 DWORD Level,

                                 LPBYTE pMonitor,
                                 DWORD cbBuf,
                                 LPDWORD pcbNeeded,
                                 LPDWORD pcReturned);
    BOOL __stdcall EnumMonitorsW(LPWSTR pName,
                                 DWORD Level,

                                 LPBYTE pMonitor,
                                 DWORD cbBuf,
                                 LPDWORD pcbNeeded,
                                 LPDWORD pcReturned);

    BOOL __stdcall AddMonitorA(LPSTR pName,
                               DWORD Level,

                               LPBYTE pMonitors);
    BOOL __stdcall AddMonitorW(LPWSTR pName,
                               DWORD Level,

                               LPBYTE pMonitors);

    BOOL __stdcall DeleteMonitorA(LPSTR pName, LPSTR pEnvironment, LPSTR pMonitorName);
    BOOL __stdcall DeleteMonitorW(LPWSTR pName, LPWSTR pEnvironment, LPWSTR pMonitorName);

    BOOL __stdcall EnumPortsA(LPSTR pName,
                              DWORD Level,

                              LPBYTE pPort,
                              DWORD cbBuf,
                              LPDWORD pcbNeeded,
                              LPDWORD pcReturned);
    BOOL __stdcall EnumPortsW(LPWSTR pName,
                              DWORD Level,

                              LPBYTE pPort,
                              DWORD cbBuf,
                              LPDWORD pcbNeeded,
                              LPDWORD pcReturned);

    BOOL __stdcall AddPortA(LPSTR pName, HWND hWnd, LPSTR pMonitorName);
    BOOL __stdcall AddPortW(LPWSTR pName, HWND hWnd, LPWSTR pMonitorName);

    BOOL __stdcall ConfigurePortA(LPSTR pName, HWND hWnd, LPSTR pPortName);
    BOOL __stdcall ConfigurePortW(LPWSTR pName, HWND hWnd, LPWSTR pPortName);

    BOOL __stdcall DeletePortA(LPSTR pName, HWND hWnd, LPSTR pPortName);
    BOOL __stdcall DeletePortW(LPWSTR pName, HWND hWnd, LPWSTR pPortName);

    BOOL __stdcall XcvDataW(HANDLE hXcv,
                            PCWSTR pszDataName,

                            PBYTE pInputData,
                            DWORD cbInputData,

                            PBYTE pOutputData,
                            DWORD cbOutputData,
                            PDWORD pcbOutputNeeded,
                            PDWORD pdwStatus);

    BOOL __stdcall GetDefaultPrinterA(LPSTR pszBuffer, LPDWORD pcchBuffer);
    BOOL __stdcall GetDefaultPrinterW(LPWSTR pszBuffer, LPDWORD pcchBuffer);

    BOOL __stdcall SetDefaultPrinterA(LPCSTR pszPrinter);
    BOOL __stdcall SetDefaultPrinterW(LPCWSTR pszPrinter);

    BOOL __stdcall SetPortA(LPSTR pName,
                            LPSTR pPortName,
                            DWORD dwLevel,

                            LPBYTE pPortInfo);
    BOOL __stdcall SetPortW(LPWSTR pName,
                            LPWSTR pPortName,
                            DWORD dwLevel,

                            LPBYTE pPortInfo);

    BOOL __stdcall AddPrinterConnectionA(LPSTR pName);
    BOOL __stdcall AddPrinterConnectionW(LPWSTR pName);

    BOOL __stdcall DeletePrinterConnectionA(LPSTR pName);
    BOOL __stdcall DeletePrinterConnectionW(LPWSTR pName);

    HANDLE
    __stdcall ConnectToPrinterDlg(HWND hwnd, DWORD Flags);

    typedef struct _PROVIDOR_INFO_1A
    {
        LPSTR pName;
        LPSTR pEnvironment;
        LPSTR pDLLName;
    } PROVIDOR_INFO_1A, *PPROVIDOR_INFO_1A, *LPPROVIDOR_INFO_1A;
    typedef struct _PROVIDOR_INFO_1W
    {
        LPWSTR pName;
        LPWSTR pEnvironment;
        LPWSTR pDLLName;
    } PROVIDOR_INFO_1W, *PPROVIDOR_INFO_1W, *LPPROVIDOR_INFO_1W;

    typedef PROVIDOR_INFO_1A PROVIDOR_INFO_1;
    typedef PPROVIDOR_INFO_1A PPROVIDOR_INFO_1;
    typedef LPPROVIDOR_INFO_1A LPPROVIDOR_INFO_1;

    typedef struct _PROVIDOR_INFO_2A
    {
        LPSTR pOrder;
    } PROVIDOR_INFO_2A, *PPROVIDOR_INFO_2A, *LPPROVIDOR_INFO_2A;
    typedef struct _PROVIDOR_INFO_2W
    {
        LPWSTR pOrder;
    } PROVIDOR_INFO_2W, *PPROVIDOR_INFO_2W, *LPPROVIDOR_INFO_2W;

    typedef PROVIDOR_INFO_2A PROVIDOR_INFO_2;
    typedef PPROVIDOR_INFO_2A PPROVIDOR_INFO_2;
    typedef LPPROVIDOR_INFO_2A LPPROVIDOR_INFO_2;

    BOOL __stdcall AddPrintProvidorA(LPSTR pName,
                                     DWORD Level,

                                     LPBYTE pProvidorInfo);
    BOOL __stdcall AddPrintProvidorW(LPWSTR pName,
                                     DWORD Level,

                                     LPBYTE pProvidorInfo);

    BOOL __stdcall DeletePrintProvidorA(LPSTR pName, LPSTR pEnvironment, LPSTR pPrintProvidorName);
    BOOL __stdcall DeletePrintProvidorW(LPWSTR pName, LPWSTR pEnvironment, LPWSTR pPrintProvidorName);

    BOOL __stdcall IsValidDevmodeA(PDEVMODEA pDevmode, size_t DevmodeSize);
    BOOL __stdcall IsValidDevmodeW(PDEVMODEW pDevmode, size_t DevmodeSize);

    typedef enum _PRINTER_OPTION_FLAGS
    {
        PRINTER_OPTION_NO_CACHE = 1 << 0,
        PRINTER_OPTION_CACHE = 1 << 1,
        PRINTER_OPTION_CLIENT_CHANGE = 1 << 2,
        PRINTER_OPTION_NO_CLIENT_DATA = 1 << 3,
    } PRINTER_OPTION_FLAGS;

    typedef struct _PRINTER_OPTIONSA
    {
        UINT cbSize;
        DWORD dwFlags;
    } PRINTER_OPTIONSA, *PPRINTER_OPTIONSA, *LPPRINTER_OPTIONSA;
    typedef struct _PRINTER_OPTIONSW
    {
        UINT cbSize;
        DWORD dwFlags;
    } PRINTER_OPTIONSW, *PPRINTER_OPTIONSW, *LPPRINTER_OPTIONSW;

    typedef PRINTER_OPTIONSA PRINTER_OPTIONS;
    typedef PPRINTER_OPTIONSA PPRINTER_OPTIONS;
    typedef LPPRINTER_OPTIONSA LPPRINTER_OPTIONS;

    BOOL __stdcall OpenPrinter2A(LPCSTR pPrinterName, LPHANDLE phPrinter, PPRINTER_DEFAULTSA pDefault, PPRINTER_OPTIONSA pOptions);
    BOOL __stdcall OpenPrinter2W(LPCWSTR pPrinterName, LPHANDLE phPrinter, PPRINTER_DEFAULTSW pDefault, PPRINTER_OPTIONSW pOptions);

    typedef struct _PRINTER_CONNECTION_INFO_1A
    {
        DWORD dwFlags;
        LPSTR pszDriverName;
    } PRINTER_CONNECTION_INFO_1A, *PPRINTER_CONNECTION_INFO_1A;
    typedef struct _PRINTER_CONNECTION_INFO_1W
    {
        DWORD dwFlags;
        LPWSTR pszDriverName;
    } PRINTER_CONNECTION_INFO_1W, *PPRINTER_CONNECTION_INFO_1W;

    typedef PRINTER_CONNECTION_INFO_1A PRINTER_CONNECTION_INFO_1;
    typedef PPRINTER_CONNECTION_INFO_1A PPRINTER_CONNECTION_INFO_1;

    BOOL __stdcall AddPrinterConnection2A(HWND hWnd, LPCSTR pszName, DWORD dwLevel, PVOID pConnectionInfo);
    BOOL __stdcall AddPrinterConnection2W(HWND hWnd, LPCWSTR pszName, DWORD dwLevel, PVOID pConnectionInfo);

    HRESULT
    __stdcall InstallPrinterDriverFromPackageA(LPCSTR pszServer, LPCSTR pszInfPath, LPCSTR pszDriverName, LPCSTR pszEnvironment, DWORD dwFlags);
    HRESULT
    __stdcall InstallPrinterDriverFromPackageW(LPCWSTR pszServer, LPCWSTR pszInfPath, LPCWSTR pszDriverName, LPCWSTR pszEnvironment, DWORD dwFlags);

    HRESULT
    __stdcall UploadPrinterDriverPackageA(LPCSTR pszServer,
                                          LPCSTR pszInfPath,
                                          LPCSTR pszEnvironment,
                                          DWORD dwFlags,
                                          HWND hwnd,

                                          LPSTR pszDestInfPath,
                                          PULONG pcchDestInfPath);
    HRESULT
    __stdcall UploadPrinterDriverPackageW(LPCWSTR pszServer,
                                          LPCWSTR pszInfPath,
                                          LPCWSTR pszEnvironment,
                                          DWORD dwFlags,
                                          HWND hwnd,

                                          LPWSTR pszDestInfPath,
                                          PULONG pcchDestInfPath);

    typedef struct _CORE_PRINTER_DRIVERA
    {
        GUID CoreDriverGUID;
        FILETIME ftDriverDate;
        DWORDLONG dwlDriverVersion;
        CHAR szPackageID[260];
    } CORE_PRINTER_DRIVERA, *PCORE_PRINTER_DRIVERA;
    typedef struct _CORE_PRINTER_DRIVERW
    {
        GUID CoreDriverGUID;
        FILETIME ftDriverDate;
        DWORDLONG dwlDriverVersion;
        WCHAR szPackageID[260];
    } CORE_PRINTER_DRIVERW, *PCORE_PRINTER_DRIVERW;

    typedef CORE_PRINTER_DRIVERA CORE_PRINTER_DRIVER;
    typedef PCORE_PRINTER_DRIVERA PCORE_PRINTER_DRIVER;

    HRESULT
    __stdcall GetCorePrinterDriversA(LPCSTR pszServer,
                                     LPCSTR pszEnvironment,
                                     LPCSTR pszzCoreDriverDependencies,
                                     DWORD cCorePrinterDrivers,
                                     PCORE_PRINTER_DRIVERA pCorePrinterDrivers);
    HRESULT
    __stdcall GetCorePrinterDriversW(LPCWSTR pszServer,
                                     LPCWSTR pszEnvironment,
                                     LPCWSTR pszzCoreDriverDependencies,
                                     DWORD cCorePrinterDrivers,
                                     PCORE_PRINTER_DRIVERW pCorePrinterDrivers);

    HRESULT
    __stdcall CorePrinterDriverInstalledA(LPCSTR pszServer,
                                          LPCSTR pszEnvironment,
                                          GUID CoreDriverGUID,
                                          FILETIME ftDriverDate,
                                          DWORDLONG dwlDriverVersion,
                                          BOOL* pbDriverInstalled);
    HRESULT
    __stdcall CorePrinterDriverInstalledW(LPCWSTR pszServer,
                                          LPCWSTR pszEnvironment,
                                          GUID CoreDriverGUID,
                                          FILETIME ftDriverDate,
                                          DWORDLONG dwlDriverVersion,
                                          BOOL* pbDriverInstalled);

    HRESULT
    __stdcall GetPrinterDriverPackagePathA(LPCSTR pszServer,
                                           LPCSTR pszEnvironment,
                                           LPCSTR pszLanguage,
                                           LPCSTR pszPackageID,
                                           LPSTR pszDriverPackageCab,
                                           DWORD cchDriverPackageCab,
                                           LPDWORD pcchRequiredSize);
    HRESULT
    __stdcall GetPrinterDriverPackagePathW(LPCWSTR pszServer,
                                           LPCWSTR pszEnvironment,
                                           LPCWSTR pszLanguage,
                                           LPCWSTR pszPackageID,
                                           LPWSTR pszDriverPackageCab,
                                           DWORD cchDriverPackageCab,
                                           LPDWORD pcchRequiredSize);

    HRESULT
    __stdcall DeletePrinterDriverPackageA(LPCSTR pszServer, LPCSTR pszInfPath, LPCSTR pszEnvironment);
    HRESULT
    __stdcall DeletePrinterDriverPackageW(LPCWSTR pszServer, LPCWSTR pszInfPath, LPCWSTR pszEnvironment);

    typedef enum
    {
        kPropertyTypeString = 1,
        kPropertyTypeInt32,
        kPropertyTypeInt64,
        kPropertyTypeByte,
        kPropertyTypeTime,
        kPropertyTypeDevMode,
        kPropertyTypeSD,
        kPropertyTypeNotificationReply,
        kPropertyTypeNotificationOptions,
        kPropertyTypeBuffer

    } EPrintPropertyType;

    typedef enum
    {
        kAddingDocumentSequence = 0,
        kDocumentSequenceAdded = 1,
        kAddingFixedDocument = 2,
        kFixedDocumentAdded = 3,
        kAddingFixedPage = 4,
        kFixedPageAdded = 5,
        kResourceAdded = 6,
        kFontAdded = 7,
        kImageAdded = 8,
        kXpsDocumentCommitted = 9

    } EPrintXPSJobProgress;

    typedef enum
    {
        kJobProduction = 1,
        kJobConsumption

    } EPrintXPSJobOperation;

    typedef struct
    {
        EPrintPropertyType ePropertyType;
        union
        {
            BYTE propertyByte;
            PWSTR propertyString;
            LONG propertyInt32;
            LONGLONG propertyInt64;
            struct
            {
                DWORD cbBuf;
                LPVOID pBuf;
            } propertyBlob;
        } value;

    } PrintPropertyValue;

    typedef struct
    {
        WCHAR* propertyName;
        PrintPropertyValue propertyValue;

    } PrintNamedProperty;

    typedef struct
    {
        ULONG numberOfProperties;
        PrintNamedProperty* propertiesCollection;

    } PrintPropertiesCollection;

    HRESULT
    __stdcall ReportJobProcessingProgress(HANDLE printerHandle, ULONG jobId, EPrintXPSJobOperation jobOperation, EPrintXPSJobProgress jobProgress);

    BOOL __stdcall GetPrinterDriver2A(HWND hWnd,
                                      HANDLE hPrinter,
                                      LPSTR pEnvironment,
                                      DWORD Level,

                                      LPBYTE pDriverInfo,
                                      DWORD cbBuf,
                                      LPDWORD pcbNeeded);
    BOOL __stdcall GetPrinterDriver2W(HWND hWnd,
                                      HANDLE hPrinter,
                                      LPWSTR pEnvironment,
                                      DWORD Level,

                                      LPBYTE pDriverInfo,
                                      DWORD cbBuf,
                                      LPDWORD pcbNeeded);

    typedef enum
    {
        PRINT_EXECUTION_CONTEXT_APPLICATION = 0,
        PRINT_EXECUTION_CONTEXT_SPOOLER_SERVICE = 1,
        PRINT_EXECUTION_CONTEXT_SPOOLER_ISOLATION_HOST = 2,
        PRINT_EXECUTION_CONTEXT_FILTER_PIPELINE = 3,
        PRINT_EXECUTION_CONTEXT_WOW64 = 4
    } PRINT_EXECUTION_CONTEXT;

    typedef struct
    {
        PRINT_EXECUTION_CONTEXT context;
        DWORD clientAppPID;
    } PRINT_EXECUTION_DATA;

    BOOL __stdcall GetPrintExecutionData(PRINT_EXECUTION_DATA* pData);

    DWORD
    __stdcall GetJobNamedPropertyValue(HANDLE hPrinter, DWORD JobId, PCWSTR pszName, PrintPropertyValue* pValue);

    void __stdcall FreePrintPropertyValue(PrintPropertyValue* pValue);

    void __stdcall FreePrintNamedPropertyArray(DWORD cProperties,

                                               PrintNamedProperty** ppProperties);

    DWORD
    __stdcall SetJobNamedProperty(HANDLE hPrinter, DWORD JobId, const PrintNamedProperty* pProperty);

    DWORD
    __stdcall DeleteJobNamedProperty(HANDLE hPrinter, DWORD JobId, PCWSTR pszName);

    DWORD
    __stdcall EnumJobNamedProperties(HANDLE hPrinter,
                                     DWORD JobId,
                                     DWORD* pcProperties,

                                     PrintNamedProperty** ppProperties);

    HRESULT
    __stdcall GetPrintOutputInfo(HWND hWnd, PCWSTR pszPrinter, HANDLE* phFile, PWSTR* ppszOutputFile);

#pragma endregion

#pragma warning(pop)
}

#pragma warning(push)
#pragma warning(disable : 4001)

#pragma once

#pragma warning(disable : 4103)

#pragma pack(push, 8)

#pragma once

#pragma warning(disable : 4103)

#pragma pack(push, 8)

#pragma once

#pragma warning(disable : 4103)

#pragma pack(push, 8)

#pragma region Application or OneCore Family

extern "C++"
{
    template <typename T> void** IID_PPV_ARGS_Helper(T** pp);
}

typedef enum tagREGCLS
{
    REGCLS_SINGLEUSE = 0,
    REGCLS_MULTIPLEUSE = 1,

    REGCLS_MULTI_SEPARATE = 2,

    REGCLS_SUSPENDED = 4,

    REGCLS_SURROGATE = 8,

    REGCLS_AGILE = 0x10,

} REGCLS;

typedef struct IRpcStubBuffer IRpcStubBuffer;
typedef struct IRpcChannelBuffer IRpcChannelBuffer;

typedef enum tagCOINITBASE
{

    COINITBASE_MULTITHREADED = 0x0,
} COINITBASE;

#pragma once

typedef struct IUnknown IUnknown;

typedef struct AsyncIUnknown AsyncIUnknown;

typedef struct IClassFactory IClassFactory;

extern "C"
{
#pragma once
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0000_v0_0_s_ifspec;

    typedef IUnknown* LPUNKNOWN;

    extern "C" const IID IID_IUnknown;
    extern "C++"
    {
        struct __declspec(uuid("00000000-0000-0000-C000-000000000046")) __declspec(novtable) IUnknown
        {
        public:
            virtual HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObject) = 0;

            virtual ULONG __stdcall AddRef(void) = 0;

            virtual ULONG __stdcall Release(void) = 0;

            template <class Q>
            HRESULT

            __stdcall QueryInterface(Q** pp)
            {
                return QueryInterface(__uuidof(Q), (void**)pp);
            }
        };
    }
    HRESULT __stdcall IUnknown_QueryInterface_Proxy(IUnknown* This, const IID& riid, void** ppvObject);

    void __stdcall IUnknown_QueryInterface_Stub(IRpcStubBuffer* This,
                                                IRpcChannelBuffer* _pRpcChannelBuffer,
                                                PRPC_MESSAGE _pRpcMessage,
                                                DWORD* _pdwStubPhase);

    ULONG __stdcall IUnknown_AddRef_Proxy(IUnknown* This);

    void __stdcall IUnknown_AddRef_Stub(IRpcStubBuffer* This, IRpcChannelBuffer* _pRpcChannelBuffer, PRPC_MESSAGE _pRpcMessage, DWORD* _pdwStubPhase);

    ULONG __stdcall IUnknown_Release_Proxy(IUnknown* This);

    void __stdcall IUnknown_Release_Stub(IRpcStubBuffer* This, IRpcChannelBuffer* _pRpcChannelBuffer, PRPC_MESSAGE _pRpcMessage, DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0001_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0001_v0_0_s_ifspec;

    extern "C" const IID IID_AsyncIUnknown;

    struct __declspec(uuid("000e0000-0000-0000-C000-000000000046")) __declspec(novtable) AsyncIUnknown : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Begin_QueryInterface(const IID& riid) = 0;

        virtual HRESULT __stdcall Finish_QueryInterface(

        void** ppvObject)
        = 0;

        virtual HRESULT __stdcall Begin_AddRef(void) = 0;

        virtual ULONG __stdcall Finish_AddRef(void) = 0;

        virtual HRESULT __stdcall Begin_Release(void) = 0;

        virtual ULONG __stdcall Finish_Release(void) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0002_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0002_v0_0_s_ifspec;

    typedef IClassFactory* LPCLASSFACTORY;

    extern "C" const IID IID_IClassFactory;

    struct __declspec(uuid("00000001-0000-0000-C000-000000000046")) __declspec(novtable) IClassFactory : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateInstance(

        IUnknown* pUnkOuter,

        const IID& riid,

        void** ppvObject)
        = 0;

        virtual HRESULT __stdcall LockServer(BOOL fLock) = 0;
    };

    HRESULT __stdcall IClassFactory_RemoteCreateInstance_Proxy(IClassFactory* This, const IID& riid, IUnknown** ppvObject);

    void __stdcall IClassFactory_RemoteCreateInstance_Stub(IRpcStubBuffer* This,
                                                           IRpcChannelBuffer* _pRpcChannelBuffer,
                                                           PRPC_MESSAGE _pRpcMessage,
                                                           DWORD* _pdwStubPhase);

    HRESULT __stdcall IClassFactory_RemoteLockServer_Proxy(IClassFactory* This, BOOL fLock);

    void __stdcall IClassFactory_RemoteLockServer_Stub(IRpcStubBuffer* This,
                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                       PRPC_MESSAGE _pRpcMessage,
                                                       DWORD* _pdwStubPhase);

#pragma endregion

    extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0003_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_unknwnbase_0000_0003_v0_0_s_ifspec;

    HRESULT __stdcall IClassFactory_CreateInstance_Proxy(IClassFactory* This,

                                                         IUnknown* pUnkOuter,

                                                         const IID& riid,

                                                         void** ppvObject);

    HRESULT __stdcall IClassFactory_CreateInstance_Stub(IClassFactory* This, const IID& riid, IUnknown** ppvObject);

    HRESULT __stdcall IClassFactory_LockServer_Proxy(IClassFactory* This, BOOL fLock);

    HRESULT __stdcall IClassFactory_LockServer_Stub(IClassFactory* This, BOOL fLock);
}

extern "C++"
{
    template <typename T> void** IID_PPV_ARGS_Helper(T** pp)
    {
#pragma prefast(suppress : 6269, "Tool issue with unused static_cast")
        static_cast<IUnknown*>(*pp);
        return reinterpret_cast<void**>(pp);
    }
}

#pragma once

typedef struct IMarshal IMarshal;

typedef struct INoMarshal INoMarshal;

typedef struct IAgileObject IAgileObject;

typedef struct IActivationFilter IActivationFilter;

typedef struct IMarshal2 IMarshal2;

typedef struct IMalloc IMalloc;

typedef struct IStdMarshalInfo IStdMarshalInfo;

typedef struct IExternalConnection IExternalConnection;

typedef struct IMultiQI IMultiQI;

typedef struct AsyncIMultiQI AsyncIMultiQI;

typedef struct IInternalUnknown IInternalUnknown;

typedef struct IEnumUnknown IEnumUnknown;

typedef struct IEnumString IEnumString;

typedef struct ISequentialStream ISequentialStream;

typedef struct IStream IStream;

typedef struct IRpcChannelBuffer IRpcChannelBuffer;

typedef struct IRpcChannelBuffer2 IRpcChannelBuffer2;

typedef struct IAsyncRpcChannelBuffer IAsyncRpcChannelBuffer;

typedef struct IRpcChannelBuffer3 IRpcChannelBuffer3;

typedef struct IRpcSyntaxNegotiate IRpcSyntaxNegotiate;

typedef struct IRpcProxyBuffer IRpcProxyBuffer;

typedef struct IRpcStubBuffer IRpcStubBuffer;

typedef struct IPSFactoryBuffer IPSFactoryBuffer;

typedef struct IChannelHook IChannelHook;

typedef struct IClientSecurity IClientSecurity;

typedef struct IServerSecurity IServerSecurity;

typedef struct IRpcOptions IRpcOptions;

typedef struct IGlobalOptions IGlobalOptions;

typedef struct ISurrogate ISurrogate;

typedef struct IGlobalInterfaceTable IGlobalInterfaceTable;

typedef struct ISynchronize ISynchronize;

typedef struct ISynchronizeHandle ISynchronizeHandle;

typedef struct ISynchronizeEvent ISynchronizeEvent;

typedef struct ISynchronizeContainer ISynchronizeContainer;

typedef struct ISynchronizeMutex ISynchronizeMutex;

typedef struct ICancelMethodCalls ICancelMethodCalls;

typedef struct IAsyncManager IAsyncManager;

typedef struct ICallFactory ICallFactory;

typedef struct IRpcHelper IRpcHelper;

typedef struct IReleaseMarshalBuffers IReleaseMarshalBuffers;

typedef struct IWaitMultiple IWaitMultiple;

typedef struct IAddrTrackingControl IAddrTrackingControl;

typedef struct IAddrExclusionControl IAddrExclusionControl;

typedef struct IPipeByte IPipeByte;

typedef struct AsyncIPipeByte AsyncIPipeByte;

typedef struct IPipeLong IPipeLong;

typedef struct AsyncIPipeLong AsyncIPipeLong;

typedef struct IPipeDouble IPipeDouble;

typedef struct AsyncIPipeDouble AsyncIPipeDouble;

typedef struct IEnumContextProps IEnumContextProps;

typedef struct IContext IContext;

typedef struct IObjContext IObjContext;

typedef struct IComThreadingInfo IComThreadingInfo;

typedef struct IProcessInitControl IProcessInitControl;

typedef struct IFastRundown IFastRundown;

typedef struct IMarshalingStream IMarshalingStream;

typedef struct IAgileReference IAgileReference;

extern "C"
{
#pragma warning(push)

#pragma warning(disable : 4820)
#pragma warning(disable : 4201)

#pragma once

#pragma region Application Family or OneCore Family

#pragma endregion
#pragma region Desktop Family or OneCore Family

#pragma endregion
#pragma region Application Family or OneCore Family

    typedef struct _COSERVERINFO
    {
        DWORD dwReserved1;
        LPWSTR pwszName;
        COAUTHINFO* pAuthInfo;
        DWORD dwReserved2;
    } COSERVERINFO;

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0000_v0_0_s_ifspec;

    typedef IMarshal* LPMARSHAL;

    extern "C" const IID IID_IMarshal;

    struct __declspec(uuid("00000003-0000-0000-C000-000000000046")) __declspec(novtable) IMarshal : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetUnmarshalClass(

        const IID& riid,

        void* pv,

        DWORD dwDestContext,

        void* pvDestContext,

        DWORD mshlflags,

        CLSID* pCid)
        = 0;

        virtual HRESULT __stdcall GetMarshalSizeMax(

        const IID& riid,

        void* pv,

        DWORD dwDestContext,

        void* pvDestContext,

        DWORD mshlflags,

        DWORD* pSize)
        = 0;

        virtual HRESULT __stdcall MarshalInterface(

        IStream* pStm,

        const IID& riid,

        void* pv,

        DWORD dwDestContext,

        void* pvDestContext,

        DWORD mshlflags)
        = 0;

        virtual HRESULT __stdcall UnmarshalInterface(

        IStream* pStm,

        const IID& riid,

        void** ppv)
        = 0;

        virtual HRESULT __stdcall ReleaseMarshalData(

        IStream* pStm)
        = 0;

        virtual HRESULT __stdcall DisconnectObject(

        DWORD dwReserved)
        = 0;
    };

    extern "C" const IID IID_INoMarshal;

    struct __declspec(uuid("ecc8691b-c1db-4dc0-855e-65f6c551af49")) __declspec(novtable) INoMarshal : public IUnknown
    {
    public:
    };

    extern "C" const IID IID_IAgileObject;

    struct __declspec(uuid("94ea2b94-e9cc-49e0-c0ff-ee64ca8f5b90")) __declspec(novtable) IAgileObject : public IUnknown
    {
    public:
    };

#pragma endregion
#pragma region Desktop Family or OneCore Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0003_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0003_v0_0_s_ifspec;

    typedef enum tagACTIVATIONTYPE
    {
        ACTIVATIONTYPE_UNCATEGORIZED = 0,
        ACTIVATIONTYPE_FROM_MONIKER = 0x1,
        ACTIVATIONTYPE_FROM_DATA = 0x2,
        ACTIVATIONTYPE_FROM_STORAGE = 0x4,
        ACTIVATIONTYPE_FROM_STREAM = 0x8,
        ACTIVATIONTYPE_FROM_FILE = 0x10
    } ACTIVATIONTYPE;

    extern "C" const IID IID_IActivationFilter;

    struct __declspec(uuid("00000017-0000-0000-C000-000000000046")) __declspec(novtable) IActivationFilter : public IUnknown
    {
    public:
        virtual HRESULT __stdcall HandleActivation(DWORD dwActivationType, const IID& rclsid, CLSID* pReplacementClsId) = 0;
    };

    typedef IMarshal2* LPMARSHAL2;

    extern "C" const IID IID_IMarshal2;

    struct __declspec(uuid("000001cf-0000-0000-C000-000000000046")) __declspec(novtable) IMarshal2 : public IMarshal
    {
    public:
    };

    typedef IMalloc* LPMALLOC;

    extern "C" const IID IID_IMalloc;

    struct __declspec(uuid("00000002-0000-0000-C000-000000000046")) __declspec(novtable) IMalloc : public IUnknown
    {
    public:
        virtual void* __stdcall Alloc(

        SIZE_T cb)
        = 0;

        virtual void* __stdcall Realloc(

        void* pv,

        SIZE_T cb)
        = 0;

        virtual void __stdcall Free(

        void* pv)
        = 0;

        virtual SIZE_T __stdcall GetSize(

        void* pv)
        = 0;

        virtual int __stdcall DidAlloc(

        void* pv)
        = 0;

        virtual void __stdcall HeapMinimize(void) = 0;
    };

    typedef IStdMarshalInfo* LPSTDMARSHALINFO;

    extern "C" const IID IID_IStdMarshalInfo;

    struct __declspec(uuid("00000018-0000-0000-C000-000000000046")) __declspec(novtable) IStdMarshalInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetClassForHandler(

        DWORD dwDestContext,

        void* pvDestContext,

        CLSID* pClsid)
        = 0;
    };

    typedef IExternalConnection* LPEXTERNALCONNECTION;

    typedef enum tagEXTCONN
    {
        EXTCONN_STRONG = 0x1,
        EXTCONN_WEAK = 0x2,
        EXTCONN_CALLABLE = 0x4
    } EXTCONN;

    extern "C" const IID IID_IExternalConnection;

    struct __declspec(uuid("00000019-0000-0000-C000-000000000046")) __declspec(novtable) IExternalConnection : public IUnknown
    {
    public:
        virtual DWORD __stdcall AddConnection(

        DWORD extconn,

        DWORD reserved)
        = 0;

        virtual DWORD __stdcall ReleaseConnection(

        DWORD extconn,

        DWORD reserved,

        BOOL fLastReleaseCloses)
        = 0;
    };

    typedef IMultiQI* LPMULTIQI;

#pragma endregion
#pragma region Application Family or OneCore Family

    typedef struct tagMULTI_QI
    {
        const IID* pIID;
        IUnknown* pItf;
        HRESULT hr;
    } MULTI_QI;

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0008_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0008_v0_0_s_ifspec;

    extern "C" const IID IID_IMultiQI;

    struct __declspec(uuid("00000020-0000-0000-C000-000000000046")) __declspec(novtable) IMultiQI : public IUnknown
    {
    public:
        virtual HRESULT __stdcall QueryMultipleInterfaces(

        ULONG cMQIs,

        MULTI_QI* pMQIs)
        = 0;
    };

    extern "C" const IID IID_AsyncIMultiQI;

    struct __declspec(uuid("000e0020-0000-0000-C000-000000000046")) __declspec(novtable) AsyncIMultiQI : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Begin_QueryMultipleInterfaces(

        ULONG cMQIs,

        MULTI_QI* pMQIs)
        = 0;

        virtual HRESULT __stdcall Finish_QueryMultipleInterfaces(

        MULTI_QI* pMQIs)
        = 0;
    };

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0009_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0009_v0_0_s_ifspec;

    extern "C" const IID IID_IInternalUnknown;

    struct __declspec(uuid("00000021-0000-0000-C000-000000000046")) __declspec(novtable) IInternalUnknown : public IUnknown
    {
    public:
        virtual HRESULT __stdcall QueryInternalInterface(

        const IID& riid,

        void** ppv)
        = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0010_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0010_v0_0_s_ifspec;

    typedef IEnumUnknown* LPENUMUNKNOWN;

    extern "C" const IID IID_IEnumUnknown;

    struct __declspec(uuid("00000100-0000-0000-C000-000000000046")) __declspec(novtable) IEnumUnknown : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(

        ULONG celt,

        IUnknown** rgelt,

        ULONG* pceltFetched)
        = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumUnknown** ppenum) = 0;
    };

    HRESULT __stdcall IEnumUnknown_RemoteNext_Proxy(IEnumUnknown* This, ULONG celt, IUnknown** rgelt, ULONG* pceltFetched);

    void __stdcall IEnumUnknown_RemoteNext_Stub(IRpcStubBuffer* This,
                                                IRpcChannelBuffer* _pRpcChannelBuffer,
                                                PRPC_MESSAGE _pRpcMessage,
                                                DWORD* _pdwStubPhase);

    typedef IEnumString* LPENUMSTRING;

    extern "C" const IID IID_IEnumString;

    struct __declspec(uuid("00000101-0000-0000-C000-000000000046")) __declspec(novtable) IEnumString : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(ULONG celt,

                                       LPOLESTR* rgelt,

                                       ULONG* pceltFetched)
        = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumString** ppenum) = 0;
    };

    HRESULT __stdcall IEnumString_RemoteNext_Proxy(IEnumString* This, ULONG celt, LPOLESTR* rgelt, ULONG* pceltFetched);

    void __stdcall IEnumString_RemoteNext_Stub(IRpcStubBuffer* This,
                                               IRpcChannelBuffer* _pRpcChannelBuffer,
                                               PRPC_MESSAGE _pRpcMessage,
                                               DWORD* _pdwStubPhase);

    extern "C" const IID IID_ISequentialStream;

    struct __declspec(uuid("0c733a30-2a1c-11ce-ade5-00aa0044773d")) __declspec(novtable) ISequentialStream : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Read(

        void* pv,

        ULONG cb,

        ULONG* pcbRead)
        = 0;

        virtual HRESULT __stdcall Write(

        const void* pv,

        ULONG cb,

        ULONG* pcbWritten)
        = 0;
    };

    HRESULT __stdcall ISequentialStream_RemoteRead_Proxy(ISequentialStream* This, byte* pv, ULONG cb, ULONG* pcbRead);

    void __stdcall ISequentialStream_RemoteRead_Stub(IRpcStubBuffer* This,
                                                     IRpcChannelBuffer* _pRpcChannelBuffer,
                                                     PRPC_MESSAGE _pRpcMessage,
                                                     DWORD* _pdwStubPhase);

    HRESULT __stdcall ISequentialStream_RemoteWrite_Proxy(ISequentialStream* This, const byte* pv, ULONG cb, ULONG* pcbWritten);

    void __stdcall ISequentialStream_RemoteWrite_Stub(IRpcStubBuffer* This,
                                                      IRpcChannelBuffer* _pRpcChannelBuffer,
                                                      PRPC_MESSAGE _pRpcMessage,
                                                      DWORD* _pdwStubPhase);

    typedef IStream* LPSTREAM;

    typedef struct tagSTATSTG
    {
        LPOLESTR pwcsName;
        DWORD type;
        ULARGE_INTEGER cbSize;
        FILETIME mtime;
        FILETIME ctime;
        FILETIME atime;
        DWORD grfMode;
        DWORD grfLocksSupported;
        CLSID clsid;
        DWORD grfStateBits;
        DWORD reserved;
    } STATSTG;

    typedef enum tagSTGTY
    {
        STGTY_STORAGE = 1,
        STGTY_STREAM = 2,
        STGTY_LOCKBYTES = 3,
        STGTY_PROPERTY = 4
    } STGTY;

    typedef enum tagSTREAM_SEEK
    {
        STREAM_SEEK_SET = 0,
        STREAM_SEEK_CUR = 1,
        STREAM_SEEK_END = 2
    } STREAM_SEEK;

    typedef enum tagLOCKTYPE
    {
        LOCK_WRITE = 1,
        LOCK_EXCLUSIVE = 2,
        LOCK_ONLYONCE = 4
    } LOCKTYPE;

    extern "C" const IID IID_IStream;

    struct __declspec(uuid("0000000c-0000-0000-C000-000000000046")) __declspec(novtable) IStream : public ISequentialStream
    {
    public:
        virtual HRESULT __stdcall Seek(LARGE_INTEGER dlibMove,
                                       DWORD dwOrigin,

                                       ULARGE_INTEGER* plibNewPosition)
        = 0;

        virtual HRESULT __stdcall SetSize(ULARGE_INTEGER libNewSize) = 0;

        virtual HRESULT __stdcall CopyTo(

        IStream* pstm,
        ULARGE_INTEGER cb,

        ULARGE_INTEGER* pcbRead,

        ULARGE_INTEGER* pcbWritten)
        = 0;

        virtual HRESULT __stdcall Commit(DWORD grfCommitFlags) = 0;

        virtual HRESULT __stdcall Revert(void) = 0;

        virtual HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) = 0;

        virtual HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) = 0;

        virtual HRESULT __stdcall Stat(STATSTG* pstatstg, DWORD grfStatFlag) = 0;

        virtual HRESULT __stdcall Clone(IStream** ppstm) = 0;
    };

    HRESULT __stdcall IStream_RemoteSeek_Proxy(IStream* This, LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition);

    void __stdcall IStream_RemoteSeek_Stub(IRpcStubBuffer* This,
                                           IRpcChannelBuffer* _pRpcChannelBuffer,
                                           PRPC_MESSAGE _pRpcMessage,
                                           DWORD* _pdwStubPhase);

    HRESULT __stdcall IStream_RemoteCopyTo_Proxy(IStream* This, IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead, ULARGE_INTEGER* pcbWritten);

    void __stdcall IStream_RemoteCopyTo_Stub(IRpcStubBuffer* This,
                                             IRpcChannelBuffer* _pRpcChannelBuffer,
                                             PRPC_MESSAGE _pRpcMessage,
                                             DWORD* _pdwStubPhase);

    typedef ULONG RPCOLEDATAREP;

    typedef struct tagRPCOLEMESSAGE
    {
        void* reserved1;
        RPCOLEDATAREP dataRepresentation;
        void* Buffer;
        ULONG cbBuffer;
        ULONG iMethod;
        void* reserved2[5];
        ULONG rpcFlags;
    } RPCOLEMESSAGE;

    typedef RPCOLEMESSAGE* PRPCOLEMESSAGE;

    extern "C" const IID IID_IRpcChannelBuffer;

    struct __declspec(uuid("D5F56B60-593B-101A-B569-08002B2DBF7A")) __declspec(novtable) IRpcChannelBuffer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetBuffer(

        RPCOLEMESSAGE* pMessage,

        const IID& riid)
        = 0;

        virtual HRESULT __stdcall SendReceive(

        RPCOLEMESSAGE* pMessage,

        ULONG* pStatus)
        = 0;

        virtual HRESULT __stdcall FreeBuffer(

        RPCOLEMESSAGE* pMessage)
        = 0;

        virtual HRESULT __stdcall GetDestCtx(

        DWORD* pdwDestContext,

        void** ppvDestContext)
        = 0;

        virtual HRESULT __stdcall IsConnected(void) = 0;
    };

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0015_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0015_v0_0_s_ifspec;

    extern "C" const IID IID_IRpcChannelBuffer2;

    struct __declspec(uuid("594f31d0-7f19-11d0-b194-00a0c90dc8bf")) __declspec(novtable) IRpcChannelBuffer2 : public IRpcChannelBuffer
    {
    public:
        virtual HRESULT __stdcall GetProtocolVersion(

        DWORD* pdwVersion)
        = 0;
    };

    extern "C" const IID IID_IAsyncRpcChannelBuffer;

    struct __declspec(uuid("a5029fb6-3c34-11d1-9c99-00c04fb998aa")) __declspec(novtable) IAsyncRpcChannelBuffer : public IRpcChannelBuffer2
    {
    public:
        virtual HRESULT __stdcall Send(

        RPCOLEMESSAGE* pMsg,

        ISynchronize* pSync,

        ULONG* pulStatus)
        = 0;

        virtual HRESULT __stdcall Receive(

        RPCOLEMESSAGE* pMsg,

        ULONG* pulStatus)
        = 0;

        virtual HRESULT __stdcall GetDestCtxEx(

        RPCOLEMESSAGE* pMsg,

        DWORD* pdwDestContext,

        void** ppvDestContext)
        = 0;
    };

    extern "C" const IID IID_IRpcChannelBuffer3;

    struct __declspec(uuid("25B15600-0115-11d0-BF0D-00AA00B8DFD2")) __declspec(novtable) IRpcChannelBuffer3 : public IRpcChannelBuffer2
    {
    public:
        virtual HRESULT __stdcall Send(

        RPCOLEMESSAGE* pMsg,

        ULONG* pulStatus)
        = 0;

        virtual HRESULT __stdcall Receive(

        RPCOLEMESSAGE* pMsg,

        ULONG ulSize,

        ULONG* pulStatus)
        = 0;

        virtual HRESULT __stdcall Cancel(

        RPCOLEMESSAGE* pMsg)
        = 0;

        virtual HRESULT __stdcall GetCallContext(

        RPCOLEMESSAGE* pMsg,

        const IID& riid,

        void** pInterface)
        = 0;

        virtual HRESULT __stdcall GetDestCtxEx(

        RPCOLEMESSAGE* pMsg,

        DWORD* pdwDestContext,

        void** ppvDestContext)
        = 0;

        virtual HRESULT __stdcall GetState(

        RPCOLEMESSAGE* pMsg,

        DWORD* pState)
        = 0;

        virtual HRESULT __stdcall RegisterAsync(

        RPCOLEMESSAGE* pMsg,

        IAsyncManager* pAsyncMgr)
        = 0;
    };

    extern "C" const IID IID_IRpcSyntaxNegotiate;

    struct __declspec(uuid("58a08519-24c8-4935-b482-3fd823333a4f")) __declspec(novtable) IRpcSyntaxNegotiate : public IUnknown
    {
    public:
        virtual HRESULT __stdcall NegotiateSyntax(

        RPCOLEMESSAGE* pMsg)
        = 0;
    };

    extern "C" const IID IID_IRpcProxyBuffer;

    struct __declspec(uuid("D5F56A34-593B-101A-B569-08002B2DBF7A")) __declspec(novtable) IRpcProxyBuffer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Connect(

        IRpcChannelBuffer* pRpcChannelBuffer)
        = 0;

        virtual void __stdcall Disconnect(void) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0020_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0020_v0_0_s_ifspec;

    extern "C" const IID IID_IRpcStubBuffer;

    struct __declspec(uuid("D5F56AFC-593B-101A-B569-08002B2DBF7A")) __declspec(novtable) IRpcStubBuffer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Connect(

        IUnknown* pUnkServer)
        = 0;

        virtual void __stdcall Disconnect(void) = 0;

        virtual HRESULT __stdcall Invoke(

        RPCOLEMESSAGE* _prpcmsg,

        IRpcChannelBuffer* _pRpcChannelBuffer)
        = 0;

        virtual IRpcStubBuffer* __stdcall IsIIDSupported(

        const IID& riid)
        = 0;

        virtual ULONG __stdcall CountRefs(void) = 0;

        virtual HRESULT __stdcall DebugServerQueryInterface(

        void** ppv)
        = 0;

        virtual void __stdcall DebugServerRelease(

        void* pv)
        = 0;
    };

    extern "C" const IID IID_IPSFactoryBuffer;

    struct __declspec(uuid("D5F569D0-593B-101A-B569-08002B2DBF7A")) __declspec(novtable) IPSFactoryBuffer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateProxy(

        IUnknown* pUnkOuter,

        const IID& riid,

        IRpcProxyBuffer** ppProxy,

        void** ppv)
        = 0;

        virtual HRESULT __stdcall CreateStub(

        const IID& riid,

        IUnknown* pUnkServer,

        IRpcStubBuffer** ppStub)
        = 0;
    };

#pragma endregion
#pragma region Desktop Family or OneCore Family

    typedef struct SChannelHookCallInfo
    {
        IID iid;
        DWORD cbSize;
        GUID uCausality;
        DWORD dwServerPid;
        DWORD iMethod;
        void* pObject;
    } SChannelHookCallInfo;

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0022_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0022_v0_0_s_ifspec;

    extern "C" const IID IID_IChannelHook;

    struct __declspec(uuid("1008c4a0-7613-11cf-9af1-0020af6e72f4")) __declspec(novtable) IChannelHook : public IUnknown
    {
    public:
        virtual void __stdcall ClientGetSize(

        const GUID& uExtent,

        const IID& riid,

        ULONG* pDataSize)
        = 0;

        virtual void __stdcall ClientFillBuffer(

        const GUID& uExtent,

        const IID& riid,

        ULONG* pDataSize,

        void* pDataBuffer)
        = 0;

        virtual void __stdcall ClientNotify(

        const GUID& uExtent,

        const IID& riid,

        ULONG cbDataSize,

        void* pDataBuffer,

        DWORD lDataRep,

        HRESULT hrFault)
        = 0;

        virtual void __stdcall ServerNotify(

        const GUID& uExtent,

        const IID& riid,

        ULONG cbDataSize,

        void* pDataBuffer,

        DWORD lDataRep)
        = 0;

        virtual void __stdcall ServerGetSize(

        const GUID& uExtent,

        const IID& riid,

        HRESULT hrFault,

        ULONG* pDataSize)
        = 0;

        virtual void __stdcall ServerFillBuffer(

        const GUID& uExtent,

        const IID& riid,

        ULONG* pDataSize,

        void* pDataBuffer,

        HRESULT hrFault)
        = 0;
    };

#pragma endregion

#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0023_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0023_v0_0_s_ifspec;

    typedef struct tagSOLE_AUTHENTICATION_SERVICE
    {
        DWORD dwAuthnSvc;
        DWORD dwAuthzSvc;
        OLECHAR* pPrincipalName;
        HRESULT hr;
    } SOLE_AUTHENTICATION_SERVICE;

    typedef SOLE_AUTHENTICATION_SERVICE* PSOLE_AUTHENTICATION_SERVICE;

    typedef enum tagEOLE_AUTHENTICATION_CAPABILITIES
    {
        EOAC_NONE = 0,
        EOAC_MUTUAL_AUTH = 0x1,
        EOAC_STATIC_CLOAKING = 0x20,
        EOAC_DYNAMIC_CLOAKING = 0x40,
        EOAC_ANY_AUTHORITY = 0x80,
        EOAC_MAKE_FULLSIC = 0x100,
        EOAC_DEFAULT = 0x800,
        EOAC_SECURE_REFS = 0x2,
        EOAC_ACCESS_CONTROL = 0x4,
        EOAC_APPID = 0x8,
        EOAC_DYNAMIC = 0x10,
        EOAC_REQUIRE_FULLSIC = 0x200,
        EOAC_AUTO_IMPERSONATE = 0x400,
        EOAC_DISABLE_AAA = 0x1000,
        EOAC_NO_CUSTOM_MARSHAL = 0x2000,
        EOAC_RESERVED1 = 0x4000
    } EOLE_AUTHENTICATION_CAPABILITIES;

    typedef struct tagSOLE_AUTHENTICATION_INFO
    {
        DWORD dwAuthnSvc;
        DWORD dwAuthzSvc;
        void* pAuthInfo;
    } SOLE_AUTHENTICATION_INFO;

    typedef struct tagSOLE_AUTHENTICATION_INFO* PSOLE_AUTHENTICATION_INFO;

    typedef struct tagSOLE_AUTHENTICATION_LIST
    {
        DWORD cAuthInfo;
        SOLE_AUTHENTICATION_INFO* aAuthInfo;
    } SOLE_AUTHENTICATION_LIST;

    typedef struct tagSOLE_AUTHENTICATION_LIST* PSOLE_AUTHENTICATION_LIST;

    extern "C" const IID IID_IClientSecurity;

    struct __declspec(uuid("0000013D-0000-0000-C000-000000000046")) __declspec(novtable) IClientSecurity : public IUnknown
    {
    public:
        virtual HRESULT __stdcall QueryBlanket(

        IUnknown* pProxy,

        DWORD* pAuthnSvc,

        DWORD* pAuthzSvc,

        OLECHAR** pServerPrincName,

        DWORD* pAuthnLevel,

        DWORD* pImpLevel,

        void** pAuthInfo,

        DWORD* pCapabilites)
        = 0;

        virtual HRESULT __stdcall SetBlanket(

        IUnknown* pProxy,

        DWORD dwAuthnSvc,

        DWORD dwAuthzSvc,

        OLECHAR* pServerPrincName,

        DWORD dwAuthnLevel,

        DWORD dwImpLevel,

        void* pAuthInfo,

        DWORD dwCapabilities)
        = 0;

        virtual HRESULT __stdcall CopyProxy(

        IUnknown* pProxy,

        IUnknown** ppCopy)
        = 0;
    };

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0024_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0024_v0_0_s_ifspec;

    extern "C" const IID IID_IServerSecurity;

    struct __declspec(uuid("0000013E-0000-0000-C000-000000000046")) __declspec(novtable) IServerSecurity : public IUnknown
    {
    public:
        virtual HRESULT __stdcall QueryBlanket(

        DWORD* pAuthnSvc,

        DWORD* pAuthzSvc,

        OLECHAR** pServerPrincName,

        DWORD* pAuthnLevel,

        DWORD* pImpLevel,

        void** pPrivs,

        DWORD* pCapabilities)
        = 0;

        virtual HRESULT __stdcall ImpersonateClient(void) = 0;

        virtual HRESULT __stdcall RevertToSelf(void) = 0;

        virtual BOOL __stdcall IsImpersonating(void) = 0;
    };

    typedef enum tagRPCOPT_PROPERTIES
    {
        COMBND_RPCTIMEOUT = 0x1,
        COMBND_SERVER_LOCALITY = 0x2,
        COMBND_RESERVED1 = 0x4,
        COMBND_RESERVED2 = 0x5,
        COMBND_RESERVED3 = 0x8,
        COMBND_RESERVED4 = 0x10
    } RPCOPT_PROPERTIES;

    typedef enum tagRPCOPT_SERVER_LOCALITY_VALUES
    {
        SERVER_LOCALITY_PROCESS_LOCAL = 0,
        SERVER_LOCALITY_MACHINE_LOCAL = 1,
        SERVER_LOCALITY_REMOTE = 2
    } RPCOPT_SERVER_LOCALITY_VALUES;

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0025_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0025_v0_0_s_ifspec;

    extern "C" const IID IID_IRpcOptions;

    struct __declspec(uuid("00000144-0000-0000-C000-000000000046")) __declspec(novtable) IRpcOptions : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Set(

        IUnknown* pPrx,

        RPCOPT_PROPERTIES dwProperty,

        ULONG_PTR dwValue)
        = 0;

        virtual HRESULT __stdcall Query(

        IUnknown* pPrx,

        RPCOPT_PROPERTIES dwProperty,

        ULONG_PTR* pdwValue)
        = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    typedef enum tagGLOBALOPT_PROPERTIES
    {
        COMGLB_EXCEPTION_HANDLING = 1,
        COMGLB_APPID = 2,
        COMGLB_RPC_THREADPOOL_SETTING = 3,
        COMGLB_RO_SETTINGS = 4,
        COMGLB_UNMARSHALING_POLICY = 5,
        COMGLB_PROPERTIES_RESERVED1 = 6,
        COMGLB_PROPERTIES_RESERVED2 = 7,
        COMGLB_PROPERTIES_RESERVED3 = 8
    } GLOBALOPT_PROPERTIES;

    typedef enum tagGLOBALOPT_EH_VALUES
    {
        COMGLB_EXCEPTION_HANDLE = 0,
        COMGLB_EXCEPTION_DONOT_HANDLE_FATAL = 1,
        COMGLB_EXCEPTION_DONOT_HANDLE = COMGLB_EXCEPTION_DONOT_HANDLE_FATAL,
        COMGLB_EXCEPTION_DONOT_HANDLE_ANY = 2
    } GLOBALOPT_EH_VALUES;

    typedef enum tagGLOBALOPT_RPCTP_VALUES
    {
        COMGLB_RPC_THREADPOOL_SETTING_DEFAULT_POOL = 0,
        COMGLB_RPC_THREADPOOL_SETTING_PRIVATE_POOL = 1
    } GLOBALOPT_RPCTP_VALUES;

    typedef enum tagGLOBALOPT_RO_FLAGS
    {
        COMGLB_STA_MODALLOOP_REMOVE_TOUCH_MESSAGES = 0x1,
        COMGLB_STA_MODALLOOP_SHARED_QUEUE_REMOVE_INPUT_MESSAGES = 0x2,
        COMGLB_STA_MODALLOOP_SHARED_QUEUE_DONOT_REMOVE_INPUT_MESSAGES = 0x4,
        COMGLB_FAST_RUNDOWN = 0x8,
        COMGLB_RESERVED1 = 0x10,
        COMGLB_RESERVED2 = 0x20,
        COMGLB_RESERVED3 = 0x40,
        COMGLB_STA_MODALLOOP_SHARED_QUEUE_REORDER_POINTER_MESSAGES = 0x80,
        COMGLB_RESERVED4 = 0x100,
        COMGLB_RESERVED5 = 0x200,
        COMGLB_RESERVED6 = 0x400
    } GLOBALOPT_RO_FLAGS;

    typedef enum tagGLOBALOPT_UNMARSHALING_POLICY_VALUES
    {
        COMGLB_UNMARSHALING_POLICY_NORMAL = 0,
        COMGLB_UNMARSHALING_POLICY_STRONG = 1,
        COMGLB_UNMARSHALING_POLICY_HYBRID = 2
    } GLOBALOPT_UNMARSHALING_POLICY_VALUES;

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0026_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0026_v0_0_s_ifspec;

    extern "C" const IID IID_IGlobalOptions;

    struct __declspec(uuid("0000015B-0000-0000-C000-000000000046")) __declspec(novtable) IGlobalOptions : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Set(

        GLOBALOPT_PROPERTIES dwProperty,

        ULONG_PTR dwValue)
        = 0;

        virtual HRESULT __stdcall Query(

        GLOBALOPT_PROPERTIES dwProperty,

        ULONG_PTR* pdwValue)
        = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0027_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0027_v0_0_s_ifspec;

    typedef ISurrogate* LPSURROGATE;

    extern "C" const IID IID_ISurrogate;

    struct __declspec(uuid("00000022-0000-0000-C000-000000000046")) __declspec(novtable) ISurrogate : public IUnknown
    {
    public:
        virtual HRESULT __stdcall LoadDllServer(const IID& Clsid) = 0;

        virtual HRESULT __stdcall FreeSurrogate(void) = 0;
    };

    typedef IGlobalInterfaceTable* LPGLOBALINTERFACETABLE;

    extern "C" const IID IID_IGlobalInterfaceTable;

    struct __declspec(uuid("00000146-0000-0000-C000-000000000046")) __declspec(novtable) IGlobalInterfaceTable : public IUnknown
    {
    public:
        virtual HRESULT __stdcall RegisterInterfaceInGlobal(

        IUnknown* pUnk,

        const IID& riid,

        DWORD* pdwCookie)
        = 0;

        virtual HRESULT __stdcall RevokeInterfaceFromGlobal(

        DWORD dwCookie)
        = 0;

        virtual HRESULT __stdcall GetInterfaceFromGlobal(

        DWORD dwCookie,

        const IID& riid,

        void** ppv)
        = 0;
    };

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0029_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0029_v0_0_s_ifspec;

    extern "C" const IID IID_ISynchronize;

    struct __declspec(uuid("00000030-0000-0000-C000-000000000046")) __declspec(novtable) ISynchronize : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Wait(DWORD dwFlags, DWORD dwMilliseconds) = 0;

        virtual HRESULT __stdcall Signal(void) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;
    };

    extern "C" const IID IID_ISynchronizeHandle;

    struct __declspec(uuid("00000031-0000-0000-C000-000000000046")) __declspec(novtable) ISynchronizeHandle : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetHandle(

        HANDLE* ph)
        = 0;
    };

    extern "C" const IID IID_ISynchronizeEvent;

    struct __declspec(uuid("00000032-0000-0000-C000-000000000046")) __declspec(novtable) ISynchronizeEvent : public ISynchronizeHandle
    {
    public:
        virtual HRESULT __stdcall SetEventHandle(

        HANDLE* ph)
        = 0;
    };

    extern "C" const IID IID_ISynchronizeContainer;

    struct __declspec(uuid("00000033-0000-0000-C000-000000000046")) __declspec(novtable) ISynchronizeContainer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall AddSynchronize(

        ISynchronize* pSync)
        = 0;

        virtual HRESULT __stdcall WaitMultiple(

        DWORD dwFlags,

        DWORD dwTimeOut,

        ISynchronize** ppSync)
        = 0;
    };

    extern "C" const IID IID_ISynchronizeMutex;

    struct __declspec(uuid("00000025-0000-0000-C000-000000000046")) __declspec(novtable) ISynchronizeMutex : public ISynchronize
    {
    public:
        virtual HRESULT __stdcall ReleaseMutex(void) = 0;
    };

    typedef ICancelMethodCalls* LPCANCELMETHODCALLS;

    extern "C" const IID IID_ICancelMethodCalls;

    struct __declspec(uuid("00000029-0000-0000-C000-000000000046")) __declspec(novtable) ICancelMethodCalls : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Cancel(

        ULONG ulSeconds)
        = 0;

        virtual HRESULT __stdcall TestCancel(void) = 0;
    };

    typedef enum tagDCOM_CALL_STATE
    {
        DCOM_NONE = 0,
        DCOM_CALL_COMPLETE = 0x1,
        DCOM_CALL_CANCELED = 0x2
    } DCOM_CALL_STATE;

    extern "C" const IID IID_IAsyncManager;

    struct __declspec(uuid("0000002A-0000-0000-C000-000000000046")) __declspec(novtable) IAsyncManager : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CompleteCall(

        HRESULT Result)
        = 0;

        virtual HRESULT __stdcall GetCallContext(

        const IID& riid,

        void** pInterface)
        = 0;

        virtual HRESULT __stdcall GetState(

        ULONG* pulStateFlags)
        = 0;
    };

    extern "C" const IID IID_ICallFactory;

    struct __declspec(uuid("1c733a30-2a1c-11ce-ade5-00aa0044773d")) __declspec(novtable) ICallFactory : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateCall(

        const IID& riid,

        IUnknown* pCtrlUnk,

        const IID& riid2,

        IUnknown** ppv)
        = 0;
    };

    extern "C" const IID IID_IRpcHelper;

    struct __declspec(uuid("00000149-0000-0000-C000-000000000046")) __declspec(novtable) IRpcHelper : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetDCOMProtocolVersion(

        DWORD* pComVersion)
        = 0;

        virtual HRESULT __stdcall GetIIDFromOBJREF(

        void* pObjRef,

        IID** piid)
        = 0;
    };

    extern "C" const IID IID_IReleaseMarshalBuffers;

    struct __declspec(uuid("eb0cb9e8-7996-11d2-872e-0000f8080859")) __declspec(novtable) IReleaseMarshalBuffers : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ReleaseMarshalBuffer(

        RPCOLEMESSAGE* pMsg,

        DWORD dwFlags,

        IUnknown* pChnl)
        = 0;
    };

    extern "C" const IID IID_IWaitMultiple;

    struct __declspec(uuid("0000002B-0000-0000-C000-000000000046")) __declspec(novtable) IWaitMultiple : public IUnknown
    {
    public:
        virtual HRESULT __stdcall WaitMultiple(

        DWORD timeout,

        ISynchronize** pSync)
        = 0;

        virtual HRESULT __stdcall AddSynchronize(

        ISynchronize* pSync)
        = 0;
    };

    typedef IAddrTrackingControl* LPADDRTRACKINGCONTROL;

    extern "C" const IID IID_IAddrTrackingControl;

    struct __declspec(uuid("00000147-0000-0000-C000-000000000046")) __declspec(novtable) IAddrTrackingControl : public IUnknown
    {
    public:
        virtual HRESULT __stdcall EnableCOMDynamicAddrTracking(void) = 0;

        virtual HRESULT __stdcall DisableCOMDynamicAddrTracking(void) = 0;
    };

    typedef IAddrExclusionControl* LPADDREXCLUSIONCONTROL;

    extern "C" const IID IID_IAddrExclusionControl;

    struct __declspec(uuid("00000148-0000-0000-C000-000000000046")) __declspec(novtable) IAddrExclusionControl : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetCurrentAddrExclusionList(

        const IID& riid,

        void** ppEnumerator)
        = 0;

        virtual HRESULT __stdcall UpdateAddrExclusionList(

        IUnknown* pEnumerator)
        = 0;
    };

    extern "C" const IID IID_IPipeByte;

    struct __declspec(uuid("DB2F3ACA-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable) IPipeByte : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Pull(BYTE* buf, ULONG cRequest, ULONG* pcReturned) = 0;

        virtual HRESULT __stdcall Push(BYTE* buf, ULONG cSent) = 0;
    };

    extern "C" const IID IID_AsyncIPipeByte;

    struct __declspec(uuid("DB2F3ACB-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable) AsyncIPipeByte : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Begin_Pull(ULONG cRequest) = 0;

        virtual HRESULT __stdcall Finish_Pull(BYTE* buf, ULONG* pcReturned) = 0;

        virtual HRESULT __stdcall Begin_Push(BYTE* buf, ULONG cSent) = 0;

        virtual HRESULT __stdcall Finish_Push(void) = 0;
    };

    extern "C" const IID IID_IPipeLong;

    struct __declspec(uuid("DB2F3ACC-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable) IPipeLong : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Pull(LONG* buf, ULONG cRequest, ULONG* pcReturned) = 0;

        virtual HRESULT __stdcall Push(LONG* buf, ULONG cSent) = 0;
    };

    extern "C" const IID IID_AsyncIPipeLong;

    struct __declspec(uuid("DB2F3ACD-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable) AsyncIPipeLong : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Begin_Pull(ULONG cRequest) = 0;

        virtual HRESULT __stdcall Finish_Pull(LONG* buf, ULONG* pcReturned) = 0;

        virtual HRESULT __stdcall Begin_Push(LONG* buf, ULONG cSent) = 0;

        virtual HRESULT __stdcall Finish_Push(void) = 0;
    };

    extern "C" const IID IID_IPipeDouble;

    struct __declspec(uuid("DB2F3ACE-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable) IPipeDouble : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Pull(DOUBLE* buf, ULONG cRequest, ULONG* pcReturned) = 0;

        virtual HRESULT __stdcall Push(DOUBLE* buf, ULONG cSent) = 0;
    };

    extern "C" const IID IID_AsyncIPipeDouble;

    struct __declspec(uuid("DB2F3ACF-2F86-11d1-8E04-00C04FB9989A")) __declspec(novtable) AsyncIPipeDouble : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Begin_Pull(ULONG cRequest) = 0;

        virtual HRESULT __stdcall Finish_Pull(DOUBLE* buf, ULONG* pcReturned) = 0;

        virtual HRESULT __stdcall Begin_Push(DOUBLE* buf, ULONG cSent) = 0;

        virtual HRESULT __stdcall Finish_Push(void) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    typedef enum _APTTYPEQUALIFIER
    {
        APTTYPEQUALIFIER_NONE = 0,
        APTTYPEQUALIFIER_IMPLICIT_MTA = 1,
        APTTYPEQUALIFIER_NA_ON_MTA = 2,
        APTTYPEQUALIFIER_NA_ON_STA = 3,
        APTTYPEQUALIFIER_NA_ON_IMPLICIT_MTA = 4,
        APTTYPEQUALIFIER_NA_ON_MAINSTA = 5,
        APTTYPEQUALIFIER_APPLICATION_STA = 6,
        APTTYPEQUALIFIER_RESERVED_1 = 7
    } APTTYPEQUALIFIER;

    typedef enum _APTTYPE
    {
        APTTYPE_CURRENT = -1,
        APTTYPE_STA = 0,
        APTTYPE_MTA = 1,
        APTTYPE_NA = 2,
        APTTYPE_MAINSTA = 3
    } APTTYPE;

#pragma endregion
#pragma region Desktop Family or OneCore Family

    typedef enum _THDTYPE
    {
        THDTYPE_BLOCKMESSAGES = 0,
        THDTYPE_PROCESSMESSAGES = 1
    } THDTYPE;

    typedef DWORD APARTMENTID;

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0048_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0048_v0_0_s_ifspec;

    extern "C" const IID IID_IComThreadingInfo;

    struct __declspec(uuid("000001ce-0000-0000-C000-000000000046")) __declspec(novtable) IComThreadingInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetCurrentApartmentType(

        APTTYPE* pAptType)
        = 0;

        virtual HRESULT __stdcall GetCurrentThreadType(

        THDTYPE* pThreadType)
        = 0;

        virtual HRESULT __stdcall GetCurrentLogicalThreadId(

        GUID* pguidLogicalThreadId)
        = 0;

        virtual HRESULT __stdcall SetCurrentLogicalThreadId(

        const GUID& rguid)
        = 0;
    };

    extern "C" const IID IID_IProcessInitControl;

    struct __declspec(uuid("72380d55-8d2b-43a3-8513-2b6ef31434e9")) __declspec(novtable) IProcessInitControl : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ResetInitializerTimeout(DWORD dwSecondsRemaining) = 0;
    };

    extern "C" const IID IID_IFastRundown;

    struct __declspec(uuid("00000040-0000-0000-C000-000000000046")) __declspec(novtable) IFastRundown : public IUnknown
    {
    public:
    };

    typedef enum CO_MARSHALING_CONTEXT_ATTRIBUTES
    {
        CO_MARSHALING_SOURCE_IS_APP_CONTAINER = 0,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_1 = 0x80000000,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_2 = 0x80000001,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_3 = 0x80000002,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_4 = 0x80000003,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_5 = 0x80000004,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_6 = 0x80000005,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_7 = 0x80000006,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_8 = 0x80000007,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_9 = 0x80000008,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_10 = 0x80000009,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_11 = 0x8000000a,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_12 = 0x8000000b,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_13 = 0x8000000c,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_14 = 0x8000000d,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_15 = 0x8000000e,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_16 = 0x8000000f,
        CO_MARSHALING_CONTEXT_ATTRIBUTE_RESERVED_17 = 0x80000010
    } CO_MARSHALING_CONTEXT_ATTRIBUTES;

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0051_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0051_v0_0_s_ifspec;

    extern "C" const IID IID_IMarshalingStream;

    struct __declspec(uuid("D8F2F5E6-6102-4863-9F26-389A4676EFDE")) __declspec(novtable) IMarshalingStream : public IStream
    {
    public:
        virtual HRESULT __stdcall GetMarshalingContextAttribute(CO_MARSHALING_CONTEXT_ATTRIBUTES attribute, ULONG_PTR* pAttributeValue)
        = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0052_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0052_v0_0_s_ifspec;

    extern "C" const IID IID_IAgileReference;
    extern "C++"
    {
        struct __declspec(uuid("C03F6A43-65A4-9818-987E-E0B810D2A6F2")) __declspec(novtable) IAgileReference : public IUnknown
        {
        public:
            virtual HRESULT __stdcall Resolve(const IID& riid, void** ppvObjectReference) = 0;

            template <class Q>
            HRESULT

            __stdcall Resolve(Q** pp)
            {
                return Resolve(__uuidof(Q), (void**)pp);
            }
        };
    }

#pragma endregion
#pragma region Application Family or OneCore Family

    extern "C" const GUID IID_ICallbackWithNoReentrancyToApplicationSTA;
#pragma endregion

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0053_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidlbase_0000_0053_v0_0_s_ifspec;

    HRESULT __stdcall IEnumUnknown_Next_Proxy(IEnumUnknown* This,

                                              ULONG celt,

                                              IUnknown** rgelt,

                                              ULONG* pceltFetched);

    HRESULT __stdcall IEnumUnknown_Next_Stub(IEnumUnknown* This, ULONG celt, IUnknown** rgelt, ULONG* pceltFetched);

    HRESULT __stdcall IEnumString_Next_Proxy(IEnumString* This,
                                             ULONG celt,

                                             LPOLESTR* rgelt,

                                             ULONG* pceltFetched);

    HRESULT __stdcall IEnumString_Next_Stub(IEnumString* This, ULONG celt, LPOLESTR* rgelt, ULONG* pceltFetched);

    HRESULT __stdcall ISequentialStream_Read_Proxy(ISequentialStream* This,

                                                   void* pv,

                                                   ULONG cb,

                                                   ULONG* pcbRead);

    HRESULT __stdcall ISequentialStream_Read_Stub(ISequentialStream* This, byte* pv, ULONG cb, ULONG* pcbRead);

    HRESULT __stdcall ISequentialStream_Write_Proxy(ISequentialStream* This,

                                                    const void* pv,

                                                    ULONG cb,

                                                    ULONG* pcbWritten);

    HRESULT __stdcall ISequentialStream_Write_Stub(ISequentialStream* This, const byte* pv, ULONG cb, ULONG* pcbWritten);

    HRESULT __stdcall IStream_Seek_Proxy(IStream* This,
                                         LARGE_INTEGER dlibMove,
                                         DWORD dwOrigin,

                                         ULARGE_INTEGER* plibNewPosition);

    HRESULT __stdcall IStream_Seek_Stub(IStream* This, LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition);

    HRESULT __stdcall IStream_CopyTo_Proxy(IStream* This,

                                           IStream* pstm,
                                           ULARGE_INTEGER cb,

                                           ULARGE_INTEGER* pcbRead,

                                           ULARGE_INTEGER* pcbWritten);

    HRESULT __stdcall IStream_CopyTo_Stub(IStream* This, IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead, ULARGE_INTEGER* pcbWritten);
}

#pragma once

#pragma warning(push)
#pragma warning(disable : 4001)

extern "C"
{
#pragma region Application Family

    extern const IID GUID_NULL;

#pragma endregion

#pragma region Desktop Family

    extern const IID CATID_MARSHALER;

    extern const IID IID_IRpcChannel;
    extern const IID IID_IRpcStub;
    extern const IID IID_IStubManager;
    extern const IID IID_IRpcProxy;
    extern const IID IID_IProxyManager;
    extern const IID IID_IPSFactory;
    extern const IID IID_IInternalMoniker;
    extern const IID IID_IDfReserved1;
    extern const IID IID_IDfReserved2;
    extern const IID IID_IDfReserved3;
    extern const CLSID CLSID_StdMarshal;
    extern const CLSID CLSID_AggStdMarshal;
    extern const CLSID CLSID_StdAsyncActManager;
    extern const IID IID_IStub;
    extern const IID IID_IProxy;
    extern const IID IID_IEnumGeneric;
    extern const IID IID_IEnumHolder;
    extern const IID IID_IEnumCallback;
    extern const IID IID_IOleManager;
    extern const IID IID_IOlePresObj;
    extern const IID IID_IDebug;
    extern const IID IID_IDebugStream;
    extern const CLSID CLSID_PSGenObject;
    extern const CLSID CLSID_PSClientSite;
    extern const CLSID CLSID_PSClassObject;
    extern const CLSID CLSID_PSInPlaceActive;
    extern const CLSID CLSID_PSInPlaceFrame;
    extern const CLSID CLSID_PSDragDrop;
    extern const CLSID CLSID_PSBindCtx;
    extern const CLSID CLSID_PSEnumerators;
    extern const CLSID CLSID_StaticMetafile;
    extern const CLSID CLSID_StaticDib;
    extern const CLSID CID_CDfsVolume;
    extern const CLSID CLSID_DCOMAccessControl;

#pragma endregion

#pragma region Application Family or OneCore Family

    extern const CLSID CLSID_GlobalOptions;
    extern const CLSID CLSID_StdGlobalInterfaceTable;

#pragma endregion

#pragma region Desktop Family

    extern const CLSID CLSID_ComBinding;
    extern const CLSID CLSID_StdEvent;
    extern const CLSID CLSID_ManualResetEvent;
    extern const CLSID CLSID_SynchronizeContainer;

    extern const CLSID CLSID_AddrControl;

    extern const CLSID CLSID_ContextSwitcher;

    extern const CLSID CLSID_CCDFormKrnl;
    extern const CLSID CLSID_CCDPropertyPage;
    extern const CLSID CLSID_CCDFormDialog;

    extern const CLSID CLSID_CCDCommandButton;
    extern const CLSID CLSID_CCDComboBox;
    extern const CLSID CLSID_CCDTextBox;
    extern const CLSID CLSID_CCDCheckBox;
    extern const CLSID CLSID_CCDLabel;
    extern const CLSID CLSID_CCDOptionButton;
    extern const CLSID CLSID_CCDListBox;
    extern const CLSID CLSID_CCDScrollBar;
    extern const CLSID CLSID_CCDGroupBox;

    extern const CLSID CLSID_CCDGeneralPropertyPage;
    extern const CLSID CLSID_CCDGenericPropertyPage;
    extern const CLSID CLSID_CCDFontPropertyPage;
    extern const CLSID CLSID_CCDColorPropertyPage;
    extern const CLSID CLSID_CCDLabelPropertyPage;
    extern const CLSID CLSID_CCDCheckBoxPropertyPage;
    extern const CLSID CLSID_CCDTextBoxPropertyPage;
    extern const CLSID CLSID_CCDOptionButtonPropertyPage;
    extern const CLSID CLSID_CCDListBoxPropertyPage;
    extern const CLSID CLSID_CCDCommandButtonPropertyPage;
    extern const CLSID CLSID_CCDComboBoxPropertyPage;
    extern const CLSID CLSID_CCDScrollBarPropertyPage;
    extern const CLSID CLSID_CCDGroupBoxPropertyPage;
    extern const CLSID CLSID_CCDXObjectPropertyPage;

    extern const CLSID CLSID_CStdPropertyFrame;

    extern const CLSID CLSID_CFormPropertyPage;
    extern const CLSID CLSID_CGridPropertyPage;

    extern const CLSID CLSID_CWSJArticlePage;
    extern const CLSID CLSID_CSystemPage;
    extern const CLSID CLSID_IdentityUnmarshal;

#pragma endregion

#pragma region Application Family

    extern const CLSID CLSID_InProcFreeMarshaler;

#pragma endregion

#pragma region Desktop Family

    extern const CLSID CLSID_Picture_Metafile;
    extern const CLSID CLSID_Picture_EnhMetafile;
    extern const CLSID CLSID_Picture_Dib;

    extern const GUID GUID_TRISTATE;

#pragma endregion
}

#pragma warning(pop)

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetMalloc(DWORD dwMemContext, LPMALLOC* ppMalloc);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CreateStreamOnHGlobal(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPSTREAM* ppstm);

extern "C" __declspec(dllimport) HRESULT __stdcall GetHGlobalFromStream(LPSTREAM pstm, HGLOBAL* phglobal);

extern "C" __declspec(dllimport) void __stdcall CoUninitialize(void);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) DWORD __stdcall CoGetCurrentProcess(void);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoInitializeEx(LPVOID pvReserved, DWORD dwCoInit);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetCallerTID(LPDWORD lpdwTID);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetCurrentLogicalThreadId(GUID* pguid);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetContextToken(ULONG_PTR* pToken);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetDefaultContext(APTTYPE aptType, const IID& riid, void** ppv);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetApartmentType(APTTYPE* pAptType, APTTYPEQUALIFIER* pAptQualifier);

#pragma endregion

#pragma region Application or OneCore Family

typedef struct tagServerInformation
{
    DWORD dwServerPid;
    DWORD dwServerTid;
    UINT64 ui64ServerAddress;
} ServerInformation, *PServerInformation;

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall CoDecodeProxy(DWORD dwClientPid, UINT64 ui64ProxyAddress, PServerInformation pServerInformation);

#pragma endregion

#pragma region Application or OneCore Family

struct CO_MTA_USAGE_COOKIE__
{
    int unused;
};
typedef struct CO_MTA_USAGE_COOKIE__* CO_MTA_USAGE_COOKIE;

extern "C" __declspec(dllimport) HRESULT __stdcall CoIncrementMTAUsage(CO_MTA_USAGE_COOKIE* pCookie);

extern "C" __declspec(dllimport) HRESULT __stdcall CoDecrementMTAUsage(CO_MTA_USAGE_COOKIE Cookie);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoAllowUnmarshalerCLSID(const IID& clsid);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetObjectContext(const IID& riid, LPVOID* ppv);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall CoGetClassObject(const IID& rclsid, DWORD dwClsContext, LPVOID pvReserved, const IID& riid, LPVOID* ppv);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall CoRegisterClassObject(const IID& rclsid, LPUNKNOWN pUnk, DWORD dwClsContext, DWORD flags, LPDWORD lpdwRegister);

extern "C" __declspec(dllimport) HRESULT __stdcall CoRevokeClassObject(DWORD dwRegister);

extern "C" __declspec(dllimport) HRESULT __stdcall CoResumeClassObjects(void);

extern "C" __declspec(dllimport) HRESULT __stdcall CoSuspendClassObjects(void);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) ULONG __stdcall CoAddRefServerProcess(void);

extern "C" __declspec(dllimport) ULONG __stdcall CoReleaseServerProcess(void);

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetPSClsid(const IID& riid, CLSID* pClsid);

extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterPSClsid(const IID& riid, const IID& rclsid);

extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterSurrogate(LPSURROGATE pSurrogate);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall CoGetMarshalSizeMax(ULONG* pulSize, const IID& riid, LPUNKNOWN pUnk, DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);

extern "C" __declspec(dllimport) HRESULT
__stdcall CoMarshalInterface(LPSTREAM pStm, const IID& riid, LPUNKNOWN pUnk, DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags);

extern "C" __declspec(dllimport) HRESULT __stdcall CoUnmarshalInterface(LPSTREAM pStm, const IID& riid, LPVOID* ppv);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoMarshalHresult(LPSTREAM pstm, HRESULT hresult);

extern "C" __declspec(dllimport) HRESULT __stdcall CoUnmarshalHresult(LPSTREAM pstm, HRESULT* phresult);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoReleaseMarshalData(LPSTREAM pStm);

extern "C" __declspec(dllimport) HRESULT __stdcall CoDisconnectObject(LPUNKNOWN pUnk, DWORD dwReserved);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoLockObjectExternal(LPUNKNOWN pUnk, BOOL fLock, BOOL fLastUnlockReleases);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall CoGetStandardMarshal(const IID& riid, LPUNKNOWN pUnk, DWORD dwDestContext, LPVOID pvDestContext, DWORD mshlflags, LPMARSHAL* ppMarshal);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetStdMarshalEx(LPUNKNOWN pUnkOuter, DWORD smexflags, LPUNKNOWN* ppUnkInner);

#pragma endregion

#pragma region Application or OneCore Family

typedef enum tagSTDMSHLFLAGS
{
    SMEXF_SERVER = 0x01,
    SMEXF_HANDLER = 0x02
} STDMSHLFLAGS;

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) BOOL __stdcall CoIsHandlerConnected(LPUNKNOWN pUnk);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall CoMarshalInterThreadInterfaceInStream(const IID& riid, LPUNKNOWN pUnk, LPSTREAM* ppStm);

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetInterfaceAndReleaseStream(LPSTREAM pStm, const IID& iid, LPVOID* ppv);

extern "C" __declspec(dllimport) HRESULT __stdcall CoCreateFreeThreadedMarshaler(LPUNKNOWN punkOuter, LPUNKNOWN* ppunkMarshal);

extern "C" __declspec(dllimport) void __stdcall CoFreeUnusedLibraries(void);

extern "C" __declspec(dllimport) void __stdcall CoFreeUnusedLibrariesEx(DWORD dwUnloadDelay, DWORD dwReserved);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoDisconnectContext(DWORD dwTimeout);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoInitializeSecurity(PSECURITY_DESCRIPTOR pSecDesc,
                                                                        LONG cAuthSvc,
                                                                        SOLE_AUTHENTICATION_SERVICE* asAuthSvc,
                                                                        void* pReserved1,
                                                                        DWORD dwAuthnLevel,
                                                                        DWORD dwImpLevel,
                                                                        void* pAuthList,
                                                                        DWORD dwCapabilities,
                                                                        void* pReserved3);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetCallContext(const IID& riid, void** ppInterface);

extern "C" __declspec(dllimport) HRESULT __stdcall CoQueryProxyBlanket(IUnknown* pProxy,
                                                                       DWORD* pwAuthnSvc,
                                                                       DWORD* pAuthzSvc,
                                                                       LPOLESTR* pServerPrincName,
                                                                       DWORD* pAuthnLevel,
                                                                       DWORD* pImpLevel,
                                                                       RPC_AUTH_IDENTITY_HANDLE* pAuthInfo,
                                                                       DWORD* pCapabilites);

extern "C" __declspec(dllimport) HRESULT __stdcall CoSetProxyBlanket(IUnknown* pProxy,
                                                                     DWORD dwAuthnSvc,
                                                                     DWORD dwAuthzSvc,
                                                                     OLECHAR* pServerPrincName,
                                                                     DWORD dwAuthnLevel,
                                                                     DWORD dwImpLevel,
                                                                     RPC_AUTH_IDENTITY_HANDLE pAuthInfo,
                                                                     DWORD dwCapabilities);

extern "C" __declspec(dllimport) HRESULT __stdcall CoCopyProxy(IUnknown* pProxy, IUnknown** ppCopy);

extern "C" __declspec(dllimport) HRESULT __stdcall CoQueryClientBlanket(DWORD* pAuthnSvc,
                                                                        DWORD* pAuthzSvc,
                                                                        LPOLESTR* pServerPrincName,
                                                                        DWORD* pAuthnLevel,
                                                                        DWORD* pImpLevel,
                                                                        RPC_AUTHZ_HANDLE* pPrivs,
                                                                        DWORD* pCapabilities);

extern "C" __declspec(dllimport) HRESULT __stdcall CoImpersonateClient(void);

extern "C" __declspec(dllimport) HRESULT __stdcall CoRevertToSelf(void);

extern "C" __declspec(dllimport) HRESULT
__stdcall CoQueryAuthenticationServices(DWORD* pcAuthSvc, SOLE_AUTHENTICATION_SERVICE** asAuthSvc);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoSwitchCallContext(IUnknown* pNewObject, IUnknown** ppOldObject);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall CoCreateInstance(const IID& rclsid, LPUNKNOWN pUnkOuter, DWORD dwClsContext, const IID& riid, LPVOID* ppv);

extern "C" __declspec(dllimport) HRESULT
__stdcall CoCreateInstanceEx(const IID& Clsid, IUnknown* punkOuter, DWORD dwClsCtx, COSERVERINFO* pServerInfo, DWORD dwCount, MULTI_QI* pResults);

extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterActivationFilter(IActivationFilter* pActivationFilter);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall CoCreateInstanceFromApp(const IID& Clsid, IUnknown* punkOuter, DWORD dwClsCtx, PVOID reserved, DWORD dwCount, MULTI_QI* pResults);

#pragma endregion

#pragma region Not Desktop or OneCore Family

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetCancelObject(DWORD dwThreadId, const IID& iid, void** ppUnk);

extern "C" __declspec(dllimport) HRESULT __stdcall CoSetCancelObject(IUnknown* pUnk);

extern "C" __declspec(dllimport) HRESULT __stdcall CoCancelCall(DWORD dwThreadId, ULONG ulTimeout);

extern "C" __declspec(dllimport) HRESULT __stdcall CoTestCancel(void);

extern "C" __declspec(dllimport) HRESULT __stdcall CoEnableCallCancellation(LPVOID pReserved);

extern "C" __declspec(dllimport) HRESULT __stdcall CoDisableCallCancellation(LPVOID pReserved);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall StringFromCLSID(const IID& rclsid, LPOLESTR* lplpsz);

extern "C" __declspec(dllimport) HRESULT __stdcall CLSIDFromString(LPCOLESTR lpsz, LPCLSID pclsid);

extern "C" __declspec(dllimport) HRESULT __stdcall StringFromIID(const IID& rclsid, LPOLESTR* lplpsz);

extern "C" __declspec(dllimport) HRESULT __stdcall IIDFromString(LPCOLESTR lpsz, LPIID lpiid);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall ProgIDFromCLSID(const IID& clsid, LPOLESTR* lplpszProgID);

extern "C" __declspec(dllimport) HRESULT __stdcall CLSIDFromProgID(LPCOLESTR lpszProgID, LPCLSID lpclsid);

#pragma endregion

#pragma region Application or OneCore Family

extern "C" __declspec(dllimport) int __stdcall StringFromGUID2(const GUID& rguid, LPOLESTR lpsz, int cchMax);

extern "C" __declspec(dllimport) HRESULT __stdcall CoCreateGuid(GUID* pguid);

typedef struct tagPROPVARIANT PROPVARIANT;

extern "C" __declspec(dllimport) HRESULT __stdcall PropVariantCopy(PROPVARIANT* pvarDest, const PROPVARIANT* pvarSrc);

extern "C" __declspec(dllimport) HRESULT __stdcall PropVariantClear(PROPVARIANT* pvar);

extern "C" __declspec(dllimport) HRESULT __stdcall FreePropVariantArray(ULONG cVariants, PROPVARIANT* rgvars);

#pragma endregion

#pragma region Desktop or OneCore Family

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall CoWaitForMultipleHandles(DWORD dwFlags, DWORD dwTimeout, ULONG cHandles, LPHANDLE pHandles, LPDWORD lpdwindex);

typedef enum tagCOWAIT_FLAGS
{
    COWAIT_DEFAULT = 0,
    COWAIT_WAITALL = 1,
    COWAIT_ALERTABLE = 2,
    COWAIT_INPUTAVAILABLE = 4,
    COWAIT_DISPATCH_CALLS = 8,
    COWAIT_DISPATCH_WINDOW_MESSAGES = 0x10,
} COWAIT_FLAGS;

typedef enum CWMO_FLAGS
{
    CWMO_DEFAULT = 0,
    CWMO_DISPATCH_CALLS = 1,
    CWMO_DISPATCH_WINDOW_MESSAGES = 2,
} CWMO_FLAGS;

extern "C" __declspec(dllimport) HRESULT
__stdcall CoWaitForMultipleObjects(DWORD dwFlags, DWORD dwTimeout, ULONG cHandles, const HANDLE* pHandles, LPDWORD lpdwindex);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetTreatAsClass(const IID& clsidOld, LPCLSID pClsidNew);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoInvalidateRemoteMachineBindings(LPOLESTR pszMachineName);

#pragma endregion

#pragma region Application or OneCore Family

enum AgileReferenceOptions
{
    AGILEREFERENCE_DEFAULT = 0,
    AGILEREFERENCE_DELAYEDMARSHAL = 1,
};

extern "C" __declspec(dllimport) HRESULT
__stdcall RoGetAgileReference(enum AgileReferenceOptions options, const IID& riid, IUnknown* pUnk, IAgileReference** ppAgileReference);

#pragma endregion

#pragma region Application or OneCore Family

typedef HRESULT(__stdcall* LPFNGETCLASSOBJECT)(const IID&, const IID&, LPVOID*);
typedef HRESULT(__stdcall* LPFNCANUNLOADNOW)(void);

extern "C" HRESULT __stdcall DllGetClassObject(const IID& rclsid, const IID& riid, LPVOID* ppv);

extern "C" HRESULT __stdcall DllCanUnloadNow(void);

extern "C" __declspec(dllimport) LPVOID __stdcall CoTaskMemAlloc(SIZE_T cb);

extern "C" __declspec(dllimport) LPVOID __stdcall CoTaskMemRealloc(LPVOID pv, SIZE_T cb);

extern "C" __declspec(dllimport) void __stdcall CoTaskMemFree(LPVOID pv);

#pragma endregion

#pragma region Desktop or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CoFileTimeNow(FILETIME* lpFileTime);

extern "C" __declspec(dllimport) HRESULT __stdcall CLSIDFromProgIDEx(LPCOLESTR lpszProgID, LPCLSID lpclsid);

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma once

#pragma once

typedef struct IMallocSpy IMallocSpy;

typedef struct IBindCtx IBindCtx;

typedef struct IEnumMoniker IEnumMoniker;

typedef struct IRunnableObject IRunnableObject;

typedef struct IRunningObjectTable IRunningObjectTable;

typedef struct IPersist IPersist;

typedef struct IPersistStream IPersistStream;

typedef struct IMoniker IMoniker;

typedef struct IROTData IROTData;

typedef struct IEnumSTATSTG IEnumSTATSTG;

typedef struct IStorage IStorage;

typedef struct IPersistFile IPersistFile;

typedef struct IPersistStorage IPersistStorage;

typedef struct ILockBytes ILockBytes;

typedef struct IEnumFORMATETC IEnumFORMATETC;

typedef struct IEnumSTATDATA IEnumSTATDATA;

typedef struct IRootStorage IRootStorage;

typedef struct IAdviseSink IAdviseSink;

typedef struct AsyncIAdviseSink AsyncIAdviseSink;

typedef struct IAdviseSink2 IAdviseSink2;

typedef struct AsyncIAdviseSink2 AsyncIAdviseSink2;

typedef struct IDataObject IDataObject;

typedef struct IDataAdviseHolder IDataAdviseHolder;

typedef struct IMessageFilter IMessageFilter;

typedef struct IClassActivator IClassActivator;

typedef struct IFillLockBytes IFillLockBytes;

typedef struct IProgressNotify IProgressNotify;

typedef struct ILayoutStorage ILayoutStorage;

typedef struct IBlockingLock IBlockingLock;

typedef struct ITimeAndNoticeControl ITimeAndNoticeControl;

typedef struct IOplockStorage IOplockStorage;

typedef struct IDirectWriterLock IDirectWriterLock;

typedef struct IUrlMon IUrlMon;

typedef struct IForegroundTransfer IForegroundTransfer;

typedef struct IThumbnailExtractor IThumbnailExtractor;

typedef struct IDummyHICONIncluder IDummyHICONIncluder;

typedef struct IProcessLock IProcessLock;

typedef struct ISurrogateService ISurrogateService;

typedef struct IInitializeSpy IInitializeSpy;

typedef struct IApartmentShutdown IApartmentShutdown;

#pragma once

extern "C"
{
#pragma once

#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0000_v0_0_s_ifspec;

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0001_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0001_v0_0_s_ifspec;

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0002_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0002_v0_0_s_ifspec;

#pragma endregion

    extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0003_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_unknwn_0000_0003_v0_0_s_ifspec;

    HRESULT __stdcall IClassFactory_CreateInstance_Proxy(IClassFactory* This,

                                                         IUnknown* pUnkOuter,

                                                         const IID& riid,

                                                         void** ppvObject);

    HRESULT __stdcall IClassFactory_CreateInstance_Stub(IClassFactory* This, const IID& riid, IUnknown** ppvObject);

    HRESULT __stdcall IClassFactory_LockServer_Proxy(IClassFactory* This, BOOL fLock);

    HRESULT __stdcall IClassFactory_LockServer_Stub(IClassFactory* This, BOOL fLock);
}

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)

#pragma once

#pragma warning(push)

#pragma warning(disable : 4820)
#pragma warning(disable : 4201)

#pragma once

#pragma warning(pop)

#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0053_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0053_v0_0_s_ifspec;

    typedef IMallocSpy* LPMALLOCSPY;

    extern "C" const IID IID_IMallocSpy;

    struct __declspec(uuid("0000001d-0000-0000-C000-000000000046")) __declspec(novtable) IMallocSpy : public IUnknown
    {
    public:
        virtual SIZE_T __stdcall PreAlloc(

        SIZE_T cbRequest)
        = 0;

        virtual void* __stdcall PostAlloc(

        void* pActual)
        = 0;

        virtual void* __stdcall PreFree(

        void* pRequest,

        BOOL fSpyed)
        = 0;

        virtual void __stdcall PostFree(

        BOOL fSpyed)
        = 0;

        virtual SIZE_T __stdcall PreRealloc(

        void* pRequest,

        SIZE_T cbRequest,

        void** ppNewRequest,

        BOOL fSpyed)
        = 0;

        virtual void* __stdcall PostRealloc(

        void* pActual,

        BOOL fSpyed)
        = 0;

        virtual void* __stdcall PreGetSize(

        void* pRequest,

        BOOL fSpyed)
        = 0;

        virtual SIZE_T __stdcall PostGetSize(

        SIZE_T cbActual,

        BOOL fSpyed)
        = 0;

        virtual void* __stdcall PreDidAlloc(

        void* pRequest,

        BOOL fSpyed)
        = 0;

        virtual int __stdcall PostDidAlloc(

        void* pRequest,

        BOOL fSpyed,

        int fActual)
        = 0;

        virtual void __stdcall PreHeapMinimize(void) = 0;

        virtual void __stdcall PostHeapMinimize(void) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0054_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0054_v0_0_s_ifspec;

    typedef IBindCtx* LPBC;

    typedef IBindCtx* LPBINDCTX;

    typedef struct tagBIND_OPTS
    {
        DWORD cbStruct;
        DWORD grfFlags;
        DWORD grfMode;
        DWORD dwTickCountDeadline;
    } BIND_OPTS, *LPBIND_OPTS;

    typedef struct tagBIND_OPTS2 : tagBIND_OPTS
    {
        DWORD dwTrackFlags;
        DWORD dwClassContext;
        LCID locale;
        COSERVERINFO* pServerInfo;
    } BIND_OPTS2, *LPBIND_OPTS2;

    typedef struct tagBIND_OPTS3 : tagBIND_OPTS2
    {
        HWND hwnd;
    } BIND_OPTS3, *LPBIND_OPTS3;

    typedef enum tagBIND_FLAGS
    {
        BIND_MAYBOTHERUSER = 1,
        BIND_JUSTTESTEXISTENCE = 2
    } BIND_FLAGS;

    extern "C" const IID IID_IBindCtx;

    struct __declspec(uuid("0000000e-0000-0000-C000-000000000046")) __declspec(novtable) IBindCtx : public IUnknown
    {
    public:
        virtual HRESULT __stdcall RegisterObjectBound(IUnknown* punk) = 0;

        virtual HRESULT __stdcall RevokeObjectBound(IUnknown* punk) = 0;

        virtual HRESULT __stdcall ReleaseBoundObjects(void) = 0;

        virtual HRESULT __stdcall SetBindOptions(

        BIND_OPTS* pbindopts)
        = 0;

        virtual HRESULT __stdcall GetBindOptions(

        BIND_OPTS* pbindopts)
        = 0;

        virtual HRESULT __stdcall GetRunningObjectTable(IRunningObjectTable** pprot) = 0;

        virtual HRESULT __stdcall RegisterObjectParam(LPOLESTR pszKey, IUnknown* punk) = 0;

        virtual HRESULT __stdcall GetObjectParam(LPOLESTR pszKey, IUnknown** ppunk) = 0;

        virtual HRESULT __stdcall EnumObjectParam(IEnumString** ppenum) = 0;

        virtual HRESULT __stdcall RevokeObjectParam(LPOLESTR pszKey) = 0;
    };

    HRESULT __stdcall IBindCtx_RemoteSetBindOptions_Proxy(IBindCtx* This, BIND_OPTS2* pbindopts);

    void __stdcall IBindCtx_RemoteSetBindOptions_Stub(IRpcStubBuffer* This,
                                                      IRpcChannelBuffer* _pRpcChannelBuffer,
                                                      PRPC_MESSAGE _pRpcMessage,
                                                      DWORD* _pdwStubPhase);

    HRESULT __stdcall IBindCtx_RemoteGetBindOptions_Proxy(IBindCtx* This, BIND_OPTS2* pbindopts);

    void __stdcall IBindCtx_RemoteGetBindOptions_Stub(IRpcStubBuffer* This,
                                                      IRpcChannelBuffer* _pRpcChannelBuffer,
                                                      PRPC_MESSAGE _pRpcMessage,
                                                      DWORD* _pdwStubPhase);

    typedef IEnumMoniker* LPENUMMONIKER;

    extern "C" const IID IID_IEnumMoniker;

    struct __declspec(uuid("00000102-0000-0000-C000-000000000046")) __declspec(novtable) IEnumMoniker : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(ULONG celt,

                                       IMoniker** rgelt,

                                       ULONG* pceltFetched)
        = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumMoniker** ppenum) = 0;
    };

    HRESULT __stdcall IEnumMoniker_RemoteNext_Proxy(IEnumMoniker* This, ULONG celt, IMoniker** rgelt, ULONG* pceltFetched);

    void __stdcall IEnumMoniker_RemoteNext_Stub(IRpcStubBuffer* This,
                                                IRpcChannelBuffer* _pRpcChannelBuffer,
                                                PRPC_MESSAGE _pRpcMessage,
                                                DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0056_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0056_v0_0_s_ifspec;

    typedef IRunnableObject* LPRUNNABLEOBJECT;

    extern "C" const IID IID_IRunnableObject;

    struct __declspec(uuid("00000126-0000-0000-C000-000000000046")) __declspec(novtable) IRunnableObject : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetRunningClass(LPCLSID lpClsid) = 0;

        virtual HRESULT __stdcall Run(LPBINDCTX pbc) = 0;

        virtual BOOL __stdcall IsRunning(void) = 0;

        virtual HRESULT __stdcall LockRunning(BOOL fLock, BOOL fLastUnlockCloses) = 0;

        virtual HRESULT __stdcall SetContainedObject(BOOL fContained) = 0;
    };

    HRESULT __stdcall IRunnableObject_RemoteIsRunning_Proxy(IRunnableObject* This);

    void __stdcall IRunnableObject_RemoteIsRunning_Stub(IRpcStubBuffer* This,
                                                        IRpcChannelBuffer* _pRpcChannelBuffer,
                                                        PRPC_MESSAGE _pRpcMessage,
                                                        DWORD* _pdwStubPhase);

    typedef IRunningObjectTable* LPRUNNINGOBJECTTABLE;

    extern "C" const IID IID_IRunningObjectTable;

    struct __declspec(uuid("00000010-0000-0000-C000-000000000046")) __declspec(novtable) IRunningObjectTable : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Register(DWORD grfFlags, IUnknown* punkObject, IMoniker* pmkObjectName, DWORD* pdwRegister) = 0;

        virtual HRESULT __stdcall Revoke(DWORD dwRegister) = 0;

        virtual HRESULT __stdcall IsRunning(IMoniker* pmkObjectName) = 0;

        virtual HRESULT __stdcall GetObject(IMoniker* pmkObjectName, IUnknown** ppunkObject) = 0;

        virtual HRESULT __stdcall NoteChangeTime(DWORD dwRegister, FILETIME* pfiletime) = 0;

        virtual HRESULT __stdcall GetTimeOfLastChange(IMoniker* pmkObjectName, FILETIME* pfiletime) = 0;

        virtual HRESULT __stdcall EnumRunning(IEnumMoniker** ppenumMoniker) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0058_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0058_v0_0_s_ifspec;

    typedef IPersist* LPPERSIST;

    extern "C" const IID IID_IPersist;

    struct __declspec(uuid("0000010c-0000-0000-C000-000000000046")) __declspec(novtable) IPersist : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetClassID(CLSID* pClassID) = 0;
    };

    typedef IPersistStream* LPPERSISTSTREAM;

    extern "C" const IID IID_IPersistStream;

    struct __declspec(uuid("00000109-0000-0000-C000-000000000046")) __declspec(novtable) IPersistStream : public IPersist
    {
    public:
        virtual HRESULT __stdcall IsDirty(void) = 0;

        virtual HRESULT __stdcall Load(IStream* pStm) = 0;

        virtual HRESULT __stdcall Save(IStream* pStm, BOOL fClearDirty) = 0;

        virtual HRESULT __stdcall GetSizeMax(ULARGE_INTEGER* pcbSize) = 0;
    };

    typedef IMoniker* LPMONIKER;

    typedef enum tagMKSYS
    {
        MKSYS_NONE = 0,
        MKSYS_GENERICCOMPOSITE = 1,
        MKSYS_FILEMONIKER = 2,
        MKSYS_ANTIMONIKER = 3,
        MKSYS_ITEMMONIKER = 4,
        MKSYS_POINTERMONIKER = 5,
        MKSYS_CLASSMONIKER = 7,
        MKSYS_OBJREFMONIKER = 8,
        MKSYS_SESSIONMONIKER = 9,
        MKSYS_LUAMONIKER = 10
    } MKSYS;

    typedef enum tagMKREDUCE
    {
        MKRREDUCE_ONE = (3 << 16),
        MKRREDUCE_TOUSER = (2 << 16),
        MKRREDUCE_THROUGHUSER = (1 << 16),
        MKRREDUCE_ALL = 0
    } MKRREDUCE;

    extern "C" const IID IID_IMoniker;

    struct __declspec(uuid("0000000f-0000-0000-C000-000000000046")) __declspec(novtable) IMoniker : public IPersistStream
    {
    public:
        virtual HRESULT __stdcall BindToObject(

        IBindCtx* pbc,

        IMoniker* pmkToLeft,

        const IID& riidResult,

        void** ppvResult)
        = 0;

        virtual HRESULT __stdcall BindToStorage(

        IBindCtx* pbc,

        IMoniker* pmkToLeft,

        const IID& riid,

        void** ppvObj)
        = 0;

        virtual HRESULT __stdcall Reduce(IBindCtx* pbc, DWORD dwReduceHowFar, IMoniker** ppmkToLeft, IMoniker** ppmkReduced) = 0;

        virtual HRESULT __stdcall ComposeWith(IMoniker* pmkRight, BOOL fOnlyIfNotGeneric, IMoniker** ppmkComposite) = 0;

        virtual HRESULT __stdcall Enum(BOOL fForward, IEnumMoniker** ppenumMoniker) = 0;

        virtual HRESULT __stdcall IsEqual(IMoniker* pmkOtherMoniker) = 0;

        virtual HRESULT __stdcall Hash(DWORD* pdwHash) = 0;

        virtual HRESULT __stdcall IsRunning(IBindCtx* pbc, IMoniker* pmkToLeft, IMoniker* pmkNewlyRunning) = 0;

        virtual HRESULT __stdcall GetTimeOfLastChange(IBindCtx* pbc, IMoniker* pmkToLeft, FILETIME* pFileTime) = 0;

        virtual HRESULT __stdcall Inverse(IMoniker** ppmk) = 0;

        virtual HRESULT __stdcall CommonPrefixWith(IMoniker* pmkOther, IMoniker** ppmkPrefix) = 0;

        virtual HRESULT __stdcall RelativePathTo(IMoniker* pmkOther, IMoniker** ppmkRelPath) = 0;

        virtual HRESULT __stdcall GetDisplayName(IBindCtx* pbc, IMoniker* pmkToLeft, LPOLESTR* ppszDisplayName) = 0;

        virtual HRESULT __stdcall ParseDisplayName(IBindCtx* pbc, IMoniker* pmkToLeft, LPOLESTR pszDisplayName, ULONG* pchEaten, IMoniker** ppmkOut)
        = 0;

        virtual HRESULT __stdcall IsSystemMoniker(DWORD* pdwMksys) = 0;
    };

    HRESULT __stdcall IMoniker_RemoteBindToObject_Proxy(
    IMoniker* This, IBindCtx* pbc, IMoniker* pmkToLeft, const IID& riidResult, IUnknown** ppvResult);

    void __stdcall IMoniker_RemoteBindToObject_Stub(IRpcStubBuffer* This,
                                                    IRpcChannelBuffer* _pRpcChannelBuffer,
                                                    PRPC_MESSAGE _pRpcMessage,
                                                    DWORD* _pdwStubPhase);

    HRESULT __stdcall IMoniker_RemoteBindToStorage_Proxy(IMoniker* This, IBindCtx* pbc, IMoniker* pmkToLeft, const IID& riid, IUnknown** ppvObj);

    void __stdcall IMoniker_RemoteBindToStorage_Stub(IRpcStubBuffer* This,
                                                     IRpcChannelBuffer* _pRpcChannelBuffer,
                                                     PRPC_MESSAGE _pRpcMessage,
                                                     DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0061_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0061_v0_0_s_ifspec;

    extern "C" const IID IID_IROTData;

    struct __declspec(uuid("f29f6bc0-5021-11ce-aa15-00006901293f")) __declspec(novtable) IROTData : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetComparisonData(byte* pbData, ULONG cbMax, ULONG* pcbData) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0062_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0062_v0_0_s_ifspec;

    typedef IEnumSTATSTG* LPENUMSTATSTG;

    extern "C" const IID IID_IEnumSTATSTG;

    struct __declspec(uuid("0000000d-0000-0000-C000-000000000046")) __declspec(novtable) IEnumSTATSTG : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(ULONG celt,

                                       STATSTG* rgelt,

                                       ULONG* pceltFetched)
        = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumSTATSTG** ppenum) = 0;
    };

    HRESULT __stdcall IEnumSTATSTG_RemoteNext_Proxy(IEnumSTATSTG* This, ULONG celt, STATSTG* rgelt, ULONG* pceltFetched);

    void __stdcall IEnumSTATSTG_RemoteNext_Stub(IRpcStubBuffer* This,
                                                IRpcChannelBuffer* _pRpcChannelBuffer,
                                                PRPC_MESSAGE _pRpcMessage,
                                                DWORD* _pdwStubPhase);

    typedef IStorage* LPSTORAGE;

    typedef struct tagRemSNB
    {
        ULONG ulCntStr;
        ULONG ulCntChar;
        OLECHAR rgString[1];
    } RemSNB;

    typedef RemSNB* wireSNB;

    typedef LPOLESTR* SNB;

    extern "C" const IID IID_IStorage;

    struct __declspec(uuid("0000000b-0000-0000-C000-000000000046")) __declspec(novtable) IStorage : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateStream(const OLECHAR* pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStream** ppstm)
        = 0;

        virtual HRESULT __stdcall OpenStream(

        const OLECHAR* pwcsName,

        void* reserved1,
        DWORD grfMode,
        DWORD reserved2,

        IStream** ppstm)
        = 0;

        virtual HRESULT __stdcall CreateStorage(const OLECHAR* pwcsName, DWORD grfMode, DWORD reserved1, DWORD reserved2, IStorage** ppstg)
        = 0;

        virtual HRESULT __stdcall OpenStorage(
        const OLECHAR* pwcsName, IStorage* pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage** ppstg)
        = 0;

        virtual HRESULT __stdcall CopyTo(DWORD ciidExclude,

                                         const IID* rgiidExclude,

                                         SNB snbExclude,

                                         IStorage* pstgDest)
        = 0;

        virtual HRESULT __stdcall MoveElementTo(const OLECHAR* pwcsName, IStorage* pstgDest, const OLECHAR* pwcsNewName, DWORD grfFlags)
        = 0;

        virtual HRESULT __stdcall Commit(DWORD grfCommitFlags) = 0;

        virtual HRESULT __stdcall Revert(void) = 0;

        virtual HRESULT __stdcall EnumElements(

        DWORD reserved1,

        void* reserved2,

        DWORD reserved3,

        IEnumSTATSTG** ppenum)
        = 0;

        virtual HRESULT __stdcall DestroyElement(const OLECHAR* pwcsName) = 0;

        virtual HRESULT __stdcall RenameElement(const OLECHAR* pwcsOldName, const OLECHAR* pwcsNewName) = 0;

        virtual HRESULT __stdcall SetElementTimes(const OLECHAR* pwcsName, const FILETIME* pctime, const FILETIME* patime, const FILETIME* pmtime)
        = 0;

        virtual HRESULT __stdcall SetClass(const IID& clsid) = 0;

        virtual HRESULT __stdcall SetStateBits(DWORD grfStateBits, DWORD grfMask) = 0;

        virtual HRESULT __stdcall Stat(STATSTG* pstatstg, DWORD grfStatFlag) = 0;
    };

    HRESULT __stdcall IStorage_RemoteOpenStream_Proxy(
    IStorage* This, const OLECHAR* pwcsName, ULONG cbReserved1, byte* reserved1, DWORD grfMode, DWORD reserved2, IStream** ppstm);

    void __stdcall IStorage_RemoteOpenStream_Stub(IRpcStubBuffer* This,
                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                  PRPC_MESSAGE _pRpcMessage,
                                                  DWORD* _pdwStubPhase);

    HRESULT __stdcall IStorage_RemoteCopyTo_Proxy(IStorage* This, DWORD ciidExclude, const IID* rgiidExclude, SNB snbExclude, IStorage* pstgDest);

    void __stdcall IStorage_RemoteCopyTo_Stub(IRpcStubBuffer* This,
                                              IRpcChannelBuffer* _pRpcChannelBuffer,
                                              PRPC_MESSAGE _pRpcMessage,
                                              DWORD* _pdwStubPhase);

    HRESULT __stdcall IStorage_RemoteEnumElements_Proxy(
    IStorage* This, DWORD reserved1, ULONG cbReserved2, byte* reserved2, DWORD reserved3, IEnumSTATSTG** ppenum);

    void __stdcall IStorage_RemoteEnumElements_Stub(IRpcStubBuffer* This,
                                                    IRpcChannelBuffer* _pRpcChannelBuffer,
                                                    PRPC_MESSAGE _pRpcMessage,
                                                    DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0064_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0064_v0_0_s_ifspec;

    typedef IPersistFile* LPPERSISTFILE;

    extern "C" const IID IID_IPersistFile;

    struct __declspec(uuid("0000010b-0000-0000-C000-000000000046")) __declspec(novtable) IPersistFile : public IPersist
    {
    public:
        virtual HRESULT __stdcall IsDirty(void) = 0;

        virtual HRESULT __stdcall Load(LPCOLESTR pszFileName, DWORD dwMode) = 0;

        virtual HRESULT __stdcall Save(LPCOLESTR pszFileName, BOOL fRemember) = 0;

        virtual HRESULT __stdcall SaveCompleted(LPCOLESTR pszFileName) = 0;

        virtual HRESULT __stdcall GetCurFile(LPOLESTR* ppszFileName) = 0;
    };

    typedef IPersistStorage* LPPERSISTSTORAGE;

    extern "C" const IID IID_IPersistStorage;

    struct __declspec(uuid("0000010a-0000-0000-C000-000000000046")) __declspec(novtable) IPersistStorage : public IPersist
    {
    public:
        virtual HRESULT __stdcall IsDirty(void) = 0;

        virtual HRESULT __stdcall InitNew(IStorage* pStg) = 0;

        virtual HRESULT __stdcall Load(IStorage* pStg) = 0;

        virtual HRESULT __stdcall Save(IStorage* pStgSave, BOOL fSameAsLoad) = 0;

        virtual HRESULT __stdcall SaveCompleted(IStorage* pStgNew) = 0;

        virtual HRESULT __stdcall HandsOffStorage(void) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0066_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0066_v0_0_s_ifspec;

    typedef ILockBytes* LPLOCKBYTES;

    extern "C" const IID IID_ILockBytes;

    struct __declspec(uuid("0000000a-0000-0000-C000-000000000046")) __declspec(novtable) ILockBytes : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ReadAt(ULARGE_INTEGER ulOffset,

                                         void* pv,
                                         ULONG cb,

                                         ULONG* pcbRead)
        = 0;

        virtual HRESULT __stdcall WriteAt(ULARGE_INTEGER ulOffset,

                                          const void* pv,
                                          ULONG cb,

                                          ULONG* pcbWritten)
        = 0;

        virtual HRESULT __stdcall Flush(void) = 0;

        virtual HRESULT __stdcall SetSize(ULARGE_INTEGER cb) = 0;

        virtual HRESULT __stdcall LockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) = 0;

        virtual HRESULT __stdcall UnlockRegion(ULARGE_INTEGER libOffset, ULARGE_INTEGER cb, DWORD dwLockType) = 0;

        virtual HRESULT __stdcall Stat(STATSTG* pstatstg, DWORD grfStatFlag) = 0;
    };

    HRESULT __stdcall ILockBytes_RemoteReadAt_Proxy(ILockBytes* This, ULARGE_INTEGER ulOffset, byte* pv, ULONG cb, ULONG* pcbRead);

    void __stdcall ILockBytes_RemoteReadAt_Stub(IRpcStubBuffer* This,
                                                IRpcChannelBuffer* _pRpcChannelBuffer,
                                                PRPC_MESSAGE _pRpcMessage,
                                                DWORD* _pdwStubPhase);

    HRESULT __stdcall ILockBytes_RemoteWriteAt_Proxy(ILockBytes* This, ULARGE_INTEGER ulOffset, const byte* pv, ULONG cb, ULONG* pcbWritten);

    void __stdcall ILockBytes_RemoteWriteAt_Stub(IRpcStubBuffer* This,
                                                 IRpcChannelBuffer* _pRpcChannelBuffer,
                                                 PRPC_MESSAGE _pRpcMessage,
                                                 DWORD* _pdwStubPhase);

    typedef IEnumFORMATETC* LPENUMFORMATETC;

    typedef struct tagDVTARGETDEVICE
    {
        DWORD tdSize;
        WORD tdDriverNameOffset;
        WORD tdDeviceNameOffset;
        WORD tdPortNameOffset;
        WORD tdExtDevmodeOffset;
        BYTE tdData[1];
    } DVTARGETDEVICE;

    typedef CLIPFORMAT* LPCLIPFORMAT;

    typedef struct tagFORMATETC
    {
        CLIPFORMAT cfFormat;
        DVTARGETDEVICE* ptd;
        DWORD dwAspect;
        LONG lindex;
        DWORD tymed;
    } FORMATETC;

    typedef struct tagFORMATETC* LPFORMATETC;

    extern "C" const IID IID_IEnumFORMATETC;

    struct __declspec(uuid("00000103-0000-0000-C000-000000000046")) __declspec(novtable) IEnumFORMATETC : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(ULONG celt,

                                       FORMATETC* rgelt,

                                       ULONG* pceltFetched)
        = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumFORMATETC** ppenum) = 0;
    };

    HRESULT __stdcall IEnumFORMATETC_RemoteNext_Proxy(IEnumFORMATETC* This, ULONG celt, FORMATETC* rgelt, ULONG* pceltFetched);

    void __stdcall IEnumFORMATETC_RemoteNext_Stub(IRpcStubBuffer* This,
                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                  PRPC_MESSAGE _pRpcMessage,
                                                  DWORD* _pdwStubPhase);

    typedef IEnumSTATDATA* LPENUMSTATDATA;

    typedef enum tagADVF
    {
        ADVF_NODATA = 1,
        ADVF_PRIMEFIRST = 2,
        ADVF_ONLYONCE = 4,
        ADVF_DATAONSTOP = 64,
        ADVFCACHE_NOHANDLER = 8,
        ADVFCACHE_FORCEBUILTIN = 16,
        ADVFCACHE_ONSAVE = 32
    } ADVF;

    typedef struct tagSTATDATA
    {
        FORMATETC formatetc;
        DWORD advf;
        IAdviseSink* pAdvSink;
        DWORD dwConnection;
    } STATDATA;

    typedef STATDATA* LPSTATDATA;

    extern "C" const IID IID_IEnumSTATDATA;

    struct __declspec(uuid("00000105-0000-0000-C000-000000000046")) __declspec(novtable) IEnumSTATDATA : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(ULONG celt,

                                       STATDATA* rgelt,

                                       ULONG* pceltFetched)
        = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumSTATDATA** ppenum) = 0;
    };

    HRESULT __stdcall IEnumSTATDATA_RemoteNext_Proxy(IEnumSTATDATA* This, ULONG celt, STATDATA* rgelt, ULONG* pceltFetched);

    void __stdcall IEnumSTATDATA_RemoteNext_Stub(IRpcStubBuffer* This,
                                                 IRpcChannelBuffer* _pRpcChannelBuffer,
                                                 PRPC_MESSAGE _pRpcMessage,
                                                 DWORD* _pdwStubPhase);

    typedef IRootStorage* LPROOTSTORAGE;

    extern "C" const IID IID_IRootStorage;

    struct __declspec(uuid("00000012-0000-0000-C000-000000000046")) __declspec(novtable) IRootStorage : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SwitchToFile(LPOLESTR pszFile) = 0;
    };

    typedef IAdviseSink* LPADVISESINK;

    typedef enum tagTYMED
    {
        TYMED_HGLOBAL = 1,
        TYMED_FILE = 2,
        TYMED_ISTREAM = 4,
        TYMED_ISTORAGE = 8,
        TYMED_GDI = 16,
        TYMED_MFPICT = 32,
        TYMED_ENHMF = 64,
        TYMED_NULL = 0
    } TYMED;

#pragma warning(push)
#pragma warning(disable : 4200)
    typedef struct tagRemSTGMEDIUM
    {
        DWORD tymed;
        DWORD dwHandleType;
        ULONG pData;
        ULONG pUnkForRelease;
        ULONG cbData;
        byte data[1];
    } RemSTGMEDIUM;

#pragma warning(pop)

    typedef struct tagSTGMEDIUM
    {
        DWORD tymed;
        union
        {
            HBITMAP hBitmap;
            HMETAFILEPICT hMetaFilePict;
            HENHMETAFILE hEnhMetaFile;
            HGLOBAL hGlobal;
            LPOLESTR lpszFileName;
            IStream* pstm;
            IStorage* pstg;
        };
        IUnknown* pUnkForRelease;
    } uSTGMEDIUM;

    typedef struct _GDI_OBJECT
    {
        DWORD ObjectType;
        union __MIDL_IAdviseSink_0002
        {
            wireHBITMAP hBitmap;
            wireHPALETTE hPalette;
            wireHGLOBAL hGeneric;
        } u;
    } GDI_OBJECT;

    typedef struct _userSTGMEDIUM
    {
        struct _STGMEDIUM_UNION
        {
            DWORD tymed;
            union __MIDL_IAdviseSink_0003
            {
                wireHMETAFILEPICT hMetaFilePict;
                wireHENHMETAFILE hHEnhMetaFile;
                GDI_OBJECT* hGdiHandle;
                wireHGLOBAL hGlobal;
                LPOLESTR lpszFileName;
                BYTE_BLOB* pstm;
                BYTE_BLOB* pstg;
            } u;
        };
        IUnknown* pUnkForRelease;
    } userSTGMEDIUM;

    typedef userSTGMEDIUM* wireSTGMEDIUM;

    typedef uSTGMEDIUM STGMEDIUM;

    typedef userSTGMEDIUM* wireASYNC_STGMEDIUM;

    typedef STGMEDIUM ASYNC_STGMEDIUM;

    typedef STGMEDIUM* LPSTGMEDIUM;

    typedef struct _userFLAG_STGMEDIUM
    {
        LONG ContextFlags;
        LONG fPassOwnership;
        userSTGMEDIUM Stgmed;
    } userFLAG_STGMEDIUM;

    typedef userFLAG_STGMEDIUM* wireFLAG_STGMEDIUM;

    typedef struct _FLAG_STGMEDIUM
    {
        LONG ContextFlags;
        LONG fPassOwnership;
        STGMEDIUM Stgmed;
    } FLAG_STGMEDIUM;

    extern "C" const IID IID_IAdviseSink;

    struct __declspec(uuid("0000010f-0000-0000-C000-000000000046")) __declspec(novtable) IAdviseSink : public IUnknown
    {
    public:
        virtual void __stdcall OnDataChange(

        FORMATETC* pFormatetc,

        STGMEDIUM* pStgmed)
        = 0;

        virtual void __stdcall OnViewChange(DWORD dwAspect, LONG lindex) = 0;

        virtual void __stdcall OnRename(

        IMoniker* pmk)
        = 0;

        virtual void __stdcall OnSave(void) = 0;

        virtual void __stdcall OnClose(void) = 0;
    };

    HRESULT __stdcall IAdviseSink_RemoteOnDataChange_Proxy(IAdviseSink* This, FORMATETC* pFormatetc, ASYNC_STGMEDIUM* pStgmed);

    void __stdcall IAdviseSink_RemoteOnDataChange_Stub(IRpcStubBuffer* This,
                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                       PRPC_MESSAGE _pRpcMessage,
                                                       DWORD* _pdwStubPhase);

    HRESULT __stdcall IAdviseSink_RemoteOnViewChange_Proxy(IAdviseSink* This, DWORD dwAspect, LONG lindex);

    void __stdcall IAdviseSink_RemoteOnViewChange_Stub(IRpcStubBuffer* This,
                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                       PRPC_MESSAGE _pRpcMessage,
                                                       DWORD* _pdwStubPhase);

    HRESULT __stdcall IAdviseSink_RemoteOnRename_Proxy(IAdviseSink* This, IMoniker* pmk);

    void __stdcall IAdviseSink_RemoteOnRename_Stub(IRpcStubBuffer* This,
                                                   IRpcChannelBuffer* _pRpcChannelBuffer,
                                                   PRPC_MESSAGE _pRpcMessage,
                                                   DWORD* _pdwStubPhase);

    HRESULT __stdcall IAdviseSink_RemoteOnSave_Proxy(IAdviseSink* This);

    void __stdcall IAdviseSink_RemoteOnSave_Stub(IRpcStubBuffer* This,
                                                 IRpcChannelBuffer* _pRpcChannelBuffer,
                                                 PRPC_MESSAGE _pRpcMessage,
                                                 DWORD* _pdwStubPhase);

    HRESULT __stdcall IAdviseSink_RemoteOnClose_Proxy(IAdviseSink* This);

    void __stdcall IAdviseSink_RemoteOnClose_Stub(IRpcStubBuffer* This,
                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                  PRPC_MESSAGE _pRpcMessage,
                                                  DWORD* _pdwStubPhase);

    extern "C" const IID IID_AsyncIAdviseSink;

    struct __declspec(uuid("00000150-0000-0000-C000-000000000046")) __declspec(novtable) AsyncIAdviseSink : public IUnknown
    {
    public:
        virtual void __stdcall Begin_OnDataChange(

        FORMATETC* pFormatetc,

        STGMEDIUM* pStgmed)
        = 0;

        virtual void __stdcall Finish_OnDataChange(void) = 0;

        virtual void __stdcall Begin_OnViewChange(DWORD dwAspect, LONG lindex) = 0;

        virtual void __stdcall Finish_OnViewChange(void) = 0;

        virtual void __stdcall Begin_OnRename(

        IMoniker* pmk)
        = 0;

        virtual void __stdcall Finish_OnRename(void) = 0;

        virtual void __stdcall Begin_OnSave(void) = 0;

        virtual void __stdcall Finish_OnSave(void) = 0;

        virtual void __stdcall Begin_OnClose(void) = 0;

        virtual void __stdcall Finish_OnClose(void) = 0;
    };

    HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnDataChange_Proxy(AsyncIAdviseSink* This, FORMATETC* pFormatetc, ASYNC_STGMEDIUM* pStgmed);

    void __stdcall AsyncIAdviseSink_Begin_RemoteOnDataChange_Stub(IRpcStubBuffer* This,
                                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                  PRPC_MESSAGE _pRpcMessage,
                                                                  DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnDataChange_Proxy(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Finish_RemoteOnDataChange_Stub(IRpcStubBuffer* This,
                                                                   IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                   PRPC_MESSAGE _pRpcMessage,
                                                                   DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnViewChange_Proxy(AsyncIAdviseSink* This, DWORD dwAspect, LONG lindex);

    void __stdcall AsyncIAdviseSink_Begin_RemoteOnViewChange_Stub(IRpcStubBuffer* This,
                                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                  PRPC_MESSAGE _pRpcMessage,
                                                                  DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnViewChange_Proxy(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Finish_RemoteOnViewChange_Stub(IRpcStubBuffer* This,
                                                                   IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                   PRPC_MESSAGE _pRpcMessage,
                                                                   DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnRename_Proxy(AsyncIAdviseSink* This, IMoniker* pmk);

    void __stdcall AsyncIAdviseSink_Begin_RemoteOnRename_Stub(IRpcStubBuffer* This,
                                                              IRpcChannelBuffer* _pRpcChannelBuffer,
                                                              PRPC_MESSAGE _pRpcMessage,
                                                              DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnRename_Proxy(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Finish_RemoteOnRename_Stub(IRpcStubBuffer* This,
                                                               IRpcChannelBuffer* _pRpcChannelBuffer,
                                                               PRPC_MESSAGE _pRpcMessage,
                                                               DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnSave_Proxy(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Begin_RemoteOnSave_Stub(IRpcStubBuffer* This,
                                                            IRpcChannelBuffer* _pRpcChannelBuffer,
                                                            PRPC_MESSAGE _pRpcMessage,
                                                            DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnSave_Proxy(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Finish_RemoteOnSave_Stub(IRpcStubBuffer* This,
                                                             IRpcChannelBuffer* _pRpcChannelBuffer,
                                                             PRPC_MESSAGE _pRpcMessage,
                                                             DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink_Begin_RemoteOnClose_Proxy(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Begin_RemoteOnClose_Stub(IRpcStubBuffer* This,
                                                             IRpcChannelBuffer* _pRpcChannelBuffer,
                                                             PRPC_MESSAGE _pRpcMessage,
                                                             DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink_Finish_RemoteOnClose_Proxy(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Finish_RemoteOnClose_Stub(IRpcStubBuffer* This,
                                                              IRpcChannelBuffer* _pRpcChannelBuffer,
                                                              PRPC_MESSAGE _pRpcMessage,
                                                              DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0071_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0071_v0_0_s_ifspec;

    typedef IAdviseSink2* LPADVISESINK2;

    extern "C" const IID IID_IAdviseSink2;

    struct __declspec(uuid("00000125-0000-0000-C000-000000000046")) __declspec(novtable) IAdviseSink2 : public IAdviseSink
    {
    public:
        virtual void __stdcall OnLinkSrcChange(

        IMoniker* pmk)
        = 0;
    };

    HRESULT __stdcall IAdviseSink2_RemoteOnLinkSrcChange_Proxy(IAdviseSink2* This, IMoniker* pmk);

    void __stdcall IAdviseSink2_RemoteOnLinkSrcChange_Stub(IRpcStubBuffer* This,
                                                           IRpcChannelBuffer* _pRpcChannelBuffer,
                                                           PRPC_MESSAGE _pRpcMessage,
                                                           DWORD* _pdwStubPhase);

    extern "C" const IID IID_AsyncIAdviseSink2;

    struct __declspec(uuid("00000151-0000-0000-C000-000000000046")) __declspec(novtable) AsyncIAdviseSink2 : public AsyncIAdviseSink
    {
    public:
        virtual void __stdcall Begin_OnLinkSrcChange(

        IMoniker* pmk)
        = 0;

        virtual void __stdcall Finish_OnLinkSrcChange(void) = 0;
    };

    HRESULT __stdcall AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Proxy(AsyncIAdviseSink2* This, IMoniker* pmk);

    void __stdcall AsyncIAdviseSink2_Begin_RemoteOnLinkSrcChange_Stub(IRpcStubBuffer* This,
                                                                      IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                      PRPC_MESSAGE _pRpcMessage,
                                                                      DWORD* _pdwStubPhase);

    HRESULT __stdcall AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Proxy(AsyncIAdviseSink2* This);

    void __stdcall AsyncIAdviseSink2_Finish_RemoteOnLinkSrcChange_Stub(IRpcStubBuffer* This,
                                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                       PRPC_MESSAGE _pRpcMessage,
                                                                       DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0072_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0072_v0_0_s_ifspec;

    typedef IDataObject* LPDATAOBJECT;

    typedef enum tagDATADIR
    {
        DATADIR_GET = 1,
        DATADIR_SET = 2
    } DATADIR;

    extern "C" const IID IID_IDataObject;

    struct __declspec(uuid("0000010e-0000-0000-C000-000000000046")) __declspec(novtable) IDataObject : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetData(

        FORMATETC* pformatetcIn,

        STGMEDIUM* pmedium)
        = 0;

        virtual HRESULT __stdcall GetDataHere(

        FORMATETC* pformatetc,

        STGMEDIUM* pmedium)
        = 0;

        virtual HRESULT __stdcall QueryGetData(FORMATETC* pformatetc) = 0;

        virtual HRESULT __stdcall GetCanonicalFormatEtc(FORMATETC* pformatectIn, FORMATETC* pformatetcOut) = 0;

        virtual HRESULT __stdcall SetData(

        FORMATETC* pformatetc,

        STGMEDIUM* pmedium,
        BOOL fRelease)
        = 0;

        virtual HRESULT __stdcall EnumFormatEtc(DWORD dwDirection, IEnumFORMATETC** ppenumFormatEtc) = 0;

        virtual HRESULT __stdcall DAdvise(FORMATETC* pformatetc, DWORD advf, IAdviseSink* pAdvSink, DWORD* pdwConnection) = 0;

        virtual HRESULT __stdcall DUnadvise(DWORD dwConnection) = 0;

        virtual HRESULT __stdcall EnumDAdvise(IEnumSTATDATA** ppenumAdvise) = 0;
    };

    HRESULT __stdcall IDataObject_RemoteGetData_Proxy(IDataObject* This, FORMATETC* pformatetcIn, STGMEDIUM* pRemoteMedium);

    void __stdcall IDataObject_RemoteGetData_Stub(IRpcStubBuffer* This,
                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                  PRPC_MESSAGE _pRpcMessage,
                                                  DWORD* _pdwStubPhase);

    HRESULT __stdcall IDataObject_RemoteGetDataHere_Proxy(IDataObject* This, FORMATETC* pformatetc, STGMEDIUM* pRemoteMedium);

    void __stdcall IDataObject_RemoteGetDataHere_Stub(IRpcStubBuffer* This,
                                                      IRpcChannelBuffer* _pRpcChannelBuffer,
                                                      PRPC_MESSAGE _pRpcMessage,
                                                      DWORD* _pdwStubPhase);

    HRESULT __stdcall IDataObject_RemoteSetData_Proxy(IDataObject* This, FORMATETC* pformatetc, FLAG_STGMEDIUM* pmedium, BOOL fRelease);

    void __stdcall IDataObject_RemoteSetData_Stub(IRpcStubBuffer* This,
                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                  PRPC_MESSAGE _pRpcMessage,
                                                  DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0073_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0073_v0_0_s_ifspec;

    typedef IDataAdviseHolder* LPDATAADVISEHOLDER;

    extern "C" const IID IID_IDataAdviseHolder;

    struct __declspec(uuid("00000110-0000-0000-C000-000000000046")) __declspec(novtable) IDataAdviseHolder : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Advise(

        IDataObject* pDataObject,

        FORMATETC* pFetc,

        DWORD advf,

        IAdviseSink* pAdvise,

        DWORD* pdwConnection)
        = 0;

        virtual HRESULT __stdcall Unadvise(

        DWORD dwConnection)
        = 0;

        virtual HRESULT __stdcall EnumAdvise(

        IEnumSTATDATA** ppenumAdvise)
        = 0;

        virtual HRESULT __stdcall SendOnDataChange(

        IDataObject* pDataObject,

        DWORD dwReserved,

        DWORD advf)
        = 0;
    };

    typedef IMessageFilter* LPMESSAGEFILTER;

    typedef enum tagCALLTYPE
    {
        CALLTYPE_TOPLEVEL = 1,
        CALLTYPE_NESTED = 2,
        CALLTYPE_ASYNC = 3,
        CALLTYPE_TOPLEVEL_CALLPENDING = 4,
        CALLTYPE_ASYNC_CALLPENDING = 5
    } CALLTYPE;

    typedef enum tagSERVERCALL
    {
        SERVERCALL_ISHANDLED = 0,
        SERVERCALL_REJECTED = 1,
        SERVERCALL_RETRYLATER = 2
    } SERVERCALL;

    typedef enum tagPENDINGTYPE
    {
        PENDINGTYPE_TOPLEVEL = 1,
        PENDINGTYPE_NESTED = 2
    } PENDINGTYPE;

    typedef enum tagPENDINGMSG
    {
        PENDINGMSG_CANCELCALL = 0,
        PENDINGMSG_WAITNOPROCESS = 1,
        PENDINGMSG_WAITDEFPROCESS = 2
    } PENDINGMSG;

    typedef struct tagINTERFACEINFO
    {
        IUnknown* pUnk;
        IID iid;
        WORD wMethod;
    } INTERFACEINFO;

    typedef struct tagINTERFACEINFO* LPINTERFACEINFO;

    extern "C" const IID IID_IMessageFilter;

    struct __declspec(uuid("00000016-0000-0000-C000-000000000046")) __declspec(novtable) IMessageFilter : public IUnknown
    {
    public:
        virtual DWORD __stdcall HandleInComingCall(

        DWORD dwCallType,

        HTASK htaskCaller,

        DWORD dwTickCount,

        LPINTERFACEINFO lpInterfaceInfo)
        = 0;

        virtual DWORD __stdcall RetryRejectedCall(

        HTASK htaskCallee,

        DWORD dwTickCount,

        DWORD dwRejectType)
        = 0;

        virtual DWORD __stdcall MessagePending(

        HTASK htaskCallee,

        DWORD dwTickCount,

        DWORD dwPendingType)
        = 0;
    };

    extern const FMTID FMTID_SummaryInformation;

    extern const FMTID FMTID_DocSummaryInformation;

    extern const FMTID FMTID_UserDefinedProperties;

    extern const FMTID FMTID_DiscardableInformation;

    extern const FMTID FMTID_ImageSummaryInformation;

    extern const FMTID FMTID_AudioSummaryInformation;

    extern const FMTID FMTID_VideoSummaryInformation;

    extern const FMTID FMTID_MediaFileSummaryInformation;

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0075_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0075_v0_0_s_ifspec;

    extern "C" const IID IID_IClassActivator;

    struct __declspec(uuid("00000140-0000-0000-C000-000000000046")) __declspec(novtable) IClassActivator : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetClassObject(const IID& rclsid, DWORD dwClassContext, LCID locale, const IID& riid, void** ppv)
        = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0076_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0076_v0_0_s_ifspec;

    extern "C" const IID IID_IFillLockBytes;

    struct __declspec(uuid("99caf010-415e-11cf-8814-00aa00b569f5")) __declspec(novtable) IFillLockBytes : public IUnknown
    {
    public:
        virtual HRESULT __stdcall FillAppend(

        const void* pv,

        ULONG cb,

        ULONG* pcbWritten)
        = 0;

        virtual HRESULT __stdcall FillAt(

        ULARGE_INTEGER ulOffset,

        const void* pv,

        ULONG cb,

        ULONG* pcbWritten)
        = 0;

        virtual HRESULT __stdcall SetFillSize(ULARGE_INTEGER ulSize) = 0;

        virtual HRESULT __stdcall Terminate(BOOL bCanceled) = 0;
    };

    HRESULT __stdcall IFillLockBytes_RemoteFillAppend_Proxy(IFillLockBytes* This, const byte* pv, ULONG cb, ULONG* pcbWritten);

    void __stdcall IFillLockBytes_RemoteFillAppend_Stub(IRpcStubBuffer* This,
                                                        IRpcChannelBuffer* _pRpcChannelBuffer,
                                                        PRPC_MESSAGE _pRpcMessage,
                                                        DWORD* _pdwStubPhase);

    HRESULT __stdcall IFillLockBytes_RemoteFillAt_Proxy(IFillLockBytes* This, ULARGE_INTEGER ulOffset, const byte* pv, ULONG cb, ULONG* pcbWritten);

    void __stdcall IFillLockBytes_RemoteFillAt_Stub(IRpcStubBuffer* This,
                                                    IRpcChannelBuffer* _pRpcChannelBuffer,
                                                    PRPC_MESSAGE _pRpcMessage,
                                                    DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0077_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0077_v0_0_s_ifspec;

    extern "C" const IID IID_IProgressNotify;

    struct __declspec(uuid("a9d758a0-4617-11cf-95fc-00aa00680db4")) __declspec(novtable) IProgressNotify : public IUnknown
    {
    public:
        virtual HRESULT __stdcall OnProgress(DWORD dwProgressCurrent, DWORD dwProgressMaximum, BOOL fAccurate, BOOL fOwner) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0078_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0078_v0_0_s_ifspec;

    typedef struct tagStorageLayout
    {
        DWORD LayoutType;
        OLECHAR* pwcsElementName;
        LARGE_INTEGER cOffset;
        LARGE_INTEGER cBytes;
    } StorageLayout;

    extern "C" const IID IID_ILayoutStorage;

    struct __declspec(uuid("0e6d4d90-6738-11cf-9608-00aa00680db4")) __declspec(novtable) ILayoutStorage : public IUnknown
    {
    public:
        virtual HRESULT __stdcall LayoutScript(

        StorageLayout* pStorageLayout,

        DWORD nEntries,

        DWORD glfInterleavedFlag)
        = 0;

        virtual HRESULT __stdcall BeginMonitor(void) = 0;

        virtual HRESULT __stdcall EndMonitor(void) = 0;

        virtual HRESULT __stdcall ReLayoutDocfile(

        OLECHAR* pwcsNewDfName)
        = 0;

        virtual HRESULT __stdcall ReLayoutDocfileOnILockBytes(

        ILockBytes* pILockBytes)
        = 0;
    };

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0079_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0079_v0_0_s_ifspec;

    extern "C" const IID IID_IBlockingLock;

    struct __declspec(uuid("30f3d47a-6447-11d1-8e3c-00c04fb9386d")) __declspec(novtable) IBlockingLock : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Lock(DWORD dwTimeout) = 0;

        virtual HRESULT __stdcall Unlock(void) = 0;
    };

    extern "C" const IID IID_ITimeAndNoticeControl;

    struct __declspec(uuid("bc0bf6ae-8878-11d1-83e9-00c04fc2c6d4")) __declspec(novtable) ITimeAndNoticeControl : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SuppressChanges(DWORD res1, DWORD res2) = 0;
    };

    extern "C" const IID IID_IOplockStorage;

    struct __declspec(uuid("8d19c834-8879-11d1-83e9-00c04fc2c6d4")) __declspec(novtable) IOplockStorage : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateStorageEx(LPCWSTR pwcsName, DWORD grfMode, DWORD stgfmt, DWORD grfAttrs, const IID& riid, void** ppstgOpen)
        = 0;

        virtual HRESULT __stdcall OpenStorageEx(LPCWSTR pwcsName, DWORD grfMode, DWORD stgfmt, DWORD grfAttrs, const IID& riid, void** ppstgOpen)
        = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0082_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0082_v0_0_s_ifspec;

    extern "C" const IID IID_IDirectWriterLock;

    struct __declspec(uuid("0e6d4d92-6738-11cf-9608-00aa00680db4")) __declspec(novtable) IDirectWriterLock : public IUnknown
    {
    public:
        virtual HRESULT __stdcall WaitForWriteAccess(DWORD dwTimeout) = 0;

        virtual HRESULT __stdcall ReleaseWriteAccess(void) = 0;

        virtual HRESULT __stdcall HaveWriteAccess(void) = 0;
    };

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0083_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0083_v0_0_s_ifspec;

    extern "C" const IID IID_IUrlMon;

    struct __declspec(uuid("00000026-0000-0000-C000-000000000046")) __declspec(novtable) IUrlMon : public IUnknown
    {
    public:
        virtual HRESULT __stdcall AsyncGetClassBits(const IID& rclsid,
                                                    LPCWSTR pszTYPE,
                                                    LPCWSTR pszExt,
                                                    DWORD dwFileVersionMS,
                                                    DWORD dwFileVersionLS,
                                                    LPCWSTR pszCodeBase,
                                                    IBindCtx* pbc,
                                                    DWORD dwClassContext,
                                                    const IID& riid,
                                                    DWORD flags)
        = 0;
    };

    extern "C" const IID IID_IForegroundTransfer;

    struct __declspec(uuid("00000145-0000-0000-C000-000000000046")) __declspec(novtable) IForegroundTransfer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall AllowForegroundTransfer(

        void* lpvReserved)
        = 0;
    };

    extern "C" const IID IID_IThumbnailExtractor;

    struct __declspec(uuid("969dc708-5c76-11d1-8d86-0000f804b057")) __declspec(novtable) IThumbnailExtractor : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ExtractThumbnail(
        IStorage* pStg, ULONG ulLength, ULONG ulHeight, ULONG* pulOutputLength, ULONG* pulOutputHeight, HBITMAP* phOutputBitmap)
        = 0;

        virtual HRESULT __stdcall OnFileUpdated(IStorage* pStg) = 0;
    };

    extern "C" const IID IID_IDummyHICONIncluder;

    struct __declspec(uuid("947990de-cc28-11d2-a0f7-00805f858fb1")) __declspec(novtable) IDummyHICONIncluder : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Dummy(HICON h1, HDC h2) = 0;
    };

    typedef enum tagApplicationType
    {
        ServerApplication = 0,
        LibraryApplication = (ServerApplication + 1)
    } ApplicationType;

    typedef enum tagShutdownType
    {
        IdleShutdown = 0,
        ForcedShutdown = (IdleShutdown + 1)
    } ShutdownType;

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0087_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0087_v0_0_s_ifspec;

    extern "C" const IID IID_IProcessLock;

    struct __declspec(uuid("000001d5-0000-0000-C000-000000000046")) __declspec(novtable) IProcessLock : public IUnknown
    {
    public:
        virtual ULONG __stdcall AddRefOnProcess(void) = 0;

        virtual ULONG __stdcall ReleaseRefOnProcess(void) = 0;
    };

    extern "C" const IID IID_ISurrogateService;

    struct __declspec(uuid("000001d4-0000-0000-C000-000000000046")) __declspec(novtable) ISurrogateService : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Init(

        const GUID& rguidProcessID,

        IProcessLock* pProcessLock,

        BOOL* pfApplicationAware)
        = 0;

        virtual HRESULT __stdcall ApplicationLaunch(

        const GUID& rguidApplID,

        ApplicationType appType)
        = 0;

        virtual HRESULT __stdcall ApplicationFree(

        const GUID& rguidApplID)
        = 0;

        virtual HRESULT __stdcall CatalogRefresh(

        ULONG ulReserved)
        = 0;

        virtual HRESULT __stdcall ProcessShutdown(

        ShutdownType shutdownType)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0089_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0089_v0_0_s_ifspec;

    typedef IInitializeSpy* LPINITIALIZESPY;

    extern "C" const IID IID_IInitializeSpy;

    struct __declspec(uuid("00000034-0000-0000-C000-000000000046")) __declspec(novtable) IInitializeSpy : public IUnknown
    {
    public:
        virtual HRESULT __stdcall PreInitialize(

        DWORD dwCoInit,

        DWORD dwCurThreadAptRefs)
        = 0;

        virtual HRESULT __stdcall PostInitialize(

        HRESULT hrCoInit,

        DWORD dwCoInit,

        DWORD dwNewThreadAptRefs)
        = 0;

        virtual HRESULT __stdcall PreUninitialize(

        DWORD dwCurThreadAptRefs)
        = 0;

        virtual HRESULT __stdcall PostUninitialize(

        DWORD dwNewThreadAptRefs)
        = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0090_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0090_v0_0_s_ifspec;

    extern "C" const IID IID_IApartmentShutdown;

    struct __declspec(uuid("A2F05A09-27A2-42B5-BC0E-AC163EF49D9B")) __declspec(novtable) IApartmentShutdown : public IUnknown
    {
    public:
        virtual void __stdcall OnUninitialize(

        UINT64 ui64ApartmentIdentifier)
        = 0;
    };

#pragma endregion

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0091_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_objidl_0000_0091_v0_0_s_ifspec;

    unsigned long __stdcall ASYNC_STGMEDIUM_UserSize(unsigned long*, unsigned long, ASYNC_STGMEDIUM*);
    unsigned char* __stdcall ASYNC_STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
    unsigned char* __stdcall ASYNC_STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
    void __stdcall ASYNC_STGMEDIUM_UserFree(unsigned long*, ASYNC_STGMEDIUM*);

    unsigned long __stdcall CLIPFORMAT_UserSize(unsigned long*, unsigned long, CLIPFORMAT*);
    unsigned char* __stdcall CLIPFORMAT_UserMarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
    unsigned char* __stdcall CLIPFORMAT_UserUnmarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
    void __stdcall CLIPFORMAT_UserFree(unsigned long*, CLIPFORMAT*);

    unsigned long __stdcall FLAG_STGMEDIUM_UserSize(unsigned long*, unsigned long, FLAG_STGMEDIUM*);
    unsigned char* __stdcall FLAG_STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
    unsigned char* __stdcall FLAG_STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
    void __stdcall FLAG_STGMEDIUM_UserFree(unsigned long*, FLAG_STGMEDIUM*);

    unsigned long __stdcall HBITMAP_UserSize(unsigned long*, unsigned long, HBITMAP*);
    unsigned char* __stdcall HBITMAP_UserMarshal(unsigned long*, unsigned char*, HBITMAP*);
    unsigned char* __stdcall HBITMAP_UserUnmarshal(unsigned long*, unsigned char*, HBITMAP*);
    void __stdcall HBITMAP_UserFree(unsigned long*, HBITMAP*);

    unsigned long __stdcall HDC_UserSize(unsigned long*, unsigned long, HDC*);
    unsigned char* __stdcall HDC_UserMarshal(unsigned long*, unsigned char*, HDC*);
    unsigned char* __stdcall HDC_UserUnmarshal(unsigned long*, unsigned char*, HDC*);
    void __stdcall HDC_UserFree(unsigned long*, HDC*);

    unsigned long __stdcall HICON_UserSize(unsigned long*, unsigned long, HICON*);
    unsigned char* __stdcall HICON_UserMarshal(unsigned long*, unsigned char*, HICON*);
    unsigned char* __stdcall HICON_UserUnmarshal(unsigned long*, unsigned char*, HICON*);
    void __stdcall HICON_UserFree(unsigned long*, HICON*);

    unsigned long __stdcall SNB_UserSize(unsigned long*, unsigned long, SNB*);
    unsigned char* __stdcall SNB_UserMarshal(unsigned long*, unsigned char*, SNB*);
    unsigned char* __stdcall SNB_UserUnmarshal(unsigned long*, unsigned char*, SNB*);
    void __stdcall SNB_UserFree(unsigned long*, SNB*);

    unsigned long __stdcall STGMEDIUM_UserSize(unsigned long*, unsigned long, STGMEDIUM*);
    unsigned char* __stdcall STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, STGMEDIUM*);
    unsigned char* __stdcall STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, STGMEDIUM*);
    void __stdcall STGMEDIUM_UserFree(unsigned long*, STGMEDIUM*);

    unsigned long __stdcall ASYNC_STGMEDIUM_UserSize64(unsigned long*, unsigned long, ASYNC_STGMEDIUM*);
    unsigned char* __stdcall ASYNC_STGMEDIUM_UserMarshal64(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
    unsigned char* __stdcall ASYNC_STGMEDIUM_UserUnmarshal64(unsigned long*, unsigned char*, ASYNC_STGMEDIUM*);
    void __stdcall ASYNC_STGMEDIUM_UserFree64(unsigned long*, ASYNC_STGMEDIUM*);

    unsigned long __stdcall CLIPFORMAT_UserSize64(unsigned long*, unsigned long, CLIPFORMAT*);
    unsigned char* __stdcall CLIPFORMAT_UserMarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
    unsigned char* __stdcall CLIPFORMAT_UserUnmarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
    void __stdcall CLIPFORMAT_UserFree64(unsigned long*, CLIPFORMAT*);

    unsigned long __stdcall FLAG_STGMEDIUM_UserSize64(unsigned long*, unsigned long, FLAG_STGMEDIUM*);
    unsigned char* __stdcall FLAG_STGMEDIUM_UserMarshal64(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
    unsigned char* __stdcall FLAG_STGMEDIUM_UserUnmarshal64(unsigned long*, unsigned char*, FLAG_STGMEDIUM*);
    void __stdcall FLAG_STGMEDIUM_UserFree64(unsigned long*, FLAG_STGMEDIUM*);

    unsigned long __stdcall HBITMAP_UserSize64(unsigned long*, unsigned long, HBITMAP*);
    unsigned char* __stdcall HBITMAP_UserMarshal64(unsigned long*, unsigned char*, HBITMAP*);
    unsigned char* __stdcall HBITMAP_UserUnmarshal64(unsigned long*, unsigned char*, HBITMAP*);
    void __stdcall HBITMAP_UserFree64(unsigned long*, HBITMAP*);

    unsigned long __stdcall HDC_UserSize64(unsigned long*, unsigned long, HDC*);
    unsigned char* __stdcall HDC_UserMarshal64(unsigned long*, unsigned char*, HDC*);
    unsigned char* __stdcall HDC_UserUnmarshal64(unsigned long*, unsigned char*, HDC*);
    void __stdcall HDC_UserFree64(unsigned long*, HDC*);

    unsigned long __stdcall HICON_UserSize64(unsigned long*, unsigned long, HICON*);
    unsigned char* __stdcall HICON_UserMarshal64(unsigned long*, unsigned char*, HICON*);
    unsigned char* __stdcall HICON_UserUnmarshal64(unsigned long*, unsigned char*, HICON*);
    void __stdcall HICON_UserFree64(unsigned long*, HICON*);

    unsigned long __stdcall SNB_UserSize64(unsigned long*, unsigned long, SNB*);
    unsigned char* __stdcall SNB_UserMarshal64(unsigned long*, unsigned char*, SNB*);
    unsigned char* __stdcall SNB_UserUnmarshal64(unsigned long*, unsigned char*, SNB*);
    void __stdcall SNB_UserFree64(unsigned long*, SNB*);

    unsigned long __stdcall STGMEDIUM_UserSize64(unsigned long*, unsigned long, STGMEDIUM*);
    unsigned char* __stdcall STGMEDIUM_UserMarshal64(unsigned long*, unsigned char*, STGMEDIUM*);
    unsigned char* __stdcall STGMEDIUM_UserUnmarshal64(unsigned long*, unsigned char*, STGMEDIUM*);
    void __stdcall STGMEDIUM_UserFree64(unsigned long*, STGMEDIUM*);

    HRESULT __stdcall IEnumUnknown_Next_Proxy(IEnumUnknown* This,

                                              ULONG celt,

                                              IUnknown** rgelt,

                                              ULONG* pceltFetched);

    HRESULT __stdcall IEnumUnknown_Next_Stub(IEnumUnknown* This, ULONG celt, IUnknown** rgelt, ULONG* pceltFetched);

    HRESULT __stdcall IEnumString_Next_Proxy(IEnumString* This,
                                             ULONG celt,

                                             LPOLESTR* rgelt,

                                             ULONG* pceltFetched);

    HRESULT __stdcall IEnumString_Next_Stub(IEnumString* This, ULONG celt, LPOLESTR* rgelt, ULONG* pceltFetched);

    HRESULT __stdcall ISequentialStream_Read_Proxy(ISequentialStream* This,

                                                   void* pv,

                                                   ULONG cb,

                                                   ULONG* pcbRead);

    HRESULT __stdcall ISequentialStream_Read_Stub(ISequentialStream* This, byte* pv, ULONG cb, ULONG* pcbRead);

    HRESULT __stdcall ISequentialStream_Write_Proxy(ISequentialStream* This,

                                                    const void* pv,

                                                    ULONG cb,

                                                    ULONG* pcbWritten);

    HRESULT __stdcall ISequentialStream_Write_Stub(ISequentialStream* This, const byte* pv, ULONG cb, ULONG* pcbWritten);

    HRESULT __stdcall IStream_Seek_Proxy(IStream* This,
                                         LARGE_INTEGER dlibMove,
                                         DWORD dwOrigin,

                                         ULARGE_INTEGER* plibNewPosition);

    HRESULT __stdcall IStream_Seek_Stub(IStream* This, LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition);

    HRESULT __stdcall IStream_CopyTo_Proxy(IStream* This,

                                           IStream* pstm,
                                           ULARGE_INTEGER cb,

                                           ULARGE_INTEGER* pcbRead,

                                           ULARGE_INTEGER* pcbWritten);

    HRESULT __stdcall IStream_CopyTo_Stub(IStream* This, IStream* pstm, ULARGE_INTEGER cb, ULARGE_INTEGER* pcbRead, ULARGE_INTEGER* pcbWritten);

    HRESULT __stdcall IBindCtx_SetBindOptions_Proxy(IBindCtx* This,

                                                    BIND_OPTS* pbindopts);

    HRESULT __stdcall IBindCtx_SetBindOptions_Stub(IBindCtx* This, BIND_OPTS2* pbindopts);

    HRESULT __stdcall IBindCtx_GetBindOptions_Proxy(IBindCtx* This,

                                                    BIND_OPTS* pbindopts);

    HRESULT __stdcall IBindCtx_GetBindOptions_Stub(IBindCtx* This, BIND_OPTS2* pbindopts);

    HRESULT __stdcall IEnumMoniker_Next_Proxy(IEnumMoniker* This,
                                              ULONG celt,

                                              IMoniker** rgelt,

                                              ULONG* pceltFetched);

    HRESULT __stdcall IEnumMoniker_Next_Stub(IEnumMoniker* This, ULONG celt, IMoniker** rgelt, ULONG* pceltFetched);

    BOOL __stdcall IRunnableObject_IsRunning_Proxy(IRunnableObject* This);

    HRESULT __stdcall IRunnableObject_IsRunning_Stub(IRunnableObject* This);

    HRESULT __stdcall IMoniker_BindToObject_Proxy(IMoniker* This,

                                                  IBindCtx* pbc,

                                                  IMoniker* pmkToLeft,

                                                  const IID& riidResult,

                                                  void** ppvResult);

    HRESULT __stdcall IMoniker_BindToObject_Stub(IMoniker* This, IBindCtx* pbc, IMoniker* pmkToLeft, const IID& riidResult, IUnknown** ppvResult);

    HRESULT __stdcall IMoniker_BindToStorage_Proxy(IMoniker* This,

                                                   IBindCtx* pbc,

                                                   IMoniker* pmkToLeft,

                                                   const IID& riid,

                                                   void** ppvObj);

    HRESULT __stdcall IMoniker_BindToStorage_Stub(IMoniker* This, IBindCtx* pbc, IMoniker* pmkToLeft, const IID& riid, IUnknown** ppvObj);

    HRESULT __stdcall IEnumSTATSTG_Next_Proxy(IEnumSTATSTG* This,
                                              ULONG celt,

                                              STATSTG* rgelt,

                                              ULONG* pceltFetched);

    HRESULT __stdcall IEnumSTATSTG_Next_Stub(IEnumSTATSTG* This, ULONG celt, STATSTG* rgelt, ULONG* pceltFetched);

    HRESULT __stdcall IStorage_OpenStream_Proxy(IStorage* This,

                                                const OLECHAR* pwcsName,

                                                void* reserved1,
                                                DWORD grfMode,
                                                DWORD reserved2,

                                                IStream** ppstm);

    HRESULT __stdcall IStorage_OpenStream_Stub(
    IStorage* This, const OLECHAR* pwcsName, ULONG cbReserved1, byte* reserved1, DWORD grfMode, DWORD reserved2, IStream** ppstm);

    HRESULT __stdcall IStorage_CopyTo_Proxy(IStorage* This,
                                            DWORD ciidExclude,

                                            const IID* rgiidExclude,

                                            SNB snbExclude,

                                            IStorage* pstgDest);

    HRESULT __stdcall IStorage_CopyTo_Stub(IStorage* This, DWORD ciidExclude, const IID* rgiidExclude, SNB snbExclude, IStorage* pstgDest);

    HRESULT __stdcall IStorage_EnumElements_Proxy(IStorage* This,

                                                  DWORD reserved1,

                                                  void* reserved2,

                                                  DWORD reserved3,

                                                  IEnumSTATSTG** ppenum);

    HRESULT __stdcall IStorage_EnumElements_Stub(
    IStorage* This, DWORD reserved1, ULONG cbReserved2, byte* reserved2, DWORD reserved3, IEnumSTATSTG** ppenum);

    HRESULT __stdcall ILockBytes_ReadAt_Proxy(ILockBytes* This,
                                              ULARGE_INTEGER ulOffset,

                                              void* pv,
                                              ULONG cb,

                                              ULONG* pcbRead);

    HRESULT __stdcall ILockBytes_ReadAt_Stub(ILockBytes* This, ULARGE_INTEGER ulOffset, byte* pv, ULONG cb, ULONG* pcbRead);

    HRESULT __stdcall ILockBytes_WriteAt_Proxy(ILockBytes* This,
                                               ULARGE_INTEGER ulOffset,

                                               const void* pv,
                                               ULONG cb,

                                               ULONG* pcbWritten);

    HRESULT __stdcall ILockBytes_WriteAt_Stub(ILockBytes* This, ULARGE_INTEGER ulOffset, const byte* pv, ULONG cb, ULONG* pcbWritten);

    HRESULT __stdcall IEnumFORMATETC_Next_Proxy(IEnumFORMATETC* This,
                                                ULONG celt,

                                                FORMATETC* rgelt,

                                                ULONG* pceltFetched);

    HRESULT __stdcall IEnumFORMATETC_Next_Stub(IEnumFORMATETC* This, ULONG celt, FORMATETC* rgelt, ULONG* pceltFetched);

    HRESULT __stdcall IEnumSTATDATA_Next_Proxy(IEnumSTATDATA* This,
                                               ULONG celt,

                                               STATDATA* rgelt,

                                               ULONG* pceltFetched);

    HRESULT __stdcall IEnumSTATDATA_Next_Stub(IEnumSTATDATA* This, ULONG celt, STATDATA* rgelt, ULONG* pceltFetched);

    void __stdcall IAdviseSink_OnDataChange_Proxy(IAdviseSink* This,

                                                  FORMATETC* pFormatetc,

                                                  STGMEDIUM* pStgmed);

    HRESULT __stdcall IAdviseSink_OnDataChange_Stub(IAdviseSink* This, FORMATETC* pFormatetc, ASYNC_STGMEDIUM* pStgmed);

    void __stdcall IAdviseSink_OnViewChange_Proxy(IAdviseSink* This, DWORD dwAspect, LONG lindex);

    HRESULT __stdcall IAdviseSink_OnViewChange_Stub(IAdviseSink* This, DWORD dwAspect, LONG lindex);

    void __stdcall IAdviseSink_OnRename_Proxy(IAdviseSink* This,

                                              IMoniker* pmk);

    HRESULT __stdcall IAdviseSink_OnRename_Stub(IAdviseSink* This, IMoniker* pmk);

    void __stdcall IAdviseSink_OnSave_Proxy(IAdviseSink* This);

    HRESULT __stdcall IAdviseSink_OnSave_Stub(IAdviseSink* This);

    void __stdcall IAdviseSink_OnClose_Proxy(IAdviseSink* This);

    HRESULT __stdcall IAdviseSink_OnClose_Stub(IAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Begin_OnDataChange_Proxy(AsyncIAdviseSink* This,

                                                             FORMATETC* pFormatetc,

                                                             STGMEDIUM* pStgmed);

    HRESULT __stdcall AsyncIAdviseSink_Begin_OnDataChange_Stub(AsyncIAdviseSink* This, FORMATETC* pFormatetc, ASYNC_STGMEDIUM* pStgmed);

    void __stdcall AsyncIAdviseSink_Finish_OnDataChange_Proxy(AsyncIAdviseSink* This);

    HRESULT __stdcall AsyncIAdviseSink_Finish_OnDataChange_Stub(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Begin_OnViewChange_Proxy(AsyncIAdviseSink* This, DWORD dwAspect, LONG lindex);

    HRESULT __stdcall AsyncIAdviseSink_Begin_OnViewChange_Stub(AsyncIAdviseSink* This, DWORD dwAspect, LONG lindex);

    void __stdcall AsyncIAdviseSink_Finish_OnViewChange_Proxy(AsyncIAdviseSink* This);

    HRESULT __stdcall AsyncIAdviseSink_Finish_OnViewChange_Stub(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Begin_OnRename_Proxy(AsyncIAdviseSink* This,

                                                         IMoniker* pmk);

    HRESULT __stdcall AsyncIAdviseSink_Begin_OnRename_Stub(AsyncIAdviseSink* This, IMoniker* pmk);

    void __stdcall AsyncIAdviseSink_Finish_OnRename_Proxy(AsyncIAdviseSink* This);

    HRESULT __stdcall AsyncIAdviseSink_Finish_OnRename_Stub(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Begin_OnSave_Proxy(AsyncIAdviseSink* This);

    HRESULT __stdcall AsyncIAdviseSink_Begin_OnSave_Stub(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Finish_OnSave_Proxy(AsyncIAdviseSink* This);

    HRESULT __stdcall AsyncIAdviseSink_Finish_OnSave_Stub(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Begin_OnClose_Proxy(AsyncIAdviseSink* This);

    HRESULT __stdcall AsyncIAdviseSink_Begin_OnClose_Stub(AsyncIAdviseSink* This);

    void __stdcall AsyncIAdviseSink_Finish_OnClose_Proxy(AsyncIAdviseSink* This);

    HRESULT __stdcall AsyncIAdviseSink_Finish_OnClose_Stub(AsyncIAdviseSink* This);

    void __stdcall IAdviseSink2_OnLinkSrcChange_Proxy(IAdviseSink2* This,

                                                      IMoniker* pmk);

    HRESULT __stdcall IAdviseSink2_OnLinkSrcChange_Stub(IAdviseSink2* This, IMoniker* pmk);

    void __stdcall AsyncIAdviseSink2_Begin_OnLinkSrcChange_Proxy(AsyncIAdviseSink2* This,

                                                                 IMoniker* pmk);

    HRESULT __stdcall AsyncIAdviseSink2_Begin_OnLinkSrcChange_Stub(AsyncIAdviseSink2* This, IMoniker* pmk);

    void __stdcall AsyncIAdviseSink2_Finish_OnLinkSrcChange_Proxy(AsyncIAdviseSink2* This);

    HRESULT __stdcall AsyncIAdviseSink2_Finish_OnLinkSrcChange_Stub(AsyncIAdviseSink2* This);

    HRESULT __stdcall IDataObject_GetData_Proxy(IDataObject* This,

                                                FORMATETC* pformatetcIn,

                                                STGMEDIUM* pmedium);

    HRESULT __stdcall IDataObject_GetData_Stub(IDataObject* This, FORMATETC* pformatetcIn, STGMEDIUM* pRemoteMedium);

    HRESULT __stdcall IDataObject_GetDataHere_Proxy(IDataObject* This,

                                                    FORMATETC* pformatetc,

                                                    STGMEDIUM* pmedium);

    HRESULT __stdcall IDataObject_GetDataHere_Stub(IDataObject* This, FORMATETC* pformatetc, STGMEDIUM* pRemoteMedium);

    HRESULT __stdcall IDataObject_SetData_Proxy(IDataObject* This,

                                                FORMATETC* pformatetc,

                                                STGMEDIUM* pmedium,
                                                BOOL fRelease);

    HRESULT __stdcall IDataObject_SetData_Stub(IDataObject* This, FORMATETC* pformatetc, FLAG_STGMEDIUM* pmedium, BOOL fRelease);

    HRESULT __stdcall IFillLockBytes_FillAppend_Proxy(IFillLockBytes* This,

                                                      const void* pv,

                                                      ULONG cb,

                                                      ULONG* pcbWritten);

    HRESULT __stdcall IFillLockBytes_FillAppend_Stub(IFillLockBytes* This, const byte* pv, ULONG cb, ULONG* pcbWritten);

    HRESULT __stdcall IFillLockBytes_FillAt_Proxy(IFillLockBytes* This,

                                                  ULARGE_INTEGER ulOffset,

                                                  const void* pv,

                                                  ULONG cb,

                                                  ULONG* pcbWritten);

    HRESULT __stdcall IFillLockBytes_FillAt_Stub(IFillLockBytes* This, ULARGE_INTEGER ulOffset, const byte* pv, ULONG cb, ULONG* pcbWritten);
}

#pragma once

typedef struct IPropertyStorage IPropertyStorage;

typedef struct IPropertySetStorage IPropertySetStorage;

typedef struct IEnumSTATPROPSTG IEnumSTATPROPSTG;

typedef struct IEnumSTATPROPSETSTG IEnumSTATPROPSETSTG;

#pragma once

typedef struct ICreateTypeInfo ICreateTypeInfo;

typedef struct ICreateTypeInfo2 ICreateTypeInfo2;

typedef struct ICreateTypeLib ICreateTypeLib;

typedef struct ICreateTypeLib2 ICreateTypeLib2;

typedef struct IDispatch IDispatch;

typedef struct IEnumVARIANT IEnumVARIANT;

typedef struct ITypeComp ITypeComp;

typedef struct ITypeInfo ITypeInfo;

typedef struct ITypeInfo2 ITypeInfo2;

typedef struct ITypeLib ITypeLib;

typedef struct ITypeLib2 ITypeLib2;

typedef struct ITypeChangeEvents ITypeChangeEvents;

typedef struct IErrorInfo IErrorInfo;

typedef struct ICreateErrorInfo ICreateErrorInfo;

typedef struct ISupportErrorInfo ISupportErrorInfo;

typedef struct ITypeFactory ITypeFactory;

typedef struct ITypeMarshal ITypeMarshal;

typedef struct IRecordInfo IRecordInfo;

typedef struct IErrorLog IErrorLog;

typedef struct IPropertyBag IPropertyBag;

typedef struct ITypeLibRegistrationReader ITypeLibRegistrationReader;

typedef struct ITypeLibRegistration ITypeLibRegistration;

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)

#pragma once
#pragma region Desktop Family or OneCore Family

#pragma endregion
#pragma region Application Family or OneCore Family

#pragma endregion
#pragma region Desktop Family or OneCore Family or OneCore Family

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0000_v0_0_s_ifspec;

    typedef CY CURRENCY;

    typedef struct tagSAFEARRAYBOUND
    {
        ULONG cElements;
        LONG lLbound;
    } SAFEARRAYBOUND;

    typedef struct tagSAFEARRAYBOUND* LPSAFEARRAYBOUND;

    typedef struct _wireVARIANT* wireVARIANT;

    typedef struct _wireBRECORD* wireBRECORD;

    typedef struct _wireSAFEARR_BSTR
    {
        ULONG Size;
        wireBSTR* aBstr;
    } SAFEARR_BSTR;

    typedef struct _wireSAFEARR_UNKNOWN
    {
        ULONG Size;
        IUnknown** apUnknown;
    } SAFEARR_UNKNOWN;

    typedef struct _wireSAFEARR_DISPATCH
    {
        ULONG Size;
        IDispatch** apDispatch;
    } SAFEARR_DISPATCH;

    typedef struct _wireSAFEARR_VARIANT
    {
        ULONG Size;
        wireVARIANT* aVariant;
    } SAFEARR_VARIANT;

    typedef struct _wireSAFEARR_BRECORD
    {
        ULONG Size;
        wireBRECORD* aRecord;
    } SAFEARR_BRECORD;

    typedef struct _wireSAFEARR_HAVEIID
    {
        ULONG Size;
        IUnknown** apUnknown;
        IID iid;
    } SAFEARR_HAVEIID;

    typedef enum tagSF_TYPE
    {
        SF_ERROR = VT_ERROR,
        SF_I1 = VT_I1,
        SF_I2 = VT_I2,
        SF_I4 = VT_I4,
        SF_I8 = VT_I8,
        SF_BSTR = VT_BSTR,
        SF_UNKNOWN = VT_UNKNOWN,
        SF_DISPATCH = VT_DISPATCH,
        SF_VARIANT = VT_VARIANT,
        SF_RECORD = VT_RECORD,
        SF_HAVEIID = (VT_UNKNOWN | VT_RESERVED)
    } SF_TYPE;

    typedef struct _wireSAFEARRAY_UNION
    {
        ULONG sfType;
        union __MIDL_IOleAutomationTypes_0001
        {
            SAFEARR_BSTR BstrStr;
            SAFEARR_UNKNOWN UnknownStr;
            SAFEARR_DISPATCH DispatchStr;
            SAFEARR_VARIANT VariantStr;
            SAFEARR_BRECORD RecordStr;
            SAFEARR_HAVEIID HaveIidStr;
            BYTE_SIZEDARR ByteStr;
            WORD_SIZEDARR WordStr;
            DWORD_SIZEDARR LongStr;
            HYPER_SIZEDARR HyperStr;
        } u;
    } SAFEARRAYUNION;

    typedef struct _wireSAFEARRAY
    {
        USHORT cDims;
        USHORT fFeatures;
        ULONG cbElements;
        ULONG cLocks;
        SAFEARRAYUNION uArrayStructs;
        SAFEARRAYBOUND rgsabound[1];
    } * wireSAFEARRAY;

    typedef wireSAFEARRAY* wirePSAFEARRAY;

    typedef struct tagSAFEARRAY
    {
        USHORT cDims;
        USHORT fFeatures;
        ULONG cbElements;
        ULONG cLocks;
        PVOID pvData;
        SAFEARRAYBOUND rgsabound[1];
    } SAFEARRAY;

    typedef SAFEARRAY* LPSAFEARRAY;

    typedef struct tagVARIANT VARIANT;

    struct tagVARIANT
    {
        union
        {
            struct
            {
                VARTYPE vt;
                WORD wReserved1;
                WORD wReserved2;
                WORD wReserved3;
                union
                {
                    LONGLONG llVal;
                    LONG lVal;
                    BYTE bVal;
                    SHORT iVal;
                    FLOAT fltVal;
                    DOUBLE dblVal;
                    VARIANT_BOOL boolVal;

                    SCODE scode;
                    CY cyVal;
                    DATE date;
                    BSTR bstrVal;
                    IUnknown* punkVal;
                    IDispatch* pdispVal;
                    SAFEARRAY* parray;
                    BYTE* pbVal;
                    SHORT* piVal;
                    LONG* plVal;
                    LONGLONG* pllVal;
                    FLOAT* pfltVal;
                    DOUBLE* pdblVal;
                    VARIANT_BOOL* pboolVal;

                    SCODE* pscode;
                    CY* pcyVal;
                    DATE* pdate;
                    BSTR* pbstrVal;
                    IUnknown** ppunkVal;
                    IDispatch** ppdispVal;
                    SAFEARRAY** pparray;
                    VARIANT* pvarVal;
                    PVOID byref;
                    CHAR cVal;
                    USHORT uiVal;
                    ULONG ulVal;
                    ULONGLONG ullVal;
                    INT intVal;
                    UINT uintVal;
                    DECIMAL* pdecVal;
                    CHAR* pcVal;
                    USHORT* puiVal;
                    ULONG* pulVal;
                    ULONGLONG* pullVal;
                    INT* pintVal;
                    UINT* puintVal;
                    struct
                    {
                        PVOID pvRecord;
                        IRecordInfo* pRecInfo;
                    };
                };
            };
            DECIMAL decVal;
        };
    };
    typedef VARIANT* LPVARIANT;

    typedef VARIANT VARIANTARG;

    typedef VARIANT* LPVARIANTARG;

    struct _wireBRECORD
    {
        ULONG fFlags;
        ULONG clSize;
        IRecordInfo* pRecInfo;
        byte* pRecord;
    };
    struct _wireVARIANT
    {
        DWORD clSize;
        DWORD rpcReserved;
        USHORT vt;
        USHORT wReserved1;
        USHORT wReserved2;
        USHORT wReserved3;
        union
        {
            LONGLONG llVal;
            LONG lVal;
            BYTE bVal;
            SHORT iVal;
            FLOAT fltVal;
            DOUBLE dblVal;
            VARIANT_BOOL boolVal;
            SCODE scode;
            CY cyVal;
            DATE date;
            wireBSTR bstrVal;
            IUnknown* punkVal;
            IDispatch* pdispVal;
            wirePSAFEARRAY parray;
            wireBRECORD brecVal;
            BYTE* pbVal;
            SHORT* piVal;
            LONG* plVal;
            LONGLONG* pllVal;
            FLOAT* pfltVal;
            DOUBLE* pdblVal;
            VARIANT_BOOL* pboolVal;
            SCODE* pscode;
            CY* pcyVal;
            DATE* pdate;
            wireBSTR* pbstrVal;
            IUnknown** ppunkVal;
            IDispatch** ppdispVal;
            wirePSAFEARRAY* pparray;
            wireVARIANT* pvarVal;
            CHAR cVal;
            USHORT uiVal;
            ULONG ulVal;
            ULONGLONG ullVal;
            INT intVal;
            UINT uintVal;
            DECIMAL decVal;
            DECIMAL* pdecVal;
            CHAR* pcVal;
            USHORT* puiVal;
            ULONG* pulVal;
            ULONGLONG* pullVal;
            INT* pintVal;
            UINT* puintVal;
        };
    };
    typedef LONG DISPID;

    typedef DISPID MEMBERID;

    typedef DWORD HREFTYPE;

    typedef enum tagTYPEKIND
    {
        TKIND_ENUM = 0,
        TKIND_RECORD = (TKIND_ENUM + 1),
        TKIND_MODULE = (TKIND_RECORD + 1),
        TKIND_INTERFACE = (TKIND_MODULE + 1),
        TKIND_DISPATCH = (TKIND_INTERFACE + 1),
        TKIND_COCLASS = (TKIND_DISPATCH + 1),
        TKIND_ALIAS = (TKIND_COCLASS + 1),
        TKIND_UNION = (TKIND_ALIAS + 1),
        TKIND_MAX = (TKIND_UNION + 1)
    } TYPEKIND;

    typedef struct tagTYPEDESC
    {
        union
        {
            struct tagTYPEDESC* lptdesc;
            struct tagARRAYDESC* lpadesc;
            HREFTYPE hreftype;
        };
        VARTYPE vt;
    } TYPEDESC;

    typedef struct tagARRAYDESC
    {
        TYPEDESC tdescElem;
        USHORT cDims;
        SAFEARRAYBOUND rgbounds[1];
    } ARRAYDESC;

    typedef struct tagPARAMDESCEX
    {
        ULONG cBytes;
        VARIANTARG varDefaultValue;
    } PARAMDESCEX;

    typedef struct tagPARAMDESCEX* LPPARAMDESCEX;

    typedef struct tagPARAMDESC
    {
        LPPARAMDESCEX pparamdescex;
        USHORT wParamFlags;
    } PARAMDESC;

    typedef struct tagPARAMDESC* LPPARAMDESC;

    typedef struct tagIDLDESC
    {
        ULONG_PTR dwReserved;
        USHORT wIDLFlags;
    } IDLDESC;

    typedef struct tagIDLDESC* LPIDLDESC;

    typedef struct tagELEMDESC
    {
        TYPEDESC tdesc;
        union
        {
            IDLDESC idldesc;
            PARAMDESC paramdesc;
        };
    } ELEMDESC, *LPELEMDESC;

    typedef struct tagTYPEATTR
    {
        GUID guid;
        LCID lcid;
        DWORD dwReserved;
        MEMBERID memidConstructor;
        MEMBERID memidDestructor;
        LPOLESTR lpstrSchema;
        ULONG cbSizeInstance;
        TYPEKIND typekind;
        WORD cFuncs;
        WORD cVars;
        WORD cImplTypes;
        WORD cbSizeVft;
        WORD cbAlignment;
        WORD wTypeFlags;
        WORD wMajorVerNum;
        WORD wMinorVerNum;
        TYPEDESC tdescAlias;
        IDLDESC idldescType;
    } TYPEATTR;

    typedef struct tagTYPEATTR* LPTYPEATTR;

    typedef struct tagDISPPARAMS
    {
        VARIANTARG* rgvarg;
        DISPID* rgdispidNamedArgs;
        UINT cArgs;
        UINT cNamedArgs;
    } DISPPARAMS;

    typedef struct tagEXCEPINFO
    {
        WORD wCode;
        WORD wReserved;
        BSTR bstrSource;
        BSTR bstrDescription;
        BSTR bstrHelpFile;
        DWORD dwHelpContext;
        PVOID pvReserved;
        HRESULT(__stdcall* pfnDeferredFillIn)(struct tagEXCEPINFO*);
        SCODE scode;
    } EXCEPINFO, *LPEXCEPINFO;

    typedef enum tagCALLCONV
    {
        CC_FASTCALL = 0,
        CC_CDECL = 1,
        CC_MSCPASCAL = (CC_CDECL + 1),
        CC_PASCAL = CC_MSCPASCAL,
        CC_MACPASCAL = (CC_PASCAL + 1),
        CC_STDCALL = (CC_MACPASCAL + 1),
        CC_FPFASTCALL = (CC_STDCALL + 1),
        CC_SYSCALL = (CC_FPFASTCALL + 1),
        CC_MPWCDECL = (CC_SYSCALL + 1),
        CC_MPWPASCAL = (CC_MPWCDECL + 1),
        CC_MAX = (CC_MPWPASCAL + 1)
    } CALLCONV;

    typedef enum tagFUNCKIND
    {
        FUNC_VIRTUAL = 0,
        FUNC_PUREVIRTUAL = (FUNC_VIRTUAL + 1),
        FUNC_NONVIRTUAL = (FUNC_PUREVIRTUAL + 1),
        FUNC_STATIC = (FUNC_NONVIRTUAL + 1),
        FUNC_DISPATCH = (FUNC_STATIC + 1)
    } FUNCKIND;

    typedef enum tagINVOKEKIND
    {
        INVOKE_FUNC = 1,
        INVOKE_PROPERTYGET = 2,
        INVOKE_PROPERTYPUT = 4,
        INVOKE_PROPERTYPUTREF = 8
    } INVOKEKIND;

    typedef struct tagFUNCDESC
    {
        MEMBERID memid;
        SCODE* lprgscode;
        ELEMDESC* lprgelemdescParam;
        FUNCKIND funckind;
        INVOKEKIND invkind;
        CALLCONV callconv;
        SHORT cParams;
        SHORT cParamsOpt;
        SHORT oVft;
        SHORT cScodes;
        ELEMDESC elemdescFunc;
        WORD wFuncFlags;
    } FUNCDESC;

    typedef struct tagFUNCDESC* LPFUNCDESC;

    typedef enum tagVARKIND
    {
        VAR_PERINSTANCE = 0,
        VAR_STATIC = (VAR_PERINSTANCE + 1),
        VAR_CONST = (VAR_STATIC + 1),
        VAR_DISPATCH = (VAR_CONST + 1)
    } VARKIND;

    typedef struct tagVARDESC
    {
        MEMBERID memid;
        LPOLESTR lpstrSchema;
        union
        {
            ULONG oInst;
            VARIANT* lpvarValue;
        };
        ELEMDESC elemdescVar;
        WORD wVarFlags;
        VARKIND varkind;
    } VARDESC;

    typedef struct tagVARDESC* LPVARDESC;

    typedef enum tagTYPEFLAGS
    {
        TYPEFLAG_FAPPOBJECT = 0x1,
        TYPEFLAG_FCANCREATE = 0x2,
        TYPEFLAG_FLICENSED = 0x4,
        TYPEFLAG_FPREDECLID = 0x8,
        TYPEFLAG_FHIDDEN = 0x10,
        TYPEFLAG_FCONTROL = 0x20,
        TYPEFLAG_FDUAL = 0x40,
        TYPEFLAG_FNONEXTENSIBLE = 0x80,
        TYPEFLAG_FOLEAUTOMATION = 0x100,
        TYPEFLAG_FRESTRICTED = 0x200,
        TYPEFLAG_FAGGREGATABLE = 0x400,
        TYPEFLAG_FREPLACEABLE = 0x800,
        TYPEFLAG_FDISPATCHABLE = 0x1000,
        TYPEFLAG_FREVERSEBIND = 0x2000,
        TYPEFLAG_FPROXY = 0x4000
    } TYPEFLAGS;

    typedef enum tagFUNCFLAGS
    {
        FUNCFLAG_FRESTRICTED = 0x1,
        FUNCFLAG_FSOURCE = 0x2,
        FUNCFLAG_FBINDABLE = 0x4,
        FUNCFLAG_FREQUESTEDIT = 0x8,
        FUNCFLAG_FDISPLAYBIND = 0x10,
        FUNCFLAG_FDEFAULTBIND = 0x20,
        FUNCFLAG_FHIDDEN = 0x40,
        FUNCFLAG_FUSESGETLASTERROR = 0x80,
        FUNCFLAG_FDEFAULTCOLLELEM = 0x100,
        FUNCFLAG_FUIDEFAULT = 0x200,
        FUNCFLAG_FNONBROWSABLE = 0x400,
        FUNCFLAG_FREPLACEABLE = 0x800,
        FUNCFLAG_FIMMEDIATEBIND = 0x1000
    } FUNCFLAGS;

    typedef enum tagVARFLAGS
    {
        VARFLAG_FREADONLY = 0x1,
        VARFLAG_FSOURCE = 0x2,
        VARFLAG_FBINDABLE = 0x4,
        VARFLAG_FREQUESTEDIT = 0x8,
        VARFLAG_FDISPLAYBIND = 0x10,
        VARFLAG_FDEFAULTBIND = 0x20,
        VARFLAG_FHIDDEN = 0x40,
        VARFLAG_FRESTRICTED = 0x80,
        VARFLAG_FDEFAULTCOLLELEM = 0x100,
        VARFLAG_FUIDEFAULT = 0x200,
        VARFLAG_FNONBROWSABLE = 0x400,
        VARFLAG_FREPLACEABLE = 0x800,
        VARFLAG_FIMMEDIATEBIND = 0x1000
    } VARFLAGS;

    typedef struct tagCLEANLOCALSTORAGE
    {
        IUnknown* pInterface;
        PVOID pStorage;
        DWORD flags;
    } CLEANLOCALSTORAGE;

    typedef struct tagCUSTDATAITEM
    {
        GUID guid;
        VARIANTARG varValue;
    } CUSTDATAITEM;

    typedef struct tagCUSTDATAITEM* LPCUSTDATAITEM;

    typedef struct tagCUSTDATA
    {
        DWORD cCustData;
        LPCUSTDATAITEM prgCustData;
    } CUSTDATA;

    typedef struct tagCUSTDATA* LPCUSTDATA;

    extern RPC_IF_HANDLE IOleAutomationTypes_v1_0_c_ifspec;
    extern RPC_IF_HANDLE IOleAutomationTypes_v1_0_s_ifspec;

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0001_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0001_v0_0_s_ifspec;

    typedef ICreateTypeInfo* LPCREATETYPEINFO;

    extern "C" const IID IID_ICreateTypeInfo;

    struct __declspec(uuid("00020405-0000-0000-C000-000000000046")) __declspec(novtable) ICreateTypeInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetGuid(const GUID& guid) = 0;

        virtual HRESULT __stdcall SetTypeFlags(UINT uTypeFlags) = 0;

        virtual HRESULT __stdcall SetDocString(

        LPOLESTR pStrDoc)
        = 0;

        virtual HRESULT __stdcall SetHelpContext(DWORD dwHelpContext) = 0;

        virtual HRESULT __stdcall SetVersion(WORD wMajorVerNum, WORD wMinorVerNum) = 0;

        virtual HRESULT __stdcall AddRefTypeInfo(ITypeInfo* pTInfo, HREFTYPE* phRefType) = 0;

        virtual HRESULT __stdcall AddFuncDesc(UINT index, FUNCDESC* pFuncDesc) = 0;

        virtual HRESULT __stdcall AddImplType(UINT index, HREFTYPE hRefType) = 0;

        virtual HRESULT __stdcall SetImplTypeFlags(UINT index, INT implTypeFlags) = 0;

        virtual HRESULT __stdcall SetAlignment(WORD cbAlignment) = 0;

        virtual HRESULT __stdcall SetSchema(

        LPOLESTR pStrSchema)
        = 0;

        virtual HRESULT __stdcall AddVarDesc(UINT index, VARDESC* pVarDesc) = 0;

        virtual HRESULT __stdcall SetFuncAndParamNames(UINT index,

                                                       LPOLESTR* rgszNames,
                                                       UINT cNames)
        = 0;

        virtual HRESULT __stdcall SetVarName(UINT index,

                                             LPOLESTR szName)
        = 0;

        virtual HRESULT __stdcall SetTypeDescAlias(TYPEDESC* pTDescAlias) = 0;

        virtual HRESULT __stdcall DefineFuncAsDllEntry(UINT index,

                                                       LPOLESTR szDllName,

                                                       LPOLESTR szProcName)
        = 0;

        virtual HRESULT __stdcall SetFuncDocString(UINT index,

                                                   LPOLESTR szDocString)
        = 0;

        virtual HRESULT __stdcall SetVarDocString(UINT index,

                                                  LPOLESTR szDocString)
        = 0;

        virtual HRESULT __stdcall SetFuncHelpContext(UINT index, DWORD dwHelpContext) = 0;

        virtual HRESULT __stdcall SetVarHelpContext(UINT index, DWORD dwHelpContext) = 0;

        virtual HRESULT __stdcall SetMops(UINT index,

                                          BSTR bstrMops)
        = 0;

        virtual HRESULT __stdcall SetTypeIdldesc(IDLDESC* pIdlDesc) = 0;

        virtual HRESULT __stdcall LayOut(void) = 0;
    };

    typedef ICreateTypeInfo2* LPCREATETYPEINFO2;

    extern "C" const IID IID_ICreateTypeInfo2;

    struct __declspec(uuid("0002040E-0000-0000-C000-000000000046")) __declspec(novtable) ICreateTypeInfo2 : public ICreateTypeInfo
    {
    public:
        virtual HRESULT __stdcall DeleteFuncDesc(UINT index) = 0;

        virtual HRESULT __stdcall DeleteFuncDescByMemId(MEMBERID memid, INVOKEKIND invKind) = 0;

        virtual HRESULT __stdcall DeleteVarDesc(UINT index) = 0;

        virtual HRESULT __stdcall DeleteVarDescByMemId(MEMBERID memid) = 0;

        virtual HRESULT __stdcall DeleteImplType(UINT index) = 0;

        virtual HRESULT __stdcall SetCustData(const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall SetFuncCustData(UINT index, const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall SetParamCustData(UINT indexFunc, UINT indexParam, const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall SetVarCustData(UINT index, const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall SetImplTypeCustData(UINT index, const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall SetHelpStringContext(ULONG dwHelpStringContext) = 0;

        virtual HRESULT __stdcall SetFuncHelpStringContext(UINT index, ULONG dwHelpStringContext) = 0;

        virtual HRESULT __stdcall SetVarHelpStringContext(UINT index, ULONG dwHelpStringContext) = 0;

        virtual HRESULT __stdcall Invalidate(void) = 0;

        virtual HRESULT __stdcall SetName(

        LPOLESTR szName)
        = 0;
    };

    typedef ICreateTypeLib* LPCREATETYPELIB;

    extern "C" const IID IID_ICreateTypeLib;

    struct __declspec(uuid("00020406-0000-0000-C000-000000000046")) __declspec(novtable) ICreateTypeLib : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateTypeInfo(

        LPOLESTR szName, TYPEKIND tkind, ICreateTypeInfo** ppCTInfo)
        = 0;

        virtual HRESULT __stdcall SetName(

        LPOLESTR szName)
        = 0;

        virtual HRESULT __stdcall SetVersion(WORD wMajorVerNum, WORD wMinorVerNum) = 0;

        virtual HRESULT __stdcall SetGuid(const GUID& guid) = 0;

        virtual HRESULT __stdcall SetDocString(

        LPOLESTR szDoc)
        = 0;

        virtual HRESULT __stdcall SetHelpFileName(

        LPOLESTR szHelpFileName)
        = 0;

        virtual HRESULT __stdcall SetHelpContext(DWORD dwHelpContext) = 0;

        virtual HRESULT __stdcall SetLcid(LCID lcid) = 0;

        virtual HRESULT __stdcall SetLibFlags(UINT uLibFlags) = 0;

        virtual HRESULT __stdcall SaveAllChanges(void) = 0;
    };

    typedef ICreateTypeLib2* LPCREATETYPELIB2;

    extern "C" const IID IID_ICreateTypeLib2;

    struct __declspec(uuid("0002040F-0000-0000-C000-000000000046")) __declspec(novtable) ICreateTypeLib2 : public ICreateTypeLib
    {
    public:
        virtual HRESULT __stdcall DeleteTypeInfo(

        LPOLESTR szName)
        = 0;

        virtual HRESULT __stdcall SetCustData(const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall SetHelpStringContext(ULONG dwHelpStringContext) = 0;

        virtual HRESULT __stdcall SetHelpStringDll(

        LPOLESTR szFileName)
        = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0005_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0005_v0_0_s_ifspec;

    typedef IDispatch* LPDISPATCH;

    extern "C" const IID IID_IDispatch;

    struct __declspec(uuid("00020400-0000-0000-C000-000000000046")) __declspec(novtable) IDispatch : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetTypeInfoCount(UINT* pctinfo) = 0;

        virtual HRESULT __stdcall GetTypeInfo(UINT iTInfo, LCID lcid, ITypeInfo** ppTInfo) = 0;

        virtual HRESULT __stdcall GetIDsOfNames(const IID& riid, LPOLESTR* rgszNames, UINT cNames, LCID lcid, DISPID* rgDispId) = 0;

        virtual HRESULT __stdcall Invoke(

        DISPID dispIdMember,

        const IID& riid,

        LCID lcid,

        WORD wFlags,

        DISPPARAMS* pDispParams,

        VARIANT* pVarResult,

        EXCEPINFO* pExcepInfo,

        UINT* puArgErr)
        = 0;
    };

    HRESULT __stdcall IDispatch_RemoteInvoke_Proxy(IDispatch* This,
                                                   DISPID dispIdMember,
                                                   const IID& riid,
                                                   LCID lcid,
                                                   DWORD dwFlags,
                                                   DISPPARAMS* pDispParams,
                                                   VARIANT* pVarResult,
                                                   EXCEPINFO* pExcepInfo,
                                                   UINT* pArgErr,
                                                   UINT cVarRef,
                                                   UINT* rgVarRefIdx,
                                                   VARIANTARG* rgVarRef);

    void __stdcall IDispatch_RemoteInvoke_Stub(IRpcStubBuffer* This,
                                               IRpcChannelBuffer* _pRpcChannelBuffer,
                                               PRPC_MESSAGE _pRpcMessage,
                                               DWORD* _pdwStubPhase);

    typedef IEnumVARIANT* LPENUMVARIANT;

    extern "C" const IID IID_IEnumVARIANT;

    struct __declspec(uuid("00020404-0000-0000-C000-000000000046")) __declspec(novtable) IEnumVARIANT : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(ULONG celt, VARIANT* rgVar, ULONG* pCeltFetched) = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumVARIANT** ppEnum) = 0;
    };

    HRESULT __stdcall IEnumVARIANT_RemoteNext_Proxy(IEnumVARIANT* This, ULONG celt, VARIANT* rgVar, ULONG* pCeltFetched);

    void __stdcall IEnumVARIANT_RemoteNext_Stub(IRpcStubBuffer* This,
                                                IRpcChannelBuffer* _pRpcChannelBuffer,
                                                PRPC_MESSAGE _pRpcMessage,
                                                DWORD* _pdwStubPhase);

    typedef ITypeComp* LPTYPECOMP;

    typedef enum tagDESCKIND
    {
        DESCKIND_NONE = 0,
        DESCKIND_FUNCDESC = (DESCKIND_NONE + 1),
        DESCKIND_VARDESC = (DESCKIND_FUNCDESC + 1),
        DESCKIND_TYPECOMP = (DESCKIND_VARDESC + 1),
        DESCKIND_IMPLICITAPPOBJ = (DESCKIND_TYPECOMP + 1),
        DESCKIND_MAX = (DESCKIND_IMPLICITAPPOBJ + 1)
    } DESCKIND;

    typedef union tagBINDPTR
    {
        FUNCDESC* lpfuncdesc;
        VARDESC* lpvardesc;
        ITypeComp* lptcomp;
    } BINDPTR;

    typedef union tagBINDPTR* LPBINDPTR;

    extern "C" const IID IID_ITypeComp;

    struct __declspec(uuid("00020403-0000-0000-C000-000000000046")) __declspec(novtable) ITypeComp : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Bind(

        LPOLESTR szName, ULONG lHashVal, WORD wFlags, ITypeInfo** ppTInfo, DESCKIND* pDescKind, BINDPTR* pBindPtr)
        = 0;

        virtual HRESULT __stdcall BindType(

        LPOLESTR szName, ULONG lHashVal, ITypeInfo** ppTInfo, ITypeComp** ppTComp)
        = 0;
    };

    HRESULT __stdcall ITypeComp_RemoteBind_Proxy(ITypeComp* This,
                                                 LPOLESTR szName,
                                                 ULONG lHashVal,
                                                 WORD wFlags,
                                                 ITypeInfo** ppTInfo,
                                                 DESCKIND* pDescKind,
                                                 LPFUNCDESC* ppFuncDesc,
                                                 LPVARDESC* ppVarDesc,
                                                 ITypeComp** ppTypeComp,
                                                 CLEANLOCALSTORAGE* pDummy);

    void __stdcall ITypeComp_RemoteBind_Stub(IRpcStubBuffer* This,
                                             IRpcChannelBuffer* _pRpcChannelBuffer,
                                             PRPC_MESSAGE _pRpcMessage,
                                             DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeComp_RemoteBindType_Proxy(ITypeComp* This, LPOLESTR szName, ULONG lHashVal, ITypeInfo** ppTInfo);

    void __stdcall ITypeComp_RemoteBindType_Stub(IRpcStubBuffer* This,
                                                 IRpcChannelBuffer* _pRpcChannelBuffer,
                                                 PRPC_MESSAGE _pRpcMessage,
                                                 DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0008_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0008_v0_0_s_ifspec;

    typedef ITypeInfo* LPTYPEINFO;

    extern "C" const IID IID_ITypeInfo;

    struct __declspec(uuid("00020401-0000-0000-C000-000000000046")) __declspec(novtable) ITypeInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetTypeAttr(TYPEATTR** ppTypeAttr) = 0;

        virtual HRESULT __stdcall GetTypeComp(ITypeComp** ppTComp) = 0;

        virtual HRESULT __stdcall GetFuncDesc(UINT index, FUNCDESC** ppFuncDesc) = 0;

        virtual HRESULT __stdcall GetVarDesc(UINT index, VARDESC** ppVarDesc) = 0;

        virtual HRESULT __stdcall GetNames(MEMBERID memid,

                                           BSTR* rgBstrNames,
                                           UINT cMaxNames,

                                           UINT* pcNames)
        = 0;

        virtual HRESULT __stdcall GetRefTypeOfImplType(UINT index, HREFTYPE* pRefType) = 0;

        virtual HRESULT __stdcall GetImplTypeFlags(UINT index, INT* pImplTypeFlags) = 0;

        virtual HRESULT __stdcall GetIDsOfNames(

        LPOLESTR* rgszNames, UINT cNames, MEMBERID* pMemId)
        = 0;

        virtual HRESULT __stdcall Invoke(
        PVOID pvInstance, MEMBERID memid, WORD wFlags, DISPPARAMS* pDispParams, VARIANT* pVarResult, EXCEPINFO* pExcepInfo, UINT* puArgErr)
        = 0;

        virtual HRESULT __stdcall GetDocumentation(MEMBERID memid,

                                                   BSTR* pBstrName,

                                                   BSTR* pBstrDocString,
                                                   DWORD* pdwHelpContext,

                                                   BSTR* pBstrHelpFile)
        = 0;

        virtual HRESULT __stdcall GetDllEntry(MEMBERID memid,
                                              INVOKEKIND invKind,

                                              BSTR* pBstrDllName,

                                              BSTR* pBstrName,
                                              WORD* pwOrdinal)
        = 0;

        virtual HRESULT __stdcall GetRefTypeInfo(HREFTYPE hRefType, ITypeInfo** ppTInfo) = 0;

        virtual HRESULT __stdcall AddressOfMember(MEMBERID memid, INVOKEKIND invKind, PVOID* ppv) = 0;

        virtual HRESULT __stdcall CreateInstance(IUnknown* pUnkOuter, const IID& riid, PVOID* ppvObj) = 0;

        virtual HRESULT __stdcall GetMops(MEMBERID memid, BSTR* pBstrMops) = 0;

        virtual HRESULT __stdcall GetContainingTypeLib(ITypeLib** ppTLib, UINT* pIndex) = 0;

        virtual void __stdcall ReleaseTypeAttr(TYPEATTR* pTypeAttr) = 0;

        virtual void __stdcall ReleaseFuncDesc(FUNCDESC* pFuncDesc) = 0;

        virtual void __stdcall ReleaseVarDesc(VARDESC* pVarDesc) = 0;
    };

    HRESULT __stdcall ITypeInfo_RemoteGetTypeAttr_Proxy(ITypeInfo* This, LPTYPEATTR* ppTypeAttr, CLEANLOCALSTORAGE* pDummy);

    void __stdcall ITypeInfo_RemoteGetTypeAttr_Stub(IRpcStubBuffer* This,
                                                    IRpcChannelBuffer* _pRpcChannelBuffer,
                                                    PRPC_MESSAGE _pRpcMessage,
                                                    DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_RemoteGetFuncDesc_Proxy(ITypeInfo* This, UINT index, LPFUNCDESC* ppFuncDesc, CLEANLOCALSTORAGE* pDummy);

    void __stdcall ITypeInfo_RemoteGetFuncDesc_Stub(IRpcStubBuffer* This,
                                                    IRpcChannelBuffer* _pRpcChannelBuffer,
                                                    PRPC_MESSAGE _pRpcMessage,
                                                    DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_RemoteGetVarDesc_Proxy(ITypeInfo* This, UINT index, LPVARDESC* ppVarDesc, CLEANLOCALSTORAGE* pDummy);

    void __stdcall ITypeInfo_RemoteGetVarDesc_Stub(IRpcStubBuffer* This,
                                                   IRpcChannelBuffer* _pRpcChannelBuffer,
                                                   PRPC_MESSAGE _pRpcMessage,
                                                   DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_RemoteGetNames_Proxy(ITypeInfo* This, MEMBERID memid, BSTR* rgBstrNames, UINT cMaxNames, UINT* pcNames);

    void __stdcall ITypeInfo_RemoteGetNames_Stub(IRpcStubBuffer* This,
                                                 IRpcChannelBuffer* _pRpcChannelBuffer,
                                                 PRPC_MESSAGE _pRpcMessage,
                                                 DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_LocalGetIDsOfNames_Proxy(ITypeInfo* This);

    void __stdcall ITypeInfo_LocalGetIDsOfNames_Stub(IRpcStubBuffer* This,
                                                     IRpcChannelBuffer* _pRpcChannelBuffer,
                                                     PRPC_MESSAGE _pRpcMessage,
                                                     DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_LocalInvoke_Proxy(ITypeInfo* This);

    void __stdcall ITypeInfo_LocalInvoke_Stub(IRpcStubBuffer* This,
                                              IRpcChannelBuffer* _pRpcChannelBuffer,
                                              PRPC_MESSAGE _pRpcMessage,
                                              DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_RemoteGetDocumentation_Proxy(
    ITypeInfo* This, MEMBERID memid, DWORD refPtrFlags, BSTR* pBstrName, BSTR* pBstrDocString, DWORD* pdwHelpContext, BSTR* pBstrHelpFile);

    void __stdcall ITypeInfo_RemoteGetDocumentation_Stub(IRpcStubBuffer* This,
                                                         IRpcChannelBuffer* _pRpcChannelBuffer,
                                                         PRPC_MESSAGE _pRpcMessage,
                                                         DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_RemoteGetDllEntry_Proxy(
    ITypeInfo* This, MEMBERID memid, INVOKEKIND invKind, DWORD refPtrFlags, BSTR* pBstrDllName, BSTR* pBstrName, WORD* pwOrdinal);

    void __stdcall ITypeInfo_RemoteGetDllEntry_Stub(IRpcStubBuffer* This,
                                                    IRpcChannelBuffer* _pRpcChannelBuffer,
                                                    PRPC_MESSAGE _pRpcMessage,
                                                    DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_LocalAddressOfMember_Proxy(ITypeInfo* This);

    void __stdcall ITypeInfo_LocalAddressOfMember_Stub(IRpcStubBuffer* This,
                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                       PRPC_MESSAGE _pRpcMessage,
                                                       DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_RemoteCreateInstance_Proxy(ITypeInfo* This, const IID& riid, IUnknown** ppvObj);

    void __stdcall ITypeInfo_RemoteCreateInstance_Stub(IRpcStubBuffer* This,
                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                       PRPC_MESSAGE _pRpcMessage,
                                                       DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_RemoteGetContainingTypeLib_Proxy(ITypeInfo* This, ITypeLib** ppTLib, UINT* pIndex);

    void __stdcall ITypeInfo_RemoteGetContainingTypeLib_Stub(IRpcStubBuffer* This,
                                                             IRpcChannelBuffer* _pRpcChannelBuffer,
                                                             PRPC_MESSAGE _pRpcMessage,
                                                             DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_LocalReleaseTypeAttr_Proxy(ITypeInfo* This);

    void __stdcall ITypeInfo_LocalReleaseTypeAttr_Stub(IRpcStubBuffer* This,
                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                       PRPC_MESSAGE _pRpcMessage,
                                                       DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_LocalReleaseFuncDesc_Proxy(ITypeInfo* This);

    void __stdcall ITypeInfo_LocalReleaseFuncDesc_Stub(IRpcStubBuffer* This,
                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                       PRPC_MESSAGE _pRpcMessage,
                                                       DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeInfo_LocalReleaseVarDesc_Proxy(ITypeInfo* This);

    void __stdcall ITypeInfo_LocalReleaseVarDesc_Stub(IRpcStubBuffer* This,
                                                      IRpcChannelBuffer* _pRpcChannelBuffer,
                                                      PRPC_MESSAGE _pRpcMessage,
                                                      DWORD* _pdwStubPhase);

    typedef ITypeInfo2* LPTYPEINFO2;

    extern "C" const IID IID_ITypeInfo2;

    struct __declspec(uuid("00020412-0000-0000-C000-000000000046")) __declspec(novtable) ITypeInfo2 : public ITypeInfo
    {
    public:
        virtual HRESULT __stdcall GetTypeKind(TYPEKIND* pTypeKind) = 0;

        virtual HRESULT __stdcall GetTypeFlags(ULONG* pTypeFlags) = 0;

        virtual HRESULT __stdcall GetFuncIndexOfMemId(MEMBERID memid, INVOKEKIND invKind, UINT* pFuncIndex) = 0;

        virtual HRESULT __stdcall GetVarIndexOfMemId(MEMBERID memid, UINT* pVarIndex) = 0;

        virtual HRESULT __stdcall GetCustData(const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall GetFuncCustData(UINT index, const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall GetParamCustData(UINT indexFunc, UINT indexParam, const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall GetVarCustData(UINT index, const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall GetImplTypeCustData(UINT index, const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall GetDocumentation2(MEMBERID memid,
                                                    LCID lcid,

                                                    BSTR* pbstrHelpString,
                                                    DWORD* pdwHelpStringContext,

                                                    BSTR* pbstrHelpStringDll)
        = 0;

        virtual HRESULT __stdcall GetAllCustData(CUSTDATA* pCustData) = 0;

        virtual HRESULT __stdcall GetAllFuncCustData(UINT index, CUSTDATA* pCustData) = 0;

        virtual HRESULT __stdcall GetAllParamCustData(UINT indexFunc, UINT indexParam, CUSTDATA* pCustData) = 0;

        virtual HRESULT __stdcall GetAllVarCustData(UINT index, CUSTDATA* pCustData) = 0;

        virtual HRESULT __stdcall GetAllImplTypeCustData(UINT index, CUSTDATA* pCustData) = 0;
    };

    HRESULT __stdcall ITypeInfo2_RemoteGetDocumentation2_Proxy(
    ITypeInfo2* This, MEMBERID memid, LCID lcid, DWORD refPtrFlags, BSTR* pbstrHelpString, DWORD* pdwHelpStringContext, BSTR* pbstrHelpStringDll);

    void __stdcall ITypeInfo2_RemoteGetDocumentation2_Stub(IRpcStubBuffer* This,
                                                           IRpcChannelBuffer* _pRpcChannelBuffer,
                                                           PRPC_MESSAGE _pRpcMessage,
                                                           DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0010_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0010_v0_0_s_ifspec;

    typedef enum tagSYSKIND
    {
        SYS_WIN16 = 0,
        SYS_WIN32 = (SYS_WIN16 + 1),
        SYS_MAC = (SYS_WIN32 + 1),
        SYS_WIN64 = (SYS_MAC + 1)
    } SYSKIND;

    typedef enum tagLIBFLAGS
    {
        LIBFLAG_FRESTRICTED = 0x1,
        LIBFLAG_FCONTROL = 0x2,
        LIBFLAG_FHIDDEN = 0x4,
        LIBFLAG_FHASDISKIMAGE = 0x8
    } LIBFLAGS;

    typedef ITypeLib* LPTYPELIB;

    typedef struct tagTLIBATTR
    {
        GUID guid;
        LCID lcid;
        SYSKIND syskind;
        WORD wMajorVerNum;
        WORD wMinorVerNum;
        WORD wLibFlags;
    } TLIBATTR;

    typedef struct tagTLIBATTR* LPTLIBATTR;

    extern "C" const IID IID_ITypeLib;

    struct __declspec(uuid("00020402-0000-0000-C000-000000000046")) __declspec(novtable) ITypeLib : public IUnknown
    {
    public:
        virtual UINT __stdcall GetTypeInfoCount(void) = 0;

        virtual HRESULT __stdcall GetTypeInfo(UINT index, ITypeInfo** ppTInfo) = 0;

        virtual HRESULT __stdcall GetTypeInfoType(UINT index, TYPEKIND* pTKind) = 0;

        virtual HRESULT __stdcall GetTypeInfoOfGuid(const GUID& guid, ITypeInfo** ppTinfo) = 0;

        virtual HRESULT __stdcall GetLibAttr(TLIBATTR** ppTLibAttr) = 0;

        virtual HRESULT __stdcall GetTypeComp(ITypeComp** ppTComp) = 0;

        virtual HRESULT __stdcall GetDocumentation(INT index,

                                                   BSTR* pBstrName,

                                                   BSTR* pBstrDocString,
                                                   DWORD* pdwHelpContext,

                                                   BSTR* pBstrHelpFile)
        = 0;

        virtual HRESULT __stdcall IsName(

        LPOLESTR szNameBuf, ULONG lHashVal, BOOL* pfName)
        = 0;

        virtual HRESULT __stdcall FindName(

        LPOLESTR szNameBuf, ULONG lHashVal, ITypeInfo** ppTInfo, MEMBERID* rgMemId, USHORT* pcFound)
        = 0;

        virtual void __stdcall ReleaseTLibAttr(TLIBATTR* pTLibAttr) = 0;
    };

    HRESULT __stdcall ITypeLib_RemoteGetTypeInfoCount_Proxy(ITypeLib* This, UINT* pcTInfo);

    void __stdcall ITypeLib_RemoteGetTypeInfoCount_Stub(IRpcStubBuffer* This,
                                                        IRpcChannelBuffer* _pRpcChannelBuffer,
                                                        PRPC_MESSAGE _pRpcMessage,
                                                        DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeLib_RemoteGetLibAttr_Proxy(ITypeLib* This, LPTLIBATTR* ppTLibAttr, CLEANLOCALSTORAGE* pDummy);

    void __stdcall ITypeLib_RemoteGetLibAttr_Stub(IRpcStubBuffer* This,
                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                  PRPC_MESSAGE _pRpcMessage,
                                                  DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeLib_RemoteGetDocumentation_Proxy(
    ITypeLib* This, INT index, DWORD refPtrFlags, BSTR* pBstrName, BSTR* pBstrDocString, DWORD* pdwHelpContext, BSTR* pBstrHelpFile);

    void __stdcall ITypeLib_RemoteGetDocumentation_Stub(IRpcStubBuffer* This,
                                                        IRpcChannelBuffer* _pRpcChannelBuffer,
                                                        PRPC_MESSAGE _pRpcMessage,
                                                        DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeLib_RemoteIsName_Proxy(ITypeLib* This, LPOLESTR szNameBuf, ULONG lHashVal, BOOL* pfName, BSTR* pBstrLibName);

    void __stdcall ITypeLib_RemoteIsName_Stub(IRpcStubBuffer* This,
                                              IRpcChannelBuffer* _pRpcChannelBuffer,
                                              PRPC_MESSAGE _pRpcMessage,
                                              DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeLib_RemoteFindName_Proxy(
    ITypeLib* This, LPOLESTR szNameBuf, ULONG lHashVal, ITypeInfo** ppTInfo, MEMBERID* rgMemId, USHORT* pcFound, BSTR* pBstrLibName);

    void __stdcall ITypeLib_RemoteFindName_Stub(IRpcStubBuffer* This,
                                                IRpcChannelBuffer* _pRpcChannelBuffer,
                                                PRPC_MESSAGE _pRpcMessage,
                                                DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeLib_LocalReleaseTLibAttr_Proxy(ITypeLib* This);

    void __stdcall ITypeLib_LocalReleaseTLibAttr_Stub(IRpcStubBuffer* This,
                                                      IRpcChannelBuffer* _pRpcChannelBuffer,
                                                      PRPC_MESSAGE _pRpcMessage,
                                                      DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0011_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0011_v0_0_s_ifspec;

    typedef ITypeLib2* LPTYPELIB2;

    extern "C" const IID IID_ITypeLib2;

    struct __declspec(uuid("00020411-0000-0000-C000-000000000046")) __declspec(novtable) ITypeLib2 : public ITypeLib
    {
    public:
        virtual HRESULT __stdcall GetCustData(const GUID& guid, VARIANT* pVarVal) = 0;

        virtual HRESULT __stdcall GetLibStatistics(ULONG* pcUniqueNames, ULONG* pcchUniqueNames) = 0;

        virtual HRESULT __stdcall GetDocumentation2(INT index,
                                                    LCID lcid,

                                                    BSTR* pbstrHelpString,
                                                    DWORD* pdwHelpStringContext,

                                                    BSTR* pbstrHelpStringDll)
        = 0;

        virtual HRESULT __stdcall GetAllCustData(CUSTDATA* pCustData) = 0;
    };

    HRESULT __stdcall ITypeLib2_RemoteGetLibStatistics_Proxy(ITypeLib2* This, ULONG* pcUniqueNames, ULONG* pcchUniqueNames);

    void __stdcall ITypeLib2_RemoteGetLibStatistics_Stub(IRpcStubBuffer* This,
                                                         IRpcChannelBuffer* _pRpcChannelBuffer,
                                                         PRPC_MESSAGE _pRpcMessage,
                                                         DWORD* _pdwStubPhase);

    HRESULT __stdcall ITypeLib2_RemoteGetDocumentation2_Proxy(
    ITypeLib2* This, INT index, LCID lcid, DWORD refPtrFlags, BSTR* pbstrHelpString, DWORD* pdwHelpStringContext, BSTR* pbstrHelpStringDll);

    void __stdcall ITypeLib2_RemoteGetDocumentation2_Stub(IRpcStubBuffer* This,
                                                          IRpcChannelBuffer* _pRpcChannelBuffer,
                                                          PRPC_MESSAGE _pRpcMessage,
                                                          DWORD* _pdwStubPhase);

    typedef ITypeChangeEvents* LPTYPECHANGEEVENTS;

    typedef enum tagCHANGEKIND
    {
        CHANGEKIND_ADDMEMBER = 0,
        CHANGEKIND_DELETEMEMBER = (CHANGEKIND_ADDMEMBER + 1),
        CHANGEKIND_SETNAMES = (CHANGEKIND_DELETEMEMBER + 1),
        CHANGEKIND_SETDOCUMENTATION = (CHANGEKIND_SETNAMES + 1),
        CHANGEKIND_GENERAL = (CHANGEKIND_SETDOCUMENTATION + 1),
        CHANGEKIND_INVALIDATE = (CHANGEKIND_GENERAL + 1),
        CHANGEKIND_CHANGEFAILED = (CHANGEKIND_INVALIDATE + 1),
        CHANGEKIND_MAX = (CHANGEKIND_CHANGEFAILED + 1)
    } CHANGEKIND;

    extern "C" const IID IID_ITypeChangeEvents;

    struct __declspec(uuid("00020410-0000-0000-C000-000000000046")) __declspec(novtable) ITypeChangeEvents : public IUnknown
    {
    public:
        virtual HRESULT __stdcall RequestTypeChange(CHANGEKIND changeKind,
                                                    ITypeInfo* pTInfoBefore,

                                                    LPOLESTR pStrName,
                                                    INT* pfCancel)
        = 0;

        virtual HRESULT __stdcall AfterTypeChange(CHANGEKIND changeKind,
                                                  ITypeInfo* pTInfoAfter,

                                                  LPOLESTR pStrName)
        = 0;
    };

    typedef IErrorInfo* LPERRORINFO;

    extern "C" const IID IID_IErrorInfo;

    struct __declspec(uuid("1CF2B120-547D-101B-8E65-08002B2BD119")) __declspec(novtable) IErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetGUID(GUID* pGUID) = 0;

        virtual HRESULT __stdcall GetSource(BSTR* pBstrSource) = 0;

        virtual HRESULT __stdcall GetDescription(BSTR* pBstrDescription) = 0;

        virtual HRESULT __stdcall GetHelpFile(BSTR* pBstrHelpFile) = 0;

        virtual HRESULT __stdcall GetHelpContext(DWORD* pdwHelpContext) = 0;
    };

    typedef ICreateErrorInfo* LPCREATEERRORINFO;

    extern "C" const IID IID_ICreateErrorInfo;

    struct __declspec(uuid("22F03340-547D-101B-8E65-08002B2BD119")) __declspec(novtable) ICreateErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetGUID(const GUID& rguid) = 0;

        virtual HRESULT __stdcall SetSource(LPOLESTR szSource) = 0;

        virtual HRESULT __stdcall SetDescription(LPOLESTR szDescription) = 0;

        virtual HRESULT __stdcall SetHelpFile(LPOLESTR szHelpFile) = 0;

        virtual HRESULT __stdcall SetHelpContext(DWORD dwHelpContext) = 0;
    };

    typedef ISupportErrorInfo* LPSUPPORTERRORINFO;

    extern "C" const IID IID_ISupportErrorInfo;

    struct __declspec(uuid("DF0B3D60-548F-101B-8E65-08002B2BD119")) __declspec(novtable) ISupportErrorInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall InterfaceSupportsErrorInfo(const IID& riid) = 0;
    };

    extern "C" const IID IID_ITypeFactory;

    struct __declspec(uuid("0000002E-0000-0000-C000-000000000046")) __declspec(novtable) ITypeFactory : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateFromTypeInfo(ITypeInfo* pTypeInfo, const IID& riid, IUnknown** ppv) = 0;
    };

    extern "C" const IID IID_ITypeMarshal;

    struct __declspec(uuid("0000002D-0000-0000-C000-000000000046")) __declspec(novtable) ITypeMarshal : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Size(PVOID pvType, DWORD dwDestContext, PVOID pvDestContext, ULONG* pSize) = 0;

        virtual HRESULT __stdcall Marshal(PVOID pvType,
                                          DWORD dwDestContext,
                                          PVOID pvDestContext,
                                          ULONG cbBufferLength,

                                          BYTE* pBuffer,

                                          ULONG* pcbWritten)
        = 0;

        virtual HRESULT __stdcall Unmarshal(PVOID pvType,
                                            DWORD dwFlags,
                                            ULONG cbBufferLength,

                                            BYTE* pBuffer,

                                            ULONG* pcbRead)
        = 0;

        virtual HRESULT __stdcall Free(PVOID pvType) = 0;
    };

    typedef IRecordInfo* LPRECORDINFO;

    extern "C" const IID IID_IRecordInfo;

    struct __declspec(uuid("0000002F-0000-0000-C000-000000000046")) __declspec(novtable) IRecordInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall RecordInit(PVOID pvNew) = 0;

        virtual HRESULT __stdcall RecordClear(PVOID pvExisting) = 0;

        virtual HRESULT __stdcall RecordCopy(PVOID pvExisting, PVOID pvNew) = 0;

        virtual HRESULT __stdcall GetGuid(GUID* pguid) = 0;

        virtual HRESULT __stdcall GetName(

        BSTR* pbstrName)
        = 0;

        virtual HRESULT __stdcall GetSize(ULONG* pcbSize) = 0;

        virtual HRESULT __stdcall GetTypeInfo(ITypeInfo** ppTypeInfo) = 0;

        virtual HRESULT __stdcall GetField(PVOID pvData, LPCOLESTR szFieldName, VARIANT* pvarField) = 0;

        virtual HRESULT __stdcall GetFieldNoCopy(PVOID pvData, LPCOLESTR szFieldName, VARIANT* pvarField, PVOID* ppvDataCArray) = 0;

        virtual HRESULT __stdcall PutField(ULONG wFlags, PVOID pvData, LPCOLESTR szFieldName, VARIANT* pvarField) = 0;

        virtual HRESULT __stdcall PutFieldNoCopy(ULONG wFlags, PVOID pvData, LPCOLESTR szFieldName, VARIANT* pvarField) = 0;

        virtual HRESULT __stdcall GetFieldNames(ULONG* pcNames,

                                                BSTR* rgBstrNames)
        = 0;

        virtual BOOL __stdcall IsMatchingType(IRecordInfo* pRecordInfo) = 0;

        virtual PVOID __stdcall RecordCreate(void) = 0;

        virtual HRESULT __stdcall RecordCreateCopy(PVOID pvSource, PVOID* ppvDest) = 0;

        virtual HRESULT __stdcall RecordDestroy(PVOID pvRecord) = 0;
    };

    typedef IErrorLog* LPERRORLOG;

    extern "C" const IID IID_IErrorLog;

    struct __declspec(uuid("3127CA40-446E-11CE-8135-00AA004BB851")) __declspec(novtable) IErrorLog : public IUnknown
    {
    public:
        virtual HRESULT __stdcall AddError(LPCOLESTR pszPropName, EXCEPINFO* pExcepInfo) = 0;
    };

    typedef IPropertyBag* LPPROPERTYBAG;

    extern "C" const IID IID_IPropertyBag;

    struct __declspec(uuid("55272A00-42CB-11CE-8135-00AA004BB851")) __declspec(novtable) IPropertyBag : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Read(LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog* pErrorLog) = 0;

        virtual HRESULT __stdcall Write(LPCOLESTR pszPropName, VARIANT* pVar) = 0;
    };

    HRESULT __stdcall IPropertyBag_RemoteRead_Proxy(
    IPropertyBag* This, LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog* pErrorLog, DWORD varType, IUnknown* pUnkObj);

    void __stdcall IPropertyBag_RemoteRead_Stub(IRpcStubBuffer* This,
                                                IRpcChannelBuffer* _pRpcChannelBuffer,
                                                PRPC_MESSAGE _pRpcMessage,
                                                DWORD* _pdwStubPhase);

    extern "C" const IID IID_ITypeLibRegistrationReader;

    struct __declspec(uuid("ED6A8A2A-B160-4E77-8F73-AA7435CD5C27")) __declspec(novtable) ITypeLibRegistrationReader : public IUnknown
    {
    public:
        virtual HRESULT __stdcall EnumTypeLibRegistrations(IEnumUnknown** ppEnumUnknown) = 0;
    };

    extern "C" const IID IID_ITypeLibRegistration;

    struct __declspec(uuid("76A3E735-02DF-4A12-98EB-043AD3600AF3")) __declspec(novtable) ITypeLibRegistration : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetGuid(GUID* pGuid) = 0;

        virtual HRESULT __stdcall GetVersion(BSTR* pVersion) = 0;

        virtual HRESULT __stdcall GetLcid(LCID* pLcid) = 0;

        virtual HRESULT __stdcall GetWin32Path(BSTR* pWin32Path) = 0;

        virtual HRESULT __stdcall GetWin64Path(BSTR* pWin64Path) = 0;

        virtual HRESULT __stdcall GetDisplayName(BSTR* pDisplayName) = 0;

        virtual HRESULT __stdcall GetFlags(DWORD* pFlags) = 0;

        virtual HRESULT __stdcall GetHelpDir(BSTR* pHelpDir) = 0;
    };

    extern "C" const CLSID CLSID_TypeLibRegistrationReader;
#pragma endregion

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0023_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oaidl_0000_0023_v0_0_s_ifspec;

    unsigned long __stdcall BSTR_UserSize(unsigned long*, unsigned long, BSTR*);
    unsigned char* __stdcall BSTR_UserMarshal(unsigned long*, unsigned char*, BSTR*);
    unsigned char* __stdcall BSTR_UserUnmarshal(unsigned long*, unsigned char*, BSTR*);
    void __stdcall BSTR_UserFree(unsigned long*, BSTR*);

    unsigned long __stdcall CLEANLOCALSTORAGE_UserSize(unsigned long*, unsigned long, CLEANLOCALSTORAGE*);
    unsigned char* __stdcall CLEANLOCALSTORAGE_UserMarshal(unsigned long*, unsigned char*, CLEANLOCALSTORAGE*);
    unsigned char* __stdcall CLEANLOCALSTORAGE_UserUnmarshal(unsigned long*, unsigned char*, CLEANLOCALSTORAGE*);
    void __stdcall CLEANLOCALSTORAGE_UserFree(unsigned long*, CLEANLOCALSTORAGE*);

    unsigned long __stdcall VARIANT_UserSize(unsigned long*, unsigned long, VARIANT*);
    unsigned char* __stdcall VARIANT_UserMarshal(unsigned long*, unsigned char*, VARIANT*);
    unsigned char* __stdcall VARIANT_UserUnmarshal(unsigned long*, unsigned char*, VARIANT*);
    void __stdcall VARIANT_UserFree(unsigned long*, VARIANT*);

    unsigned long __stdcall BSTR_UserSize64(unsigned long*, unsigned long, BSTR*);
    unsigned char* __stdcall BSTR_UserMarshal64(unsigned long*, unsigned char*, BSTR*);
    unsigned char* __stdcall BSTR_UserUnmarshal64(unsigned long*, unsigned char*, BSTR*);
    void __stdcall BSTR_UserFree64(unsigned long*, BSTR*);

    unsigned long __stdcall CLEANLOCALSTORAGE_UserSize64(unsigned long*, unsigned long, CLEANLOCALSTORAGE*);
    unsigned char* __stdcall CLEANLOCALSTORAGE_UserMarshal64(unsigned long*, unsigned char*, CLEANLOCALSTORAGE*);
    unsigned char* __stdcall CLEANLOCALSTORAGE_UserUnmarshal64(unsigned long*, unsigned char*, CLEANLOCALSTORAGE*);
    void __stdcall CLEANLOCALSTORAGE_UserFree64(unsigned long*, CLEANLOCALSTORAGE*);

    unsigned long __stdcall VARIANT_UserSize64(unsigned long*, unsigned long, VARIANT*);
    unsigned char* __stdcall VARIANT_UserMarshal64(unsigned long*, unsigned char*, VARIANT*);
    unsigned char* __stdcall VARIANT_UserUnmarshal64(unsigned long*, unsigned char*, VARIANT*);
    void __stdcall VARIANT_UserFree64(unsigned long*, VARIANT*);

    HRESULT __stdcall IDispatch_Invoke_Proxy(IDispatch* This,

                                             DISPID dispIdMember,

                                             const IID& riid,

                                             LCID lcid,

                                             WORD wFlags,

                                             DISPPARAMS* pDispParams,

                                             VARIANT* pVarResult,

                                             EXCEPINFO* pExcepInfo,

                                             UINT* puArgErr);

    HRESULT __stdcall IDispatch_Invoke_Stub(IDispatch* This,
                                            DISPID dispIdMember,
                                            const IID& riid,
                                            LCID lcid,
                                            DWORD dwFlags,
                                            DISPPARAMS* pDispParams,
                                            VARIANT* pVarResult,
                                            EXCEPINFO* pExcepInfo,
                                            UINT* pArgErr,
                                            UINT cVarRef,
                                            UINT* rgVarRefIdx,
                                            VARIANTARG* rgVarRef);

    HRESULT __stdcall IEnumVARIANT_Next_Proxy(IEnumVARIANT* This, ULONG celt, VARIANT* rgVar, ULONG* pCeltFetched);

    HRESULT __stdcall IEnumVARIANT_Next_Stub(IEnumVARIANT* This, ULONG celt, VARIANT* rgVar, ULONG* pCeltFetched);

    HRESULT __stdcall ITypeComp_Bind_Proxy(ITypeComp* This,

                                           LPOLESTR szName,
                                           ULONG lHashVal,
                                           WORD wFlags,
                                           ITypeInfo** ppTInfo,
                                           DESCKIND* pDescKind,
                                           BINDPTR* pBindPtr);

    HRESULT __stdcall ITypeComp_Bind_Stub(ITypeComp* This,
                                          LPOLESTR szName,
                                          ULONG lHashVal,
                                          WORD wFlags,
                                          ITypeInfo** ppTInfo,
                                          DESCKIND* pDescKind,
                                          LPFUNCDESC* ppFuncDesc,
                                          LPVARDESC* ppVarDesc,
                                          ITypeComp** ppTypeComp,
                                          CLEANLOCALSTORAGE* pDummy);

    HRESULT __stdcall ITypeComp_BindType_Proxy(ITypeComp* This,

                                               LPOLESTR szName,
                                               ULONG lHashVal,
                                               ITypeInfo** ppTInfo,
                                               ITypeComp** ppTComp);

    HRESULT __stdcall ITypeComp_BindType_Stub(ITypeComp* This, LPOLESTR szName, ULONG lHashVal, ITypeInfo** ppTInfo);

    HRESULT __stdcall ITypeInfo_GetTypeAttr_Proxy(ITypeInfo* This, TYPEATTR** ppTypeAttr);

    HRESULT __stdcall ITypeInfo_GetTypeAttr_Stub(ITypeInfo* This, LPTYPEATTR* ppTypeAttr, CLEANLOCALSTORAGE* pDummy);

    HRESULT __stdcall ITypeInfo_GetFuncDesc_Proxy(ITypeInfo* This, UINT index, FUNCDESC** ppFuncDesc);

    HRESULT __stdcall ITypeInfo_GetFuncDesc_Stub(ITypeInfo* This, UINT index, LPFUNCDESC* ppFuncDesc, CLEANLOCALSTORAGE* pDummy);

    HRESULT __stdcall ITypeInfo_GetVarDesc_Proxy(ITypeInfo* This, UINT index, VARDESC** ppVarDesc);

    HRESULT __stdcall ITypeInfo_GetVarDesc_Stub(ITypeInfo* This, UINT index, LPVARDESC* ppVarDesc, CLEANLOCALSTORAGE* pDummy);

    HRESULT __stdcall ITypeInfo_GetNames_Proxy(ITypeInfo* This,
                                               MEMBERID memid,

                                               BSTR* rgBstrNames,
                                               UINT cMaxNames,

                                               UINT* pcNames);

    HRESULT __stdcall ITypeInfo_GetNames_Stub(ITypeInfo* This, MEMBERID memid, BSTR* rgBstrNames, UINT cMaxNames, UINT* pcNames);

    HRESULT __stdcall ITypeInfo_GetIDsOfNames_Proxy(ITypeInfo* This,

                                                    LPOLESTR* rgszNames,
                                                    UINT cNames,
                                                    MEMBERID* pMemId);

    HRESULT __stdcall ITypeInfo_GetIDsOfNames_Stub(ITypeInfo* This);

    HRESULT __stdcall ITypeInfo_Invoke_Proxy(ITypeInfo* This,
                                             PVOID pvInstance,
                                             MEMBERID memid,
                                             WORD wFlags,
                                             DISPPARAMS* pDispParams,
                                             VARIANT* pVarResult,
                                             EXCEPINFO* pExcepInfo,
                                             UINT* puArgErr);

    HRESULT __stdcall ITypeInfo_Invoke_Stub(ITypeInfo* This);

    HRESULT __stdcall ITypeInfo_GetDocumentation_Proxy(ITypeInfo* This,
                                                       MEMBERID memid,

                                                       BSTR* pBstrName,

                                                       BSTR* pBstrDocString,
                                                       DWORD* pdwHelpContext,

                                                       BSTR* pBstrHelpFile);

    HRESULT __stdcall ITypeInfo_GetDocumentation_Stub(
    ITypeInfo* This, MEMBERID memid, DWORD refPtrFlags, BSTR* pBstrName, BSTR* pBstrDocString, DWORD* pdwHelpContext, BSTR* pBstrHelpFile);

    HRESULT __stdcall ITypeInfo_GetDllEntry_Proxy(ITypeInfo* This,
                                                  MEMBERID memid,
                                                  INVOKEKIND invKind,

                                                  BSTR* pBstrDllName,

                                                  BSTR* pBstrName,
                                                  WORD* pwOrdinal);

    HRESULT __stdcall ITypeInfo_GetDllEntry_Stub(
    ITypeInfo* This, MEMBERID memid, INVOKEKIND invKind, DWORD refPtrFlags, BSTR* pBstrDllName, BSTR* pBstrName, WORD* pwOrdinal);

    HRESULT __stdcall ITypeInfo_AddressOfMember_Proxy(ITypeInfo* This, MEMBERID memid, INVOKEKIND invKind, PVOID* ppv);

    HRESULT __stdcall ITypeInfo_AddressOfMember_Stub(ITypeInfo* This);

    HRESULT __stdcall ITypeInfo_CreateInstance_Proxy(ITypeInfo* This, IUnknown* pUnkOuter, const IID& riid, PVOID* ppvObj);

    HRESULT __stdcall ITypeInfo_CreateInstance_Stub(ITypeInfo* This, const IID& riid, IUnknown** ppvObj);

    HRESULT __stdcall ITypeInfo_GetContainingTypeLib_Proxy(ITypeInfo* This, ITypeLib** ppTLib, UINT* pIndex);

    HRESULT __stdcall ITypeInfo_GetContainingTypeLib_Stub(ITypeInfo* This, ITypeLib** ppTLib, UINT* pIndex);

    void __stdcall ITypeInfo_ReleaseTypeAttr_Proxy(ITypeInfo* This, TYPEATTR* pTypeAttr);

    HRESULT __stdcall ITypeInfo_ReleaseTypeAttr_Stub(ITypeInfo* This);

    void __stdcall ITypeInfo_ReleaseFuncDesc_Proxy(ITypeInfo* This, FUNCDESC* pFuncDesc);

    HRESULT __stdcall ITypeInfo_ReleaseFuncDesc_Stub(ITypeInfo* This);

    void __stdcall ITypeInfo_ReleaseVarDesc_Proxy(ITypeInfo* This, VARDESC* pVarDesc);

    HRESULT __stdcall ITypeInfo_ReleaseVarDesc_Stub(ITypeInfo* This);

    HRESULT __stdcall ITypeInfo2_GetDocumentation2_Proxy(ITypeInfo2* This,
                                                         MEMBERID memid,
                                                         LCID lcid,

                                                         BSTR* pbstrHelpString,
                                                         DWORD* pdwHelpStringContext,

                                                         BSTR* pbstrHelpStringDll);

    HRESULT __stdcall ITypeInfo2_GetDocumentation2_Stub(
    ITypeInfo2* This, MEMBERID memid, LCID lcid, DWORD refPtrFlags, BSTR* pbstrHelpString, DWORD* pdwHelpStringContext, BSTR* pbstrHelpStringDll);

    UINT __stdcall ITypeLib_GetTypeInfoCount_Proxy(ITypeLib* This);

    HRESULT __stdcall ITypeLib_GetTypeInfoCount_Stub(ITypeLib* This, UINT* pcTInfo);

    HRESULT __stdcall ITypeLib_GetLibAttr_Proxy(ITypeLib* This, TLIBATTR** ppTLibAttr);

    HRESULT __stdcall ITypeLib_GetLibAttr_Stub(ITypeLib* This, LPTLIBATTR* ppTLibAttr, CLEANLOCALSTORAGE* pDummy);

    HRESULT __stdcall ITypeLib_GetDocumentation_Proxy(ITypeLib* This,
                                                      INT index,

                                                      BSTR* pBstrName,

                                                      BSTR* pBstrDocString,
                                                      DWORD* pdwHelpContext,

                                                      BSTR* pBstrHelpFile);

    HRESULT __stdcall ITypeLib_GetDocumentation_Stub(
    ITypeLib* This, INT index, DWORD refPtrFlags, BSTR* pBstrName, BSTR* pBstrDocString, DWORD* pdwHelpContext, BSTR* pBstrHelpFile);

    HRESULT __stdcall ITypeLib_IsName_Proxy(ITypeLib* This,

                                            LPOLESTR szNameBuf,
                                            ULONG lHashVal,
                                            BOOL* pfName);

    HRESULT __stdcall ITypeLib_IsName_Stub(ITypeLib* This, LPOLESTR szNameBuf, ULONG lHashVal, BOOL* pfName, BSTR* pBstrLibName);

    HRESULT __stdcall ITypeLib_FindName_Proxy(ITypeLib* This,

                                              LPOLESTR szNameBuf,
                                              ULONG lHashVal,
                                              ITypeInfo** ppTInfo,
                                              MEMBERID* rgMemId,
                                              USHORT* pcFound);

    HRESULT __stdcall ITypeLib_FindName_Stub(
    ITypeLib* This, LPOLESTR szNameBuf, ULONG lHashVal, ITypeInfo** ppTInfo, MEMBERID* rgMemId, USHORT* pcFound, BSTR* pBstrLibName);

    void __stdcall ITypeLib_ReleaseTLibAttr_Proxy(ITypeLib* This, TLIBATTR* pTLibAttr);

    HRESULT __stdcall ITypeLib_ReleaseTLibAttr_Stub(ITypeLib* This);

    HRESULT __stdcall ITypeLib2_GetLibStatistics_Proxy(ITypeLib2* This, ULONG* pcUniqueNames, ULONG* pcchUniqueNames);

    HRESULT __stdcall ITypeLib2_GetLibStatistics_Stub(ITypeLib2* This, ULONG* pcUniqueNames, ULONG* pcchUniqueNames);

    HRESULT __stdcall ITypeLib2_GetDocumentation2_Proxy(ITypeLib2* This,
                                                        INT index,
                                                        LCID lcid,

                                                        BSTR* pbstrHelpString,
                                                        DWORD* pdwHelpStringContext,

                                                        BSTR* pbstrHelpStringDll);

    HRESULT __stdcall ITypeLib2_GetDocumentation2_Stub(
    ITypeLib2* This, INT index, LCID lcid, DWORD refPtrFlags, BSTR* pbstrHelpString, DWORD* pdwHelpStringContext, BSTR* pbstrHelpStringDll);

    HRESULT __stdcall IPropertyBag_Read_Proxy(IPropertyBag* This, LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog* pErrorLog);

    HRESULT __stdcall IPropertyBag_Read_Stub(
    IPropertyBag* This, LPCOLESTR pszPropName, VARIANT* pVar, IErrorLog* pErrorLog, DWORD varType, IUnknown* pUnkObj);
}

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)
#pragma warning(disable : 4237)

#pragma once

#pragma region Application Family or OneCore Family

    typedef struct tagVersionedStream
    {
        GUID guidVersion;
        IStream* pStream;
    } VERSIONEDSTREAM;

    typedef struct tagVersionedStream* LPVERSIONEDSTREAM;

    typedef struct tagPROPVARIANT PROPVARIANT;
    typedef struct tagCAC
    {
        ULONG cElems;
        CHAR* pElems;
    } CAC;

    typedef struct tagCAUB
    {
        ULONG cElems;
        UCHAR* pElems;
    } CAUB;

    typedef struct tagCAI
    {
        ULONG cElems;
        SHORT* pElems;
    } CAI;

    typedef struct tagCAUI
    {
        ULONG cElems;
        USHORT* pElems;
    } CAUI;

    typedef struct tagCAL
    {
        ULONG cElems;
        LONG* pElems;
    } CAL;

    typedef struct tagCAUL
    {
        ULONG cElems;
        ULONG* pElems;
    } CAUL;

    typedef struct tagCAFLT
    {
        ULONG cElems;
        FLOAT* pElems;
    } CAFLT;

    typedef struct tagCADBL
    {
        ULONG cElems;
        DOUBLE* pElems;
    } CADBL;

    typedef struct tagCACY
    {
        ULONG cElems;
        CY* pElems;
    } CACY;

    typedef struct tagCADATE
    {
        ULONG cElems;
        DATE* pElems;
    } CADATE;

    typedef struct tagCABSTR
    {
        ULONG cElems;
        BSTR* pElems;
    } CABSTR;

    typedef struct tagCABSTRBLOB
    {
        ULONG cElems;
        BSTRBLOB* pElems;
    } CABSTRBLOB;

    typedef struct tagCABOOL
    {
        ULONG cElems;
        VARIANT_BOOL* pElems;
    } CABOOL;

    typedef struct tagCASCODE
    {
        ULONG cElems;
        SCODE* pElems;
    } CASCODE;

    typedef struct tagCAPROPVARIANT
    {
        ULONG cElems;
        PROPVARIANT* pElems;
    } CAPROPVARIANT;

    typedef struct tagCAH
    {
        ULONG cElems;
        LARGE_INTEGER* pElems;
    } CAH;

    typedef struct tagCAUH
    {
        ULONG cElems;
        ULARGE_INTEGER* pElems;
    } CAUH;

    typedef struct tagCALPSTR
    {
        ULONG cElems;
        LPSTR* pElems;
    } CALPSTR;

    typedef struct tagCALPWSTR
    {
        ULONG cElems;
        LPWSTR* pElems;
    } CALPWSTR;

    typedef struct tagCAFILETIME
    {
        ULONG cElems;
        FILETIME* pElems;
    } CAFILETIME;

    typedef struct tagCACLIPDATA
    {
        ULONG cElems;
        CLIPDATA* pElems;
    } CACLIPDATA;

    typedef struct tagCACLSID
    {
        ULONG cElems;
        CLSID* pElems;
    } CACLSID;

    typedef WORD PROPVAR_PAD1;
    typedef WORD PROPVAR_PAD2;
    typedef WORD PROPVAR_PAD3;

    struct tagPROPVARIANT
    {
        union
        {
            struct
            {
                VARTYPE vt;
                PROPVAR_PAD1 wReserved1;
                PROPVAR_PAD2 wReserved2;
                PROPVAR_PAD3 wReserved3;
                union
                {
                    CHAR cVal;
                    UCHAR bVal;
                    SHORT iVal;
                    USHORT uiVal;
                    LONG lVal;
                    ULONG ulVal;
                    INT intVal;
                    UINT uintVal;
                    LARGE_INTEGER hVal;
                    ULARGE_INTEGER uhVal;
                    FLOAT fltVal;
                    DOUBLE dblVal;
                    VARIANT_BOOL boolVal;

                    SCODE scode;
                    CY cyVal;
                    DATE date;
                    FILETIME filetime;
                    CLSID* puuid;
                    CLIPDATA* pclipdata;
                    BSTR bstrVal;
                    BSTRBLOB bstrblobVal;
                    BLOB blob;
                    LPSTR pszVal;
                    LPWSTR pwszVal;
                    IUnknown* punkVal;
                    IDispatch* pdispVal;
                    IStream* pStream;
                    IStorage* pStorage;
                    LPVERSIONEDSTREAM pVersionedStream;
                    LPSAFEARRAY parray;
                    CAC cac;
                    CAUB caub;
                    CAI cai;
                    CAUI caui;
                    CAL cal;
                    CAUL caul;
                    CAH cah;
                    CAUH cauh;
                    CAFLT caflt;
                    CADBL cadbl;
                    CABOOL cabool;
                    CASCODE cascode;
                    CACY cacy;
                    CADATE cadate;
                    CAFILETIME cafiletime;
                    CACLSID cauuid;
                    CACLIPDATA caclipdata;
                    CABSTR cabstr;
                    CABSTRBLOB cabstrblob;
                    CALPSTR calpstr;
                    CALPWSTR calpwstr;
                    CAPROPVARIANT capropvar;
                    CHAR* pcVal;
                    UCHAR* pbVal;
                    SHORT* piVal;
                    USHORT* puiVal;
                    LONG* plVal;
                    ULONG* pulVal;
                    INT* pintVal;
                    UINT* puintVal;
                    FLOAT* pfltVal;
                    DOUBLE* pdblVal;
                    VARIANT_BOOL* pboolVal;
                    DECIMAL* pdecVal;
                    SCODE* pscode;
                    CY* pcyVal;
                    DATE* pdate;
                    BSTR* pbstrVal;
                    IUnknown** ppunkVal;
                    IDispatch** ppdispVal;
                    LPSAFEARRAY* pparray;
                    PROPVARIANT* pvarVal;
                };
            };

            DECIMAL decVal;
        };
    };

    typedef struct tagPROPVARIANT* LPPROPVARIANT;

    typedef struct tagPROPSPEC
    {
        ULONG ulKind;
        union
        {
            PROPID propid;
            LPOLESTR lpwstr;
        };
    } PROPSPEC;

    typedef struct tagSTATPROPSTG
    {
        LPOLESTR lpwstrName;
        PROPID propid;
        VARTYPE vt;
    } STATPROPSTG;

    typedef struct tagSTATPROPSETSTG
    {
        FMTID fmtid;
        CLSID clsid;
        DWORD grfFlags;
        FILETIME mtime;
        FILETIME ctime;
        FILETIME atime;
        DWORD dwOSVersion;
    } STATPROPSETSTG;

    extern RPC_IF_HANDLE __MIDL_itf_propidlbase_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_propidlbase_0000_0000_v0_0_s_ifspec;

    extern "C" const IID IID_IPropertyStorage;

    struct __declspec(uuid("00000138-0000-0000-C000-000000000046")) __declspec(novtable) IPropertyStorage : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ReadMultiple(ULONG cpspec, const PROPSPEC rgpspec[], PROPVARIANT rgpropvar[]) = 0;

        virtual HRESULT __stdcall WriteMultiple(ULONG cpspec, const PROPSPEC rgpspec[], const PROPVARIANT rgpropvar[], PROPID propidNameFirst)
        = 0;

        virtual HRESULT __stdcall DeleteMultiple(ULONG cpspec, const PROPSPEC rgpspec[]) = 0;

        virtual HRESULT __stdcall ReadPropertyNames(ULONG cpropid, const PROPID rgpropid[], LPOLESTR rglpwstrName[]) = 0;

        virtual HRESULT __stdcall WritePropertyNames(ULONG cpropid, const PROPID rgpropid[], const LPOLESTR rglpwstrName[]) = 0;

        virtual HRESULT __stdcall DeletePropertyNames(ULONG cpropid, const PROPID rgpropid[]) = 0;

        virtual HRESULT __stdcall Commit(DWORD grfCommitFlags) = 0;

        virtual HRESULT __stdcall Revert(void) = 0;

        virtual HRESULT __stdcall Enum(IEnumSTATPROPSTG** ppenum) = 0;

        virtual HRESULT __stdcall SetTimes(const FILETIME* pctime, const FILETIME* patime, const FILETIME* pmtime) = 0;

        virtual HRESULT __stdcall SetClass(const IID& clsid) = 0;

        virtual HRESULT __stdcall Stat(STATPROPSETSTG* pstatpsstg) = 0;
    };

    typedef IPropertySetStorage* LPPROPERTYSETSTORAGE;

    extern "C" const IID IID_IPropertySetStorage;

    struct __declspec(uuid("0000013A-0000-0000-C000-000000000046")) __declspec(novtable) IPropertySetStorage : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Create(const IID& rfmtid, const CLSID* pclsid, DWORD grfFlags, DWORD grfMode, IPropertyStorage** ppprstg)
        = 0;

        virtual HRESULT __stdcall Open(const IID& rfmtid, DWORD grfMode, IPropertyStorage** ppprstg) = 0;

        virtual HRESULT __stdcall Delete(const IID& rfmtid) = 0;

        virtual HRESULT __stdcall Enum(IEnumSTATPROPSETSTG** ppenum) = 0;
    };

    typedef IEnumSTATPROPSTG* LPENUMSTATPROPSTG;

    extern "C" const IID IID_IEnumSTATPROPSTG;

    struct __declspec(uuid("00000139-0000-0000-C000-000000000046")) __declspec(novtable) IEnumSTATPROPSTG : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(ULONG celt,

                                       STATPROPSTG* rgelt,

                                       ULONG* pceltFetched)
        = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumSTATPROPSTG** ppenum) = 0;
    };

    HRESULT __stdcall IEnumSTATPROPSTG_RemoteNext_Proxy(IEnumSTATPROPSTG* This, ULONG celt, STATPROPSTG* rgelt, ULONG* pceltFetched);

    void __stdcall IEnumSTATPROPSTG_RemoteNext_Stub(IRpcStubBuffer* This,
                                                    IRpcChannelBuffer* _pRpcChannelBuffer,
                                                    PRPC_MESSAGE _pRpcMessage,
                                                    DWORD* _pdwStubPhase);

    typedef IEnumSTATPROPSETSTG* LPENUMSTATPROPSETSTG;

    extern "C" const IID IID_IEnumSTATPROPSETSTG;

    struct __declspec(uuid("0000013B-0000-0000-C000-000000000046")) __declspec(novtable) IEnumSTATPROPSETSTG : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(ULONG celt,

                                       STATPROPSETSTG* rgelt,

                                       ULONG* pceltFetched)
        = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumSTATPROPSETSTG** ppenum) = 0;
    };

    HRESULT __stdcall IEnumSTATPROPSETSTG_RemoteNext_Proxy(IEnumSTATPROPSETSTG* This, ULONG celt, STATPROPSETSTG* rgelt, ULONG* pceltFetched);

    void __stdcall IEnumSTATPROPSETSTG_RemoteNext_Stub(IRpcStubBuffer* This,
                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                       PRPC_MESSAGE _pRpcMessage,
                                                       DWORD* _pdwStubPhase);

    typedef IPropertyStorage* LPPROPERTYSTORAGE;

#pragma endregion

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_propidlbase_0000_0004_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_propidlbase_0000_0004_v0_0_s_ifspec;

    unsigned long __stdcall BSTR_UserSize(unsigned long*, unsigned long, BSTR*);
    unsigned char* __stdcall BSTR_UserMarshal(unsigned long*, unsigned char*, BSTR*);
    unsigned char* __stdcall BSTR_UserUnmarshal(unsigned long*, unsigned char*, BSTR*);
    void __stdcall BSTR_UserFree(unsigned long*, BSTR*);

    unsigned long __stdcall LPSAFEARRAY_UserSize(unsigned long*, unsigned long, LPSAFEARRAY*);
    unsigned char* __stdcall LPSAFEARRAY_UserMarshal(unsigned long*, unsigned char*, LPSAFEARRAY*);
    unsigned char* __stdcall LPSAFEARRAY_UserUnmarshal(unsigned long*, unsigned char*, LPSAFEARRAY*);
    void __stdcall LPSAFEARRAY_UserFree(unsigned long*, LPSAFEARRAY*);

    unsigned long __stdcall BSTR_UserSize64(unsigned long*, unsigned long, BSTR*);
    unsigned char* __stdcall BSTR_UserMarshal64(unsigned long*, unsigned char*, BSTR*);
    unsigned char* __stdcall BSTR_UserUnmarshal64(unsigned long*, unsigned char*, BSTR*);
    void __stdcall BSTR_UserFree64(unsigned long*, BSTR*);

    unsigned long __stdcall LPSAFEARRAY_UserSize64(unsigned long*, unsigned long, LPSAFEARRAY*);
    unsigned char* __stdcall LPSAFEARRAY_UserMarshal64(unsigned long*, unsigned char*, LPSAFEARRAY*);
    unsigned char* __stdcall LPSAFEARRAY_UserUnmarshal64(unsigned long*, unsigned char*, LPSAFEARRAY*);
    void __stdcall LPSAFEARRAY_UserFree64(unsigned long*, LPSAFEARRAY*);

    HRESULT __stdcall IEnumSTATPROPSTG_Next_Proxy(IEnumSTATPROPSTG* This,
                                                  ULONG celt,

                                                  STATPROPSTG* rgelt,

                                                  ULONG* pceltFetched);

    HRESULT __stdcall IEnumSTATPROPSTG_Next_Stub(IEnumSTATPROPSTG* This, ULONG celt, STATPROPSTG* rgelt, ULONG* pceltFetched);

    HRESULT __stdcall IEnumSTATPROPSETSTG_Next_Proxy(IEnumSTATPROPSETSTG* This,
                                                     ULONG celt,

                                                     STATPROPSETSTG* rgelt,

                                                     ULONG* pceltFetched);

    HRESULT __stdcall IEnumSTATPROPSETSTG_Next_Stub(IEnumSTATPROPSETSTG* This, ULONG celt, STATPROPSETSTG* rgelt, ULONG* pceltFetched);
}

#pragma region Application Family

typedef DWORD STGFMT;

extern "C" __declspec(dllimport) HRESULT
__stdcall StgCreateDocfile(const WCHAR* pwcsName, DWORD grfMode, DWORD reserved, IStorage** ppstgOpen);

extern "C" __declspec(dllimport) HRESULT
__stdcall StgCreateDocfileOnILockBytes(ILockBytes* plkbyt, DWORD grfMode, DWORD reserved, IStorage** ppstgOpen);

extern "C" __declspec(dllimport) HRESULT
__stdcall StgOpenStorage(const WCHAR* pwcsName, IStorage* pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage** ppstgOpen);

extern "C" __declspec(dllimport) HRESULT __stdcall StgOpenStorageOnILockBytes(
ILockBytes* plkbyt, IStorage* pstgPriority, DWORD grfMode, SNB snbExclude, DWORD reserved, IStorage** ppstgOpen);

extern "C" __declspec(dllimport) HRESULT __stdcall StgIsStorageFile(const WCHAR* pwcsName);

extern "C" __declspec(dllimport) HRESULT __stdcall StgIsStorageILockBytes(ILockBytes* plkbyt);

extern "C" __declspec(dllimport) HRESULT
__stdcall StgSetTimes(const WCHAR* lpszName, const FILETIME* pctime, const FILETIME* patime, const FILETIME* pmtime);

typedef struct tagSTGOPTIONS
{
    USHORT usVersion;
    USHORT reserved;
    ULONG ulSectorSize;

    const WCHAR* pwcsTemplateFile;
} STGOPTIONS;

extern "C" __declspec(dllimport) HRESULT __stdcall StgCreateStorageEx(const WCHAR* pwcsName,
                                                                      DWORD grfMode,
                                                                      DWORD stgfmt,
                                                                      DWORD grfAttrs,
                                                                      STGOPTIONS* pStgOptions,
                                                                      PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                                      const IID& riid,
                                                                      void** ppObjectOpen);

extern "C" __declspec(dllimport) HRESULT __stdcall StgOpenStorageEx(const WCHAR* pwcsName,
                                                                    DWORD grfMode,
                                                                    DWORD stgfmt,
                                                                    DWORD grfAttrs,
                                                                    STGOPTIONS* pStgOptions,
                                                                    PSECURITY_DESCRIPTOR pSecurityDescriptor,
                                                                    const IID& riid,
                                                                    void** ppObjectOpen);

extern "C" __declspec(dllimport) HRESULT
__stdcall StgCreatePropStg(IUnknown* pUnk, const IID& fmtid, const CLSID* pclsid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage** ppPropStg);

extern "C" __declspec(dllimport) HRESULT
__stdcall StgOpenPropStg(IUnknown* pUnk, const IID& fmtid, DWORD grfFlags, DWORD dwReserved, IPropertyStorage** ppPropStg);

extern "C" __declspec(dllimport) HRESULT
__stdcall StgCreatePropSetStg(IStorage* pStorage, DWORD dwReserved, IPropertySetStorage** ppPropSetStg);

extern "C" __declspec(dllimport) HRESULT __stdcall FmtIdToPropStgName(const FMTID* pfmtid, LPOLESTR oszName);

extern "C" __declspec(dllimport) HRESULT __stdcall PropStgNameToFmtId(const LPOLESTR oszName, FMTID* pfmtid);

extern "C" __declspec(dllimport) HRESULT __stdcall ReadClassStg(LPSTORAGE pStg, CLSID* pclsid);

extern "C" __declspec(dllimport) HRESULT __stdcall WriteClassStg(LPSTORAGE pStg, const IID& rclsid);

extern "C" __declspec(dllimport) HRESULT __stdcall ReadClassStm(LPSTREAM pStm, CLSID* pclsid);

extern "C" __declspec(dllimport) HRESULT __stdcall WriteClassStm(LPSTREAM pStm, const IID& rclsid);

extern "C" __declspec(dllimport) HRESULT __stdcall GetHGlobalFromILockBytes(LPLOCKBYTES plkbyt, HGLOBAL* phglobal);

extern "C" __declspec(dllimport) HRESULT
__stdcall CreateILockBytesOnHGlobal(HGLOBAL hGlobal, BOOL fDeleteOnRelease, LPLOCKBYTES* pplkbyt);

extern "C" __declspec(dllimport) HRESULT __stdcall GetConvertStg(LPSTORAGE pStg);

#pragma endregion

typedef enum tagCOINIT
{
    COINIT_APARTMENTTHREADED = 0x2,

    COINIT_MULTITHREADED = COINITBASE_MULTITHREADED,
    COINIT_DISABLE_OLE1DDE = 0x4,
    COINIT_SPEED_OVER_MEMORY = 0x8,
} COINIT;

#pragma region Desktop Partition

extern "C" __declspec(dllimport) DWORD __stdcall CoBuildVersion(void);

extern "C" __declspec(dllimport) HRESULT __stdcall CoInitialize(LPVOID pvReserved);

extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterMallocSpy(LPMALLOCSPY pMallocSpy);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRevokeMallocSpy(void);
extern "C" __declspec(dllimport) HRESULT __stdcall CoCreateStandardMalloc(DWORD memctx, IMalloc** ppMalloc);

extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterInitializeSpy(IInitializeSpy* pSpy, ULARGE_INTEGER* puliCookie);
extern "C" __declspec(dllimport) HRESULT __stdcall CoRevokeInitializeSpy(ULARGE_INTEGER uliCookie);

typedef enum tagCOMSD
{
    SD_LAUNCHPERMISSIONS = 0,
    SD_ACCESSPERMISSIONS = 1,
    SD_LAUNCHRESTRICTIONS = 2,
    SD_ACCESSRESTRICTIONS = 3

} COMSD;
extern "C" __declspec(dllimport) HRESULT __stdcall CoGetSystemSecurityPermissions(COMSD comSDType, PSECURITY_DESCRIPTOR* ppSD);

extern "C" __declspec(dllimport) HINSTANCE __stdcall CoLoadLibrary(LPOLESTR lpszLibName, BOOL bAutoFree);
extern "C" __declspec(dllimport) void __stdcall CoFreeLibrary(HINSTANCE hInst);
extern "C" __declspec(dllimport) void __stdcall CoFreeAllLibraries(void);

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetInstanceFromFile(
COSERVERINFO* pServerInfo, CLSID* pClsid, IUnknown* punkOuter, DWORD dwClsCtx, DWORD grfMode, OLECHAR* pwszName, DWORD dwCount, MULTI_QI* pResults);

extern "C" __declspec(dllimport) HRESULT __stdcall CoGetInstanceFromIStorage(
COSERVERINFO* pServerInfo, CLSID* pClsid, IUnknown* punkOuter, DWORD dwClsCtx, struct IStorage* pstg, DWORD dwCount, MULTI_QI* pResults);

extern "C" __declspec(dllimport) HRESULT __stdcall CoAllowSetForegroundWindow(IUnknown* pUnk, LPVOID lpvReserved);

extern "C" __declspec(dllimport) HRESULT __stdcall DcomChannelSetHResult(LPVOID pvReserved, ULONG* pulReserved, HRESULT appsHR);

extern "C" __declspec(dllimport) BOOL __stdcall CoIsOle1Class(const IID& rclsid);
extern "C" __declspec(dllimport) HRESULT __stdcall CLSIDFromProgIDEx(LPCOLESTR lpszProgID, LPCLSID lpclsid);

extern "C" __declspec(dllimport) BOOL __stdcall CoFileTimeToDosDateTime(FILETIME* lpFileTime, LPWORD lpDosDate, LPWORD lpDosTime);
extern "C" __declspec(dllimport) BOOL __stdcall CoDosDateTimeToFileTime(WORD nDosDate, WORD nDosTime, FILETIME* lpFileTime);
extern "C" __declspec(dllimport) HRESULT __stdcall CoFileTimeNow(FILETIME* lpFileTime);

extern "C" __declspec(dllimport) HRESULT
__stdcall CoRegisterMessageFilter(LPMESSAGEFILTER lpMessageFilter, LPMESSAGEFILTER* lplpMessageFilter);

extern "C" __declspec(dllimport) HRESULT __stdcall CoRegisterChannelHook(const GUID& ExtensionUuid, IChannelHook* pChannelHook);

extern "C" __declspec(dllimport) HRESULT __stdcall CoTreatAsClass(const IID& clsidOld, const IID& clsidNew);

extern "C" __declspec(dllimport) HRESULT __stdcall CreateDataAdviseHolder(LPDATAADVISEHOLDER* ppDAHolder);

extern "C" __declspec(dllimport) HRESULT
__stdcall CreateDataCache(LPUNKNOWN pUnkOuter, const IID& rclsid, const IID& iid, LPVOID* ppv);

extern "C" __declspec(dllimport) HRESULT
__stdcall StgOpenAsyncDocfileOnIFillLockBytes(IFillLockBytes* pflb, DWORD grfMode, DWORD asyncFlags, IStorage** ppstgOpen);

extern "C" __declspec(dllimport) HRESULT __stdcall StgGetIFillLockBytesOnILockBytes(ILockBytes* pilb, IFillLockBytes** ppflb);

extern "C" __declspec(dllimport) HRESULT __stdcall StgGetIFillLockBytesOnFile(OLECHAR const* pwcsName, IFillLockBytes** ppflb);

extern "C" __declspec(dllimport) HRESULT
__stdcall StgOpenLayoutDocfile(OLECHAR const* pwcsDfName, DWORD grfMode, DWORD reserved, IStorage** ppstgOpen);

#pragma endregion

#pragma region Desktop Partition

extern "C" __declspec(dllimport) HRESULT
__stdcall CoInstall(IBindCtx* pbc, DWORD dwFlags, uCLSSPEC* pClassSpec, QUERYCONTEXT* pQuery, LPWSTR pszCodeBase);

#pragma endregion

#pragma region PC Application Partition

extern "C" __declspec(dllimport) HRESULT __stdcall BindMoniker(LPMONIKER pmk, DWORD grfOpt, const IID& iidResult, LPVOID* ppvResult);

extern "C" __declspec(dllimport) HRESULT
__stdcall CoGetObject(LPCWSTR pszName, BIND_OPTS* pBindOptions, const IID& riid, void** ppv);
extern "C" __declspec(dllimport) HRESULT
__stdcall MkParseDisplayName(LPBC pbc, LPCOLESTR szUserName, ULONG* pchEaten, LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT
__stdcall MonikerRelativePathTo(LPMONIKER pmkSrc, LPMONIKER pmkDest, LPMONIKER* ppmkRelPath, BOOL dwReserved);
extern "C" __declspec(dllimport) HRESULT
__stdcall MonikerCommonPrefixWith(LPMONIKER pmkThis, LPMONIKER pmkOther, LPMONIKER* ppmkCommon);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateBindCtx(DWORD reserved, LPBC* ppbc);
extern "C" __declspec(dllimport) HRESULT
__stdcall CreateGenericComposite(LPMONIKER pmkFirst, LPMONIKER pmkRest, LPMONIKER* ppmkComposite);
extern "C" __declspec(dllimport) HRESULT __stdcall GetClassFile(LPCOLESTR szFilename, CLSID* pclsid);

extern "C" __declspec(dllimport) HRESULT __stdcall CreateClassMoniker(const IID& rclsid, LPMONIKER* ppmk);

extern "C" __declspec(dllimport) HRESULT __stdcall CreateFileMoniker(LPCOLESTR lpszPathName, LPMONIKER* ppmk);

extern "C" __declspec(dllimport) HRESULT __stdcall CreateItemMoniker(LPCOLESTR lpszDelim, LPCOLESTR lpszItem, LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateAntiMoniker(LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT __stdcall CreatePointerMoniker(LPUNKNOWN punk, LPMONIKER* ppmk);
extern "C" __declspec(dllimport) HRESULT __stdcall CreateObjrefMoniker(LPUNKNOWN punk, LPMONIKER* ppmk);

#pragma endregion

#pragma region Desktop Partition

extern "C" __declspec(dllimport) HRESULT __stdcall GetRunningObjectTable(DWORD reserved, LPRUNNINGOBJECTTABLE* pprot);

#pragma endregion

#pragma once

typedef struct IPersistMoniker IPersistMoniker;

typedef struct IMonikerProp IMonikerProp;

typedef struct IBindProtocol IBindProtocol;

typedef struct IBinding IBinding;

typedef struct IBindStatusCallback IBindStatusCallback;

typedef struct IBindStatusCallbackEx IBindStatusCallbackEx;

typedef struct IAuthenticate IAuthenticate;

typedef struct IAuthenticateEx IAuthenticateEx;

typedef struct IHttpNegotiate IHttpNegotiate;

typedef struct IHttpNegotiate2 IHttpNegotiate2;

typedef struct IHttpNegotiate3 IHttpNegotiate3;

typedef struct IWinInetFileStream IWinInetFileStream;

typedef struct IWindowForBindingUI IWindowForBindingUI;

typedef struct ICodeInstall ICodeInstall;

typedef struct IUri IUri;

typedef struct IUriContainer IUriContainer;

typedef struct IUriBuilder IUriBuilder;

typedef struct IUriBuilderFactory IUriBuilderFactory;

typedef struct IWinInetInfo IWinInetInfo;

typedef struct IHttpSecurity IHttpSecurity;

typedef struct IWinInetHttpInfo IWinInetHttpInfo;

typedef struct IWinInetHttpTimeouts IWinInetHttpTimeouts;

typedef struct IWinInetCacheHints IWinInetCacheHints;

typedef struct IWinInetCacheHints2 IWinInetCacheHints2;

typedef struct IBindHost IBindHost;

typedef struct IInternet IInternet;

typedef struct IInternetBindInfo IInternetBindInfo;

typedef struct IInternetBindInfoEx IInternetBindInfoEx;

typedef struct IInternetProtocolRoot IInternetProtocolRoot;

typedef struct IInternetProtocol IInternetProtocol;

typedef struct IInternetProtocolEx IInternetProtocolEx;

typedef struct IInternetProtocolSink IInternetProtocolSink;

typedef struct IInternetProtocolSinkStackable IInternetProtocolSinkStackable;

typedef struct IInternetSession IInternetSession;

typedef struct IInternetThreadSwitch IInternetThreadSwitch;

typedef struct IInternetPriority IInternetPriority;

typedef struct IInternetProtocolInfo IInternetProtocolInfo;

typedef struct IInternetSecurityMgrSite IInternetSecurityMgrSite;

typedef struct IInternetSecurityManager IInternetSecurityManager;

typedef struct IInternetSecurityManagerEx IInternetSecurityManagerEx;

typedef struct IInternetSecurityManagerEx2 IInternetSecurityManagerEx2;

typedef struct IZoneIdentifier IZoneIdentifier;

typedef struct IZoneIdentifier2 IZoneIdentifier2;

typedef struct IInternetHostSecurityManager IInternetHostSecurityManager;

typedef struct IInternetZoneManager IInternetZoneManager;

typedef struct IInternetZoneManagerEx IInternetZoneManagerEx;

typedef struct IInternetZoneManagerEx2 IInternetZoneManagerEx2;

typedef struct ISoftDistExt ISoftDistExt;

typedef struct ICatalogFileInfo ICatalogFileInfo;

typedef struct IDataFilter IDataFilter;

typedef struct IEncodingFilterFactory IEncodingFilterFactory;

typedef struct IWrappedProtocol IWrappedProtocol;

typedef struct IGetBindHandle IGetBindHandle;

typedef struct IBindCallbackRedirect IBindCallbackRedirect;

typedef struct IBindHttpSecurity IBindHttpSecurity;

#pragma once

typedef struct IOleAdviseHolder IOleAdviseHolder;

typedef struct IOleCache IOleCache;

typedef struct IOleCache2 IOleCache2;

typedef struct IOleCacheControl IOleCacheControl;

typedef struct IParseDisplayName IParseDisplayName;

typedef struct IOleContainer IOleContainer;

typedef struct IOleClientSite IOleClientSite;

typedef struct IOleObject IOleObject;

typedef struct IOleWindow IOleWindow;

typedef struct IOleLink IOleLink;

typedef struct IOleItemContainer IOleItemContainer;

typedef struct IOleInPlaceUIWindow IOleInPlaceUIWindow;

typedef struct IOleInPlaceActiveObject IOleInPlaceActiveObject;

typedef struct IOleInPlaceFrame IOleInPlaceFrame;

typedef struct IOleInPlaceObject IOleInPlaceObject;

typedef struct IOleInPlaceSite IOleInPlaceSite;

typedef struct IContinue IContinue;

typedef struct IViewObject IViewObject;

typedef struct IViewObject2 IViewObject2;

typedef struct IDropSource IDropSource;

typedef struct IDropTarget IDropTarget;

typedef struct IDropSourceNotify IDropSourceNotify;

typedef struct IEnterpriseDropTarget IEnterpriseDropTarget;

typedef struct IEnumOLEVERB IEnumOLEVERB;

extern "C"
{
#pragma once

#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0000_v0_0_s_ifspec;

    typedef IOleAdviseHolder* LPOLEADVISEHOLDER;

    extern "C" const IID IID_IOleAdviseHolder;

    struct __declspec(uuid("00000111-0000-0000-C000-000000000046")) __declspec(novtable) IOleAdviseHolder : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Advise(

        IAdviseSink* pAdvise,

        DWORD* pdwConnection)
        = 0;

        virtual HRESULT __stdcall Unadvise(DWORD dwConnection) = 0;

        virtual HRESULT __stdcall EnumAdvise(

        IEnumSTATDATA** ppenumAdvise)
        = 0;

        virtual HRESULT __stdcall SendOnRename(

        IMoniker* pmk)
        = 0;

        virtual HRESULT __stdcall SendOnSave(void) = 0;

        virtual HRESULT __stdcall SendOnClose(void) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0001_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0001_v0_0_s_ifspec;

    typedef IOleCache* LPOLECACHE;

    extern "C" const IID IID_IOleCache;

    struct __declspec(uuid("0000011e-0000-0000-C000-000000000046")) __declspec(novtable) IOleCache : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Cache(FORMATETC* pformatetc, DWORD advf, DWORD* pdwConnection) = 0;

        virtual HRESULT __stdcall Uncache(DWORD dwConnection) = 0;

        virtual HRESULT __stdcall EnumCache(IEnumSTATDATA** ppenumSTATDATA) = 0;

        virtual HRESULT __stdcall InitCache(IDataObject* pDataObject) = 0;

        virtual HRESULT __stdcall SetData(FORMATETC* pformatetc, STGMEDIUM* pmedium, BOOL fRelease) = 0;
    };

    typedef IOleCache2* LPOLECACHE2;

    typedef enum tagDISCARDCACHE
    {
        DISCARDCACHE_SAVEIFDIRTY = 0,
        DISCARDCACHE_NOSAVE = 1
    } DISCARDCACHE;

    extern "C" const IID IID_IOleCache2;

    struct __declspec(uuid("00000128-0000-0000-C000-000000000046")) __declspec(novtable) IOleCache2 : public IOleCache
    {
    public:
        virtual HRESULT __stdcall UpdateCache(

        LPDATAOBJECT pDataObject,

        DWORD grfUpdf,

        LPVOID pReserved)
        = 0;

        virtual HRESULT __stdcall DiscardCache(DWORD dwDiscardOptions) = 0;
    };

    HRESULT __stdcall IOleCache2_RemoteUpdateCache_Proxy(IOleCache2* This, LPDATAOBJECT pDataObject, DWORD grfUpdf, LONG_PTR pReserved);

    void __stdcall IOleCache2_RemoteUpdateCache_Stub(IRpcStubBuffer* This,
                                                     IRpcChannelBuffer* _pRpcChannelBuffer,
                                                     PRPC_MESSAGE _pRpcMessage,
                                                     DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0003_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0003_v0_0_s_ifspec;

    typedef IOleCacheControl* LPOLECACHECONTROL;

    extern "C" const IID IID_IOleCacheControl;

    struct __declspec(uuid("00000129-0000-0000-C000-000000000046")) __declspec(novtable) IOleCacheControl : public IUnknown
    {
    public:
        virtual HRESULT __stdcall OnRun(LPDATAOBJECT pDataObject) = 0;

        virtual HRESULT __stdcall OnStop(void) = 0;
    };

    typedef IParseDisplayName* LPPARSEDISPLAYNAME;

    extern "C" const IID IID_IParseDisplayName;

    struct __declspec(uuid("0000011a-0000-0000-C000-000000000046")) __declspec(novtable) IParseDisplayName : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ParseDisplayName(IBindCtx* pbc, LPOLESTR pszDisplayName, ULONG* pchEaten, IMoniker** ppmkOut) = 0;
    };

    typedef IOleContainer* LPOLECONTAINER;

    extern "C" const IID IID_IOleContainer;

    struct __declspec(uuid("0000011b-0000-0000-C000-000000000046")) __declspec(novtable) IOleContainer : public IParseDisplayName
    {
    public:
        virtual HRESULT __stdcall EnumObjects(DWORD grfFlags, IEnumUnknown** ppenum) = 0;

        virtual HRESULT __stdcall LockContainer(BOOL fLock) = 0;
    };

    typedef IOleClientSite* LPOLECLIENTSITE;

    extern "C" const IID IID_IOleClientSite;

    struct __declspec(uuid("00000118-0000-0000-C000-000000000046")) __declspec(novtable) IOleClientSite : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SaveObject(void) = 0;

        virtual HRESULT __stdcall GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk) = 0;

        virtual HRESULT __stdcall GetContainer(IOleContainer** ppContainer) = 0;

        virtual HRESULT __stdcall ShowObject(void) = 0;

        virtual HRESULT __stdcall OnShowWindow(BOOL fShow) = 0;

        virtual HRESULT __stdcall RequestNewObjectLayout(void) = 0;
    };

    typedef IOleObject* LPOLEOBJECT;

    typedef enum tagOLEGETMONIKER
    {
        OLEGETMONIKER_ONLYIFTHERE = 1,
        OLEGETMONIKER_FORCEASSIGN = 2,
        OLEGETMONIKER_UNASSIGN = 3,
        OLEGETMONIKER_TEMPFORUSER = 4
    } OLEGETMONIKER;

    typedef enum tagOLEWHICHMK
    {
        OLEWHICHMK_CONTAINER = 1,
        OLEWHICHMK_OBJREL = 2,
        OLEWHICHMK_OBJFULL = 3
    } OLEWHICHMK;

    typedef enum tagUSERCLASSTYPE
    {
        USERCLASSTYPE_FULL = 1,
        USERCLASSTYPE_SHORT = 2,
        USERCLASSTYPE_APPNAME = 3
    } USERCLASSTYPE;

    typedef enum tagOLEMISC
    {
        OLEMISC_RECOMPOSEONRESIZE = 0x1,
        OLEMISC_ONLYICONIC = 0x2,
        OLEMISC_INSERTNOTREPLACE = 0x4,
        OLEMISC_STATIC = 0x8,
        OLEMISC_CANTLINKINSIDE = 0x10,
        OLEMISC_CANLINKBYOLE1 = 0x20,
        OLEMISC_ISLINKOBJECT = 0x40,
        OLEMISC_INSIDEOUT = 0x80,
        OLEMISC_ACTIVATEWHENVISIBLE = 0x100,
        OLEMISC_RENDERINGISDEVICEINDEPENDENT = 0x200,
        OLEMISC_INVISIBLEATRUNTIME = 0x400,
        OLEMISC_ALWAYSRUN = 0x800,
        OLEMISC_ACTSLIKEBUTTON = 0x1000,
        OLEMISC_ACTSLIKELABEL = 0x2000,
        OLEMISC_NOUIACTIVATE = 0x4000,
        OLEMISC_ALIGNABLE = 0x8000,
        OLEMISC_SIMPLEFRAME = 0x10000,
        OLEMISC_SETCLIENTSITEFIRST = 0x20000,
        OLEMISC_IMEMODE = 0x40000,
        OLEMISC_IGNOREACTIVATEWHENVISIBLE = 0x80000,
        OLEMISC_WANTSTOMENUMERGE = 0x100000,
        OLEMISC_SUPPORTSMULTILEVELUNDO = 0x200000
    } OLEMISC;

    typedef enum tagOLECLOSE
    {
        OLECLOSE_SAVEIFDIRTY = 0,
        OLECLOSE_NOSAVE = 1,
        OLECLOSE_PROMPTSAVE = 2
    } OLECLOSE;

    extern "C" const IID IID_IOleObject;

    struct __declspec(uuid("00000112-0000-0000-C000-000000000046")) __declspec(novtable) IOleObject : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetClientSite(IOleClientSite* pClientSite) = 0;

        virtual HRESULT __stdcall GetClientSite(IOleClientSite** ppClientSite) = 0;

        virtual HRESULT __stdcall SetHostNames(LPCOLESTR szContainerApp, LPCOLESTR szContainerObj) = 0;

        virtual HRESULT __stdcall Close(DWORD dwSaveOption) = 0;

        virtual HRESULT __stdcall SetMoniker(DWORD dwWhichMoniker, IMoniker* pmk) = 0;

        virtual HRESULT __stdcall GetMoniker(DWORD dwAssign, DWORD dwWhichMoniker, IMoniker** ppmk) = 0;

        virtual HRESULT __stdcall InitFromData(IDataObject* pDataObject, BOOL fCreation, DWORD dwReserved) = 0;

        virtual HRESULT __stdcall GetClipboardData(DWORD dwReserved, IDataObject** ppDataObject) = 0;

        virtual HRESULT __stdcall DoVerb(LONG iVerb, LPMSG lpmsg, IOleClientSite* pActiveSite, LONG lindex, HWND hwndParent, LPCRECT lprcPosRect)
        = 0;

        virtual HRESULT __stdcall EnumVerbs(IEnumOLEVERB** ppEnumOleVerb) = 0;

        virtual HRESULT __stdcall Update(void) = 0;

        virtual HRESULT __stdcall IsUpToDate(void) = 0;

        virtual HRESULT __stdcall GetUserClassID(CLSID* pClsid) = 0;

        virtual HRESULT __stdcall GetUserType(DWORD dwFormOfType, LPOLESTR* pszUserType) = 0;

        virtual HRESULT __stdcall SetExtent(DWORD dwDrawAspect, SIZEL* psizel) = 0;

        virtual HRESULT __stdcall GetExtent(DWORD dwDrawAspect, SIZEL* psizel) = 0;

        virtual HRESULT __stdcall Advise(IAdviseSink* pAdvSink, DWORD* pdwConnection) = 0;

        virtual HRESULT __stdcall Unadvise(DWORD dwConnection) = 0;

        virtual HRESULT __stdcall EnumAdvise(IEnumSTATDATA** ppenumAdvise) = 0;

        virtual HRESULT __stdcall GetMiscStatus(DWORD dwAspect, DWORD* pdwStatus) = 0;

        virtual HRESULT __stdcall SetColorScheme(LOGPALETTE* pLogpal) = 0;
    };

    typedef enum tagOLERENDER
    {
        OLERENDER_NONE = 0,
        OLERENDER_DRAW = 1,
        OLERENDER_FORMAT = 2,
        OLERENDER_ASIS = 3
    } OLERENDER;

    typedef OLERENDER* LPOLERENDER;

    typedef struct tagOBJECTDESCRIPTOR
    {
        ULONG cbSize;
        CLSID clsid;
        DWORD dwDrawAspect;
        SIZEL sizel;
        POINTL pointl;
        DWORD dwStatus;
        DWORD dwFullUserTypeName;
        DWORD dwSrcOfCopy;
    } OBJECTDESCRIPTOR;

    typedef struct tagOBJECTDESCRIPTOR* POBJECTDESCRIPTOR;

    typedef struct tagOBJECTDESCRIPTOR* LPOBJECTDESCRIPTOR;

    typedef struct tagOBJECTDESCRIPTOR LINKSRCDESCRIPTOR;

    typedef struct tagOBJECTDESCRIPTOR* PLINKSRCDESCRIPTOR;

    typedef struct tagOBJECTDESCRIPTOR* LPLINKSRCDESCRIPTOR;

    extern RPC_IF_HANDLE IOLETypes_v0_0_c_ifspec;
    extern RPC_IF_HANDLE IOLETypes_v0_0_s_ifspec;

    typedef IOleWindow* LPOLEWINDOW;

    extern "C" const IID IID_IOleWindow;

    struct __declspec(uuid("00000114-0000-0000-C000-000000000046")) __declspec(novtable) IOleWindow : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetWindow(HWND* phwnd) = 0;

        virtual HRESULT __stdcall ContextSensitiveHelp(BOOL fEnterMode) = 0;
    };

    typedef IOleLink* LPOLELINK;

    typedef enum tagOLEUPDATE
    {
        OLEUPDATE_ALWAYS = 1,
        OLEUPDATE_ONCALL = 3
    } OLEUPDATE;

    typedef OLEUPDATE* LPOLEUPDATE;

    typedef OLEUPDATE* POLEUPDATE;

    typedef enum tagOLELINKBIND
    {
        OLELINKBIND_EVENIFCLASSDIFF = 1
    } OLELINKBIND;

    extern "C" const IID IID_IOleLink;

    struct __declspec(uuid("0000011d-0000-0000-C000-000000000046")) __declspec(novtable) IOleLink : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetUpdateOptions(DWORD dwUpdateOpt) = 0;

        virtual HRESULT __stdcall GetUpdateOptions(DWORD* pdwUpdateOpt) = 0;

        virtual HRESULT __stdcall SetSourceMoniker(IMoniker* pmk, const IID& rclsid) = 0;

        virtual HRESULT __stdcall GetSourceMoniker(IMoniker** ppmk) = 0;

        virtual HRESULT __stdcall SetSourceDisplayName(LPCOLESTR pszStatusText) = 0;

        virtual HRESULT __stdcall GetSourceDisplayName(LPOLESTR* ppszDisplayName) = 0;

        virtual HRESULT __stdcall BindToSource(DWORD bindflags, IBindCtx* pbc) = 0;

        virtual HRESULT __stdcall BindIfRunning(void) = 0;

        virtual HRESULT __stdcall GetBoundSource(IUnknown** ppunk) = 0;

        virtual HRESULT __stdcall UnbindSource(void) = 0;

        virtual HRESULT __stdcall Update(IBindCtx* pbc) = 0;
    };

    typedef IOleItemContainer* LPOLEITEMCONTAINER;

    typedef enum tagBINDSPEED
    {
        BINDSPEED_INDEFINITE = 1,
        BINDSPEED_MODERATE = 2,
        BINDSPEED_IMMEDIATE = 3
    } BINDSPEED;

    typedef enum tagOLECONTF
    {
        OLECONTF_EMBEDDINGS = 1,
        OLECONTF_LINKS = 2,
        OLECONTF_OTHERS = 4,
        OLECONTF_ONLYUSER = 8,
        OLECONTF_ONLYIFRUNNING = 16
    } OLECONTF;

    extern "C" const IID IID_IOleItemContainer;

    struct __declspec(uuid("0000011c-0000-0000-C000-000000000046")) __declspec(novtable) IOleItemContainer : public IOleContainer
    {
    public:
        virtual HRESULT __stdcall GetObject(LPOLESTR pszItem, DWORD dwSpeedNeeded, IBindCtx* pbc, const IID& riid, void** ppvObject)
        = 0;

        virtual HRESULT __stdcall GetObjectStorage(LPOLESTR pszItem, IBindCtx* pbc, const IID& riid, void** ppvStorage) = 0;

        virtual HRESULT __stdcall IsRunning(LPOLESTR pszItem) = 0;
    };

    typedef IOleInPlaceUIWindow* LPOLEINPLACEUIWINDOW;

    typedef RECT BORDERWIDTHS;

    typedef LPRECT LPBORDERWIDTHS;

    typedef LPCRECT LPCBORDERWIDTHS;

    extern "C" const IID IID_IOleInPlaceUIWindow;

    struct __declspec(uuid("00000115-0000-0000-C000-000000000046")) __declspec(novtable) IOleInPlaceUIWindow : public IOleWindow
    {
    public:
        virtual HRESULT __stdcall GetBorder(LPRECT lprectBorder) = 0;

        virtual HRESULT __stdcall RequestBorderSpace(LPCBORDERWIDTHS pborderwidths) = 0;

        virtual HRESULT __stdcall SetBorderSpace(LPCBORDERWIDTHS pborderwidths) = 0;

        virtual HRESULT __stdcall SetActiveObject(IOleInPlaceActiveObject* pActiveObject, LPCOLESTR pszObjName) = 0;
    };

    typedef IOleInPlaceActiveObject* LPOLEINPLACEACTIVEOBJECT;

    extern "C" const IID IID_IOleInPlaceActiveObject;

    struct __declspec(uuid("00000117-0000-0000-C000-000000000046")) __declspec(novtable) IOleInPlaceActiveObject : public IOleWindow
    {
    public:
        virtual HRESULT __stdcall TranslateAcceleratorA(

        LPMSG lpmsg)
        = 0;

        virtual HRESULT __stdcall OnFrameWindowActivate(BOOL fActivate) = 0;

        virtual HRESULT __stdcall OnDocWindowActivate(BOOL fActivate) = 0;

        virtual HRESULT __stdcall ResizeBorder(

        LPCRECT prcBorder,

        IOleInPlaceUIWindow* pUIWindow,

        BOOL fFrameWindow)
        = 0;

        virtual HRESULT __stdcall EnableModeless(BOOL fEnable) = 0;
    };

    HRESULT __stdcall IOleInPlaceActiveObject_RemoteTranslateAccelerator_Proxy(IOleInPlaceActiveObject* This);

    void __stdcall IOleInPlaceActiveObject_RemoteTranslateAccelerator_Stub(IRpcStubBuffer* This,
                                                                           IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                           PRPC_MESSAGE _pRpcMessage,
                                                                           DWORD* _pdwStubPhase);

    HRESULT __stdcall IOleInPlaceActiveObject_RemoteResizeBorder_Proxy(
    IOleInPlaceActiveObject* This, LPCRECT prcBorder, const IID& riid, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow);

    void __stdcall IOleInPlaceActiveObject_RemoteResizeBorder_Stub(IRpcStubBuffer* This,
                                                                   IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                   PRPC_MESSAGE _pRpcMessage,
                                                                   DWORD* _pdwStubPhase);

    typedef IOleInPlaceFrame* LPOLEINPLACEFRAME;

    typedef struct tagOIFI
    {
        UINT cb;
        BOOL fMDIApp;
        HWND hwndFrame;
        HACCEL haccel;
        UINT cAccelEntries;
    } OLEINPLACEFRAMEINFO;

    typedef struct tagOIFI* LPOLEINPLACEFRAMEINFO;

    typedef struct tagOleMenuGroupWidths
    {
        LONG width[6];
    } OLEMENUGROUPWIDTHS;

    typedef struct tagOleMenuGroupWidths* LPOLEMENUGROUPWIDTHS;

    typedef HGLOBAL HOLEMENU;

    extern "C" const IID IID_IOleInPlaceFrame;

    struct __declspec(uuid("00000116-0000-0000-C000-000000000046")) __declspec(novtable) IOleInPlaceFrame : public IOleInPlaceUIWindow
    {
    public:
        virtual HRESULT __stdcall InsertMenus(HMENU hmenuShared, LPOLEMENUGROUPWIDTHS lpMenuWidths) = 0;

        virtual HRESULT __stdcall SetMenu(HMENU hmenuShared, HOLEMENU holemenu, HWND hwndActiveObject) = 0;

        virtual HRESULT __stdcall RemoveMenus(HMENU hmenuShared) = 0;

        virtual HRESULT __stdcall SetStatusText(LPCOLESTR pszStatusText) = 0;

        virtual HRESULT __stdcall EnableModeless(BOOL fEnable) = 0;

        virtual HRESULT __stdcall TranslateAcceleratorA(LPMSG lpmsg, WORD wID) = 0;
    };

    typedef IOleInPlaceObject* LPOLEINPLACEOBJECT;

    extern "C" const IID IID_IOleInPlaceObject;

    struct __declspec(uuid("00000113-0000-0000-C000-000000000046")) __declspec(novtable) IOleInPlaceObject : public IOleWindow
    {
    public:
        virtual HRESULT __stdcall InPlaceDeactivate(void) = 0;

        virtual HRESULT __stdcall UIDeactivate(void) = 0;

        virtual HRESULT __stdcall SetObjectRects(LPCRECT lprcPosRect, LPCRECT lprcClipRect) = 0;

        virtual HRESULT __stdcall ReactivateAndUndo(void) = 0;
    };

    typedef IOleInPlaceSite* LPOLEINPLACESITE;

    extern "C" const IID IID_IOleInPlaceSite;

    struct __declspec(uuid("00000119-0000-0000-C000-000000000046")) __declspec(novtable) IOleInPlaceSite : public IOleWindow
    {
    public:
        virtual HRESULT __stdcall CanInPlaceActivate(void) = 0;

        virtual HRESULT __stdcall OnInPlaceActivate(void) = 0;

        virtual HRESULT __stdcall OnUIActivate(void) = 0;

        virtual HRESULT __stdcall GetWindowContext(IOleInPlaceFrame** ppFrame,
                                                   IOleInPlaceUIWindow** ppDoc,
                                                   LPRECT lprcPosRect,
                                                   LPRECT lprcClipRect,
                                                   LPOLEINPLACEFRAMEINFO lpFrameInfo)
        = 0;

        virtual HRESULT __stdcall Scroll(SIZE scrollExtant) = 0;

        virtual HRESULT __stdcall OnUIDeactivate(BOOL fUndoable) = 0;

        virtual HRESULT __stdcall OnInPlaceDeactivate(void) = 0;

        virtual HRESULT __stdcall DiscardUndoState(void) = 0;

        virtual HRESULT __stdcall DeactivateAndUndo(void) = 0;

        virtual HRESULT __stdcall OnPosRectChange(LPCRECT lprcPosRect) = 0;
    };

    extern "C" const IID IID_IContinue;

    struct __declspec(uuid("0000012a-0000-0000-C000-000000000046")) __declspec(novtable) IContinue : public IUnknown
    {
    public:
        virtual HRESULT __stdcall FContinue(void) = 0;
    };

    typedef IViewObject* LPVIEWOBJECT;

    extern "C" const IID IID_IViewObject;

    struct __declspec(uuid("0000010d-0000-0000-C000-000000000046")) __declspec(novtable) IViewObject : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Draw(

        DWORD dwDrawAspect,

        LONG lindex,

        void* pvAspect,

        DVTARGETDEVICE* ptd,

        HDC hdcTargetDev,

        HDC hdcDraw,

        LPCRECTL lprcBounds,

        LPCRECTL lprcWBounds,

        BOOL(__stdcall* pfnContinue)(ULONG_PTR dwContinue),

        ULONG_PTR dwContinue)
        = 0;

        virtual HRESULT __stdcall GetColorSet(

        DWORD dwDrawAspect,

        LONG lindex,

        void* pvAspect,

        DVTARGETDEVICE* ptd,

        HDC hicTargetDev,

        LOGPALETTE** ppColorSet)
        = 0;

        virtual HRESULT __stdcall Freeze(

        DWORD dwDrawAspect,

        LONG lindex,

        void* pvAspect,

        DWORD* pdwFreeze)
        = 0;

        virtual HRESULT __stdcall Unfreeze(DWORD dwFreeze) = 0;

        virtual HRESULT __stdcall SetAdvise(DWORD aspects, DWORD advf, IAdviseSink* pAdvSink) = 0;

        virtual HRESULT __stdcall GetAdvise(

        DWORD* pAspects,

        DWORD* pAdvf,

        IAdviseSink** ppAdvSink)
        = 0;
    };

    HRESULT __stdcall IViewObject_RemoteDraw_Proxy(IViewObject* This,
                                                   DWORD dwDrawAspect,
                                                   LONG lindex,
                                                   ULONG_PTR pvAspect,
                                                   DVTARGETDEVICE* ptd,
                                                   HDC hdcTargetDev,
                                                   HDC hdcDraw,
                                                   LPCRECTL lprcBounds,
                                                   LPCRECTL lprcWBounds,
                                                   IContinue* pContinue);

    void __stdcall IViewObject_RemoteDraw_Stub(IRpcStubBuffer* This,
                                               IRpcChannelBuffer* _pRpcChannelBuffer,
                                               PRPC_MESSAGE _pRpcMessage,
                                               DWORD* _pdwStubPhase);

    HRESULT __stdcall IViewObject_RemoteGetColorSet_Proxy(IViewObject* This,
                                                          DWORD dwDrawAspect,
                                                          LONG lindex,
                                                          ULONG_PTR pvAspect,
                                                          DVTARGETDEVICE* ptd,
                                                          ULONG_PTR hicTargetDev,
                                                          LOGPALETTE** ppColorSet);

    void __stdcall IViewObject_RemoteGetColorSet_Stub(IRpcStubBuffer* This,
                                                      IRpcChannelBuffer* _pRpcChannelBuffer,
                                                      PRPC_MESSAGE _pRpcMessage,
                                                      DWORD* _pdwStubPhase);

    HRESULT __stdcall IViewObject_RemoteFreeze_Proxy(IViewObject* This, DWORD dwDrawAspect, LONG lindex, ULONG_PTR pvAspect, DWORD* pdwFreeze);

    void __stdcall IViewObject_RemoteFreeze_Stub(IRpcStubBuffer* This,
                                                 IRpcChannelBuffer* _pRpcChannelBuffer,
                                                 PRPC_MESSAGE _pRpcMessage,
                                                 DWORD* _pdwStubPhase);

    HRESULT __stdcall IViewObject_RemoteGetAdvise_Proxy(IViewObject* This, DWORD* pAspects, DWORD* pAdvf, IAdviseSink** ppAdvSink);

    void __stdcall IViewObject_RemoteGetAdvise_Stub(IRpcStubBuffer* This,
                                                    IRpcChannelBuffer* _pRpcChannelBuffer,
                                                    PRPC_MESSAGE _pRpcMessage,
                                                    DWORD* _pdwStubPhase);

    typedef IViewObject2* LPVIEWOBJECT2;

    extern "C" const IID IID_IViewObject2;

    struct __declspec(uuid("00000127-0000-0000-C000-000000000046")) __declspec(novtable) IViewObject2 : public IViewObject
    {
    public:
        virtual HRESULT __stdcall GetExtent(DWORD dwDrawAspect, LONG lindex, DVTARGETDEVICE* ptd, LPSIZEL lpsizel) = 0;
    };

    typedef IDropSource* LPDROPSOURCE;

    extern "C" const IID IID_IDropSource;

    struct __declspec(uuid("00000121-0000-0000-C000-000000000046")) __declspec(novtable) IDropSource : public IUnknown
    {
    public:
        virtual HRESULT __stdcall QueryContinueDrag(

        BOOL fEscapePressed,

        DWORD grfKeyState)
        = 0;

        virtual HRESULT __stdcall GiveFeedback(

        DWORD dwEffect)
        = 0;
    };

    typedef IDropTarget* LPDROPTARGET;

    extern "C" const IID IID_IDropTarget;

    struct __declspec(uuid("00000122-0000-0000-C000-000000000046")) __declspec(novtable) IDropTarget : public IUnknown
    {
    public:
        virtual HRESULT __stdcall DragEnter(IDataObject* pDataObj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect) = 0;

        virtual HRESULT __stdcall DragOver(DWORD grfKeyState, POINTL pt, DWORD* pdwEffect) = 0;

        virtual HRESULT __stdcall DragLeave(void) = 0;

        virtual HRESULT __stdcall Drop(IDataObject* pDataObj, DWORD grfKeyState, POINTL pt, DWORD* pdwEffect) = 0;
    };

    extern "C" const IID IID_IDropSourceNotify;

    struct __declspec(uuid("0000012B-0000-0000-C000-000000000046")) __declspec(novtable) IDropSourceNotify : public IUnknown
    {
    public:
        virtual HRESULT __stdcall DragEnterTarget(

        HWND hwndTarget)
        = 0;

        virtual HRESULT __stdcall DragLeaveTarget(void) = 0;
    };

    extern "C" const IID IID_IEnterpriseDropTarget;

    struct __declspec(uuid("390E3878-FD55-4E18-819D-4682081C0CFD")) __declspec(novtable) IEnterpriseDropTarget : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetDropSourceEnterpriseId(LPCWSTR identity) = 0;

        virtual HRESULT __stdcall IsEvaluatingEdpPolicy(BOOL* value) = 0;
    };

#pragma endregion
#pragma region Application Family or OneCore Family

    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0024_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0024_v0_0_s_ifspec;

    typedef IEnumOLEVERB* LPENUMOLEVERB;

    typedef struct tagOLEVERB
    {
        LONG lVerb;
        LPOLESTR lpszVerbName;
        DWORD fuFlags;
        DWORD grfAttribs;
    } OLEVERB;

    typedef struct tagOLEVERB* LPOLEVERB;

    typedef enum tagOLEVERBATTRIB
    {
        OLEVERBATTRIB_NEVERDIRTIES = 1,
        OLEVERBATTRIB_ONCONTAINERMENU = 2
    } OLEVERBATTRIB;

    extern "C" const IID IID_IEnumOLEVERB;

    struct __declspec(uuid("00000104-0000-0000-C000-000000000046")) __declspec(novtable) IEnumOLEVERB : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Next(

        ULONG celt,

        LPOLEVERB rgelt,

        ULONG* pceltFetched)
        = 0;

        virtual HRESULT __stdcall Skip(ULONG celt) = 0;

        virtual HRESULT __stdcall Reset(void) = 0;

        virtual HRESULT __stdcall Clone(IEnumOLEVERB** ppenum) = 0;
    };

    HRESULT __stdcall IEnumOLEVERB_RemoteNext_Proxy(IEnumOLEVERB* This, ULONG celt, LPOLEVERB rgelt, ULONG* pceltFetched);

    void __stdcall IEnumOLEVERB_RemoteNext_Stub(IRpcStubBuffer* This,
                                                IRpcChannelBuffer* _pRpcChannelBuffer,
                                                PRPC_MESSAGE _pRpcMessage,
                                                DWORD* _pdwStubPhase);

#pragma endregion

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0025_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_oleidl_0000_0025_v0_0_s_ifspec;

    unsigned long __stdcall CLIPFORMAT_UserSize(unsigned long*, unsigned long, CLIPFORMAT*);
    unsigned char* __stdcall CLIPFORMAT_UserMarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
    unsigned char* __stdcall CLIPFORMAT_UserUnmarshal(unsigned long*, unsigned char*, CLIPFORMAT*);
    void __stdcall CLIPFORMAT_UserFree(unsigned long*, CLIPFORMAT*);

    unsigned long __stdcall HACCEL_UserSize(unsigned long*, unsigned long, HACCEL*);
    unsigned char* __stdcall HACCEL_UserMarshal(unsigned long*, unsigned char*, HACCEL*);
    unsigned char* __stdcall HACCEL_UserUnmarshal(unsigned long*, unsigned char*, HACCEL*);
    void __stdcall HACCEL_UserFree(unsigned long*, HACCEL*);

    unsigned long __stdcall HDC_UserSize(unsigned long*, unsigned long, HDC*);
    unsigned char* __stdcall HDC_UserMarshal(unsigned long*, unsigned char*, HDC*);
    unsigned char* __stdcall HDC_UserUnmarshal(unsigned long*, unsigned char*, HDC*);
    void __stdcall HDC_UserFree(unsigned long*, HDC*);

    unsigned long __stdcall HGLOBAL_UserSize(unsigned long*, unsigned long, HGLOBAL*);
    unsigned char* __stdcall HGLOBAL_UserMarshal(unsigned long*, unsigned char*, HGLOBAL*);
    unsigned char* __stdcall HGLOBAL_UserUnmarshal(unsigned long*, unsigned char*, HGLOBAL*);
    void __stdcall HGLOBAL_UserFree(unsigned long*, HGLOBAL*);

    unsigned long __stdcall HMENU_UserSize(unsigned long*, unsigned long, HMENU*);
    unsigned char* __stdcall HMENU_UserMarshal(unsigned long*, unsigned char*, HMENU*);
    unsigned char* __stdcall HMENU_UserUnmarshal(unsigned long*, unsigned char*, HMENU*);
    void __stdcall HMENU_UserFree(unsigned long*, HMENU*);

    unsigned long __stdcall HWND_UserSize(unsigned long*, unsigned long, HWND*);
    unsigned char* __stdcall HWND_UserMarshal(unsigned long*, unsigned char*, HWND*);
    unsigned char* __stdcall HWND_UserUnmarshal(unsigned long*, unsigned char*, HWND*);
    void __stdcall HWND_UserFree(unsigned long*, HWND*);

    unsigned long __stdcall STGMEDIUM_UserSize(unsigned long*, unsigned long, STGMEDIUM*);
    unsigned char* __stdcall STGMEDIUM_UserMarshal(unsigned long*, unsigned char*, STGMEDIUM*);
    unsigned char* __stdcall STGMEDIUM_UserUnmarshal(unsigned long*, unsigned char*, STGMEDIUM*);
    void __stdcall STGMEDIUM_UserFree(unsigned long*, STGMEDIUM*);

    unsigned long __stdcall CLIPFORMAT_UserSize64(unsigned long*, unsigned long, CLIPFORMAT*);
    unsigned char* __stdcall CLIPFORMAT_UserMarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
    unsigned char* __stdcall CLIPFORMAT_UserUnmarshal64(unsigned long*, unsigned char*, CLIPFORMAT*);
    void __stdcall CLIPFORMAT_UserFree64(unsigned long*, CLIPFORMAT*);

    unsigned long __stdcall HACCEL_UserSize64(unsigned long*, unsigned long, HACCEL*);
    unsigned char* __stdcall HACCEL_UserMarshal64(unsigned long*, unsigned char*, HACCEL*);
    unsigned char* __stdcall HACCEL_UserUnmarshal64(unsigned long*, unsigned char*, HACCEL*);
    void __stdcall HACCEL_UserFree64(unsigned long*, HACCEL*);

    unsigned long __stdcall HDC_UserSize64(unsigned long*, unsigned long, HDC*);
    unsigned char* __stdcall HDC_UserMarshal64(unsigned long*, unsigned char*, HDC*);
    unsigned char* __stdcall HDC_UserUnmarshal64(unsigned long*, unsigned char*, HDC*);
    void __stdcall HDC_UserFree64(unsigned long*, HDC*);

    unsigned long __stdcall HGLOBAL_UserSize64(unsigned long*, unsigned long, HGLOBAL*);
    unsigned char* __stdcall HGLOBAL_UserMarshal64(unsigned long*, unsigned char*, HGLOBAL*);
    unsigned char* __stdcall HGLOBAL_UserUnmarshal64(unsigned long*, unsigned char*, HGLOBAL*);
    void __stdcall HGLOBAL_UserFree64(unsigned long*, HGLOBAL*);

    unsigned long __stdcall HMENU_UserSize64(unsigned long*, unsigned long, HMENU*);
    unsigned char* __stdcall HMENU_UserMarshal64(unsigned long*, unsigned char*, HMENU*);
    unsigned char* __stdcall HMENU_UserUnmarshal64(unsigned long*, unsigned char*, HMENU*);
    void __stdcall HMENU_UserFree64(unsigned long*, HMENU*);

    unsigned long __stdcall HWND_UserSize64(unsigned long*, unsigned long, HWND*);
    unsigned char* __stdcall HWND_UserMarshal64(unsigned long*, unsigned char*, HWND*);
    unsigned char* __stdcall HWND_UserUnmarshal64(unsigned long*, unsigned char*, HWND*);
    void __stdcall HWND_UserFree64(unsigned long*, HWND*);

    unsigned long __stdcall STGMEDIUM_UserSize64(unsigned long*, unsigned long, STGMEDIUM*);
    unsigned char* __stdcall STGMEDIUM_UserMarshal64(unsigned long*, unsigned char*, STGMEDIUM*);
    unsigned char* __stdcall STGMEDIUM_UserUnmarshal64(unsigned long*, unsigned char*, STGMEDIUM*);
    void __stdcall STGMEDIUM_UserFree64(unsigned long*, STGMEDIUM*);

    HRESULT __stdcall IOleCache2_UpdateCache_Proxy(IOleCache2* This,

                                                   LPDATAOBJECT pDataObject,

                                                   DWORD grfUpdf,

                                                   LPVOID pReserved);

    HRESULT __stdcall IOleCache2_UpdateCache_Stub(IOleCache2* This, LPDATAOBJECT pDataObject, DWORD grfUpdf, LONG_PTR pReserved);

    HRESULT __stdcall IOleInPlaceActiveObject_TranslateAccelerator_Proxy(IOleInPlaceActiveObject* This,

                                                                         LPMSG lpmsg);

    HRESULT __stdcall IOleInPlaceActiveObject_TranslateAccelerator_Stub(IOleInPlaceActiveObject* This);

    HRESULT __stdcall IOleInPlaceActiveObject_ResizeBorder_Proxy(IOleInPlaceActiveObject* This,

                                                                 LPCRECT prcBorder,

                                                                 IOleInPlaceUIWindow* pUIWindow,

                                                                 BOOL fFrameWindow);

    HRESULT __stdcall IOleInPlaceActiveObject_ResizeBorder_Stub(
    IOleInPlaceActiveObject* This, LPCRECT prcBorder, const IID& riid, IOleInPlaceUIWindow* pUIWindow, BOOL fFrameWindow);

    HRESULT __stdcall IViewObject_Draw_Proxy(IViewObject* This,

                                             DWORD dwDrawAspect,

                                             LONG lindex,

                                             void* pvAspect,

                                             DVTARGETDEVICE* ptd,

                                             HDC hdcTargetDev,

                                             HDC hdcDraw,

                                             LPCRECTL lprcBounds,

                                             LPCRECTL lprcWBounds,

                                             BOOL(__stdcall* pfnContinue)(ULONG_PTR dwContinue),

                                             ULONG_PTR dwContinue);

    HRESULT __stdcall IViewObject_Draw_Stub(IViewObject* This,
                                            DWORD dwDrawAspect,
                                            LONG lindex,
                                            ULONG_PTR pvAspect,
                                            DVTARGETDEVICE* ptd,
                                            HDC hdcTargetDev,
                                            HDC hdcDraw,
                                            LPCRECTL lprcBounds,
                                            LPCRECTL lprcWBounds,
                                            IContinue* pContinue);

    HRESULT __stdcall IViewObject_GetColorSet_Proxy(IViewObject* This,

                                                    DWORD dwDrawAspect,

                                                    LONG lindex,

                                                    void* pvAspect,

                                                    DVTARGETDEVICE* ptd,

                                                    HDC hicTargetDev,

                                                    LOGPALETTE** ppColorSet);

    HRESULT __stdcall IViewObject_GetColorSet_Stub(IViewObject* This,
                                                   DWORD dwDrawAspect,
                                                   LONG lindex,
                                                   ULONG_PTR pvAspect,
                                                   DVTARGETDEVICE* ptd,
                                                   ULONG_PTR hicTargetDev,
                                                   LOGPALETTE** ppColorSet);

    HRESULT __stdcall IViewObject_Freeze_Proxy(IViewObject* This,

                                               DWORD dwDrawAspect,

                                               LONG lindex,

                                               void* pvAspect,

                                               DWORD* pdwFreeze);

    HRESULT __stdcall IViewObject_Freeze_Stub(IViewObject* This, DWORD dwDrawAspect, LONG lindex, ULONG_PTR pvAspect, DWORD* pdwFreeze);

    HRESULT __stdcall IViewObject_GetAdvise_Proxy(IViewObject* This,

                                                  DWORD* pAspects,

                                                  DWORD* pAdvf,

                                                  IAdviseSink** ppAdvSink);

    HRESULT __stdcall IViewObject_GetAdvise_Stub(IViewObject* This, DWORD* pAspects, DWORD* pAdvf, IAdviseSink** ppAdvSink);

    HRESULT __stdcall IEnumOLEVERB_Next_Proxy(IEnumOLEVERB* This,

                                              ULONG celt,

                                              LPOLEVERB rgelt,

                                              ULONG* pceltFetched);

    HRESULT __stdcall IEnumOLEVERB_Next_Stub(IEnumOLEVERB* This, ULONG celt, LPOLEVERB rgelt, ULONG* pceltFetched);
}

#pragma once

typedef struct IServiceProvider IServiceProvider;

extern "C"
{
#pragma comment(lib, "uuid.lib")

#pragma region Desktop Family

    extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_0000_v0_0_s_ifspec;

    typedef IServiceProvider* LPSERVICEPROVIDER;

    extern "C" const IID IID_IServiceProvider;
    extern "C++"
    {
        struct __declspec(uuid("6d5140c1-7436-11ce-8034-00aa006009fa")) __declspec(novtable) IServiceProvider : public IUnknown
        {
        public:
            virtual HRESULT __stdcall QueryService(const GUID& guidService, const IID& riid, void** ppvObject) = 0;

            template <class Q> HRESULT __stdcall QueryService(const GUID& guidService, Q** pp)
            {
                return QueryService(guidService, __uuidof(Q), (void**)pp);
            }
        };
    }

    HRESULT __stdcall IServiceProvider_RemoteQueryService_Proxy(IServiceProvider* This,
                                                                const GUID& guidService,
                                                                const IID& riid,
                                                                IUnknown** ppvObject);

    void __stdcall IServiceProvider_RemoteQueryService_Stub(IRpcStubBuffer* This,
                                                            IRpcChannelBuffer* _pRpcChannelBuffer,
                                                            PRPC_MESSAGE _pRpcMessage,
                                                            DWORD* _pdwStubPhase);

#pragma endregion

    extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_0001_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_servprov_0000_0001_v0_0_s_ifspec;

    HRESULT __stdcall IServiceProvider_QueryService_Proxy(IServiceProvider* This,

                                                          const GUID& guidService,

                                                          const IID& riid,

                                                          void** ppvObject);

    HRESULT __stdcall IServiceProvider_QueryService_Stub(IServiceProvider* This, const GUID& guidService, const IID& riid, IUnknown** ppvObject);
}

#pragma once

typedef struct IXMLDOMImplementation IXMLDOMImplementation;

typedef struct IXMLDOMNode IXMLDOMNode;

typedef struct IXMLDOMDocumentFragment IXMLDOMDocumentFragment;

typedef struct IXMLDOMDocument IXMLDOMDocument;

typedef struct IXMLDOMNodeList IXMLDOMNodeList;

typedef struct IXMLDOMNamedNodeMap IXMLDOMNamedNodeMap;

typedef struct IXMLDOMCharacterData IXMLDOMCharacterData;

typedef struct IXMLDOMAttribute IXMLDOMAttribute;

typedef struct IXMLDOMElement IXMLDOMElement;

typedef struct IXMLDOMText IXMLDOMText;

typedef struct IXMLDOMComment IXMLDOMComment;

typedef struct IXMLDOMProcessingInstruction IXMLDOMProcessingInstruction;

typedef struct IXMLDOMCDATASection IXMLDOMCDATASection;

typedef struct IXMLDOMDocumentType IXMLDOMDocumentType;

typedef struct IXMLDOMNotation IXMLDOMNotation;

typedef struct IXMLDOMEntity IXMLDOMEntity;

typedef struct IXMLDOMEntityReference IXMLDOMEntityReference;

typedef struct IXMLDOMParseError IXMLDOMParseError;

typedef struct IXTLRuntime IXTLRuntime;

typedef struct XMLDOMDocumentEvents XMLDOMDocumentEvents;

typedef class DOMDocument DOMDocument;

typedef class DOMFreeThreadedDocument DOMFreeThreadedDocument;

typedef struct IXMLHttpRequest IXMLHttpRequest;

typedef class XMLHTTPRequest XMLHTTPRequest;

typedef struct IXMLDSOControl IXMLDSOControl;

typedef class XMLDSOControl XMLDSOControl;

typedef struct IXMLElementCollection IXMLElementCollection;

typedef struct IXMLDocument IXMLDocument;

typedef struct IXMLDocument2 IXMLDocument2;

typedef struct IXMLElement IXMLElement;

typedef struct IXMLElement2 IXMLElement2;

typedef struct IXMLAttribute IXMLAttribute;

typedef struct IXMLError IXMLError;

typedef class XMLDocument XMLDocument;

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4001)
#pragma once
#pragma warning(push)
#pragma warning(disable : 4001)
#pragma once
#pragma warning(pop)
#pragma warning(pop)
#pragma region Desktop Family
#pragma endregion

#pragma warning(push)
#pragma warning(disable : 4820)
#pragma region Desktop Family

    typedef struct _xml_error
    {
        unsigned int _nLine;
        BSTR _pchBuf;
        unsigned int _cchBuf;
        unsigned int _ich;
        BSTR _pszFound;
        BSTR _pszExpected;
        DWORD _reserved1;
        DWORD _reserved2;
    } XML_ERROR;

    extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_0000_v0_0_s_ifspec;

#pragma region Desktop Family
#pragma endregion

    typedef enum tagDOMNodeType
    {
        NODE_INVALID = 0,
        NODE_ELEMENT = (NODE_INVALID + 1),
        NODE_ATTRIBUTE = (NODE_ELEMENT + 1),
        NODE_TEXT = (NODE_ATTRIBUTE + 1),
        NODE_CDATA_SECTION = (NODE_TEXT + 1),
        NODE_ENTITY_REFERENCE = (NODE_CDATA_SECTION + 1),
        NODE_ENTITY = (NODE_ENTITY_REFERENCE + 1),
        NODE_PROCESSING_INSTRUCTION = (NODE_ENTITY + 1),
        NODE_COMMENT = (NODE_PROCESSING_INSTRUCTION + 1),
        NODE_DOCUMENT = (NODE_COMMENT + 1),
        NODE_DOCUMENT_TYPE = (NODE_DOCUMENT + 1),
        NODE_DOCUMENT_FRAGMENT = (NODE_DOCUMENT_TYPE + 1),
        NODE_NOTATION = (NODE_DOCUMENT_FRAGMENT + 1)
    } DOMNodeType;

#pragma region Desktop Family
#pragma endregion

    typedef enum tagXMLEMEM_TYPE
    {
        XMLELEMTYPE_ELEMENT = 0,
        XMLELEMTYPE_TEXT = (XMLELEMTYPE_ELEMENT + 1),
        XMLELEMTYPE_COMMENT = (XMLELEMTYPE_TEXT + 1),
        XMLELEMTYPE_DOCUMENT = (XMLELEMTYPE_COMMENT + 1),
        XMLELEMTYPE_DTD = (XMLELEMTYPE_DOCUMENT + 1),
        XMLELEMTYPE_PI = (XMLELEMTYPE_DTD + 1),
        XMLELEMTYPE_OTHER = (XMLELEMTYPE_PI + 1)
    } XMLELEM_TYPE;

    extern "C" const IID LIBID_MSXML;

    extern "C" const IID IID_IXMLDOMImplementation;

    struct __declspec(uuid("2933BF8F-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMImplementation : public IDispatch
    {
    public:
        virtual HRESULT __stdcall hasFeature(BSTR feature, BSTR version, VARIANT_BOOL* hasFeature) = 0;
    };

    extern "C" const IID IID_IXMLDOMNode;

    struct __declspec(uuid("2933BF80-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMNode : public IDispatch
    {
    public:
        virtual HRESULT __stdcall get_nodeName(BSTR* name) = 0;

        virtual HRESULT __stdcall get_nodeValue(VARIANT* value) = 0;

        virtual HRESULT __stdcall put_nodeValue(VARIANT value) = 0;

        virtual HRESULT __stdcall get_nodeType(DOMNodeType* type) = 0;

        virtual HRESULT __stdcall get_parentNode(IXMLDOMNode** parent) = 0;

        virtual HRESULT __stdcall get_childNodes(IXMLDOMNodeList** childList) = 0;

        virtual HRESULT __stdcall get_firstChild(IXMLDOMNode** firstChild) = 0;

        virtual HRESULT __stdcall get_lastChild(IXMLDOMNode** lastChild) = 0;

        virtual HRESULT __stdcall get_previousSibling(IXMLDOMNode** previousSibling) = 0;

        virtual HRESULT __stdcall get_nextSibling(IXMLDOMNode** nextSibling) = 0;

        virtual HRESULT __stdcall get_attributes(IXMLDOMNamedNodeMap** attributeMap) = 0;

        virtual HRESULT __stdcall insertBefore(IXMLDOMNode* newChild, VARIANT refChild, IXMLDOMNode** outNewChild) = 0;

        virtual HRESULT __stdcall replaceChild(IXMLDOMNode* newChild, IXMLDOMNode* oldChild, IXMLDOMNode** outOldChild) = 0;

        virtual HRESULT __stdcall removeChild(IXMLDOMNode* childNode, IXMLDOMNode** oldChild) = 0;

        virtual HRESULT __stdcall appendChild(IXMLDOMNode* newChild, IXMLDOMNode** outNewChild) = 0;

        virtual HRESULT __stdcall hasChildNodes(VARIANT_BOOL* hasChild) = 0;

        virtual HRESULT __stdcall get_ownerDocument(IXMLDOMDocument** XMLDOMDocument) = 0;

        virtual HRESULT __stdcall cloneNode(VARIANT_BOOL deep, IXMLDOMNode** cloneRoot) = 0;

        virtual HRESULT __stdcall get_nodeTypeString(BSTR* nodeType) = 0;

        virtual HRESULT __stdcall get_text(BSTR* text) = 0;

        virtual HRESULT __stdcall put_text(BSTR text) = 0;

        virtual HRESULT __stdcall get_specified(VARIANT_BOOL* isSpecified) = 0;

        virtual HRESULT __stdcall get_definition(IXMLDOMNode** definitionNode) = 0;

        virtual HRESULT __stdcall get_nodeTypedValue(VARIANT* typedValue) = 0;

        virtual HRESULT __stdcall put_nodeTypedValue(VARIANT typedValue) = 0;

        virtual HRESULT __stdcall get_dataType(VARIANT* dataTypeName) = 0;

        virtual HRESULT __stdcall put_dataType(BSTR dataTypeName) = 0;

        virtual HRESULT __stdcall get_xml(BSTR* xmlString) = 0;

        virtual HRESULT __stdcall transformNode(IXMLDOMNode* stylesheet, BSTR* xmlString) = 0;

        virtual HRESULT __stdcall selectNodes(BSTR queryString, IXMLDOMNodeList** resultList) = 0;

        virtual HRESULT __stdcall selectSingleNode(BSTR queryString, IXMLDOMNode** resultNode) = 0;

        virtual HRESULT __stdcall get_parsed(VARIANT_BOOL* isParsed) = 0;

        virtual HRESULT __stdcall get_namespaceURI(BSTR* namespaceURI) = 0;

        virtual HRESULT __stdcall get_prefix(BSTR* prefixString) = 0;

        virtual HRESULT __stdcall get_baseName(BSTR* nameString) = 0;

        virtual HRESULT __stdcall transformNodeToObject(IXMLDOMNode* stylesheet, VARIANT outputObject) = 0;
    };

    extern "C" const IID IID_IXMLDOMDocumentFragment;

    struct __declspec(uuid("3efaa413-272f-11d2-836f-0000f87a7782")) __declspec(novtable) IXMLDOMDocumentFragment : public IXMLDOMNode
    {
    public:
    };

    extern "C" const IID IID_IXMLDOMDocument;

    struct __declspec(uuid("2933BF81-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMDocument : public IXMLDOMNode
    {
    public:
        virtual HRESULT __stdcall get_doctype(IXMLDOMDocumentType** documentType) = 0;

        virtual HRESULT __stdcall get_implementation(IXMLDOMImplementation** impl) = 0;

        virtual HRESULT __stdcall get_documentElement(IXMLDOMElement** DOMElement) = 0;

        virtual HRESULT __stdcall putref_documentElement(IXMLDOMElement* DOMElement) = 0;

        virtual HRESULT __stdcall createElement(BSTR tagName, IXMLDOMElement** element) = 0;

        virtual HRESULT __stdcall createDocumentFragment(IXMLDOMDocumentFragment** docFrag) = 0;

        virtual HRESULT __stdcall createTextNode(BSTR data, IXMLDOMText** text) = 0;

        virtual HRESULT __stdcall createComment(BSTR data, IXMLDOMComment** comment) = 0;

        virtual HRESULT __stdcall createCDATASection(BSTR data, IXMLDOMCDATASection** cdata) = 0;

        virtual HRESULT __stdcall createProcessingInstruction(BSTR target, BSTR data, IXMLDOMProcessingInstruction** pi) = 0;

        virtual HRESULT __stdcall createAttribute(BSTR name, IXMLDOMAttribute** attribute) = 0;

        virtual HRESULT __stdcall createEntityReference(BSTR name, IXMLDOMEntityReference** entityRef) = 0;

        virtual HRESULT __stdcall getElementsByTagName(BSTR tagName, IXMLDOMNodeList** resultList) = 0;

        virtual HRESULT __stdcall createNode(VARIANT Type, BSTR name, BSTR namespaceURI, IXMLDOMNode** node) = 0;

        virtual HRESULT __stdcall nodeFromID(BSTR idString, IXMLDOMNode** node) = 0;

        virtual HRESULT __stdcall load(VARIANT xmlSource, VARIANT_BOOL* isSuccessful) = 0;

        virtual HRESULT __stdcall get_readyState(long* value) = 0;

        virtual HRESULT __stdcall get_parseError(IXMLDOMParseError** errorObj) = 0;

        virtual HRESULT __stdcall get_url(BSTR* urlString) = 0;

        virtual HRESULT __stdcall get_async(VARIANT_BOOL* isAsync) = 0;

        virtual HRESULT __stdcall put_async(VARIANT_BOOL isAsync) = 0;

        virtual HRESULT __stdcall abort(void) = 0;

        virtual HRESULT __stdcall loadXML(BSTR bstrXML, VARIANT_BOOL* isSuccessful) = 0;

        virtual HRESULT __stdcall save(VARIANT destination) = 0;

        virtual HRESULT __stdcall get_validateOnParse(VARIANT_BOOL* isValidating) = 0;

        virtual HRESULT __stdcall put_validateOnParse(VARIANT_BOOL isValidating) = 0;

        virtual HRESULT __stdcall get_resolveExternals(VARIANT_BOOL* isResolving) = 0;

        virtual HRESULT __stdcall put_resolveExternals(VARIANT_BOOL isResolving) = 0;

        virtual HRESULT __stdcall get_preserveWhiteSpace(VARIANT_BOOL* isPreserving) = 0;

        virtual HRESULT __stdcall put_preserveWhiteSpace(VARIANT_BOOL isPreserving) = 0;

        virtual HRESULT __stdcall put_onreadystatechange(VARIANT readystatechangeSink) = 0;

        virtual HRESULT __stdcall put_ondataavailable(VARIANT ondataavailableSink) = 0;

        virtual HRESULT __stdcall put_ontransformnode(VARIANT ontransformnodeSink) = 0;
    };

    extern "C" const IID IID_IXMLDOMNodeList;

    struct __declspec(uuid("2933BF82-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMNodeList : public IDispatch
    {
    public:
        virtual HRESULT __stdcall get_item(long index, IXMLDOMNode** listItem) = 0;

        virtual HRESULT __stdcall get_length(long* listLength) = 0;

        virtual HRESULT __stdcall nextNode(IXMLDOMNode** nextItem) = 0;

        virtual HRESULT __stdcall reset(void) = 0;

        virtual HRESULT __stdcall get__newEnum(IUnknown** ppUnk) = 0;
    };

    extern "C" const IID IID_IXMLDOMNamedNodeMap;

    struct __declspec(uuid("2933BF83-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMNamedNodeMap : public IDispatch
    {
    public:
        virtual HRESULT __stdcall getNamedItem(BSTR name, IXMLDOMNode** namedItem) = 0;

        virtual HRESULT __stdcall setNamedItem(IXMLDOMNode* newItem, IXMLDOMNode** nameItem) = 0;

        virtual HRESULT __stdcall removeNamedItem(BSTR name, IXMLDOMNode** namedItem) = 0;

        virtual HRESULT __stdcall get_item(long index, IXMLDOMNode** listItem) = 0;

        virtual HRESULT __stdcall get_length(long* listLength) = 0;

        virtual HRESULT __stdcall getQualifiedItem(BSTR baseName, BSTR namespaceURI, IXMLDOMNode** qualifiedItem) = 0;

        virtual HRESULT __stdcall removeQualifiedItem(BSTR baseName, BSTR namespaceURI, IXMLDOMNode** qualifiedItem) = 0;

        virtual HRESULT __stdcall nextNode(IXMLDOMNode** nextItem) = 0;

        virtual HRESULT __stdcall reset(void) = 0;

        virtual HRESULT __stdcall get__newEnum(IUnknown** ppUnk) = 0;
    };

    extern "C" const IID IID_IXMLDOMCharacterData;

    struct __declspec(uuid("2933BF84-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMCharacterData : public IXMLDOMNode
    {
    public:
        virtual HRESULT __stdcall get_data(BSTR* data) = 0;

        virtual HRESULT __stdcall put_data(BSTR data) = 0;

        virtual HRESULT __stdcall get_length(long* dataLength) = 0;

        virtual HRESULT __stdcall substringData(long offset, long count, BSTR* data) = 0;

        virtual HRESULT __stdcall appendData(BSTR data) = 0;

        virtual HRESULT __stdcall insertData(long offset, BSTR data) = 0;

        virtual HRESULT __stdcall deleteData(long offset, long count) = 0;

        virtual HRESULT __stdcall replaceData(long offset, long count, BSTR data) = 0;
    };

    extern "C" const IID IID_IXMLDOMAttribute;

    struct __declspec(uuid("2933BF85-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMAttribute : public IXMLDOMNode
    {
    public:
        virtual HRESULT __stdcall get_name(BSTR* attributeName) = 0;

        virtual HRESULT __stdcall get_value(VARIANT* attributeValue) = 0;

        virtual HRESULT __stdcall put_value(VARIANT attributeValue) = 0;
    };

    extern "C" const IID IID_IXMLDOMElement;

    struct __declspec(uuid("2933BF86-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMElement : public IXMLDOMNode
    {
    public:
        virtual HRESULT __stdcall get_tagName(BSTR* tagName) = 0;

        virtual HRESULT __stdcall getAttribute(BSTR name, VARIANT* value) = 0;

        virtual HRESULT __stdcall setAttribute(BSTR name, VARIANT value) = 0;

        virtual HRESULT __stdcall removeAttribute(BSTR name) = 0;

        virtual HRESULT __stdcall getAttributeNode(BSTR name, IXMLDOMAttribute** attributeNode) = 0;

        virtual HRESULT __stdcall setAttributeNode(IXMLDOMAttribute* DOMAttribute, IXMLDOMAttribute** attributeNode) = 0;

        virtual HRESULT __stdcall removeAttributeNode(IXMLDOMAttribute* DOMAttribute, IXMLDOMAttribute** attributeNode) = 0;

        virtual HRESULT __stdcall getElementsByTagName(BSTR tagName, IXMLDOMNodeList** resultList) = 0;

        virtual HRESULT __stdcall normalize(void) = 0;
    };

    extern "C" const IID IID_IXMLDOMText;

    struct __declspec(uuid("2933BF87-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMText : public IXMLDOMCharacterData
    {
    public:
        virtual HRESULT __stdcall splitText(long offset, IXMLDOMText** rightHandTextNode) = 0;
    };

    extern "C" const IID IID_IXMLDOMComment;

    struct __declspec(uuid("2933BF88-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMComment : public IXMLDOMCharacterData
    {
    public:
    };

    extern "C" const IID IID_IXMLDOMProcessingInstruction;

    struct __declspec(uuid("2933BF89-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMProcessingInstruction : public IXMLDOMNode
    {
    public:
        virtual HRESULT __stdcall get_target(BSTR* name) = 0;

        virtual HRESULT __stdcall get_data(BSTR* value) = 0;

        virtual HRESULT __stdcall put_data(BSTR value) = 0;
    };

    extern "C" const IID IID_IXMLDOMCDATASection;

    struct __declspec(uuid("2933BF8A-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMCDATASection : public IXMLDOMText
    {
    public:
    };

    extern "C" const IID IID_IXMLDOMDocumentType;

    struct __declspec(uuid("2933BF8B-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMDocumentType : public IXMLDOMNode
    {
    public:
        virtual HRESULT __stdcall get_name(BSTR* rootName) = 0;

        virtual HRESULT __stdcall get_entities(IXMLDOMNamedNodeMap** entityMap) = 0;

        virtual HRESULT __stdcall get_notations(IXMLDOMNamedNodeMap** notationMap) = 0;
    };

    extern "C" const IID IID_IXMLDOMNotation;

    struct __declspec(uuid("2933BF8C-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMNotation : public IXMLDOMNode
    {
    public:
        virtual HRESULT __stdcall get_publicId(VARIANT* publicID) = 0;

        virtual HRESULT __stdcall get_systemId(VARIANT* systemID) = 0;
    };

    extern "C" const IID IID_IXMLDOMEntity;

    struct __declspec(uuid("2933BF8D-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMEntity : public IXMLDOMNode
    {
    public:
        virtual HRESULT __stdcall get_publicId(VARIANT* publicID) = 0;

        virtual HRESULT __stdcall get_systemId(VARIANT* systemID) = 0;

        virtual HRESULT __stdcall get_notationName(BSTR* name) = 0;
    };

    extern "C" const IID IID_IXMLDOMEntityReference;

    struct __declspec(uuid("2933BF8E-7B36-11d2-B20E-00C04F983E60")) __declspec(novtable) IXMLDOMEntityReference : public IXMLDOMNode
    {
    public:
    };

    extern "C" const IID IID_IXMLDOMParseError;

    struct __declspec(uuid("3efaa426-272f-11d2-836f-0000f87a7782")) __declspec(novtable) IXMLDOMParseError : public IDispatch
    {
    public:
        virtual HRESULT __stdcall get_errorCode(long* errorCode) = 0;

        virtual HRESULT __stdcall get_url(BSTR* urlString) = 0;

        virtual HRESULT __stdcall get_reason(BSTR* reasonString) = 0;

        virtual HRESULT __stdcall get_srcText(BSTR* sourceString) = 0;

        virtual HRESULT __stdcall get_line(long* lineNumber) = 0;

        virtual HRESULT __stdcall get_linepos(long* linePosition) = 0;

        virtual HRESULT __stdcall get_filepos(long* filePosition) = 0;
    };

    extern "C" const IID IID_IXTLRuntime;

    struct __declspec(uuid("3efaa425-272f-11d2-836f-0000f87a7782")) __declspec(novtable) IXTLRuntime : public IXMLDOMNode
    {
    public:
        virtual HRESULT __stdcall uniqueID(IXMLDOMNode* pNode, long* pID) = 0;

        virtual HRESULT __stdcall depth(IXMLDOMNode* pNode, long* pDepth) = 0;

        virtual HRESULT __stdcall childNumber(IXMLDOMNode* pNode, long* pNumber) = 0;

        virtual HRESULT __stdcall ancestorChildNumber(BSTR bstrNodeName, IXMLDOMNode* pNode, long* pNumber) = 0;

        virtual HRESULT __stdcall absoluteChildNumber(IXMLDOMNode* pNode, long* pNumber) = 0;

        virtual HRESULT __stdcall formatIndex(long lIndex, BSTR bstrFormat, BSTR* pbstrFormattedString) = 0;

        virtual HRESULT __stdcall formatNumber(double dblNumber, BSTR bstrFormat, BSTR* pbstrFormattedString) = 0;

        virtual HRESULT __stdcall formatDate(VARIANT varDate, BSTR bstrFormat, VARIANT varDestLocale, BSTR* pbstrFormattedString)
        = 0;

        virtual HRESULT __stdcall formatTime(VARIANT varTime, BSTR bstrFormat, VARIANT varDestLocale, BSTR* pbstrFormattedString)
        = 0;
    };

    extern "C" const IID DIID_XMLDOMDocumentEvents;

    struct __declspec(uuid("3efaa427-272f-11d2-836f-0000f87a7782")) __declspec(novtable) XMLDOMDocumentEvents : public IDispatch
    {
    };

    extern "C" const CLSID CLSID_DOMDocument;

    class __declspec(uuid("2933BF90-7B36-11d2-B20E-00C04F983E60")) DOMDocument;

    extern "C" const CLSID CLSID_DOMFreeThreadedDocument;

    class __declspec(uuid("2933BF91-7B36-11d2-B20E-00C04F983E60")) DOMFreeThreadedDocument;

    extern "C" const IID IID_IXMLHttpRequest;

    struct __declspec(uuid("ED8C108D-4349-11D2-91A4-00C04F7969E8")) __declspec(novtable) IXMLHttpRequest : public IDispatch
    {
    public:
        virtual HRESULT __stdcall open(BSTR bstrMethod, BSTR bstrUrl, VARIANT varAsync, VARIANT bstrUser, VARIANT bstrPassword) = 0;

        virtual HRESULT __stdcall setRequestHeader(BSTR bstrHeader, BSTR bstrValue) = 0;

        virtual HRESULT __stdcall getResponseHeader(BSTR bstrHeader, BSTR* pbstrValue) = 0;

        virtual HRESULT __stdcall getAllResponseHeaders(BSTR* pbstrHeaders) = 0;

        virtual HRESULT __stdcall send(VARIANT varBody) = 0;

        virtual HRESULT __stdcall abort(void) = 0;

        virtual HRESULT __stdcall get_status(long* plStatus) = 0;

        virtual HRESULT __stdcall get_statusText(BSTR* pbstrStatus) = 0;

        virtual HRESULT __stdcall get_responseXML(IDispatch** ppBody) = 0;

        virtual HRESULT __stdcall get_responseText(BSTR* pbstrBody) = 0;

        virtual HRESULT __stdcall get_responseBody(VARIANT* pvarBody) = 0;

        virtual HRESULT __stdcall get_responseStream(VARIANT* pvarBody) = 0;

        virtual HRESULT __stdcall get_readyState(long* plState) = 0;

        virtual HRESULT __stdcall put_onreadystatechange(IDispatch* pReadyStateSink) = 0;
    };

    extern "C" const CLSID CLSID_XMLHTTPRequest;

    class __declspec(uuid("ED8C108E-4349-11D2-91A4-00C04F7969E8")) XMLHTTPRequest;

    extern "C" const IID IID_IXMLDSOControl;

    struct __declspec(uuid("310afa62-0575-11d2-9ca9-0060b0ec3d39")) __declspec(novtable) IXMLDSOControl : public IDispatch
    {
    public:
        virtual HRESULT __stdcall get_XMLDocument(IXMLDOMDocument** ppDoc) = 0;

        virtual HRESULT __stdcall put_XMLDocument(IXMLDOMDocument* ppDoc) = 0;

        virtual HRESULT __stdcall get_JavaDSOCompatible(BOOL* fJavaDSOCompatible) = 0;

        virtual HRESULT __stdcall put_JavaDSOCompatible(BOOL fJavaDSOCompatible) = 0;

        virtual HRESULT __stdcall get_readyState(long* state) = 0;
    };

    extern "C" const CLSID CLSID_XMLDSOControl;

    class __declspec(uuid("550dda30-0541-11d2-9ca9-0060b0ec3d39")) XMLDSOControl;

    extern "C" const IID IID_IXMLElementCollection;

    struct __declspec(uuid("65725580-9B5D-11d0-9BFE-00C04FC99C8E")) __declspec(novtable) IXMLElementCollection : public IDispatch
    {
    public:
        virtual HRESULT __stdcall put_length(long v) = 0;

        virtual HRESULT __stdcall get_length(long* p) = 0;

        virtual HRESULT __stdcall get__newEnum(IUnknown** ppUnk) = 0;

        virtual HRESULT __stdcall item(VARIANT var1, VARIANT var2, IDispatch** ppDisp) = 0;
    };

    extern "C" const IID IID_IXMLDocument;

    struct __declspec(uuid("F52E2B61-18A1-11d1-B105-00805F49916B")) __declspec(novtable) IXMLDocument : public IDispatch
    {
    public:
        virtual HRESULT __stdcall get_root(IXMLElement** p) = 0;

        virtual HRESULT __stdcall get_fileSize(BSTR* p) = 0;

        virtual HRESULT __stdcall get_fileModifiedDate(BSTR* p) = 0;

        virtual HRESULT __stdcall get_fileUpdatedDate(BSTR* p) = 0;

        virtual HRESULT __stdcall get_URL(BSTR* p) = 0;

        virtual HRESULT __stdcall put_URL(BSTR p) = 0;

        virtual HRESULT __stdcall get_mimeType(BSTR* p) = 0;

        virtual HRESULT __stdcall get_readyState(long* pl) = 0;

        virtual HRESULT __stdcall get_charset(BSTR* p) = 0;

        virtual HRESULT __stdcall put_charset(BSTR p) = 0;

        virtual HRESULT __stdcall get_version(BSTR* p) = 0;

        virtual HRESULT __stdcall get_doctype(BSTR* p) = 0;

        virtual HRESULT __stdcall get_dtdURL(BSTR* p) = 0;

        virtual HRESULT __stdcall createElement(VARIANT vType, VARIANT var1, IXMLElement** ppElem) = 0;
    };

    extern "C" const IID IID_IXMLDocument2;

    struct __declspec(uuid("2B8DE2FE-8D2D-11d1-B2FC-00C04FD915A9")) __declspec(novtable) IXMLDocument2 : public IDispatch
    {
    public:
        virtual HRESULT __stdcall get_root(IXMLElement2** p) = 0;

        virtual HRESULT __stdcall get_fileSize(BSTR* p) = 0;

        virtual HRESULT __stdcall get_fileModifiedDate(BSTR* p) = 0;

        virtual HRESULT __stdcall get_fileUpdatedDate(BSTR* p) = 0;

        virtual HRESULT __stdcall get_URL(BSTR* p) = 0;

        virtual HRESULT __stdcall put_URL(BSTR p) = 0;

        virtual HRESULT __stdcall get_mimeType(BSTR* p) = 0;

        virtual HRESULT __stdcall get_readyState(long* pl) = 0;

        virtual HRESULT __stdcall get_charset(BSTR* p) = 0;

        virtual HRESULT __stdcall put_charset(BSTR p) = 0;

        virtual HRESULT __stdcall get_version(BSTR* p) = 0;

        virtual HRESULT __stdcall get_doctype(BSTR* p) = 0;

        virtual HRESULT __stdcall get_dtdURL(BSTR* p) = 0;

        virtual HRESULT __stdcall createElement(VARIANT vType, VARIANT var1, IXMLElement2** ppElem) = 0;

        virtual HRESULT __stdcall get_async(VARIANT_BOOL* pf) = 0;

        virtual HRESULT __stdcall put_async(VARIANT_BOOL f) = 0;
    };

    extern "C" const IID IID_IXMLElement;

    struct __declspec(uuid("3F7F31AC-E15F-11d0-9C25-00C04FC99C8E")) __declspec(novtable) IXMLElement : public IDispatch
    {
    public:
        virtual HRESULT __stdcall get_tagName(BSTR* p) = 0;

        virtual HRESULT __stdcall put_tagName(BSTR p) = 0;

        virtual HRESULT __stdcall get_parent(IXMLElement** ppParent) = 0;

        virtual HRESULT __stdcall setAttribute(BSTR strPropertyName, VARIANT PropertyValue) = 0;

        virtual HRESULT __stdcall getAttribute(BSTR strPropertyName, VARIANT* PropertyValue) = 0;

        virtual HRESULT __stdcall removeAttribute(BSTR strPropertyName) = 0;

        virtual HRESULT __stdcall get_children(IXMLElementCollection** pp) = 0;

        virtual HRESULT __stdcall get_type(long* plType) = 0;

        virtual HRESULT __stdcall get_text(BSTR* p) = 0;

        virtual HRESULT __stdcall put_text(BSTR p) = 0;

        virtual HRESULT __stdcall addChild(IXMLElement* pChildElem, long lIndex, long lReserved) = 0;

        virtual HRESULT __stdcall removeChild(IXMLElement* pChildElem) = 0;
    };

    extern "C" const IID IID_IXMLElement2;

    struct __declspec(uuid("2B8DE2FF-8D2D-11d1-B2FC-00C04FD915A9")) __declspec(novtable) IXMLElement2 : public IDispatch
    {
    public:
        virtual HRESULT __stdcall get_tagName(BSTR* p) = 0;

        virtual HRESULT __stdcall put_tagName(BSTR p) = 0;

        virtual HRESULT __stdcall get_parent(IXMLElement2** ppParent) = 0;

        virtual HRESULT __stdcall setAttribute(BSTR strPropertyName, VARIANT PropertyValue) = 0;

        virtual HRESULT __stdcall getAttribute(BSTR strPropertyName, VARIANT* PropertyValue) = 0;

        virtual HRESULT __stdcall removeAttribute(BSTR strPropertyName) = 0;

        virtual HRESULT __stdcall get_children(IXMLElementCollection** pp) = 0;

        virtual HRESULT __stdcall get_type(long* plType) = 0;

        virtual HRESULT __stdcall get_text(BSTR* p) = 0;

        virtual HRESULT __stdcall put_text(BSTR p) = 0;

        virtual HRESULT __stdcall addChild(IXMLElement2* pChildElem, long lIndex, long lReserved) = 0;

        virtual HRESULT __stdcall removeChild(IXMLElement2* pChildElem) = 0;

        virtual HRESULT __stdcall get_attributes(IXMLElementCollection** pp) = 0;
    };

    extern "C" const IID IID_IXMLAttribute;

    struct __declspec(uuid("D4D4A0FC-3B73-11d1-B2B4-00C04FB92596")) __declspec(novtable) IXMLAttribute : public IDispatch
    {
    public:
        virtual HRESULT __stdcall get_name(BSTR* n) = 0;

        virtual HRESULT __stdcall get_value(BSTR* v) = 0;
    };

    extern "C" const IID IID_IXMLError;

    struct __declspec(uuid("948C5AD3-C58D-11d0-9C0B-00C04FC99C8E")) __declspec(novtable) IXMLError : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetErrorInfo(XML_ERROR* pErrorReturn) = 0;
    };

    extern "C" const CLSID CLSID_XMLDocument;

    class __declspec(uuid("CFC399AF-D876-11d0-9C10-00C04FC99C8E")) XMLDocument;

#pragma endregion

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_0001_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_msxml_0000_0001_v0_0_s_ifspec;
}

extern "C"
{
#pragma comment(lib, "uuid.lib")

#pragma warning(push)

#pragma warning(disable : 4820)
#pragma region Desktop Family

    extern "C" const IID CLSID_SBS_StdURLMoniker;
    extern "C" const IID CLSID_SBS_HttpProtocol;
    extern "C" const IID CLSID_SBS_FtpProtocol;
    extern "C" const IID CLSID_SBS_GopherProtocol;
    extern "C" const IID CLSID_SBS_HttpSProtocol;
    extern "C" const IID CLSID_SBS_FileProtocol;
    extern "C" const IID CLSID_SBS_MkProtocol;
    extern "C" const IID CLSID_SBS_UrlMkBindCtx;
    extern "C" const IID CLSID_SBS_SoftDistExt;
    extern "C" const IID CLSID_SBS_CdlProtocol;
    extern "C" const IID CLSID_SBS_ClassInstallFilter;
    extern "C" const IID CLSID_SBS_InternetSecurityManager;
    extern "C" const IID CLSID_SBS_InternetZoneManager;

    extern "C" const IID IID_IAsyncMoniker;
    extern "C" const IID CLSID_StdURLMoniker;
    extern "C" const IID CLSID_HttpProtocol;
    extern "C" const IID CLSID_FtpProtocol;
    extern "C" const IID CLSID_GopherProtocol;
    extern "C" const IID CLSID_HttpSProtocol;
    extern "C" const IID CLSID_FileProtocol;
    extern "C" const IID CLSID_ResProtocol;
    extern "C" const IID CLSID_AboutProtocol;
    extern "C" const IID CLSID_JSProtocol;
    extern "C" const IID CLSID_MailtoProtocol;
    extern "C" const IID CLSID_IE4_PROTOCOLS;
    extern "C" const IID CLSID_MkProtocol;
    extern "C" const IID CLSID_StdURLProtocol;
    extern "C" const IID CLSID_TBAuthProtocol;
    extern "C" const IID CLSID_UrlMkBindCtx;
    extern "C" const IID CLSID_CdlProtocol;
    extern "C" const IID CLSID_ClassInstallFilter;
    extern "C" const IID IID_IAsyncBindCtx;

    extern "C" HRESULT __stdcall CreateURLMoniker(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER* ppmk);
    extern "C" HRESULT __stdcall CreateURLMonikerEx(LPMONIKER pMkCtx, LPCWSTR szURL, LPMONIKER* ppmk, DWORD dwFlags);
    extern "C" HRESULT __stdcall GetClassURL(LPCWSTR szURL, CLSID* pClsID);
    extern "C" HRESULT __stdcall CreateAsyncBindCtx(DWORD reserved, IBindStatusCallback* pBSCb, IEnumFORMATETC* pEFetc, IBindCtx** ppBC);

    extern "C" HRESULT __stdcall CreateURLMonikerEx2(LPMONIKER pMkCtx, IUri* pUri, LPMONIKER* ppmk, DWORD dwFlags);
    extern "C" HRESULT __stdcall CreateAsyncBindCtxEx(
    IBindCtx* pbc, DWORD dwOptions, IBindStatusCallback* pBSCb, IEnumFORMATETC* pEnum, IBindCtx** ppBC, DWORD reserved);
    extern "C" HRESULT __stdcall MkParseDisplayNameEx(IBindCtx* pbc, LPCWSTR szDisplayName, ULONG* pchEaten, LPMONIKER* ppmk);
    extern "C" HRESULT __stdcall RegisterBindStatusCallback(LPBC pBC, IBindStatusCallback* pBSCb, IBindStatusCallback** ppBSCBPrev, DWORD dwReserved);
    extern "C" HRESULT __stdcall RevokeBindStatusCallback(LPBC pBC, IBindStatusCallback* pBSCb);
    extern "C" HRESULT __stdcall GetClassFileOrMime(
    LPBC pBC, LPCWSTR szFilename, LPVOID pBuffer, DWORD cbSize, LPCWSTR szMime, DWORD dwReserved, CLSID* pclsid);
    extern "C" HRESULT __stdcall IsValidURL(LPBC pBC, LPCWSTR szURL, DWORD dwReserved);
    extern "C" HRESULT __stdcall CoGetClassObjectFromURL(const IID& rCLASSID,
                                                         LPCWSTR szCODE,
                                                         DWORD dwFileVersionMS,
                                                         DWORD dwFileVersionLS,
                                                         LPCWSTR szTYPE,
                                                         LPBINDCTX pBindCtx,
                                                         DWORD dwClsContext,
                                                         LPVOID pvReserved,
                                                         const IID& riid,
                                                         LPVOID* ppv);
    extern "C" HRESULT __stdcall IEInstallScope(LPDWORD pdwScope);
    extern "C" HRESULT __stdcall FaultInIEFeature(HWND hWnd, uCLSSPEC* pClassSpec, QUERYCONTEXT* pQuery, DWORD dwFlags);
    extern "C" HRESULT __stdcall GetComponentIDFromCLSSPEC(uCLSSPEC* pClassspec, LPSTR* ppszComponentID);

    extern "C" HRESULT __stdcall IsAsyncMoniker(IMoniker* pmk);
    extern "C" HRESULT __stdcall CreateURLBinding(LPCWSTR lpszUrl, IBindCtx* pbc, IBinding** ppBdg);

    extern "C" HRESULT __stdcall RegisterMediaTypes(UINT ctypes, const LPCSTR* rgszTypes, CLIPFORMAT* rgcfTypes);
    extern "C" HRESULT __stdcall FindMediaType(LPCSTR rgszTypes, CLIPFORMAT* rgcfTypes);
    extern "C" HRESULT __stdcall CreateFormatEnumerator(UINT cfmtetc, FORMATETC* rgfmtetc, IEnumFORMATETC** ppenumfmtetc);
    extern "C" HRESULT __stdcall RegisterFormatEnumerator(LPBC pBC, IEnumFORMATETC* pEFetc, DWORD reserved);
    extern "C" HRESULT __stdcall RevokeFormatEnumerator(LPBC pBC, IEnumFORMATETC* pEFetc);
    extern "C" HRESULT __stdcall RegisterMediaTypeClass(LPBC pBC, UINT ctypes, const LPCSTR* rgszTypes, CLSID* rgclsID, DWORD reserved);
    extern "C" HRESULT __stdcall FindMediaTypeClass(LPBC pBC, LPCSTR szType, CLSID* pclsID, DWORD reserved);
#pragma endregion
#pragma region Application Family

    extern "C" HRESULT __stdcall UrlMkSetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved);
    extern "C" HRESULT __stdcall UrlMkGetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD* pdwBufferLengthOut, DWORD dwReserved);
#pragma endregion
#pragma region Desktop Family

    extern "C" HRESULT __stdcall FindMimeFromData(
    LPBC pBC, LPCWSTR pwzUrl, LPVOID pBuffer, DWORD cbSize, LPCWSTR pwzMimeProposed, DWORD dwMimeFlags, LPWSTR* ppwzMimeOut, DWORD dwReserved);

    extern "C" HRESULT __stdcall ObtainUserAgentString(DWORD dwOption, LPSTR pszUAOut, DWORD* cbSize);
    extern "C" HRESULT __stdcall CompareSecurityIds(BYTE* pbSecurityId1, DWORD dwLen1, BYTE* pbSecurityId2, DWORD dwLen2, DWORD dwReserved);
    extern "C" HRESULT __stdcall CompatFlagsFromClsid(CLSID* pclsid, LPDWORD pdwCompatFlags, LPDWORD pdwMiscStatusFlags);

    typedef enum IEObjectType
    {
        IE_EPM_OBJECT_EVENT,
        IE_EPM_OBJECT_MUTEX,
        IE_EPM_OBJECT_SEMAPHORE,
        IE_EPM_OBJECT_SHARED_MEMORY,
        IE_EPM_OBJECT_WAITABLE_TIMER,
        IE_EPM_OBJECT_FILE,
        IE_EPM_OBJECT_NAMED_PIPE,
        IE_EPM_OBJECT_REGISTRY,
    } IEObjectType;

    extern "C" HRESULT __stdcall SetAccessForIEAppContainer(HANDLE hObject, IEObjectType ieObjectType, DWORD dwAccessMask);

#pragma endregion
#pragma region Application Family

#pragma endregion
#pragma region Desktop Family

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0000_v0_0_s_ifspec;

    typedef IPersistMoniker* LPPERSISTMONIKER;

    extern "C" const IID IID_IPersistMoniker;

    struct __declspec(uuid("79eac9c9-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IPersistMoniker : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetClassID(CLSID* pClassID) = 0;

        virtual HRESULT __stdcall IsDirty(void) = 0;

        virtual HRESULT __stdcall Load(BOOL fFullyAvailable, IMoniker* pimkName, LPBC pibc, DWORD grfMode) = 0;

        virtual HRESULT __stdcall Save(IMoniker* pimkName, LPBC pbc, BOOL fRemember) = 0;

        virtual HRESULT __stdcall SaveCompleted(IMoniker* pimkName, LPBC pibc) = 0;

        virtual HRESULT __stdcall GetCurMoniker(IMoniker** ppimkName) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0001_v0_0_s_ifspec;

    typedef IMonikerProp* LPMONIKERPROP;

    typedef enum __MIDL_IMonikerProp_0001
    {
        MIMETYPEPROP = 0,
        USE_SRC_URL = 0x1,
        CLASSIDPROP = 0x2,
        TRUSTEDDOWNLOADPROP = 0x3,
        POPUPLEVELPROP = 0x4
    } MONIKERPROPERTY;

    extern "C" const IID IID_IMonikerProp;

    struct __declspec(uuid("a5ca5f7f-1847-4d87-9c5b-918509f7511d")) __declspec(novtable) IMonikerProp : public IUnknown
    {
    public:
        virtual HRESULT __stdcall PutProperty(MONIKERPROPERTY mkp, LPCWSTR val) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0002_v0_0_s_ifspec;

    typedef IBindProtocol* LPBINDPROTOCOL;

    extern "C" const IID IID_IBindProtocol;

    struct __declspec(uuid("79eac9cd-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IBindProtocol : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateBinding(LPCWSTR szUrl, IBindCtx* pbc, IBinding** ppb) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0003_v0_0_s_ifspec;

    typedef IBinding* LPBINDING;

    extern "C" const IID IID_IBinding;

    struct __declspec(uuid("79eac9c0-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IBinding : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Abort(void) = 0;

        virtual HRESULT __stdcall Suspend(void) = 0;

        virtual HRESULT __stdcall Resume(void) = 0;

        virtual HRESULT __stdcall SetPriority(LONG nPriority) = 0;

        virtual HRESULT __stdcall GetPriority(LONG* pnPriority) = 0;

        virtual HRESULT __stdcall GetBindResult(CLSID* pclsidProtocol,
                                                DWORD* pdwResult,

                                                LPOLESTR* pszResult,
                                                DWORD* pdwReserved)
        = 0;
    };

    HRESULT __stdcall IBinding_RemoteGetBindResult_Proxy(IBinding* This, CLSID* pclsidProtocol, DWORD* pdwResult, LPOLESTR* pszResult, DWORD dwReserved);

    void __stdcall IBinding_RemoteGetBindResult_Stub(IRpcStubBuffer* This,
                                                     IRpcChannelBuffer* _pRpcChannelBuffer,
                                                     PRPC_MESSAGE _pRpcMessage,
                                                     DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Application Family

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0004_v0_0_s_ifspec;

    typedef IBindStatusCallback* LPBINDSTATUSCALLBACK;

    typedef enum __MIDL_IBindStatusCallback_0001
    {
        BINDVERB_GET = 0,
        BINDVERB_POST = 0x1,
        BINDVERB_PUT = 0x2,
        BINDVERB_CUSTOM = 0x3,
        BINDVERB_RESERVED1 = 0x4
    } BINDVERB;

    typedef enum __MIDL_IBindStatusCallback_0002
    {
        BINDINFOF_URLENCODESTGMEDDATA = 0x1,
        BINDINFOF_URLENCODEDEXTRAINFO = 0x2
    } BINDINFOF;

    typedef enum __MIDL_IBindStatusCallback_0003
    {
        BINDF_ASYNCHRONOUS = 0x1,
        BINDF_ASYNCSTORAGE = 0x2,
        BINDF_NOPROGRESSIVERENDERING = 0x4,
        BINDF_OFFLINEOPERATION = 0x8,
        BINDF_GETNEWESTVERSION = 0x10,
        BINDF_NOWRITECACHE = 0x20,
        BINDF_NEEDFILE = 0x40,
        BINDF_PULLDATA = 0x80,
        BINDF_IGNORESECURITYPROBLEM = 0x100,
        BINDF_RESYNCHRONIZE = 0x200,
        BINDF_HYPERLINK = 0x400,
        BINDF_NO_UI = 0x800,
        BINDF_SILENTOPERATION = 0x1000,
        BINDF_PRAGMA_NO_CACHE = 0x2000,
        BINDF_GETCLASSOBJECT = 0x4000,
        BINDF_RESERVED_1 = 0x8000,
        BINDF_FREE_THREADED = 0x10000,
        BINDF_DIRECT_READ = 0x20000,
        BINDF_FORMS_SUBMIT = 0x40000,
        BINDF_GETFROMCACHE_IF_NET_FAIL = 0x80000,
        BINDF_FROMURLMON = 0x100000,
        BINDF_FWD_BACK = 0x200000,
        BINDF_PREFERDEFAULTHANDLER = 0x400000,
        BINDF_ENFORCERESTRICTED = 0x800000,
        BINDF_RESERVED_2 = 0x80000000,
        BINDF_RESERVED_3 = 0x1000000,
        BINDF_RESERVED_4 = 0x2000000,
        BINDF_RESERVED_5 = 0x4000000,
        BINDF_RESERVED_6 = 0x8000000,
        BINDF_RESERVED_7 = 0x40000000,
        BINDF_RESERVED_8 = 0x20000000
    } BINDF;

    typedef enum __MIDL_IBindStatusCallback_0004
    {
        URL_ENCODING_NONE = 0,
        URL_ENCODING_ENABLE_UTF8 = 0x10000000,
        URL_ENCODING_DISABLE_UTF8 = 0x20000000
    } URL_ENCODING;

    typedef struct _tagBINDINFO
    {
        ULONG cbSize;
        LPWSTR szExtraInfo;
        STGMEDIUM stgmedData;
        DWORD grfBindInfoF;
        DWORD dwBindVerb;
        LPWSTR szCustomVerb;
        DWORD cbstgmedData;
        DWORD dwOptions;
        DWORD dwOptionsFlags;
        DWORD dwCodePage;
        SECURITY_ATTRIBUTES securityAttributes;
        IID iid;
        IUnknown* pUnk;
        DWORD dwReserved;
    } BINDINFO;

    typedef struct _REMSECURITY_ATTRIBUTES
    {
        DWORD nLength;
        DWORD lpSecurityDescriptor;
        BOOL bInheritHandle;
    } REMSECURITY_ATTRIBUTES;

    typedef struct _REMSECURITY_ATTRIBUTES* PREMSECURITY_ATTRIBUTES;

    typedef struct _REMSECURITY_ATTRIBUTES* LPREMSECURITY_ATTRIBUTES;

    typedef struct _tagRemBINDINFO
    {
        ULONG cbSize;
        LPWSTR szExtraInfo;
        DWORD grfBindInfoF;
        DWORD dwBindVerb;
        LPWSTR szCustomVerb;
        DWORD cbstgmedData;
        DWORD dwOptions;
        DWORD dwOptionsFlags;
        DWORD dwCodePage;
        REMSECURITY_ATTRIBUTES securityAttributes;
        IID iid;
        IUnknown* pUnk;
        DWORD dwReserved;
    } RemBINDINFO;

    typedef struct tagRemFORMATETC
    {
        DWORD cfFormat;
        DWORD ptd;
        DWORD dwAspect;
        LONG lindex;
        DWORD tymed;
    } RemFORMATETC;

    typedef struct tagRemFORMATETC* LPREMFORMATETC;

    typedef enum __MIDL_IBindStatusCallback_0005
    {
        BINDINFO_OPTIONS_WININETFLAG = 0x10000,
        BINDINFO_OPTIONS_ENABLE_UTF8 = 0x20000,
        BINDINFO_OPTIONS_DISABLE_UTF8 = 0x40000,
        BINDINFO_OPTIONS_USE_IE_ENCODING = 0x80000,
        BINDINFO_OPTIONS_BINDTOOBJECT = 0x100000,
        BINDINFO_OPTIONS_SECURITYOPTOUT = 0x200000,
        BINDINFO_OPTIONS_IGNOREMIMETEXTPLAIN = 0x400000,
        BINDINFO_OPTIONS_USEBINDSTRINGCREDS = 0x800000,
        BINDINFO_OPTIONS_IGNOREHTTPHTTPSREDIRECTS = 0x1000000,
        BINDINFO_OPTIONS_IGNORE_SSLERRORS_ONCE = 0x2000000,
        BINDINFO_WPC_DOWNLOADBLOCKED = 0x8000000,
        BINDINFO_WPC_LOGGING_ENABLED = 0x10000000,
        BINDINFO_OPTIONS_ALLOWCONNECTDATA = 0x20000000,
        BINDINFO_OPTIONS_DISABLEAUTOREDIRECTS = 0x40000000,
        BINDINFO_OPTIONS_SHDOCVW_NAVIGATE = (int)0x80000000
    } BINDINFO_OPTIONS;

    typedef enum __MIDL_IBindStatusCallback_0006
    {
        BSCF_FIRSTDATANOTIFICATION = 0x1,
        BSCF_INTERMEDIATEDATANOTIFICATION = 0x2,
        BSCF_LASTDATANOTIFICATION = 0x4,
        BSCF_DATAFULLYAVAILABLE = 0x8,
        BSCF_AVAILABLEDATASIZEUNKNOWN = 0x10,
        BSCF_SKIPDRAINDATAFORFILEURLS = 0x20,
        BSCF_64BITLENGTHDOWNLOAD = 0x40
    } BSCF;

    typedef enum tagBINDSTATUS
    {
        BINDSTATUS_FINDINGRESOURCE = 1,
        BINDSTATUS_CONNECTING = (BINDSTATUS_FINDINGRESOURCE + 1),
        BINDSTATUS_REDIRECTING = (BINDSTATUS_CONNECTING + 1),
        BINDSTATUS_BEGINDOWNLOADDATA = (BINDSTATUS_REDIRECTING + 1),
        BINDSTATUS_DOWNLOADINGDATA = (BINDSTATUS_BEGINDOWNLOADDATA + 1),
        BINDSTATUS_ENDDOWNLOADDATA = (BINDSTATUS_DOWNLOADINGDATA + 1),
        BINDSTATUS_BEGINDOWNLOADCOMPONENTS = (BINDSTATUS_ENDDOWNLOADDATA + 1),
        BINDSTATUS_INSTALLINGCOMPONENTS = (BINDSTATUS_BEGINDOWNLOADCOMPONENTS + 1),
        BINDSTATUS_ENDDOWNLOADCOMPONENTS = (BINDSTATUS_INSTALLINGCOMPONENTS + 1),
        BINDSTATUS_USINGCACHEDCOPY = (BINDSTATUS_ENDDOWNLOADCOMPONENTS + 1),
        BINDSTATUS_SENDINGREQUEST = (BINDSTATUS_USINGCACHEDCOPY + 1),
        BINDSTATUS_CLASSIDAVAILABLE = (BINDSTATUS_SENDINGREQUEST + 1),
        BINDSTATUS_MIMETYPEAVAILABLE = (BINDSTATUS_CLASSIDAVAILABLE + 1),
        BINDSTATUS_CACHEFILENAMEAVAILABLE = (BINDSTATUS_MIMETYPEAVAILABLE + 1),
        BINDSTATUS_BEGINSYNCOPERATION = (BINDSTATUS_CACHEFILENAMEAVAILABLE + 1),
        BINDSTATUS_ENDSYNCOPERATION = (BINDSTATUS_BEGINSYNCOPERATION + 1),
        BINDSTATUS_BEGINUPLOADDATA = (BINDSTATUS_ENDSYNCOPERATION + 1),
        BINDSTATUS_UPLOADINGDATA = (BINDSTATUS_BEGINUPLOADDATA + 1),
        BINDSTATUS_ENDUPLOADDATA = (BINDSTATUS_UPLOADINGDATA + 1),
        BINDSTATUS_PROTOCOLCLASSID = (BINDSTATUS_ENDUPLOADDATA + 1),
        BINDSTATUS_ENCODING = (BINDSTATUS_PROTOCOLCLASSID + 1),
        BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE = (BINDSTATUS_ENCODING + 1),
        BINDSTATUS_CLASSINSTALLLOCATION = (BINDSTATUS_VERIFIEDMIMETYPEAVAILABLE + 1),
        BINDSTATUS_DECODING = (BINDSTATUS_CLASSINSTALLLOCATION + 1),
        BINDSTATUS_LOADINGMIMEHANDLER = (BINDSTATUS_DECODING + 1),
        BINDSTATUS_CONTENTDISPOSITIONATTACH = (BINDSTATUS_LOADINGMIMEHANDLER + 1),
        BINDSTATUS_FILTERREPORTMIMETYPE = (BINDSTATUS_CONTENTDISPOSITIONATTACH + 1),
        BINDSTATUS_CLSIDCANINSTANTIATE = (BINDSTATUS_FILTERREPORTMIMETYPE + 1),
        BINDSTATUS_IUNKNOWNAVAILABLE = (BINDSTATUS_CLSIDCANINSTANTIATE + 1),
        BINDSTATUS_DIRECTBIND = (BINDSTATUS_IUNKNOWNAVAILABLE + 1),
        BINDSTATUS_RAWMIMETYPE = (BINDSTATUS_DIRECTBIND + 1),
        BINDSTATUS_PROXYDETECTING = (BINDSTATUS_RAWMIMETYPE + 1),
        BINDSTATUS_ACCEPTRANGES = (BINDSTATUS_PROXYDETECTING + 1),
        BINDSTATUS_COOKIE_SENT = (BINDSTATUS_ACCEPTRANGES + 1),
        BINDSTATUS_COMPACT_POLICY_RECEIVED = (BINDSTATUS_COOKIE_SENT + 1),
        BINDSTATUS_COOKIE_SUPPRESSED = (BINDSTATUS_COMPACT_POLICY_RECEIVED + 1),
        BINDSTATUS_COOKIE_STATE_UNKNOWN = (BINDSTATUS_COOKIE_SUPPRESSED + 1),
        BINDSTATUS_COOKIE_STATE_ACCEPT = (BINDSTATUS_COOKIE_STATE_UNKNOWN + 1),
        BINDSTATUS_COOKIE_STATE_REJECT = (BINDSTATUS_COOKIE_STATE_ACCEPT + 1),
        BINDSTATUS_COOKIE_STATE_PROMPT = (BINDSTATUS_COOKIE_STATE_REJECT + 1),
        BINDSTATUS_COOKIE_STATE_LEASH = (BINDSTATUS_COOKIE_STATE_PROMPT + 1),
        BINDSTATUS_COOKIE_STATE_DOWNGRADE = (BINDSTATUS_COOKIE_STATE_LEASH + 1),
        BINDSTATUS_POLICY_HREF = (BINDSTATUS_COOKIE_STATE_DOWNGRADE + 1),
        BINDSTATUS_P3P_HEADER = (BINDSTATUS_POLICY_HREF + 1),
        BINDSTATUS_SESSION_COOKIE_RECEIVED = (BINDSTATUS_P3P_HEADER + 1),
        BINDSTATUS_PERSISTENT_COOKIE_RECEIVED = (BINDSTATUS_SESSION_COOKIE_RECEIVED + 1),
        BINDSTATUS_SESSION_COOKIES_ALLOWED = (BINDSTATUS_PERSISTENT_COOKIE_RECEIVED + 1),
        BINDSTATUS_CACHECONTROL = (BINDSTATUS_SESSION_COOKIES_ALLOWED + 1),
        BINDSTATUS_CONTENTDISPOSITIONFILENAME = (BINDSTATUS_CACHECONTROL + 1),
        BINDSTATUS_MIMETEXTPLAINMISMATCH = (BINDSTATUS_CONTENTDISPOSITIONFILENAME + 1),
        BINDSTATUS_PUBLISHERAVAILABLE = (BINDSTATUS_MIMETEXTPLAINMISMATCH + 1),
        BINDSTATUS_DISPLAYNAMEAVAILABLE = (BINDSTATUS_PUBLISHERAVAILABLE + 1),
        BINDSTATUS_SSLUX_NAVBLOCKED = (BINDSTATUS_DISPLAYNAMEAVAILABLE + 1),
        BINDSTATUS_SERVER_MIMETYPEAVAILABLE = (BINDSTATUS_SSLUX_NAVBLOCKED + 1),
        BINDSTATUS_SNIFFED_CLASSIDAVAILABLE = (BINDSTATUS_SERVER_MIMETYPEAVAILABLE + 1),
        BINDSTATUS_64BIT_PROGRESS = (BINDSTATUS_SNIFFED_CLASSIDAVAILABLE + 1),
        BINDSTATUS_LAST = BINDSTATUS_64BIT_PROGRESS,
        BINDSTATUS_RESERVED_0 = (BINDSTATUS_LAST + 1),
        BINDSTATUS_RESERVED_1 = (BINDSTATUS_RESERVED_0 + 1),
        BINDSTATUS_RESERVED_2 = (BINDSTATUS_RESERVED_1 + 1),
        BINDSTATUS_RESERVED_3 = (BINDSTATUS_RESERVED_2 + 1),
        BINDSTATUS_RESERVED_4 = (BINDSTATUS_RESERVED_3 + 1),
        BINDSTATUS_RESERVED_5 = (BINDSTATUS_RESERVED_4 + 1),
        BINDSTATUS_RESERVED_6 = (BINDSTATUS_RESERVED_5 + 1),
        BINDSTATUS_RESERVED_7 = (BINDSTATUS_RESERVED_6 + 1),
        BINDSTATUS_RESERVED_8 = (BINDSTATUS_RESERVED_7 + 1),
        BINDSTATUS_RESERVED_9 = (BINDSTATUS_RESERVED_8 + 1),
        BINDSTATUS_RESERVED_A = (BINDSTATUS_RESERVED_9 + 1),
        BINDSTATUS_RESERVED_B = (BINDSTATUS_RESERVED_A + 1),
        BINDSTATUS_RESERVED_C = (BINDSTATUS_RESERVED_B + 1),
        BINDSTATUS_RESERVED_D = (BINDSTATUS_RESERVED_C + 1),
        BINDSTATUS_RESERVED_E = (BINDSTATUS_RESERVED_D + 1),
        BINDSTATUS_RESERVED_F = (BINDSTATUS_RESERVED_E + 1),
        BINDSTATUS_RESERVED_10 = (BINDSTATUS_RESERVED_F + 1),
        BINDSTATUS_RESERVED_11 = (BINDSTATUS_RESERVED_10 + 1),
        BINDSTATUS_RESERVED_12 = (BINDSTATUS_RESERVED_11 + 1),
        BINDSTATUS_RESERVED_13 = (BINDSTATUS_RESERVED_12 + 1),
        BINDSTATUS_LAST_PRIVATE = BINDSTATUS_RESERVED_13
    } BINDSTATUS;

    extern "C" const IID IID_IBindStatusCallback;

    struct __declspec(uuid("79eac9c1-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IBindStatusCallback : public IUnknown
    {
    public:
        virtual HRESULT __stdcall OnStartBinding(DWORD dwReserved, IBinding* pib) = 0;

        virtual HRESULT __stdcall GetPriority(LONG* pnPriority) = 0;

        virtual HRESULT __stdcall OnLowResource(DWORD reserved) = 0;

        virtual HRESULT __stdcall OnProgress(ULONG ulProgress, ULONG ulProgressMax, ULONG ulStatusCode, LPCWSTR szStatusText) = 0;

        virtual HRESULT __stdcall OnStopBinding(HRESULT hresult, LPCWSTR szError) = 0;

        virtual HRESULT __stdcall GetBindInfo(DWORD* grfBINDF, BINDINFO* pbindinfo) = 0;

        virtual HRESULT __stdcall OnDataAvailable(DWORD grfBSCF, DWORD dwSize, FORMATETC* pformatetc, STGMEDIUM* pstgmed) = 0;

        virtual HRESULT __stdcall OnObjectAvailable(const IID& riid, IUnknown* punk) = 0;
    };

    HRESULT __stdcall IBindStatusCallback_RemoteGetBindInfo_Proxy(IBindStatusCallback* This,
                                                                  DWORD* grfBINDF,
                                                                  RemBINDINFO* pbindinfo,
                                                                  RemSTGMEDIUM* pstgmed);

    void __stdcall IBindStatusCallback_RemoteGetBindInfo_Stub(IRpcStubBuffer* This,
                                                              IRpcChannelBuffer* _pRpcChannelBuffer,
                                                              PRPC_MESSAGE _pRpcMessage,
                                                              DWORD* _pdwStubPhase);

    HRESULT __stdcall IBindStatusCallback_RemoteOnDataAvailable_Proxy(
    IBindStatusCallback* This, DWORD grfBSCF, DWORD dwSize, RemFORMATETC* pformatetc, RemSTGMEDIUM* pstgmed);

    void __stdcall IBindStatusCallback_RemoteOnDataAvailable_Stub(IRpcStubBuffer* This,
                                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                  PRPC_MESSAGE _pRpcMessage,
                                                                  DWORD* _pdwStubPhase);

#pragma endregion
#pragma region Desktop Family

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0005_v0_0_s_ifspec;

    typedef IBindStatusCallbackEx* LPBINDSTATUSCALLBACKEX;

    typedef enum __MIDL_IBindStatusCallbackEx_0001
    {
        BINDF2_DISABLEBASICOVERHTTP = 0x1,
        BINDF2_DISABLEAUTOCOOKIEHANDLING = 0x2,
        BINDF2_READ_DATA_GREATER_THAN_4GB = 0x4,
        BINDF2_DISABLE_HTTP_REDIRECT_XSECURITYID = 0x8,
        BINDF2_SETDOWNLOADMODE = 0x20,
        BINDF2_DISABLE_HTTP_REDIRECT_CACHING = 0x40,
        BINDF2_KEEP_CALLBACK_MODULE_LOADED = 0x80,
        BINDF2_ALLOW_PROXY_CRED_PROMPT = 0x100,
        BINDF2_RESERVED_17 = 0x200,
        BINDF2_RESERVED_16 = 0x400,
        BINDF2_RESERVED_15 = 0x800,
        BINDF2_RESERVED_14 = 0x1000,
        BINDF2_RESERVED_13 = 0x2000,
        BINDF2_RESERVED_12 = 0x4000,
        BINDF2_RESERVED_11 = 0x8000,
        BINDF2_RESERVED_10 = 0x10000,
        BINDF2_RESERVED_F = 0x20000,
        BINDF2_RESERVED_E = 0x40000,
        BINDF2_RESERVED_D = 0x80000,
        BINDF2_RESERVED_C = 0x100000,
        BINDF2_RESERVED_B = 0x200000,
        BINDF2_RESERVED_A = 0x400000,
        BINDF2_RESERVED_9 = 0x800000,
        BINDF2_RESERVED_8 = 0x1000000,
        BINDF2_RESERVED_7 = 0x2000000,
        BINDF2_RESERVED_6 = 0x4000000,
        BINDF2_RESERVED_5 = 0x8000000,
        BINDF2_RESERVED_4 = 0x10000000,
        BINDF2_RESERVED_3 = 0x20000000,
        BINDF2_RESERVED_2 = 0x40000000,
        BINDF2_RESERVED_1 = 0x80000000
    } BINDF2;

    extern "C" const IID IID_IBindStatusCallbackEx;

    struct __declspec(uuid("aaa74ef9-8ee7-4659-88d9-f8c504da73cc")) __declspec(novtable) IBindStatusCallbackEx : public IBindStatusCallback
    {
    public:
        virtual HRESULT __stdcall GetBindInfoEx(DWORD* grfBINDF, BINDINFO* pbindinfo, DWORD* grfBINDF2, DWORD* pdwReserved) = 0;
    };

    HRESULT __stdcall IBindStatusCallbackEx_RemoteGetBindInfoEx_Proxy(
    IBindStatusCallbackEx* This, DWORD* grfBINDF, RemBINDINFO* pbindinfo, RemSTGMEDIUM* pstgmed, DWORD* grfBINDF2, DWORD* pdwReserved);

    void __stdcall IBindStatusCallbackEx_RemoteGetBindInfoEx_Stub(IRpcStubBuffer* This,
                                                                  IRpcChannelBuffer* _pRpcChannelBuffer,
                                                                  PRPC_MESSAGE _pRpcMessage,
                                                                  DWORD* _pdwStubPhase);

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0006_v0_0_s_ifspec;

    typedef IAuthenticate* LPAUTHENTICATION;

    extern "C" const IID IID_IAuthenticate;

    struct __declspec(uuid("79eac9d0-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IAuthenticate : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Authenticate(HWND* phwnd, LPWSTR* pszUsername, LPWSTR* pszPassword) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0007_v0_0_s_ifspec;

    typedef IAuthenticateEx* LPAUTHENTICATIONEX;

    typedef enum __MIDL_IAuthenticateEx_0001
    {
        AUTHENTICATEF_PROXY = 0x1,
        AUTHENTICATEF_BASIC = 0x2,
        AUTHENTICATEF_HTTP = 0x4
    } AUTHENTICATEF;

    typedef struct _tagAUTHENTICATEINFO
    {
        DWORD dwFlags;
        DWORD dwReserved;
    } AUTHENTICATEINFO;

    extern "C" const IID IID_IAuthenticateEx;

    struct __declspec(uuid("2ad1edaf-d83d-48b5-9adf-03dbe19f53bd")) __declspec(novtable) IAuthenticateEx : public IAuthenticate
    {
    public:
        virtual HRESULT __stdcall AuthenticateEx(HWND* phwnd, LPWSTR* pszUsername, LPWSTR* pszPassword, AUTHENTICATEINFO* pauthinfo)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0008_v0_0_s_ifspec;

    typedef IHttpNegotiate* LPHTTPNEGOTIATE;

    extern "C" const IID IID_IHttpNegotiate;

    struct __declspec(uuid("79eac9d2-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IHttpNegotiate : public IUnknown
    {
    public:
        virtual HRESULT __stdcall BeginningTransaction(LPCWSTR szURL, LPCWSTR szHeaders, DWORD dwReserved, LPWSTR* pszAdditionalHeaders)
        = 0;

        virtual HRESULT __stdcall OnResponse(DWORD dwResponseCode, LPCWSTR szResponseHeaders, LPCWSTR szRequestHeaders, LPWSTR* pszAdditionalRequestHeaders)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0009_v0_0_s_ifspec;

    typedef IHttpNegotiate2* LPHTTPNEGOTIATE2;

    extern "C" const IID IID_IHttpNegotiate2;

    struct __declspec(uuid("4F9F9FCB-E0F4-48eb-B7AB-FA2EA9365CB4")) __declspec(novtable) IHttpNegotiate2 : public IHttpNegotiate
    {
    public:
        virtual HRESULT __stdcall GetRootSecurityId(BYTE* pbSecurityId, DWORD* pcbSecurityId, DWORD_PTR dwReserved) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0010_v0_0_s_ifspec;

    typedef IHttpNegotiate3* LPHTTPNEGOTIATE3;

    extern "C" const IID IID_IHttpNegotiate3;

    struct __declspec(uuid("57b6c80a-34c2-4602-bc26-66a02fc57153")) __declspec(novtable) IHttpNegotiate3 : public IHttpNegotiate2
    {
    public:
        virtual HRESULT __stdcall GetSerializedClientCertContext(BYTE** ppbCert, DWORD* pcbCert) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0011_v0_0_s_ifspec;

    typedef IWinInetFileStream* LPWININETFILESTREAM;

    extern "C" const IID IID_IWinInetFileStream;

    struct __declspec(uuid("F134C4B7-B1F8-4e75-B886-74B90943BECB")) __declspec(novtable) IWinInetFileStream : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetHandleForUnlock(DWORD_PTR hWinInetLockHandle, DWORD_PTR dwReserved) = 0;

        virtual HRESULT __stdcall SetDeleteFile(DWORD_PTR dwReserved) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0012_v0_0_s_ifspec;

    typedef IWindowForBindingUI* LPWINDOWFORBINDINGUI;

    extern "C" const IID IID_IWindowForBindingUI;

    struct __declspec(uuid("79eac9d5-bafa-11ce-8c82-00aa004ba90b")) __declspec(novtable) IWindowForBindingUI : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetWindow(const GUID& rguidReason, HWND* phwnd) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0013_v0_0_s_ifspec;

    typedef ICodeInstall* LPCODEINSTALL;

    typedef enum __MIDL_ICodeInstall_0001
    {
        CIP_DISK_FULL = 0,
        CIP_ACCESS_DENIED = (CIP_DISK_FULL + 1),
        CIP_NEWER_VERSION_EXISTS = (CIP_ACCESS_DENIED + 1),
        CIP_OLDER_VERSION_EXISTS = (CIP_NEWER_VERSION_EXISTS + 1),
        CIP_NAME_CONFLICT = (CIP_OLDER_VERSION_EXISTS + 1),
        CIP_TRUST_VERIFICATION_COMPONENT_MISSING = (CIP_NAME_CONFLICT + 1),
        CIP_EXE_SELF_REGISTERATION_TIMEOUT = (CIP_TRUST_VERIFICATION_COMPONENT_MISSING + 1),
        CIP_UNSAFE_TO_ABORT = (CIP_EXE_SELF_REGISTERATION_TIMEOUT + 1),
        CIP_NEED_REBOOT = (CIP_UNSAFE_TO_ABORT + 1),
        CIP_NEED_REBOOT_UI_PERMISSION = (CIP_NEED_REBOOT + 1)
    } CIP_STATUS;

    extern "C" const IID IID_ICodeInstall;

    struct __declspec(uuid("79eac9d1-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) ICodeInstall : public IWindowForBindingUI
    {
    public:
        virtual HRESULT __stdcall OnCodeInstallProblem(ULONG ulStatusCode, LPCWSTR szDestination, LPCWSTR szSource, DWORD dwReserved)
        = 0;
    };

#pragma endregion

#pragma region Application Family

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0014_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0014_v0_0_s_ifspec;

    typedef enum __MIDL_IUri_0001
    {
        Uri_PROPERTY_ABSOLUTE_URI = 0,
        Uri_PROPERTY_STRING_START = Uri_PROPERTY_ABSOLUTE_URI,
        Uri_PROPERTY_AUTHORITY = 1,
        Uri_PROPERTY_DISPLAY_URI = 2,
        Uri_PROPERTY_DOMAIN = 3,
        Uri_PROPERTY_EXTENSION = 4,
        Uri_PROPERTY_FRAGMENT = 5,
        Uri_PROPERTY_HOST = 6,
        Uri_PROPERTY_PASSWORD = 7,
        Uri_PROPERTY_PATH = 8,
        Uri_PROPERTY_PATH_AND_QUERY = 9,
        Uri_PROPERTY_QUERY = 10,
        Uri_PROPERTY_RAW_URI = 11,
        Uri_PROPERTY_SCHEME_NAME = 12,
        Uri_PROPERTY_USER_INFO = 13,
        Uri_PROPERTY_USER_NAME = 14,
        Uri_PROPERTY_STRING_LAST = Uri_PROPERTY_USER_NAME,
        Uri_PROPERTY_HOST_TYPE = 15,
        Uri_PROPERTY_DWORD_START = Uri_PROPERTY_HOST_TYPE,
        Uri_PROPERTY_PORT = 16,
        Uri_PROPERTY_SCHEME = 17,
        Uri_PROPERTY_ZONE = 18,
        Uri_PROPERTY_DWORD_LAST = Uri_PROPERTY_ZONE
    } Uri_PROPERTY;

    typedef enum __MIDL_IUri_0002
    {
        Uri_HOST_UNKNOWN = 0,
        Uri_HOST_DNS = (Uri_HOST_UNKNOWN + 1),
        Uri_HOST_IPV4 = (Uri_HOST_DNS + 1),
        Uri_HOST_IPV6 = (Uri_HOST_IPV4 + 1),
        Uri_HOST_IDN = (Uri_HOST_IPV6 + 1)
    } Uri_HOST_TYPE;

    extern "C" const IID IID_IUri;

    struct __declspec(uuid("A39EE748-6A27-4817-A6F2-13914BEF5890")) __declspec(novtable) IUri : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetPropertyBSTR(Uri_PROPERTY uriProp, BSTR* pbstrProperty, DWORD dwFlags) = 0;

        virtual HRESULT __stdcall GetPropertyLength(Uri_PROPERTY uriProp, DWORD* pcchProperty, DWORD dwFlags) = 0;

        virtual HRESULT __stdcall GetPropertyDWORD(Uri_PROPERTY uriProp, DWORD* pdwProperty, DWORD dwFlags) = 0;

        virtual HRESULT __stdcall HasProperty(Uri_PROPERTY uriProp, BOOL* pfHasProperty) = 0;

        virtual HRESULT __stdcall GetAbsoluteUri(BSTR* pbstrAbsoluteUri) = 0;

        virtual HRESULT __stdcall GetAuthority(BSTR* pbstrAuthority) = 0;

        virtual HRESULT __stdcall GetDisplayUri(BSTR* pbstrDisplayString) = 0;

        virtual HRESULT __stdcall GetDomain(BSTR* pbstrDomain) = 0;

        virtual HRESULT __stdcall GetExtension(BSTR* pbstrExtension) = 0;

        virtual HRESULT __stdcall GetFragment(BSTR* pbstrFragment) = 0;

        virtual HRESULT __stdcall GetHost(BSTR* pbstrHost) = 0;

        virtual HRESULT __stdcall GetPassword(BSTR* pbstrPassword) = 0;

        virtual HRESULT __stdcall GetPath(BSTR* pbstrPath) = 0;

        virtual HRESULT __stdcall GetPathAndQuery(BSTR* pbstrPathAndQuery) = 0;

        virtual HRESULT __stdcall GetQuery(BSTR* pbstrQuery) = 0;

        virtual HRESULT __stdcall GetRawUri(BSTR* pbstrRawUri) = 0;

        virtual HRESULT __stdcall GetSchemeName(BSTR* pbstrSchemeName) = 0;

        virtual HRESULT __stdcall GetUserInfo(BSTR* pbstrUserInfo) = 0;

        virtual HRESULT __stdcall GetUserNameA(BSTR* pbstrUserName) = 0;

        virtual HRESULT __stdcall GetHostType(DWORD* pdwHostType) = 0;

        virtual HRESULT __stdcall GetPort(DWORD* pdwPort) = 0;

        virtual HRESULT __stdcall GetScheme(DWORD* pdwScheme) = 0;

        virtual HRESULT __stdcall GetZone(DWORD* pdwZone) = 0;

        virtual HRESULT __stdcall GetProperties(LPDWORD pdwFlags) = 0;

        virtual HRESULT __stdcall IsEqual(IUri* pUri, BOOL* pfEqual) = 0;
    };

    extern "C" HRESULT __stdcall CreateUri(LPCWSTR pwzURI, DWORD dwFlags, DWORD_PTR dwReserved, IUri** ppURI);

    extern "C" HRESULT __stdcall CreateUriWithFragment(LPCWSTR pwzURI, LPCWSTR pwzFragment, DWORD dwFlags, DWORD_PTR dwReserved, IUri** ppURI);

#pragma endregion
#pragma region Desktop Family

    extern "C" HRESULT __stdcall CreateUriFromMultiByteString(
    LPCSTR pszANSIInputUri, DWORD dwEncodingFlags, DWORD dwCodePage, DWORD dwCreateFlags, DWORD_PTR dwReserved, IUri** ppUri);

#pragma endregion
#pragma region Application Family

#pragma endregion
#pragma region Desktop Family

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0015_v0_0_s_ifspec;

    extern "C" const IID IID_IUriContainer;

    struct __declspec(uuid("a158a630-ed6f-45fb-b987-f68676f57752")) __declspec(novtable) IUriContainer : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetIUri(IUri** ppIUri) = 0;
    };

    extern "C" const IID IID_IUriBuilder;

    struct __declspec(uuid("4221B2E1-8955-46c0-BD5B-DE9897565DE7")) __declspec(novtable) IUriBuilder : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateUriSimple(DWORD dwAllowEncodingPropertyMask,
                                                  DWORD_PTR dwReserved,

                                                  IUri** ppIUri)
        = 0;

        virtual HRESULT __stdcall CreateUri(DWORD dwCreateFlags,
                                            DWORD dwAllowEncodingPropertyMask,
                                            DWORD_PTR dwReserved,

                                            IUri** ppIUri)
        = 0;

        virtual HRESULT __stdcall CreateUriWithFlags(DWORD dwCreateFlags,
                                                     DWORD dwUriBuilderFlags,
                                                     DWORD dwAllowEncodingPropertyMask,
                                                     DWORD_PTR dwReserved,

                                                     IUri** ppIUri)
        = 0;

        virtual HRESULT __stdcall GetIUri(

        IUri** ppIUri)
        = 0;

        virtual HRESULT __stdcall SetIUri(

        IUri* pIUri)
        = 0;

        virtual HRESULT __stdcall GetFragment(

        DWORD* pcchFragment,

        LPCWSTR* ppwzFragment)
        = 0;

        virtual HRESULT __stdcall GetHost(

        DWORD* pcchHost,

        LPCWSTR* ppwzHost)
        = 0;

        virtual HRESULT __stdcall GetPassword(

        DWORD* pcchPassword,

        LPCWSTR* ppwzPassword)
        = 0;

        virtual HRESULT __stdcall GetPath(

        DWORD* pcchPath,

        LPCWSTR* ppwzPath)
        = 0;

        virtual HRESULT __stdcall GetPort(

        BOOL* pfHasPort,

        DWORD* pdwPort)
        = 0;

        virtual HRESULT __stdcall GetQuery(

        DWORD* pcchQuery,

        LPCWSTR* ppwzQuery)
        = 0;

        virtual HRESULT __stdcall GetSchemeName(

        DWORD* pcchSchemeName,

        LPCWSTR* ppwzSchemeName)
        = 0;

        virtual HRESULT __stdcall GetUserNameA(

        DWORD* pcchUserName,

        LPCWSTR* ppwzUserName)
        = 0;

        virtual HRESULT __stdcall SetFragment(

        LPCWSTR pwzNewValue)
        = 0;

        virtual HRESULT __stdcall SetHost(

        LPCWSTR pwzNewValue)
        = 0;

        virtual HRESULT __stdcall SetPassword(

        LPCWSTR pwzNewValue)
        = 0;

        virtual HRESULT __stdcall SetPath(

        LPCWSTR pwzNewValue)
        = 0;

        virtual HRESULT __stdcall SetPortA(BOOL fHasPort, DWORD dwNewValue) = 0;

        virtual HRESULT __stdcall SetQuery(

        LPCWSTR pwzNewValue)
        = 0;

        virtual HRESULT __stdcall SetSchemeName(

        LPCWSTR pwzNewValue)
        = 0;

        virtual HRESULT __stdcall SetUserName(

        LPCWSTR pwzNewValue)
        = 0;

        virtual HRESULT __stdcall RemoveProperties(DWORD dwPropertyMask) = 0;

        virtual HRESULT __stdcall HasBeenModified(

        BOOL* pfModified)
        = 0;
    };

    extern "C" const IID IID_IUriBuilderFactory;

    struct __declspec(uuid("E982CE48-0B96-440c-BC37-0C869B27A29E")) __declspec(novtable) IUriBuilderFactory : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateIUriBuilder(

        DWORD dwFlags,

        DWORD_PTR dwReserved,

        IUriBuilder** ppIUriBuilder)
        = 0;

        virtual HRESULT __stdcall CreateInitializedIUriBuilder(

        DWORD dwFlags,

        DWORD_PTR dwReserved,

        IUriBuilder** ppIUriBuilder)
        = 0;
    };

    extern "C" HRESULT __stdcall CreateIUriBuilder(IUri* pIUri, DWORD dwFlags, DWORD_PTR dwReserved, IUriBuilder** ppIUriBuilder);
#pragma endregion
#pragma region Desktop Family

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0018_v0_0_s_ifspec;

    typedef IWinInetInfo* LPWININETINFO;

    extern "C" const IID IID_IWinInetInfo;

    struct __declspec(uuid("79eac9d6-bafa-11ce-8c82-00aa004ba90b")) __declspec(novtable) IWinInetInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall QueryOption(DWORD dwOption, LPVOID pBuffer, DWORD* pcbBuf) = 0;
    };

    HRESULT __stdcall IWinInetInfo_RemoteQueryOption_Proxy(IWinInetInfo* This, DWORD dwOption, BYTE* pBuffer, DWORD* pcbBuf);

    void __stdcall IWinInetInfo_RemoteQueryOption_Stub(IRpcStubBuffer* This,
                                                       IRpcChannelBuffer* _pRpcChannelBuffer,
                                                       PRPC_MESSAGE _pRpcMessage,
                                                       DWORD* _pdwStubPhase);

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0019_v0_0_s_ifspec;

    typedef IHttpSecurity* LPHTTPSECURITY;

    extern "C" const IID IID_IHttpSecurity;

    struct __declspec(uuid("79eac9d7-bafa-11ce-8c82-00aa004ba90b")) __declspec(novtable) IHttpSecurity : public IWindowForBindingUI
    {
    public:
        virtual HRESULT __stdcall OnSecurityProblem(DWORD dwProblem) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0020_v0_0_s_ifspec;

    typedef IWinInetHttpInfo* LPWININETHTTPINFO;

    extern "C" const IID IID_IWinInetHttpInfo;

    struct __declspec(uuid("79eac9d8-bafa-11ce-8c82-00aa004ba90b")) __declspec(novtable) IWinInetHttpInfo : public IWinInetInfo
    {
    public:
        virtual HRESULT __stdcall QueryInfo(DWORD dwOption, LPVOID pBuffer, DWORD* pcbBuf, DWORD* pdwFlags, DWORD* pdwReserved) = 0;
    };

    HRESULT __stdcall IWinInetHttpInfo_RemoteQueryInfo_Proxy(
    IWinInetHttpInfo* This, DWORD dwOption, BYTE* pBuffer, DWORD* pcbBuf, DWORD* pdwFlags, DWORD* pdwReserved);

    void __stdcall IWinInetHttpInfo_RemoteQueryInfo_Stub(IRpcStubBuffer* This,
                                                         IRpcChannelBuffer* _pRpcChannelBuffer,
                                                         PRPC_MESSAGE _pRpcMessage,
                                                         DWORD* _pdwStubPhase);

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0021_v0_0_s_ifspec;

    extern "C" const IID IID_IWinInetHttpTimeouts;

    struct __declspec(uuid("F286FA56-C1FD-4270-8E67-B3EB790A81E8")) __declspec(novtable) IWinInetHttpTimeouts : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetRequestTimeouts(

        DWORD* pdwConnectTimeout,

        DWORD* pdwSendTimeout,

        DWORD* pdwReceiveTimeout)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0022_v0_0_s_ifspec;

    typedef IWinInetCacheHints* LPWININETCACHEHINTS;

    extern "C" const IID IID_IWinInetCacheHints;

    struct __declspec(uuid("DD1EC3B3-8391-4fdb-A9E6-347C3CAAA7DD")) __declspec(novtable) IWinInetCacheHints : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetCacheExtension(LPCWSTR pwzExt, LPVOID pszCacheFile, DWORD* pcbCacheFile, DWORD* pdwWinInetError, DWORD* pdwReserved)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0023_v0_0_s_ifspec;

    typedef IWinInetCacheHints2* LPWININETCACHEHINTS2;

    extern "C" const IID IID_IWinInetCacheHints2;

    struct __declspec(uuid("7857AEAC-D31F-49bf-884E-DD46DF36780A")) __declspec(novtable) IWinInetCacheHints2 : public IWinInetCacheHints
    {
    public:
        virtual HRESULT __stdcall SetCacheExtension2(LPCWSTR pwzExt,

                                                     WCHAR* pwzCacheFile,
                                                     DWORD* pcchCacheFile,
                                                     DWORD* pdwWinInetError,
                                                     DWORD* pdwReserved)
        = 0;
    };

    extern "C" const GUID SID_BindHost;

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0024_v0_0_s_ifspec;

    typedef IBindHost* LPBINDHOST;

    extern "C" const IID IID_IBindHost;

    struct __declspec(uuid("fc4801a1-2ba9-11cf-a229-00aa003d7352")) __declspec(novtable) IBindHost : public IUnknown
    {
    public:
        virtual HRESULT __stdcall CreateMoniker(LPOLESTR szName, IBindCtx* pBC, IMoniker** ppmk, DWORD dwReserved) = 0;

        virtual HRESULT __stdcall MonikerBindToStorage(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, const IID& riid, void** ppvObj)
        = 0;

        virtual HRESULT __stdcall MonikerBindToObject(IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, const IID& riid, void** ppvObj)
        = 0;
    };

    HRESULT __stdcall IBindHost_RemoteMonikerBindToStorage_Proxy(
    IBindHost* This, IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, const IID& riid, IUnknown** ppvObj);

    void __stdcall IBindHost_RemoteMonikerBindToStorage_Stub(IRpcStubBuffer* This,
                                                             IRpcChannelBuffer* _pRpcChannelBuffer,
                                                             PRPC_MESSAGE _pRpcMessage,
                                                             DWORD* _pdwStubPhase);

    HRESULT __stdcall IBindHost_RemoteMonikerBindToObject_Proxy(
    IBindHost* This, IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, const IID& riid, IUnknown** ppvObj);

    void __stdcall IBindHost_RemoteMonikerBindToObject_Stub(IRpcStubBuffer* This,
                                                            IRpcChannelBuffer* _pRpcChannelBuffer,
                                                            PRPC_MESSAGE _pRpcMessage,
                                                            DWORD* _pdwStubPhase);

    struct IBindStatusCallback;
    extern "C" HRESULT __stdcall HlinkSimpleNavigateToString(LPCWSTR szTarget,
                                                             LPCWSTR szLocation,
                                                             LPCWSTR szTargetFrameName,
                                                             IUnknown* pUnk,
                                                             IBindCtx* pbc,
                                                             IBindStatusCallback*,
                                                             DWORD grfHLNF,
                                                             DWORD dwReserved);

    extern "C" HRESULT __stdcall HlinkSimpleNavigateToMoniker(IMoniker* pmkTarget,
                                                              LPCWSTR szLocation,
                                                              LPCWSTR szTargetFrameName,
                                                              IUnknown* pUnk,
                                                              IBindCtx* pbc,
                                                              IBindStatusCallback*,
                                                              DWORD grfHLNF,
                                                              DWORD dwReserved);

    extern "C" HRESULT __stdcall URLOpenStreamA(LPUNKNOWN, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);
    extern "C" HRESULT __stdcall URLOpenStreamW(LPUNKNOWN, LPCWSTR, DWORD, LPBINDSTATUSCALLBACK);
    extern "C" HRESULT __stdcall URLOpenPullStreamA(LPUNKNOWN, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);
    extern "C" HRESULT __stdcall URLOpenPullStreamW(LPUNKNOWN, LPCWSTR, DWORD, LPBINDSTATUSCALLBACK);
    extern "C" HRESULT __stdcall URLDownloadToFileA(LPUNKNOWN, LPCSTR, LPCSTR, DWORD, LPBINDSTATUSCALLBACK);
    extern "C" HRESULT __stdcall URLDownloadToFileW(LPUNKNOWN, LPCWSTR, LPCWSTR, DWORD, LPBINDSTATUSCALLBACK);
    extern "C" HRESULT __stdcall URLDownloadToCacheFileA(LPUNKNOWN, LPCSTR, LPSTR, DWORD cchFileName, DWORD, LPBINDSTATUSCALLBACK);
    extern "C" HRESULT __stdcall URLDownloadToCacheFileW(LPUNKNOWN, LPCWSTR, LPWSTR, DWORD cchFileName, DWORD, LPBINDSTATUSCALLBACK);
    extern "C" HRESULT __stdcall URLOpenBlockingStreamA(LPUNKNOWN, LPCSTR, LPSTREAM*, DWORD, LPBINDSTATUSCALLBACK);
    extern "C" HRESULT __stdcall URLOpenBlockingStreamW(LPUNKNOWN, LPCWSTR, LPSTREAM*, DWORD, LPBINDSTATUSCALLBACK);

    extern "C" HRESULT __stdcall HlinkGoBack(IUnknown* pUnk);
    extern "C" HRESULT __stdcall HlinkGoForward(IUnknown* pUnk);
    extern "C" HRESULT __stdcall HlinkNavigateString(IUnknown* pUnk, LPCWSTR szTarget);
    extern "C" HRESULT __stdcall HlinkNavigateMoniker(IUnknown* pUnk, IMoniker* pmkTarget);

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0025_v0_0_s_ifspec;

    typedef IInternet* LPIINTERNET;

    extern "C" const IID IID_IInternet;

    struct __declspec(uuid("79eac9e0-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternet : public IUnknown
    {
    public:
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0026_v0_0_s_ifspec;

    typedef IInternetBindInfo* LPIINTERNETBINDINFO;

    typedef enum tagBINDSTRING
    {
        BINDSTRING_HEADERS = 1,
        BINDSTRING_ACCEPT_MIMES = (BINDSTRING_HEADERS + 1),
        BINDSTRING_EXTRA_URL = (BINDSTRING_ACCEPT_MIMES + 1),
        BINDSTRING_LANGUAGE = (BINDSTRING_EXTRA_URL + 1),
        BINDSTRING_USERNAME = (BINDSTRING_LANGUAGE + 1),
        BINDSTRING_PASSWORD = (BINDSTRING_USERNAME + 1),
        BINDSTRING_UA_PIXELS = (BINDSTRING_PASSWORD + 1),
        BINDSTRING_UA_COLOR = (BINDSTRING_UA_PIXELS + 1),
        BINDSTRING_OS = (BINDSTRING_UA_COLOR + 1),
        BINDSTRING_USER_AGENT = (BINDSTRING_OS + 1),
        BINDSTRING_ACCEPT_ENCODINGS = (BINDSTRING_USER_AGENT + 1),
        BINDSTRING_POST_COOKIE = (BINDSTRING_ACCEPT_ENCODINGS + 1),
        BINDSTRING_POST_DATA_MIME = (BINDSTRING_POST_COOKIE + 1),
        BINDSTRING_URL = (BINDSTRING_POST_DATA_MIME + 1),
        BINDSTRING_IID = (BINDSTRING_URL + 1),
        BINDSTRING_FLAG_BIND_TO_OBJECT = (BINDSTRING_IID + 1),
        BINDSTRING_PTR_BIND_CONTEXT = (BINDSTRING_FLAG_BIND_TO_OBJECT + 1),
        BINDSTRING_XDR_ORIGIN = (BINDSTRING_PTR_BIND_CONTEXT + 1),
        BINDSTRING_DOWNLOADPATH = (BINDSTRING_XDR_ORIGIN + 1),
        BINDSTRING_ROOTDOC_URL = (BINDSTRING_DOWNLOADPATH + 1),
        BINDSTRING_INITIAL_FILENAME = (BINDSTRING_ROOTDOC_URL + 1),
        BINDSTRING_PROXY_USERNAME = (BINDSTRING_INITIAL_FILENAME + 1),
        BINDSTRING_PROXY_PASSWORD = (BINDSTRING_PROXY_USERNAME + 1),
        BINDSTRING_ENTERPRISE_ID = (BINDSTRING_PROXY_PASSWORD + 1),
        BINDSTRING_DOC_URL = (BINDSTRING_ENTERPRISE_ID + 1),
        BINDSTRING_SAMESITE_COOKIE_LEVEL = (BINDSTRING_DOC_URL + 1)
    } BINDSTRING;

    extern "C" const IID IID_IInternetBindInfo;

    struct __declspec(uuid("79eac9e1-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetBindInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetBindInfo(DWORD* grfBINDF, BINDINFO* pbindinfo) = 0;

        virtual HRESULT __stdcall GetBindString(ULONG ulStringType,

                                                LPOLESTR* ppwzStr,
                                                ULONG cEl,
                                                ULONG* pcElFetched)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0027_v0_0_s_ifspec;

    typedef IInternetBindInfoEx* LPIINTERNETBINDINFOEX;

    extern "C" const IID IID_IInternetBindInfoEx;

    struct __declspec(uuid("a3e015b7-a82c-4dcd-a150-569aeeed36ab")) __declspec(novtable) IInternetBindInfoEx : public IInternetBindInfo
    {
    public:
        virtual HRESULT __stdcall GetBindInfoEx(DWORD* grfBINDF, BINDINFO* pbindinfo, DWORD* grfBINDF2, DWORD* pdwReserved) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0028_v0_0_s_ifspec;

    typedef IInternetProtocolRoot* LPIINTERNETPROTOCOLROOT;

    typedef enum _tagPI_FLAGS
    {
        PI_PARSE_URL = 0x1,
        PI_FILTER_MODE = 0x2,
        PI_FORCE_ASYNC = 0x4,
        PI_USE_WORKERTHREAD = 0x8,
        PI_MIMEVERIFICATION = 0x10,
        PI_CLSIDLOOKUP = 0x20,
        PI_DATAPROGRESS = 0x40,
        PI_SYNCHRONOUS = 0x80,
        PI_APARTMENTTHREADED = 0x100,
        PI_CLASSINSTALL = 0x200,
        PI_PASSONBINDCTX = 0x2000,
        PI_NOMIMEHANDLER = 0x8000,
        PI_LOADAPPDIRECT = 0x4000,
        PD_FORCE_SWITCH = 0x10000,
        PI_PREFERDEFAULTHANDLER = 0x20000
    } PI_FLAGS;

    typedef struct _tagPROTOCOLDATA
    {
        DWORD grfFlags;
        DWORD dwState;
        LPVOID pData;
        ULONG cbData;
    } PROTOCOLDATA;

    typedef struct _tagStartParam
    {
        IID iid;
        IBindCtx* pIBindCtx;
        IUnknown* pItf;
    } StartParam;

    extern "C" const IID IID_IInternetProtocolRoot;

    struct __declspec(uuid("79eac9e3-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetProtocolRoot : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Start(LPCWSTR szUrl, IInternetProtocolSink* pOIProtSink, IInternetBindInfo* pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved)
        = 0;

        virtual HRESULT __stdcall Continue(PROTOCOLDATA* pProtocolData) = 0;

        virtual HRESULT __stdcall Abort(HRESULT hrReason, DWORD dwOptions) = 0;

        virtual HRESULT __stdcall Terminate(DWORD dwOptions) = 0;

        virtual HRESULT __stdcall Suspend(void) = 0;

        virtual HRESULT __stdcall Resume(void) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0029_v0_0_s_ifspec;

    typedef IInternetProtocol* LPIINTERNETPROTOCOL;

    extern "C" const IID IID_IInternetProtocol;

    struct __declspec(uuid("79eac9e4-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetProtocol : public IInternetProtocolRoot
    {
    public:
        virtual HRESULT __stdcall Read(void* pv, ULONG cb, ULONG* pcbRead) = 0;

        virtual HRESULT __stdcall Seek(LARGE_INTEGER dlibMove, DWORD dwOrigin, ULARGE_INTEGER* plibNewPosition) = 0;

        virtual HRESULT __stdcall LockRequest(DWORD dwOptions) = 0;

        virtual HRESULT __stdcall UnlockRequest(void) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0030_v0_0_s_ifspec;

    extern "C" const IID IID_IInternetProtocolEx;

    struct __declspec(uuid("C7A98E66-1010-492c-A1C8-C809E1F75905")) __declspec(novtable) IInternetProtocolEx : public IInternetProtocol
    {
    public:
        virtual HRESULT __stdcall StartEx(IUri* pUri, IInternetProtocolSink* pOIProtSink, IInternetBindInfo* pOIBindInfo, DWORD grfPI, HANDLE_PTR dwReserved)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0031_v0_0_s_ifspec;

    typedef IInternetProtocolSink* LPIINTERNETPROTOCOLSINK;

    extern "C" const IID IID_IInternetProtocolSink;

    struct __declspec(uuid("79eac9e5-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetProtocolSink : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Switch(PROTOCOLDATA* pProtocolData) = 0;

        virtual HRESULT __stdcall ReportProgress(ULONG ulStatusCode, LPCWSTR szStatusText) = 0;

        virtual HRESULT __stdcall ReportData(DWORD grfBSCF, ULONG ulProgress, ULONG ulProgressMax) = 0;

        virtual HRESULT __stdcall ReportResult(HRESULT hrResult, DWORD dwError, LPCWSTR szResult) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0032_v0_0_s_ifspec;

    typedef IInternetProtocolSinkStackable* LPIINTERNETPROTOCOLSINKStackable;

    extern "C" const IID IID_IInternetProtocolSinkStackable;

    struct __declspec(uuid("79eac9f0-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetProtocolSinkStackable : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SwitchSink(IInternetProtocolSink* pOIProtSink) = 0;

        virtual HRESULT __stdcall CommitSwitch(void) = 0;

        virtual HRESULT __stdcall RollbackSwitch(void) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0033_v0_0_s_ifspec;

    typedef IInternetSession* LPIINTERNETSESSION;

    typedef enum _tagOIBDG_FLAGS
    {
        OIBDG_APARTMENTTHREADED = 0x100,
        OIBDG_DATAONLY = 0x1000
    } OIBDG_FLAGS;

    extern "C" const IID IID_IInternetSession;

    struct __declspec(uuid("79eac9e7-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetSession : public IUnknown
    {
    public:
        virtual HRESULT __stdcall RegisterNameSpace(
        IClassFactory* pCF, const IID& rclsid, LPCWSTR pwzProtocol, ULONG cPatterns, const LPCWSTR* ppwzPatterns, DWORD dwReserved)
        = 0;

        virtual HRESULT __stdcall UnregisterNameSpace(IClassFactory* pCF, LPCWSTR pszProtocol) = 0;

        virtual HRESULT __stdcall RegisterMimeFilter(IClassFactory* pCF, const IID& rclsid, LPCWSTR pwzType) = 0;

        virtual HRESULT __stdcall UnregisterMimeFilter(IClassFactory* pCF, LPCWSTR pwzType) = 0;

        virtual HRESULT __stdcall CreateBinding(
        LPBC pBC, LPCWSTR szUrl, IUnknown* pUnkOuter, IUnknown** ppUnk, IInternetProtocol** ppOInetProt, DWORD dwOption)
        = 0;

        virtual HRESULT __stdcall SetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD dwBufferLength, DWORD dwReserved) = 0;

        virtual HRESULT __stdcall GetSessionOption(DWORD dwOption, LPVOID pBuffer, DWORD* pdwBufferLength, DWORD dwReserved) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0034_v0_0_s_ifspec;

    typedef IInternetThreadSwitch* LPIINTERNETTHREADSWITCH;

    extern "C" const IID IID_IInternetThreadSwitch;

    struct __declspec(uuid("79eac9e8-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetThreadSwitch : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Prepare(void) = 0;

        virtual HRESULT __stdcall Continue(void) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0035_v0_0_s_ifspec;

    typedef IInternetPriority* LPIINTERNETPRIORITY;

    extern "C" const IID IID_IInternetPriority;

    struct __declspec(uuid("79eac9eb-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetPriority : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetPriority(LONG nPriority) = 0;

        virtual HRESULT __stdcall GetPriority(LONG* pnPriority) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0036_v0_0_s_ifspec;

    typedef IInternetProtocolInfo* LPIINTERNETPROTOCOLINFO;

    typedef enum _tagPARSEACTION
    {
        PARSE_CANONICALIZE = 1,
        PARSE_FRIENDLY = (PARSE_CANONICALIZE + 1),
        PARSE_SECURITY_URL = (PARSE_FRIENDLY + 1),
        PARSE_ROOTDOCUMENT = (PARSE_SECURITY_URL + 1),
        PARSE_DOCUMENT = (PARSE_ROOTDOCUMENT + 1),
        PARSE_ANCHOR = (PARSE_DOCUMENT + 1),
        PARSE_ENCODE_IS_UNESCAPE = (PARSE_ANCHOR + 1),
        PARSE_DECODE_IS_ESCAPE = (PARSE_ENCODE_IS_UNESCAPE + 1),
        PARSE_PATH_FROM_URL = (PARSE_DECODE_IS_ESCAPE + 1),
        PARSE_URL_FROM_PATH = (PARSE_PATH_FROM_URL + 1),
        PARSE_MIME = (PARSE_URL_FROM_PATH + 1),
        PARSE_SERVER = (PARSE_MIME + 1),
        PARSE_SCHEMA = (PARSE_SERVER + 1),
        PARSE_SITE = (PARSE_SCHEMA + 1),
        PARSE_DOMAIN = (PARSE_SITE + 1),
        PARSE_LOCATION = (PARSE_DOMAIN + 1),
        PARSE_SECURITY_DOMAIN = (PARSE_LOCATION + 1),
        PARSE_ESCAPE = (PARSE_SECURITY_DOMAIN + 1),
        PARSE_UNESCAPE = (PARSE_ESCAPE + 1)
    } PARSEACTION;

    typedef enum _tagPSUACTION
    {
        PSU_DEFAULT = 1,
        PSU_SECURITY_URL_ONLY = (PSU_DEFAULT + 1)
    } PSUACTION;

    typedef enum _tagQUERYOPTION
    {
        QUERY_EXPIRATION_DATE = 1,
        QUERY_TIME_OF_LAST_CHANGE = (QUERY_EXPIRATION_DATE + 1),
        QUERY_CONTENT_ENCODING = (QUERY_TIME_OF_LAST_CHANGE + 1),
        QUERY_CONTENT_TYPE = (QUERY_CONTENT_ENCODING + 1),
        QUERY_REFRESH = (QUERY_CONTENT_TYPE + 1),
        QUERY_RECOMBINE = (QUERY_REFRESH + 1),
        QUERY_CAN_NAVIGATE = (QUERY_RECOMBINE + 1),
        QUERY_USES_NETWORK = (QUERY_CAN_NAVIGATE + 1),
        QUERY_IS_CACHED = (QUERY_USES_NETWORK + 1),
        QUERY_IS_INSTALLEDENTRY = (QUERY_IS_CACHED + 1),
        QUERY_IS_CACHED_OR_MAPPED = (QUERY_IS_INSTALLEDENTRY + 1),
        QUERY_USES_CACHE = (QUERY_IS_CACHED_OR_MAPPED + 1),
        QUERY_IS_SECURE = (QUERY_USES_CACHE + 1),
        QUERY_IS_SAFE = (QUERY_IS_SECURE + 1),
        QUERY_USES_HISTORYFOLDER = (QUERY_IS_SAFE + 1),
        QUERY_IS_CACHED_AND_USABLE_OFFLINE = (QUERY_USES_HISTORYFOLDER + 1)
    } QUERYOPTION;

    extern "C" const IID IID_IInternetProtocolInfo;

    struct __declspec(uuid("79eac9ec-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetProtocolInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ParseUrl(LPCWSTR pwzUrl,
                                           PARSEACTION ParseAction,
                                           DWORD dwParseFlags,

                                           LPWSTR pwzResult,
                                           DWORD cchResult,
                                           DWORD* pcchResult,
                                           DWORD dwReserved)
        = 0;

        virtual HRESULT __stdcall CombineUrl(LPCWSTR pwzBaseUrl,
                                             LPCWSTR pwzRelativeUrl,
                                             DWORD dwCombineFlags,

                                             LPWSTR pwzResult,
                                             DWORD cchResult,
                                             DWORD* pcchResult,
                                             DWORD dwReserved)
        = 0;

        virtual HRESULT __stdcall CompareUrl(LPCWSTR pwzUrl1, LPCWSTR pwzUrl2, DWORD dwCompareFlags) = 0;

        virtual HRESULT __stdcall QueryInfo(
        LPCWSTR pwzUrl, QUERYOPTION OueryOption, DWORD dwQueryFlags, LPVOID pBuffer, DWORD cbBuffer, DWORD* pcbBuf, DWORD dwReserved)
        = 0;
    };

    extern "C" HRESULT __stdcall CoInternetParseUrl(
    LPCWSTR pwzUrl, PARSEACTION ParseAction, DWORD dwFlags, LPWSTR pszResult, DWORD cchResult, DWORD* pcchResult, DWORD dwReserved);

    extern "C" HRESULT __stdcall CoInternetParseIUri(
    IUri* pIUri, PARSEACTION ParseAction, DWORD dwFlags, LPWSTR pwzResult, DWORD cchResult, DWORD* pcchResult, DWORD_PTR dwReserved);
    extern "C" HRESULT __stdcall CoInternetCombineUrl(
    LPCWSTR pwzBaseUrl, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, LPWSTR pszResult, DWORD cchResult, DWORD* pcchResult, DWORD dwReserved);

    extern "C" HRESULT __stdcall CoInternetCombineUrlEx(
    IUri* pBaseUri, LPCWSTR pwzRelativeUrl, DWORD dwCombineFlags, IUri** ppCombinedUri, DWORD_PTR dwReserved);
    extern "C" HRESULT __stdcall CoInternetCombineIUri(
    IUri* pBaseUri, IUri* pRelativeUri, DWORD dwCombineFlags, IUri** ppCombinedUri, DWORD_PTR dwReserved);
    extern "C" HRESULT __stdcall CoInternetCompareUrl(LPCWSTR pwzUrl1, LPCWSTR pwzUrl2, DWORD dwFlags);
    extern "C" HRESULT __stdcall CoInternetGetProtocolFlags(LPCWSTR pwzUrl, DWORD* pdwFlags, DWORD dwReserved);
    extern "C" HRESULT __stdcall CoInternetQueryInfo(
    LPCWSTR pwzUrl, QUERYOPTION QueryOptions, DWORD dwQueryFlags, LPVOID pvBuffer, DWORD cbBuffer, DWORD* pcbBuffer, DWORD dwReserved);
    extern "C" HRESULT __stdcall CoInternetGetSession(DWORD dwSessionMode, IInternetSession** ppIInternetSession, DWORD dwReserved);
    extern "C" HRESULT __stdcall CoInternetGetSecurityUrl(LPCWSTR pwszUrl, LPWSTR* ppwszSecUrl, PSUACTION psuAction, DWORD dwReserved);
    extern "C" HRESULT __stdcall AsyncInstallDistributionUnit(LPCWSTR szDistUnit,
                                                              LPCWSTR szTYPE,
                                                              LPCWSTR szExt,
                                                              DWORD dwFileVersionMS,
                                                              DWORD dwFileVersionLS,
                                                              LPCWSTR szURL,
                                                              IBindCtx* pbc,
                                                              LPVOID pvReserved,
                                                              DWORD flags);

    extern "C" HRESULT __stdcall CoInternetGetSecurityUrlEx(IUri* pUri, IUri** ppSecUri, PSUACTION psuAction, DWORD_PTR dwReserved);

    typedef enum _tagINTERNETFEATURELIST
    {
        FEATURE_OBJECT_CACHING = 0,
        FEATURE_ZONE_ELEVATION = (FEATURE_OBJECT_CACHING + 1),
        FEATURE_MIME_HANDLING = (FEATURE_ZONE_ELEVATION + 1),
        FEATURE_MIME_SNIFFING = (FEATURE_MIME_HANDLING + 1),
        FEATURE_WINDOW_RESTRICTIONS = (FEATURE_MIME_SNIFFING + 1),
        FEATURE_WEBOC_POPUPMANAGEMENT = (FEATURE_WINDOW_RESTRICTIONS + 1),
        FEATURE_BEHAVIORS = (FEATURE_WEBOC_POPUPMANAGEMENT + 1),
        FEATURE_DISABLE_MK_PROTOCOL = (FEATURE_BEHAVIORS + 1),
        FEATURE_LOCALMACHINE_LOCKDOWN = (FEATURE_DISABLE_MK_PROTOCOL + 1),
        FEATURE_SECURITYBAND = (FEATURE_LOCALMACHINE_LOCKDOWN + 1),
        FEATURE_RESTRICT_ACTIVEXINSTALL = (FEATURE_SECURITYBAND + 1),
        FEATURE_VALIDATE_NAVIGATE_URL = (FEATURE_RESTRICT_ACTIVEXINSTALL + 1),
        FEATURE_RESTRICT_FILEDOWNLOAD = (FEATURE_VALIDATE_NAVIGATE_URL + 1),
        FEATURE_ADDON_MANAGEMENT = (FEATURE_RESTRICT_FILEDOWNLOAD + 1),
        FEATURE_PROTOCOL_LOCKDOWN = (FEATURE_ADDON_MANAGEMENT + 1),
        FEATURE_HTTP_USERNAME_PASSWORD_DISABLE = (FEATURE_PROTOCOL_LOCKDOWN + 1),
        FEATURE_SAFE_BINDTOOBJECT = (FEATURE_HTTP_USERNAME_PASSWORD_DISABLE + 1),
        FEATURE_UNC_SAVEDFILECHECK = (FEATURE_SAFE_BINDTOOBJECT + 1),
        FEATURE_GET_URL_DOM_FILEPATH_UNENCODED = (FEATURE_UNC_SAVEDFILECHECK + 1),
        FEATURE_TABBED_BROWSING = (FEATURE_GET_URL_DOM_FILEPATH_UNENCODED + 1),
        FEATURE_SSLUX = (FEATURE_TABBED_BROWSING + 1),
        FEATURE_DISABLE_NAVIGATION_SOUNDS = (FEATURE_SSLUX + 1),
        FEATURE_DISABLE_LEGACY_COMPRESSION = (FEATURE_DISABLE_NAVIGATION_SOUNDS + 1),
        FEATURE_FORCE_ADDR_AND_STATUS = (FEATURE_DISABLE_LEGACY_COMPRESSION + 1),
        FEATURE_XMLHTTP = (FEATURE_FORCE_ADDR_AND_STATUS + 1),
        FEATURE_DISABLE_TELNET_PROTOCOL = (FEATURE_XMLHTTP + 1),
        FEATURE_FEEDS = (FEATURE_DISABLE_TELNET_PROTOCOL + 1),
        FEATURE_BLOCK_INPUT_PROMPTS = (FEATURE_FEEDS + 1),
        FEATURE_ENTRY_COUNT = (FEATURE_BLOCK_INPUT_PROMPTS + 1)
    } INTERNETFEATURELIST;

    extern "C" HRESULT __stdcall CoInternetSetFeatureEnabled(INTERNETFEATURELIST FeatureEntry, DWORD dwFlags, BOOL fEnable);
    extern "C" HRESULT __stdcall CoInternetIsFeatureEnabled(INTERNETFEATURELIST FeatureEntry, DWORD dwFlags);
    extern "C" HRESULT __stdcall CoInternetIsFeatureEnabledForUrl(INTERNETFEATURELIST FeatureEntry,
                                                                  DWORD dwFlags,
                                                                  LPCWSTR szURL,
                                                                  IInternetSecurityManager* pSecMgr);
    extern "C" HRESULT __stdcall CoInternetIsFeatureEnabledForIUri(INTERNETFEATURELIST FeatureEntry,
                                                                   DWORD dwFlags,
                                                                   IUri* pIUri,
                                                                   IInternetSecurityManagerEx2* pSecMgr);
    extern "C" HRESULT __stdcall CoInternetIsFeatureZoneElevationEnabled(LPCWSTR szFromURL,
                                                                         LPCWSTR szToURL,
                                                                         IInternetSecurityManager* pSecMgr,
                                                                         DWORD dwFlags);

    extern "C" HRESULT __stdcall CopyStgMedium(const STGMEDIUM* pcstgmedSrc, STGMEDIUM* pstgmedDest);
    extern "C" HRESULT __stdcall CopyBindInfo(const BINDINFO* pcbiSrc, BINDINFO* pbiDest);
    extern "C" void __stdcall ReleaseBindInfo(BINDINFO* pbindinfo);

    extern "C" PWSTR __stdcall IEGetUserPrivateNamespaceName(void);

    extern "C" HRESULT __stdcall CoInternetCreateSecurityManager(IServiceProvider* pSP, IInternetSecurityManager** ppSM, DWORD dwReserved);

    extern "C" HRESULT __stdcall CoInternetCreateZoneManager(IServiceProvider* pSP, IInternetZoneManager** ppZM, DWORD dwReserved);

    extern "C" const IID CLSID_InternetSecurityManager;
    extern "C" const IID CLSID_InternetZoneManager;

    extern "C" const IID CLSID_PersistentZoneIdentifier;

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0037_v0_0_s_ifspec;

    extern "C" const IID IID_IInternetSecurityMgrSite;

    struct __declspec(uuid("79eac9ed-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetSecurityMgrSite : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetWindow(HWND* phwnd) = 0;

        virtual HRESULT __stdcall EnableModeless(BOOL fEnable) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0038_v0_0_s_ifspec;

    typedef enum __MIDL_IInternetSecurityManager_0001
    {
        PUAF_DEFAULT = 0,
        PUAF_NOUI = 0x1,
        PUAF_ISFILE = 0x2,
        PUAF_WARN_IF_DENIED = 0x4,
        PUAF_FORCEUI_FOREGROUND = 0x8,
        PUAF_CHECK_TIFS = 0x10,
        PUAF_DONTCHECKBOXINDIALOG = 0x20,
        PUAF_TRUSTED = 0x40,
        PUAF_ACCEPT_WILDCARD_SCHEME = 0x80,
        PUAF_ENFORCERESTRICTED = 0x100,
        PUAF_NOSAVEDFILECHECK = 0x200,
        PUAF_REQUIRESAVEDFILECHECK = 0x400,
        PUAF_DONT_USE_CACHE = 0x1000,
        PUAF_RESERVED1 = 0x2000,
        PUAF_RESERVED2 = 0x4000,
        PUAF_LMZ_UNLOCKED = 0x10000,
        PUAF_LMZ_LOCKED = 0x20000,
        PUAF_DEFAULTZONEPOL = 0x40000,
        PUAF_NPL_USE_LOCKED_IF_RESTRICTED = 0x80000,
        PUAF_NOUIIFLOCKED = 0x100000,
        PUAF_DRAGPROTOCOLCHECK = 0x200000
    } PUAF;

    typedef enum __MIDL_IInternetSecurityManager_0002
    {
        PUAFOUT_DEFAULT = 0,
        PUAFOUT_ISLOCKZONEPOLICY = 0x1
    } PUAFOUT;

    typedef enum __MIDL_IInternetSecurityManager_0003
    {
        SZM_CREATE = 0,
        SZM_DELETE = 0x1
    } SZM_FLAGS;

    extern "C" const IID IID_IInternetSecurityManager;

    struct __declspec(uuid("79eac9ee-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT __stdcall SetSecuritySite(IInternetSecurityMgrSite* pSite) = 0;

        virtual HRESULT __stdcall GetSecuritySite(IInternetSecurityMgrSite** ppSite) = 0;

        virtual HRESULT __stdcall MapUrlToZone(LPCWSTR pwszUrl, DWORD* pdwZone, DWORD dwFlags) = 0;

        virtual HRESULT __stdcall GetSecurityId(

        LPCWSTR pwszUrl,

        BYTE* pbSecurityId,

        DWORD* pcbSecurityId,

        DWORD_PTR dwReserved)
        = 0;

        virtual HRESULT __stdcall ProcessUrlAction(
        LPCWSTR pwszUrl, DWORD dwAction, BYTE* pPolicy, DWORD cbPolicy, BYTE* pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved)
        = 0;

        virtual HRESULT __stdcall QueryCustomPolicy(
        LPCWSTR pwszUrl, const GUID& guidKey, BYTE** ppPolicy, DWORD* pcbPolicy, BYTE* pContext, DWORD cbContext, DWORD dwReserved)
        = 0;

        virtual HRESULT __stdcall SetZoneMapping(DWORD dwZone, LPCWSTR lpszPattern, DWORD dwFlags) = 0;

        virtual HRESULT __stdcall GetZoneMappings(DWORD dwZone, IEnumString** ppenumString, DWORD dwFlags) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0039_v0_0_s_ifspec;

    extern "C" const IID IID_IInternetSecurityManagerEx;

    struct __declspec(uuid("F164EDF1-CC7C-4f0d-9A94-34222625C393")) __declspec(novtable) IInternetSecurityManagerEx : public IInternetSecurityManager
    {
    public:
        virtual HRESULT __stdcall ProcessUrlActionEx(
        LPCWSTR pwszUrl, DWORD dwAction, BYTE* pPolicy, DWORD cbPolicy, BYTE* pContext, DWORD cbContext, DWORD dwFlags, DWORD dwReserved, DWORD* pdwOutFlags)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0040_v0_0_s_ifspec;

    extern "C" const IID IID_IInternetSecurityManagerEx2;

    struct __declspec(uuid("F1E50292-A795-4117-8E09-2B560A72AC60")) __declspec(novtable) IInternetSecurityManagerEx2 : public IInternetSecurityManagerEx
    {
    public:
        virtual HRESULT __stdcall MapUrlToZoneEx2(

        IUri* pUri,
        DWORD* pdwZone,
        DWORD dwFlags,

        LPWSTR* ppwszMappedUrl,

        DWORD* pdwOutFlags)
        = 0;

        virtual HRESULT __stdcall ProcessUrlActionEx2(

        IUri* pUri, DWORD dwAction, BYTE* pPolicy, DWORD cbPolicy, BYTE* pContext, DWORD cbContext, DWORD dwFlags, DWORD_PTR dwReserved, DWORD* pdwOutFlags)
        = 0;

        virtual HRESULT __stdcall GetSecurityIdEx2(

        IUri* pUri,

        BYTE* pbSecurityId,

        DWORD* pcbSecurityId,

        DWORD_PTR dwReserved)
        = 0;

        virtual HRESULT __stdcall QueryCustomPolicyEx2(

        IUri* pUri, const GUID& guidKey, BYTE** ppPolicy, DWORD* pcbPolicy, BYTE* pContext, DWORD cbContext, DWORD_PTR dwReserved)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0041_v0_0_s_ifspec;

    extern "C" const IID IID_IZoneIdentifier;

    struct __declspec(uuid("cd45f185-1b21-48e2-967b-ead743a8914e")) __declspec(novtable) IZoneIdentifier : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetId(DWORD* pdwZone) = 0;

        virtual HRESULT __stdcall SetId(DWORD dwZone) = 0;

        virtual HRESULT __stdcall Remove(void) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0042_v0_0_s_ifspec;

    extern "C" const IID IID_IZoneIdentifier2;

    struct __declspec(uuid("EB5E760C-09EF-45C0-B510-70830CE31E6A")) __declspec(novtable) IZoneIdentifier2 : public IZoneIdentifier
    {
    public:
        virtual HRESULT __stdcall GetLastWriterPackageFamilyName(LPWSTR* packageFamilyName) = 0;

        virtual HRESULT __stdcall SetLastWriterPackageFamilyName(LPCWSTR packageFamilyName) = 0;

        virtual HRESULT __stdcall RemoveLastWriterPackageFamilyName(void) = 0;

        virtual HRESULT __stdcall GetAppZoneId(DWORD* zone) = 0;

        virtual HRESULT __stdcall SetAppZoneId(DWORD zone) = 0;

        virtual HRESULT __stdcall RemoveAppZoneId(void) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0043_v0_0_s_ifspec;

    extern "C" const IID IID_IInternetHostSecurityManager;

    struct __declspec(uuid("3af280b6-cb3f-11d0-891e-00c04fb6bfc4")) __declspec(novtable) IInternetHostSecurityManager : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetSecurityId(

        BYTE* pbSecurityId,

        DWORD* pcbSecurityId,
        DWORD_PTR dwReserved)
        = 0;

        virtual HRESULT __stdcall ProcessUrlAction(DWORD dwAction,

                                                   BYTE* pPolicy,
                                                   DWORD cbPolicy,

                                                   BYTE* pContext,
                                                   DWORD cbContext,
                                                   DWORD dwFlags,
                                                   DWORD dwReserved)
        = 0;

        virtual HRESULT __stdcall QueryCustomPolicy(const GUID& guidKey,

                                                    BYTE** ppPolicy,

                                                    DWORD* pcbPolicy,

                                                    BYTE* pContext,
                                                    DWORD cbContext,
                                                    DWORD dwReserved)
        = 0;
    };

    extern "C" const GUID GUID_CUSTOM_LOCALMACHINEZONEUNLOCKED;

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0044_v0_0_s_ifspec;

    typedef IInternetZoneManager* LPURLZONEMANAGER;

    typedef enum tagURLZONE
    {
        URLZONE_INVALID = -1,
        URLZONE_PREDEFINED_MIN = 0,
        URLZONE_LOCAL_MACHINE = 0,
        URLZONE_INTRANET = (URLZONE_LOCAL_MACHINE + 1),
        URLZONE_TRUSTED = (URLZONE_INTRANET + 1),
        URLZONE_INTERNET = (URLZONE_TRUSTED + 1),
        URLZONE_UNTRUSTED = (URLZONE_INTERNET + 1),
        URLZONE_PREDEFINED_MAX = 999,
        URLZONE_USER_MIN = 1000,
        URLZONE_USER_MAX = 10000
    } URLZONE;

    typedef enum tagURLTEMPLATE
    {
        URLTEMPLATE_CUSTOM = 0,
        URLTEMPLATE_PREDEFINED_MIN = 0x10000,
        URLTEMPLATE_LOW = 0x10000,
        URLTEMPLATE_MEDLOW = 0x10500,
        URLTEMPLATE_MEDIUM = 0x11000,
        URLTEMPLATE_MEDHIGH = 0x11500,
        URLTEMPLATE_HIGH = 0x12000,
        URLTEMPLATE_PREDEFINED_MAX = 0x20000
    } URLTEMPLATE;

    enum __MIDL_IInternetZoneManager_0001
    {
        MAX_ZONE_PATH = 260,
        MAX_ZONE_DESCRIPTION = 200
    };
    typedef enum __MIDL_IInternetZoneManager_0002
    {
        ZAFLAGS_CUSTOM_EDIT = 0x1,
        ZAFLAGS_ADD_SITES = 0x2,
        ZAFLAGS_REQUIRE_VERIFICATION = 0x4,
        ZAFLAGS_INCLUDE_PROXY_OVERRIDE = 0x8,
        ZAFLAGS_INCLUDE_INTRANET_SITES = 0x10,
        ZAFLAGS_NO_UI = 0x20,
        ZAFLAGS_SUPPORTS_VERIFICATION = 0x40,
        ZAFLAGS_UNC_AS_INTRANET = 0x80,
        ZAFLAGS_DETECT_INTRANET = 0x100,
        ZAFLAGS_USE_LOCKED_ZONES = 0x10000,
        ZAFLAGS_VERIFY_TEMPLATE_SETTINGS = 0x20000,
        ZAFLAGS_NO_CACHE = 0x40000
    } ZAFLAGS;

    typedef struct _ZONEATTRIBUTES
    {
        ULONG cbSize;
        WCHAR szDisplayName[260];
        WCHAR szDescription[200];
        WCHAR szIconPath[260];
        DWORD dwTemplateMinLevel;
        DWORD dwTemplateRecommended;
        DWORD dwTemplateCurrentLevel;
        DWORD dwFlags;
    } ZONEATTRIBUTES;

    typedef struct _ZONEATTRIBUTES* LPZONEATTRIBUTES;

    typedef enum _URLZONEREG
    {
        URLZONEREG_DEFAULT = 0,
        URLZONEREG_HKLM = (URLZONEREG_DEFAULT + 1),
        URLZONEREG_HKCU = (URLZONEREG_HKLM + 1)
    } URLZONEREG;

    extern "C" const IID IID_IInternetZoneManager;

    struct __declspec(uuid("79eac9ef-baf9-11ce-8c82-00aa004ba90b")) __declspec(novtable) IInternetZoneManager : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetZoneAttributes(DWORD dwZone,

                                                    ZONEATTRIBUTES* pZoneAttributes)
        = 0;

        virtual HRESULT __stdcall SetZoneAttributes(DWORD dwZone,

                                                    ZONEATTRIBUTES* pZoneAttributes)
        = 0;

        virtual HRESULT __stdcall GetZoneCustomPolicy(DWORD dwZone,
                                                      const GUID& guidKey,

                                                      BYTE** ppPolicy,

                                                      DWORD* pcbPolicy,
                                                      URLZONEREG urlZoneReg)
        = 0;

        virtual HRESULT __stdcall SetZoneCustomPolicy(DWORD dwZone,
                                                      const GUID& guidKey,

                                                      BYTE* pPolicy,
                                                      DWORD cbPolicy,
                                                      URLZONEREG urlZoneReg)
        = 0;

        virtual HRESULT __stdcall GetZoneActionPolicy(DWORD dwZone,
                                                      DWORD dwAction,

                                                      BYTE* pPolicy,
                                                      DWORD cbPolicy,
                                                      URLZONEREG urlZoneReg)
        = 0;

        virtual HRESULT __stdcall SetZoneActionPolicy(DWORD dwZone,
                                                      DWORD dwAction,

                                                      BYTE* pPolicy,
                                                      DWORD cbPolicy,
                                                      URLZONEREG urlZoneReg)
        = 0;

        virtual HRESULT __stdcall PromptAction(DWORD dwAction, HWND hwndParent, LPCWSTR pwszUrl, LPCWSTR pwszText, DWORD dwPromptFlags)
        = 0;

        virtual HRESULT __stdcall LogAction(DWORD dwAction, LPCWSTR pwszUrl, LPCWSTR pwszText, DWORD dwLogFlags) = 0;

        virtual HRESULT __stdcall CreateZoneEnumerator(DWORD* pdwEnum, DWORD* pdwCount, DWORD dwFlags) = 0;

        virtual HRESULT __stdcall GetZoneAt(DWORD dwEnum, DWORD dwIndex, DWORD* pdwZone) = 0;

        virtual HRESULT __stdcall DestroyZoneEnumerator(DWORD dwEnum) = 0;

        virtual HRESULT __stdcall CopyTemplatePoliciesToZone(DWORD dwTemplate, DWORD dwZone, DWORD dwReserved) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0045_v0_0_s_ifspec;

    extern "C" const IID IID_IInternetZoneManagerEx;

    struct __declspec(uuid("A4C23339-8E06-431e-9BF4-7E711C085648")) __declspec(novtable) IInternetZoneManagerEx : public IInternetZoneManager
    {
    public:
        virtual HRESULT __stdcall GetZoneActionPolicyEx(DWORD dwZone,
                                                        DWORD dwAction,

                                                        BYTE* pPolicy,
                                                        DWORD cbPolicy,
                                                        URLZONEREG urlZoneReg,
                                                        DWORD dwFlags)
        = 0;

        virtual HRESULT __stdcall SetZoneActionPolicyEx(DWORD dwZone,
                                                        DWORD dwAction,

                                                        BYTE* pPolicy,
                                                        DWORD cbPolicy,
                                                        URLZONEREG urlZoneReg,
                                                        DWORD dwFlags)
        = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0046_v0_0_s_ifspec;

    extern "C" const IID IID_IInternetZoneManagerEx2;

    struct __declspec(uuid("EDC17559-DD5D-4846-8EEF-8BECBA5A4ABF")) __declspec(novtable) IInternetZoneManagerEx2 : public IInternetZoneManagerEx
    {
    public:
        virtual HRESULT __stdcall GetZoneAttributesEx(DWORD dwZone, ZONEATTRIBUTES* pZoneAttributes, DWORD dwFlags) = 0;

        virtual HRESULT __stdcall GetZoneSecurityState(DWORD dwZoneIndex, BOOL fRespectPolicy, LPDWORD pdwState, BOOL* pfPolicyEncountered)
        = 0;

        virtual HRESULT __stdcall GetIESecurityState(BOOL fRespectPolicy, LPDWORD pdwState, BOOL* pfPolicyEncountered, BOOL fNoCache)
        = 0;

        virtual HRESULT __stdcall FixUnsecureSettings(void) = 0;
    };

    extern "C" const IID CLSID_SoftDistExt;

    typedef struct _tagCODEBASEHOLD
    {
        ULONG cbSize;
        LPWSTR szDistUnit;
        LPWSTR szCodeBase;
        DWORD dwVersionMS;
        DWORD dwVersionLS;
        DWORD dwStyle;
    } CODEBASEHOLD;

    typedef struct _tagCODEBASEHOLD* LPCODEBASEHOLD;

    typedef struct _tagSOFTDISTINFO
    {
        ULONG cbSize;
        DWORD dwFlags;
        DWORD dwAdState;
        LPWSTR szTitle;
        LPWSTR szAbstract;
        LPWSTR szHREF;
        DWORD dwInstalledVersionMS;
        DWORD dwInstalledVersionLS;
        DWORD dwUpdateVersionMS;
        DWORD dwUpdateVersionLS;
        DWORD dwAdvertisedVersionMS;
        DWORD dwAdvertisedVersionLS;
        DWORD dwReserved;
    } SOFTDISTINFO;

    typedef struct _tagSOFTDISTINFO* LPSOFTDISTINFO;

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0047_v0_0_s_ifspec;

    extern "C" const IID IID_ISoftDistExt;

    struct __declspec(uuid("B15B8DC1-C7E1-11d0-8680-00AA00BDCB71")) __declspec(novtable) ISoftDistExt : public IUnknown
    {
    public:
        virtual HRESULT __stdcall ProcessSoftDist(LPCWSTR szCDFURL, IXMLElement* pSoftDistElement, LPSOFTDISTINFO lpsdi) = 0;

        virtual HRESULT __stdcall GetFirstCodeBase(

        LPWSTR* szCodeBase, LPDWORD dwMaxSize)
        = 0;

        virtual HRESULT __stdcall GetNextCodeBase(

        LPWSTR* szCodeBase, LPDWORD dwMaxSize)
        = 0;

        virtual HRESULT __stdcall AsyncInstallDistributionUnit(IBindCtx* pbc, LPVOID pvReserved, DWORD flags, LPCODEBASEHOLD lpcbh)
        = 0;
    };

    extern "C" HRESULT __stdcall GetSoftwareUpdateInfo(LPCWSTR szDistUnit, LPSOFTDISTINFO psdi);
    extern "C" HRESULT __stdcall SetSoftwareUpdateAdvertisementState(LPCWSTR szDistUnit,
                                                                     DWORD dwAdState,
                                                                     DWORD dwAdvertisedVersionMS,
                                                                     DWORD dwAdvertisedVersionLS);

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0048_v0_0_s_ifspec;

    typedef ICatalogFileInfo* LPCATALOGFILEINFO;

    extern "C" const IID IID_ICatalogFileInfo;

    struct __declspec(uuid("711C7600-6B48-11d1-B403-00AA00B92AF1")) __declspec(novtable) ICatalogFileInfo : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetCatalogFile(

        LPSTR* ppszCatalogFile)
        = 0;

        virtual HRESULT __stdcall GetJavaTrust(void** ppJavaTrust) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0049_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0049_v0_0_s_ifspec;

    typedef IDataFilter* LPDATAFILTER;

    extern "C" const IID IID_IDataFilter;

    struct __declspec(uuid("69d14c80-c18e-11d0-a9ce-006097942311")) __declspec(novtable) IDataFilter : public IUnknown
    {
    public:
        virtual HRESULT __stdcall DoEncode(DWORD dwFlags,
                                           LONG lInBufferSize,
                                           BYTE* pbInBuffer,
                                           LONG lOutBufferSize,
                                           BYTE* pbOutBuffer,
                                           LONG lInBytesAvailable,
                                           LONG* plInBytesRead,
                                           LONG* plOutBytesWritten,
                                           DWORD dwReserved)
        = 0;

        virtual HRESULT __stdcall DoDecode(DWORD dwFlags,
                                           LONG lInBufferSize,
                                           BYTE* pbInBuffer,
                                           LONG lOutBufferSize,
                                           BYTE* pbOutBuffer,
                                           LONG lInBytesAvailable,
                                           LONG* plInBytesRead,
                                           LONG* plOutBytesWritten,
                                           DWORD dwReserved)
        = 0;

        virtual HRESULT __stdcall SetEncodingLevel(DWORD dwEncLevel) = 0;
    };

    typedef struct _tagPROTOCOLFILTERDATA
    {
        DWORD cbSize;
        IInternetProtocolSink* pProtocolSink;
        IInternetProtocol* pProtocol;
        IUnknown* pUnk;
        DWORD dwFilterFlags;
    } PROTOCOLFILTERDATA;

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0050_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0050_v0_0_s_ifspec;

    typedef IEncodingFilterFactory* LPENCODINGFILTERFACTORY;

    typedef struct _tagDATAINFO
    {
        ULONG ulTotalSize;
        ULONG ulavrPacketSize;
        ULONG ulConnectSpeed;
        ULONG ulProcessorSpeed;
    } DATAINFO;

    extern "C" const IID IID_IEncodingFilterFactory;

    struct __declspec(uuid("70bdde00-c18e-11d0-a9ce-006097942311")) __declspec(novtable) IEncodingFilterFactory : public IUnknown
    {
    public:
        virtual HRESULT __stdcall FindBestFilter(LPCWSTR pwzCodeIn, LPCWSTR pwzCodeOut, DATAINFO info, IDataFilter** ppDF) = 0;

        virtual HRESULT __stdcall GetDefaultFilter(LPCWSTR pwzCodeIn, LPCWSTR pwzCodeOut, IDataFilter** ppDF) = 0;
    };

    BOOL __stdcall IsLoggingEnabledA(LPCSTR pszUrl);
    BOOL __stdcall IsLoggingEnabledW(LPCWSTR pwszUrl);

    typedef struct _tagHIT_LOGGING_INFO
    {
        DWORD dwStructSize;
        LPSTR lpszLoggedUrlName;
        SYSTEMTIME StartTime;
        SYSTEMTIME EndTime;
        LPSTR lpszExtendedInfo;
    } HIT_LOGGING_INFO;

    typedef struct _tagHIT_LOGGING_INFO* LPHIT_LOGGING_INFO;

    BOOL __stdcall WriteHitLogging(LPHIT_LOGGING_INFO lpLogginginfo);

    struct CONFIRMSAFETY
    {
        CLSID clsid;
        IUnknown* pUnk;
        DWORD dwFlags;
    };
    extern "C" const GUID GUID_CUSTOM_CONFIRMOBJECTSAFETY;

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0051_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0051_v0_0_s_ifspec;

    typedef IWrappedProtocol* LPIWRAPPEDPROTOCOL;

    extern "C" const IID IID_IWrappedProtocol;

    struct __declspec(uuid("53c84785-8425-4dc5-971b-e58d9c19f9b6")) __declspec(novtable) IWrappedProtocol : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetWrapperCode(LONG* pnCode, DWORD_PTR dwReserved) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0052_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0052_v0_0_s_ifspec;

    typedef IGetBindHandle* LPGETBINDHANDLE;

    typedef enum __MIDL_IGetBindHandle_0001
    {
        BINDHANDLETYPES_APPCACHE = 0,
        BINDHANDLETYPES_DEPENDENCY = 0x1,
        BINDHANDLETYPES_COUNT = (BINDHANDLETYPES_DEPENDENCY + 1)
    } BINDHANDLETYPES;

    extern "C" const IID IID_IGetBindHandle;

    struct __declspec(uuid("AF0FF408-129D-4b20-91F0-02BD23D88352")) __declspec(novtable) IGetBindHandle : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetBindHandle(BINDHANDLETYPES enumRequestedHandle, HANDLE* pRetHandle) = 0;
    };

    typedef struct _tagPROTOCOL_ARGUMENT
    {
        LPCWSTR szMethod;
        LPCWSTR szTargetUrl;
    } PROTOCOL_ARGUMENT;

    typedef struct _tagPROTOCOL_ARGUMENT* LPPROTOCOL_ARGUMENT;

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0053_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0053_v0_0_s_ifspec;

    typedef IBindCallbackRedirect* LPBINDCALLBACKREDIRECT;

    extern "C" const IID IID_IBindCallbackRedirect;

    struct __declspec(uuid("11C81BC2-121E-4ed5-B9C4-B430BD54F2C0")) __declspec(novtable) IBindCallbackRedirect : public IUnknown
    {
    public:
        virtual HRESULT __stdcall Redirect(LPCWSTR lpcUrl, VARIANT_BOOL* vbCancel) = 0;
    };

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0054_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0054_v0_0_s_ifspec;

    extern "C" const IID IID_IBindHttpSecurity;

    struct __declspec(uuid("a9eda967-f50e-4a33-b358-206f6ef3086d")) __declspec(novtable) IBindHttpSecurity : public IUnknown
    {
    public:
        virtual HRESULT __stdcall GetIgnoreCertMask(DWORD* pdwIgnoreCertMask) = 0;
    };

#pragma endregion

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0055_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_urlmon_0000_0055_v0_0_s_ifspec;

    unsigned long __stdcall BSTR_UserSize(unsigned long*, unsigned long, BSTR*);
    unsigned char* __stdcall BSTR_UserMarshal(unsigned long*, unsigned char*, BSTR*);
    unsigned char* __stdcall BSTR_UserUnmarshal(unsigned long*, unsigned char*, BSTR*);
    void __stdcall BSTR_UserFree(unsigned long*, BSTR*);

    unsigned long __stdcall HWND_UserSize(unsigned long*, unsigned long, HWND*);
    unsigned char* __stdcall HWND_UserMarshal(unsigned long*, unsigned char*, HWND*);
    unsigned char* __stdcall HWND_UserUnmarshal(unsigned long*, unsigned char*, HWND*);
    void __stdcall HWND_UserFree(unsigned long*, HWND*);

    unsigned long __stdcall BSTR_UserSize64(unsigned long*, unsigned long, BSTR*);
    unsigned char* __stdcall BSTR_UserMarshal64(unsigned long*, unsigned char*, BSTR*);
    unsigned char* __stdcall BSTR_UserUnmarshal64(unsigned long*, unsigned char*, BSTR*);
    void __stdcall BSTR_UserFree64(unsigned long*, BSTR*);

    unsigned long __stdcall HWND_UserSize64(unsigned long*, unsigned long, HWND*);
    unsigned char* __stdcall HWND_UserMarshal64(unsigned long*, unsigned char*, HWND*);
    unsigned char* __stdcall HWND_UserUnmarshal64(unsigned long*, unsigned char*, HWND*);
    void __stdcall HWND_UserFree64(unsigned long*, HWND*);

    HRESULT __stdcall IBinding_GetBindResult_Proxy(IBinding* This,
                                                   CLSID* pclsidProtocol,
                                                   DWORD* pdwResult,

                                                   LPOLESTR* pszResult,
                                                   DWORD* pdwReserved);

    HRESULT __stdcall IBinding_GetBindResult_Stub(IBinding* This, CLSID* pclsidProtocol, DWORD* pdwResult, LPOLESTR* pszResult, DWORD dwReserved);

    HRESULT __stdcall IBindStatusCallback_GetBindInfo_Proxy(IBindStatusCallback* This, DWORD* grfBINDF, BINDINFO* pbindinfo);

    HRESULT __stdcall IBindStatusCallback_GetBindInfo_Stub(IBindStatusCallback* This, DWORD* grfBINDF, RemBINDINFO* pbindinfo, RemSTGMEDIUM* pstgmed);

    HRESULT __stdcall IBindStatusCallback_OnDataAvailable_Proxy(
    IBindStatusCallback* This, DWORD grfBSCF, DWORD dwSize, FORMATETC* pformatetc, STGMEDIUM* pstgmed);

    HRESULT __stdcall IBindStatusCallback_OnDataAvailable_Stub(
    IBindStatusCallback* This, DWORD grfBSCF, DWORD dwSize, RemFORMATETC* pformatetc, RemSTGMEDIUM* pstgmed);

    HRESULT __stdcall IBindStatusCallbackEx_GetBindInfoEx_Proxy(
    IBindStatusCallbackEx* This, DWORD* grfBINDF, BINDINFO* pbindinfo, DWORD* grfBINDF2, DWORD* pdwReserved);

    HRESULT __stdcall IBindStatusCallbackEx_GetBindInfoEx_Stub(
    IBindStatusCallbackEx* This, DWORD* grfBINDF, RemBINDINFO* pbindinfo, RemSTGMEDIUM* pstgmed, DWORD* grfBINDF2, DWORD* pdwReserved);

    HRESULT __stdcall IWinInetInfo_QueryOption_Proxy(IWinInetInfo* This, DWORD dwOption, LPVOID pBuffer, DWORD* pcbBuf);

    HRESULT __stdcall IWinInetInfo_QueryOption_Stub(IWinInetInfo* This, DWORD dwOption, BYTE* pBuffer, DWORD* pcbBuf);

    HRESULT __stdcall IWinInetHttpInfo_QueryInfo_Proxy(
    IWinInetHttpInfo* This, DWORD dwOption, LPVOID pBuffer, DWORD* pcbBuf, DWORD* pdwFlags, DWORD* pdwReserved);

    HRESULT __stdcall IWinInetHttpInfo_QueryInfo_Stub(
    IWinInetHttpInfo* This, DWORD dwOption, BYTE* pBuffer, DWORD* pcbBuf, DWORD* pdwFlags, DWORD* pdwReserved);

    HRESULT __stdcall IBindHost_MonikerBindToStorage_Proxy(
    IBindHost* This, IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, const IID& riid, void** ppvObj);

    HRESULT __stdcall IBindHost_MonikerBindToStorage_Stub(
    IBindHost* This, IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, const IID& riid, IUnknown** ppvObj);

    HRESULT __stdcall IBindHost_MonikerBindToObject_Proxy(
    IBindHost* This, IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, const IID& riid, void** ppvObj);

    HRESULT __stdcall IBindHost_MonikerBindToObject_Stub(
    IBindHost* This, IMoniker* pMk, IBindCtx* pBC, IBindStatusCallback* pBSC, const IID& riid, IUnknown** ppvObj);
}

#pragma once

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)
#pragma warning(disable : 4201)
#pragma warning(disable : 4237)

#pragma once

#pragma region Desktop Family or OneCore Family

    enum PIDMSI_STATUS_VALUE
    {
        PIDMSI_STATUS_NORMAL = 0,
        PIDMSI_STATUS_NEW = (PIDMSI_STATUS_NORMAL + 1),
        PIDMSI_STATUS_PRELIM = (PIDMSI_STATUS_NEW + 1),
        PIDMSI_STATUS_DRAFT = (PIDMSI_STATUS_PRELIM + 1),
        PIDMSI_STATUS_INPROGRESS = (PIDMSI_STATUS_DRAFT + 1),
        PIDMSI_STATUS_EDIT = (PIDMSI_STATUS_INPROGRESS + 1),
        PIDMSI_STATUS_REVIEW = (PIDMSI_STATUS_EDIT + 1),
        PIDMSI_STATUS_PROOF = (PIDMSI_STATUS_REVIEW + 1),
        PIDMSI_STATUS_FINAL = (PIDMSI_STATUS_PROOF + 1),
        PIDMSI_STATUS_OTHER = 0x7fff
    };
#pragma endregion
#pragma region Application Family or OneCore Family

    extern "C" __declspec(dllimport) HRESULT __stdcall PropVariantCopy(PROPVARIANT* pvarDest, const PROPVARIANT* pvarSrc);

    extern "C" __declspec(dllimport) HRESULT __stdcall PropVariantClear(PROPVARIANT* pvar);

    extern "C" __declspec(dllimport) HRESULT __stdcall FreePropVariantArray(ULONG cVariants, PROPVARIANT* rgvars);

    inline void PropVariantInit(PROPVARIANT* pvar)
    {
        memset(pvar, 0, sizeof(PROPVARIANT));
    }

#pragma endregion

#pragma region Desktop Family

    typedef struct tagSERIALIZEDPROPERTYVALUE
    {
        DWORD dwType;
        BYTE rgb[1];
    } SERIALIZEDPROPERTYVALUE;

    extern "C"

    SERIALIZEDPROPERTYVALUE* __stdcall StgConvertVariantToProperty(
    const PROPVARIANT* pvar, USHORT CodePage, SERIALIZEDPROPERTYVALUE* pprop, ULONG* pcb, PROPID pid, BOOLEAN fReserved, ULONG* pcIndirect);

    class PMemoryAllocator;

    extern "C"

    BOOLEAN __stdcall StgConvertPropertyToVariant(const SERIALIZEDPROPERTYVALUE* pprop, USHORT CodePage, PROPVARIANT* pvar, PMemoryAllocator* pma);

#pragma endregion

#pragma warning(pop)

    extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0004_v0_0_c_ifspec;
    extern RPC_IF_HANDLE __MIDL_itf_propidl_0000_0004_v0_0_s_ifspec;

    unsigned long __stdcall BSTR_UserSize(unsigned long*, unsigned long, BSTR*);
    unsigned char* __stdcall BSTR_UserMarshal(unsigned long*, unsigned char*, BSTR*);
    unsigned char* __stdcall BSTR_UserUnmarshal(unsigned long*, unsigned char*, BSTR*);
    void __stdcall BSTR_UserFree(unsigned long*, BSTR*);

    unsigned long __stdcall LPSAFEARRAY_UserSize(unsigned long*, unsigned long, LPSAFEARRAY*);
    unsigned char* __stdcall LPSAFEARRAY_UserMarshal(unsigned long*, unsigned char*, LPSAFEARRAY*);
    unsigned char* __stdcall LPSAFEARRAY_UserUnmarshal(unsigned long*, unsigned char*, LPSAFEARRAY*);
    void __stdcall LPSAFEARRAY_UserFree(unsigned long*, LPSAFEARRAY*);

    unsigned long __stdcall BSTR_UserSize64(unsigned long*, unsigned long, BSTR*);
    unsigned char* __stdcall BSTR_UserMarshal64(unsigned long*, unsigned char*, BSTR*);
    unsigned char* __stdcall BSTR_UserUnmarshal64(unsigned long*, unsigned char*, BSTR*);
    void __stdcall BSTR_UserFree64(unsigned long*, BSTR*);

    unsigned long __stdcall LPSAFEARRAY_UserSize64(unsigned long*, unsigned long, LPSAFEARRAY*);
    unsigned char* __stdcall LPSAFEARRAY_UserMarshal64(unsigned long*, unsigned char*, LPSAFEARRAY*);
    unsigned char* __stdcall LPSAFEARRAY_UserUnmarshal64(unsigned long*, unsigned char*, LPSAFEARRAY*);
    void __stdcall LPSAFEARRAY_UserFree64(unsigned long*, LPSAFEARRAY*);

    HRESULT __stdcall IEnumSTATPROPSTG_Next_Proxy(IEnumSTATPROPSTG* This,
                                                  ULONG celt,

                                                  STATPROPSTG* rgelt,

                                                  ULONG* pceltFetched);

    HRESULT __stdcall IEnumSTATPROPSTG_Next_Stub(IEnumSTATPROPSTG* This, ULONG celt, STATPROPSTG* rgelt, ULONG* pceltFetched);

    HRESULT __stdcall IEnumSTATPROPSETSTG_Next_Proxy(IEnumSTATPROPSETSTG* This,
                                                     ULONG celt,

                                                     STATPROPSETSTG* rgelt,

                                                     ULONG* pceltFetched);

    HRESULT __stdcall IEnumSTATPROPSETSTG_Next_Stub(IEnumSTATPROPSETSTG* This, ULONG celt, STATPROPSETSTG* rgelt, ULONG* pceltFetched);
}

#pragma region Desktop Partition

extern "C" __declspec(dllimport) HRESULT
__stdcall CreateStdProgressIndicator(HWND hwndParent, LPCOLESTR pszTitle, IBindStatusCallback* pIbscCaller, IBindStatusCallback** ppIbsc);

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4820)

#pragma once

#pragma warning(disable : 4103)

#pragma pack(push, 8)

extern "C" const IID IID_StdOle;

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) BSTR __stdcall SysAllocString(const OLECHAR* psz);
extern "C" __declspec(dllimport) INT __stdcall SysReAllocString(BSTR* pbstr, const OLECHAR* psz);
extern "C" __declspec(dllimport) BSTR __stdcall SysAllocStringLen(const OLECHAR* strIn, UINT ui);
extern "C" __declspec(dllimport) INT __stdcall SysReAllocStringLen(BSTR* pbstr, const OLECHAR* psz, unsigned int len);
extern "C" __declspec(dllimport) HRESULT __stdcall SysAddRefString(BSTR bstrString);
extern "C" __declspec(dllimport) void __stdcall SysReleaseString(BSTR bstrString);
extern "C" __declspec(dllimport) void __stdcall SysFreeString(BSTR bstrString);
extern "C" __declspec(dllimport) UINT __stdcall SysStringLen(BSTR pbstr);

extern "C" __declspec(dllimport) UINT __stdcall SysStringByteLen(BSTR bstr);
extern "C" __declspec(dllimport) BSTR __stdcall SysAllocStringByteLen(LPCSTR psz, UINT len);

#pragma endregion

#pragma region Desktop Family or OneCore Family

extern "C" __declspec(dllimport) INT __stdcall DosDateTimeToVariantTime(USHORT wDosDate, USHORT wDosTime, DOUBLE* pvtime);

extern "C" __declspec(dllimport) INT __stdcall VariantTimeToDosDateTime(DOUBLE vtime, USHORT* pwDosDate, USHORT* pwDosTime);

#pragma endregion

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) INT __stdcall SystemTimeToVariantTime(LPSYSTEMTIME lpSystemTime, DOUBLE* pvtime);
extern "C" __declspec(dllimport) INT __stdcall VariantTimeToSystemTime(DOUBLE vtime, LPSYSTEMTIME lpSystemTime);

#pragma endregion

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayAllocDescriptor(UINT cDims, SAFEARRAY** ppsaOut);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayAllocDescriptorEx(VARTYPE vt, UINT cDims, SAFEARRAY** ppsaOut);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayAllocData(SAFEARRAY* psa);
extern "C" __declspec(dllimport) SAFEARRAY* __stdcall SafeArrayCreate(VARTYPE vt, UINT cDims, SAFEARRAYBOUND* rgsabound);
extern "C" __declspec(dllimport) SAFEARRAY* __stdcall SafeArrayCreateEx(VARTYPE vt, UINT cDims, SAFEARRAYBOUND* rgsabound, PVOID pvExtra);

extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayCopyData(SAFEARRAY* psaSource, SAFEARRAY* psaTarget);
extern "C" __declspec(dllimport) void __stdcall SafeArrayReleaseDescriptor(SAFEARRAY* psa);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayDestroyDescriptor(SAFEARRAY* psa);
extern "C" __declspec(dllimport) void __stdcall SafeArrayReleaseData(PVOID pData);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayDestroyData(SAFEARRAY* psa);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayAddRef(SAFEARRAY* psa, PVOID* ppDataToRelease);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayDestroy(SAFEARRAY* psa);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayRedim(SAFEARRAY* psa, SAFEARRAYBOUND* psaboundNew);
extern "C" __declspec(dllimport) UINT __stdcall SafeArrayGetDim(SAFEARRAY* psa);
extern "C" __declspec(dllimport) UINT __stdcall SafeArrayGetElemsize(SAFEARRAY* psa);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayGetUBound(SAFEARRAY* psa, UINT nDim, LONG* plUbound);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayGetLBound(SAFEARRAY* psa, UINT nDim, LONG* plLbound);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayLock(SAFEARRAY* psa);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayUnlock(SAFEARRAY* psa);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayAccessData(SAFEARRAY* psa, void** ppvData);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayUnaccessData(SAFEARRAY* psa);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayGetElement(SAFEARRAY* psa, LONG* rgIndices, void* pv);

extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayPutElement(SAFEARRAY* psa, LONG* rgIndices, void* pv);

extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayCopy(SAFEARRAY* psa, SAFEARRAY** ppsaOut);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayPtrOfIndex(SAFEARRAY* psa, LONG* rgIndices, void** ppvData);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArraySetRecordInfo(SAFEARRAY* psa, IRecordInfo* prinfo);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayGetRecordInfo(SAFEARRAY* psa, IRecordInfo** prinfo);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArraySetIID(SAFEARRAY* psa, const GUID& guid);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayGetIID(SAFEARRAY* psa, GUID* pguid);
extern "C" __declspec(dllimport) HRESULT __stdcall SafeArrayGetVartype(SAFEARRAY* psa, VARTYPE* pvt);
extern "C" __declspec(dllimport) SAFEARRAY* __stdcall SafeArrayCreateVector(VARTYPE vt, LONG lLbound, ULONG cElements);
extern "C" __declspec(dllimport) SAFEARRAY* __stdcall SafeArrayCreateVectorEx(VARTYPE vt, LONG lLbound, ULONG cElements, PVOID pvExtra);

#pragma endregion

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) void __stdcall VariantInit(VARIANTARG* pvarg);
extern "C" __declspec(dllimport) HRESULT __stdcall VariantClear(VARIANTARG* pvarg);

extern "C" __declspec(dllimport) HRESULT __stdcall VariantCopy(VARIANTARG* pvargDest, const VARIANTARG* pvargSrc);

extern "C" __declspec(dllimport) HRESULT __stdcall VariantCopyInd(VARIANT* pvarDest, const VARIANTARG* pvargSrc);

extern "C" __declspec(dllimport) HRESULT
__stdcall VariantChangeType(VARIANTARG* pvargDest, const VARIANTARG* pvarSrc, USHORT wFlags, VARTYPE vt);

extern "C" __declspec(dllimport) HRESULT
__stdcall VariantChangeTypeEx(VARIANTARG* pvargDest, const VARIANTARG* pvarSrc, LCID lcid, USHORT wFlags, VARTYPE vt);

#pragma endregion

#pragma region Desktop Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall VectorFromBstr(BSTR bstr, SAFEARRAY** ppsa);

extern "C" __declspec(dllimport) HRESULT __stdcall BstrFromVector(SAFEARRAY* psa, BSTR* pbstr);

#pragma endregion

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromI2(SHORT sIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromI4(LONG lIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromI8(LONG64 i64In, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromR4(FLOAT fltIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromR8(DOUBLE dblIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromCy(CY cyIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromDate(DATE dateIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromDisp(IDispatch* pdispIn, LCID lcid, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromBool(VARIANT_BOOL boolIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromI1(CHAR cIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromUI2(USHORT uiIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromUI4(ULONG ulIn, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromUI8(ULONG64 ui64In, BYTE* pbOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI1FromDec(const DECIMAL* pdecIn, BYTE* pbOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromUI1(BYTE bIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromI4(LONG lIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromI8(LONG64 i64In, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromR4(FLOAT fltIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromR8(DOUBLE dblIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromCy(CY cyIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromDate(DATE dateIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromDisp(IDispatch* pdispIn, LCID lcid, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromBool(VARIANT_BOOL boolIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromI1(CHAR cIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromUI2(USHORT uiIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromUI4(ULONG ulIn, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromUI8(ULONG64 ui64In, SHORT* psOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI2FromDec(const DECIMAL* pdecIn, SHORT* psOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromUI1(BYTE bIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromI2(SHORT sIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromI8(LONG64 i64In, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromR4(FLOAT fltIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromR8(DOUBLE dblIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromCy(CY cyIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromDate(DATE dateIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromDisp(IDispatch* pdispIn, LCID lcid, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromBool(VARIANT_BOOL boolIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromI1(CHAR cIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromUI2(USHORT uiIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromUI4(ULONG ulIn, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromUI8(ULONG64 ui64In, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromDec(const DECIMAL* pdecIn, LONG* plOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromUI1(BYTE bIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromI2(SHORT sIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromR4(FLOAT fltIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromR8(DOUBLE dblIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromCy(CY cyIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromDate(DATE dateIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromDisp(IDispatch* pdispIn, LCID lcid, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromBool(VARIANT_BOOL boolIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromI1(CHAR cIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromUI2(USHORT uiIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromUI4(ULONG ulIn, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromUI8(ULONG64 ui64In, LONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI8FromDec(const DECIMAL* pdecIn, LONG64* pi64Out);

extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromUI1(BYTE bIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromI2(SHORT sIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromI4(LONG lIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromI8(LONG64 i64In, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromR8(DOUBLE dblIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromCy(CY cyIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromDate(DATE dateIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromDisp(IDispatch* pdispIn, LCID lcid, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromBool(VARIANT_BOOL boolIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromI1(CHAR cIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromUI2(USHORT uiIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromUI4(ULONG ulIn, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromUI8(ULONG64 ui64In, FLOAT* pfltOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR4FromDec(const DECIMAL* pdecIn, FLOAT* pfltOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromUI1(BYTE bIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromI2(SHORT sIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromI4(LONG lIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromI8(LONG64 i64In, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromR4(FLOAT fltIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromCy(CY cyIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromDate(DATE dateIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromDisp(IDispatch* pdispIn, LCID lcid, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromBool(VARIANT_BOOL boolIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromI1(CHAR cIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromUI2(USHORT uiIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromUI4(ULONG ulIn, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromUI8(ULONG64 ui64In, DOUBLE* pdblOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarR8FromDec(const DECIMAL* pdecIn, DOUBLE* pdblOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromUI1(BYTE bIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromI2(SHORT sIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromI4(LONG lIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromI8(LONG64 i64In, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromR4(FLOAT fltIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromR8(DOUBLE dblIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromCy(CY cyIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromDisp(IDispatch* pdispIn, LCID lcid, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromBool(VARIANT_BOOL boolIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromI1(CHAR cIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromUI2(USHORT uiIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromUI4(ULONG ulIn, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromUI8(ULONG64 ui64In, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromDec(const DECIMAL* pdecIn, DATE* pdateOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromUI1(BYTE bIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromI2(SHORT sIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromI4(LONG lIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromI8(LONG64 i64In, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromR4(FLOAT fltIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromR8(DOUBLE dblIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromDate(DATE dateIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromDisp(IDispatch* pdispIn, LCID lcid, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromBool(VARIANT_BOOL boolIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromI1(CHAR cIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromUI2(USHORT uiIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromUI4(ULONG ulIn, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromUI8(ULONG64 ui64In, CY* pcyOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarCyFromDec(const DECIMAL* pdecIn, CY* pcyOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromUI1(BYTE bVal, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromI2(SHORT iVal, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromI4(LONG lIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromI8(LONG64 i64In, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromR4(FLOAT fltIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromR8(DOUBLE dblIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromCy(CY cyIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromDate(DATE dateIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromDisp(IDispatch* pdispIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromBool(VARIANT_BOOL boolIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromI1(CHAR cIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromUI2(USHORT uiIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromUI4(ULONG ulIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromUI8(ULONG64 ui64In, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBstrFromDec(const DECIMAL* pdecIn, LCID lcid, ULONG dwFlags, BSTR* pbstrOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromUI1(BYTE bIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromI2(SHORT sIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromI4(LONG lIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromI8(LONG64 i64In, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromR4(FLOAT fltIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromR8(DOUBLE dblIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromDate(DATE dateIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromCy(CY cyIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT
__stdcall VarBoolFromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromDisp(IDispatch* pdispIn, LCID lcid, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromI1(CHAR cIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromUI2(USHORT uiIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromUI4(ULONG ulIn, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromUI8(ULONG64 i64In, VARIANT_BOOL* pboolOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarBoolFromDec(const DECIMAL* pdecIn, VARIANT_BOOL* pboolOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromUI1(BYTE bIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromI2(SHORT uiIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromI4(LONG lIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromI8(LONG64 i64In, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromR4(FLOAT fltIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromR8(DOUBLE dblIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromDate(DATE dateIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromCy(CY cyIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromDisp(IDispatch* pdispIn, LCID lcid, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromBool(VARIANT_BOOL boolIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromUI2(USHORT uiIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromUI4(ULONG ulIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromUI8(ULONG64 i64In, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarI1FromDec(const DECIMAL* pdecIn, CHAR* pcOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromUI1(BYTE bIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromI2(SHORT uiIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromI4(LONG lIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromI8(LONG64 i64In, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromR4(FLOAT fltIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromR8(DOUBLE dblIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromDate(DATE dateIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromCy(CY cyIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromDisp(IDispatch* pdispIn, LCID lcid, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromBool(VARIANT_BOOL boolIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromI1(CHAR cIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromUI4(ULONG ulIn, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromUI8(ULONG64 i64In, USHORT* puiOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI2FromDec(const DECIMAL* pdecIn, USHORT* puiOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromUI1(BYTE bIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromI2(SHORT uiIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromI4(LONG lIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromI8(LONG64 i64In, ULONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromR4(FLOAT fltIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromR8(DOUBLE dblIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromDate(DATE dateIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromCy(CY cyIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromDisp(IDispatch* pdispIn, LCID lcid, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromBool(VARIANT_BOOL boolIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromI1(CHAR cIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromUI2(USHORT uiIn, ULONG* pulOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromUI8(ULONG64 ui64In, ULONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI4FromDec(const DECIMAL* pdecIn, ULONG* pulOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromUI1(BYTE bIn, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromI2(SHORT sIn, ULONG64* pi64Out);

#pragma endregion

#pragma region Desktop Family

extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromI4(LONG lIn, ULONG64* pi64Out);

#pragma endregion

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromI8(LONG64 ui64In, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromR4(FLOAT fltIn, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromR8(DOUBLE dblIn, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromCy(CY cyIn, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromDate(DATE dateIn, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromDisp(IDispatch* pdispIn, LCID lcid, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromBool(VARIANT_BOOL boolIn, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromI1(CHAR cIn, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromUI2(USHORT uiIn, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromUI4(ULONG ulIn, ULONG64* pi64Out);
extern "C" __declspec(dllimport) HRESULT __stdcall VarUI8FromDec(const DECIMAL* pdecIn, ULONG64* pi64Out);

extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromUI1(BYTE bIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromI2(SHORT uiIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromI4(LONG lIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromI8(LONG64 i64In, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromR4(FLOAT fltIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromR8(DOUBLE dblIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromDate(DATE dateIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromCy(CY cyIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromDisp(IDispatch* pdispIn, LCID lcid, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromBool(VARIANT_BOOL boolIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromI1(CHAR cIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromUI2(USHORT uiIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromUI4(ULONG ulIn, DECIMAL* pdecOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDecFromUI8(ULONG64 ui64In, DECIMAL* pdecOut);

#pragma endregion

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromI8(LONG64 i64In, LONG* plOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarI4FromUI8(ULONG64 ui64In, LONG* plOut);

#pragma endregion

#pragma region Desktop Family

#pragma endregion

typedef struct
{
    INT cDig;
    ULONG dwInFlags;
    ULONG dwOutFlags;
    INT cchUsed;
    INT nBaseShift;
    INT nPwr10;
} NUMPARSE;

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall VarParseNumFromStr(LPCOLESTR strIn, LCID lcid, ULONG dwFlags, NUMPARSE* pnumprs, BYTE* rgbDig);

extern "C" __declspec(dllimport) HRESULT
__stdcall VarNumFromParseNum(NUMPARSE* pnumprs, BYTE* rgbDig, ULONG dwVtBits, VARIANT* pvar);

#pragma endregion

#pragma region Application Family or OneCore Family

extern "C" HRESULT __stdcall VarAdd(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarAnd(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarCat(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarDiv(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarEqv(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarIdiv(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarImp(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarMod(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarMul(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarOr(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarPow(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarSub(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarXor(LPVARIANT pvarLeft, LPVARIANT pvarRight, LPVARIANT pvarResult);

extern "C" HRESULT __stdcall VarAbs(LPVARIANT pvarIn, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarFix(LPVARIANT pvarIn, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarInt(LPVARIANT pvarIn, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarNeg(LPVARIANT pvarIn, LPVARIANT pvarResult);
extern "C" HRESULT __stdcall VarNot(LPVARIANT pvarIn, LPVARIANT pvarResult);

extern "C" HRESULT __stdcall VarRound(LPVARIANT pvarIn, int cDecimals, LPVARIANT pvarResult);

extern "C" HRESULT __stdcall VarCmp(LPVARIANT pvarLeft, LPVARIANT pvarRight, LCID lcid, ULONG dwFlags);

#pragma endregion

extern "C++"
{
#pragma region Application Family or OneCore Family

    __inline HRESULT

    __stdcall VarCmp(LPVARIANT pvarLeft, LPVARIANT pvarRight, LCID lcid)
    {
        return VarCmp(pvarLeft, pvarRight, lcid, 0);
    }

#pragma endregion
}

#pragma region Application Family or OneCore Family

extern "C" HRESULT __stdcall VarDecAdd(LPDECIMAL pdecLeft, LPDECIMAL pdecRight, LPDECIMAL pdecResult);
extern "C" HRESULT __stdcall VarDecDiv(LPDECIMAL pdecLeft, LPDECIMAL pdecRight, LPDECIMAL pdecResult);
extern "C" HRESULT __stdcall VarDecMul(LPDECIMAL pdecLeft, LPDECIMAL pdecRight, LPDECIMAL pdecResult);
extern "C" HRESULT __stdcall VarDecSub(LPDECIMAL pdecLeft, LPDECIMAL pdecRight, LPDECIMAL pdecResult);

extern "C" HRESULT __stdcall VarDecAbs(LPDECIMAL pdecIn, LPDECIMAL pdecResult);
extern "C" HRESULT __stdcall VarDecFix(LPDECIMAL pdecIn, LPDECIMAL pdecResult);
extern "C" HRESULT __stdcall VarDecInt(LPDECIMAL pdecIn, LPDECIMAL pdecResult);
extern "C" HRESULT __stdcall VarDecNeg(LPDECIMAL pdecIn, LPDECIMAL pdecResult);

extern "C" HRESULT __stdcall VarDecRound(LPDECIMAL pdecIn, int cDecimals, LPDECIMAL pdecResult);

extern "C" HRESULT __stdcall VarDecCmp(LPDECIMAL pdecLeft, LPDECIMAL pdecRight);
extern "C" HRESULT __stdcall VarDecCmpR8(LPDECIMAL pdecLeft, double dblRight);

extern "C" HRESULT __stdcall VarCyAdd(CY cyLeft, CY cyRight, LPCY pcyResult);
extern "C" HRESULT __stdcall VarCyMul(CY cyLeft, CY cyRight, LPCY pcyResult);
extern "C" HRESULT __stdcall VarCyMulI4(CY cyLeft, LONG lRight, LPCY pcyResult);
extern "C" HRESULT __stdcall VarCyMulI8(CY cyLeft, LONG64 lRight, LPCY pcyResult);
extern "C" HRESULT __stdcall VarCySub(CY cyLeft, CY cyRight, LPCY pcyResult);

extern "C" HRESULT __stdcall VarCyAbs(CY cyIn, LPCY pcyResult);
extern "C" HRESULT __stdcall VarCyFix(CY cyIn, LPCY pcyResult);
extern "C" HRESULT __stdcall VarCyInt(CY cyIn, LPCY pcyResult);
extern "C" HRESULT __stdcall VarCyNeg(CY cyIn, LPCY pcyResult);

extern "C" HRESULT __stdcall VarCyRound(CY cyIn, int cDecimals, LPCY pcyResult);

extern "C" HRESULT __stdcall VarCyCmp(CY cyLeft, CY cyRight);
extern "C" HRESULT __stdcall VarCyCmpR8(CY cyLeft, double dblRight);

extern "C" HRESULT __stdcall VarBstrCat(BSTR bstrLeft, BSTR bstrRight, LPBSTR pbstrResult);
extern "C" HRESULT __stdcall VarBstrCmp(BSTR bstrLeft, BSTR bstrRight, LCID lcid, ULONG dwFlags);
extern "C" HRESULT __stdcall VarR8Pow(double dblLeft, double dblRight, double* pdblResult);
extern "C" HRESULT __stdcall VarR4CmpR8(float fltLeft, double dblRight);
extern "C" HRESULT __stdcall VarR8Round(double dblIn, int cDecimals, double* pdblResult);

#pragma endregion

typedef struct
{
    SYSTEMTIME st;
    USHORT wDayOfYear;
} UDATE;

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromUdate(UDATE* pudateIn, ULONG dwFlags, DATE* pdateOut);
extern "C" __declspec(dllimport) HRESULT __stdcall VarDateFromUdateEx(UDATE* pudateIn, LCID lcid, ULONG dwFlags, DATE* pdateOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarUdateFromDate(DATE dateIn, ULONG dwFlags, UDATE* pudateOut);

#pragma endregion

#pragma region Desktop Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall GetAltMonthNames(LCID lcid, LPOLESTR** prgp);

#pragma endregion

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT
__stdcall VarFormat(LPVARIANT pvarIn, LPOLESTR pstrFormat, int iFirstDay, int iFirstWeek, ULONG dwFlags, BSTR* pbstrOut);

extern "C" __declspec(dllimport) HRESULT
__stdcall VarFormatDateTime(LPVARIANT pvarIn, int iNamedFormat, ULONG dwFlags, BSTR* pbstrOut);

extern "C" __declspec(dllimport) HRESULT
__stdcall VarFormatNumber(LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR* pbstrOut);

extern "C" __declspec(dllimport) HRESULT
__stdcall VarFormatPercent(LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR* pbstrOut);

extern "C" __declspec(dllimport) HRESULT
__stdcall VarFormatCurrency(LPVARIANT pvarIn, int iNumDig, int iIncLead, int iUseParens, int iGroup, ULONG dwFlags, BSTR* pbstrOut);

extern "C" __declspec(dllimport) HRESULT
__stdcall VarWeekdayName(int iWeekday, int fAbbrev, int iFirstDay, ULONG dwFlags, BSTR* pbstrOut);

extern "C" __declspec(dllimport) HRESULT __stdcall VarMonthName(int iMonth, int fAbbrev, ULONG dwFlags, BSTR* pbstrOut);

extern "C" __declspec(dllimport) HRESULT
__stdcall VarFormatFromTokens(LPVARIANT pvarIn, LPOLESTR pstrFormat, LPBYTE pbTokCur, ULONG dwFlags, BSTR* pbstrOut, LCID lcid);

extern "C" __declspec(dllimport) HRESULT
__stdcall VarTokenizeFormatString(LPOLESTR pstrFormat, LPBYTE rgbTok, int cbTok, int iFirstDay, int iFirstWeek, LCID lcid, int* pcbActual);

#pragma endregion

#pragma region Desktop Family or OneCore Family

typedef ITypeLib* LPTYPELIB;

typedef LONG DISPID;
typedef DISPID MEMBERID;

#pragma endregion

#pragma region Application Family or OneCore Family

#pragma endregion

#pragma region Desktop Family or OneCore Family

typedef ITypeInfo* LPTYPEINFO;

typedef ITypeComp* LPTYPECOMP;

typedef ICreateTypeLib* LPCREATETYPELIB;

typedef ICreateTypeInfo* LPCREATETYPEINFO;

extern "C" __declspec(dllimport) ULONG __stdcall LHashValOfNameSysA(SYSKIND syskind, LCID lcid, LPCSTR szName);

extern "C" __declspec(dllimport) ULONG __stdcall LHashValOfNameSys(SYSKIND syskind, LCID lcid, const OLECHAR* szName);

extern "C" __declspec(dllimport) HRESULT __stdcall LoadTypeLib(LPCOLESTR szFile, ITypeLib** pptlib);

typedef enum tagREGKIND
{
    REGKIND_DEFAULT,
    REGKIND_REGISTER,
    REGKIND_NONE
} REGKIND;

extern "C" __declspec(dllimport) HRESULT __stdcall LoadTypeLibEx(LPCOLESTR szFile, REGKIND regkind, ITypeLib** pptlib);

extern "C" __declspec(dllimport) HRESULT
__stdcall LoadRegTypeLib(const GUID& rguid, WORD wVerMajor, WORD wVerMinor, LCID lcid, ITypeLib** pptlib);

extern "C" __declspec(dllimport) HRESULT
__stdcall QueryPathOfRegTypeLib(const GUID& guid, USHORT wMaj, USHORT wMin, LCID lcid, LPBSTR lpbstrPathName);

extern "C" __declspec(dllimport) HRESULT __stdcall RegisterTypeLib(ITypeLib* ptlib, LPCOLESTR szFullPath, LPCOLESTR szHelpDir);

extern "C" __declspec(dllimport) HRESULT
__stdcall UnRegisterTypeLib(const GUID& libID, WORD wVerMajor, WORD wVerMinor, LCID lcid, SYSKIND syskind);

extern "C" __declspec(dllimport) HRESULT __stdcall RegisterTypeLibForUser(ITypeLib* ptlib, OLECHAR* szFullPath, OLECHAR* szHelpDir);

extern "C" __declspec(dllimport) HRESULT
__stdcall UnRegisterTypeLibForUser(const GUID& libID, WORD wMajorVerNum, WORD wMinorVerNum, LCID lcid, SYSKIND syskind);

extern "C" __declspec(dllimport) HRESULT __stdcall CreateTypeLib(SYSKIND syskind, LPCOLESTR szFile, ICreateTypeLib** ppctlib);

extern "C" __declspec(dllimport) HRESULT __stdcall CreateTypeLib2(SYSKIND syskind, LPCOLESTR szFile, ICreateTypeLib2** ppctlib);

typedef IDispatch* LPDISPATCH;

typedef struct tagPARAMDATA
{
    OLECHAR* szName;
    VARTYPE vt;
} PARAMDATA, *LPPARAMDATA;

typedef struct tagMETHODDATA
{
    OLECHAR* szName;
    PARAMDATA* ppdata;
    DISPID dispid;
    UINT iMeth;
    CALLCONV cc;
    UINT cArgs;
    WORD wFlags;
    VARTYPE vtReturn;
} METHODDATA, *LPMETHODDATA;

typedef struct tagINTERFACEDATA
{
    METHODDATA* pmethdata;
    UINT cMembers;
} INTERFACEDATA, *LPINTERFACEDATA;

extern "C" __declspec(dllimport) HRESULT
__stdcall DispGetParam(DISPPARAMS* pdispparams, UINT position, VARTYPE vtTarg, VARIANT* pvarResult, UINT* puArgErr);

extern "C" __declspec(dllimport) HRESULT
__stdcall DispGetIDsOfNames(ITypeInfo* ptinfo, LPOLESTR* rgszNames, UINT cNames, DISPID* rgdispid);

#pragma endregion

#pragma region Application Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall DispInvoke(
void* _this, ITypeInfo* ptinfo, DISPID dispidMember, WORD wFlags, DISPPARAMS* pparams, VARIANT* pvarResult, EXCEPINFO* pexcepinfo, UINT* puArgErr);

#pragma endregion

#pragma region Desktop Family or OneCore Family

extern "C" __declspec(dllimport) HRESULT __stdcall CreateDispTypeInfo(INTERFACEDATA* pidata, LCID lcid, ITypeInfo** pptinfo);

extern "C" __declspec(dllimport) HRESULT
__stdcall CreateStdDispatch(IUnknown* punkOuter, void* pvThis, ITypeInfo* ptinfo, IUnknown** ppunkStdDisp);

extern "C" __declspec(dllimport) HRESULT __stdcall DispCallFunc(
void* pvInstance, ULONG_PTR oVft, CALLCONV cc, VARTYPE vtReturn, UINT cActuals, VARTYPE* prgvt, VARIANTARG** prgpvarg, VARIANT* pvargResult);

extern "C" __declspec(dllimport) HRESULT
__stdcall RegisterActiveObject(IUnknown* punk, const IID& rclsid, DWORD dwFlags, DWORD* pdwRegister);

extern "C" __declspec(dllimport) HRESULT __stdcall RevokeActiveObject(DWORD dwRegister, void* pvReserved);

extern "C" __declspec(dllimport) HRESULT __stdcall GetActiveObject(const IID& rclsid, void* pvReserved, IUnknown** ppunk);

extern "C" __declspec(dllimport) HRESULT __stdcall SetErrorInfo(ULONG dwReserved, IErrorInfo* perrinfo);

extern "C" __declspec(dllimport) HRESULT __stdcall GetErrorInfo(ULONG dwReserved, IErrorInfo** pperrinfo);

extern "C" __declspec(dllimport) HRESULT __stdcall CreateErrorInfo(ICreateErrorInfo** pperrinfo);

extern "C" __declspec(dllimport) HRESULT __stdcall GetRecordInfoFromTypeInfo(ITypeInfo* pTypeInfo, IRecordInfo** ppRecInfo);

extern "C" __declspec(dllimport) HRESULT __stdcall GetRecordInfoFromGuids(
const GUID& rGuidTypeLib, ULONG uVerMajor, ULONG uVerMinor, LCID lcid, const GUID& rGuidTypeInfo, IRecordInfo** ppRecInfo);

extern "C" __declspec(dllimport) ULONG __stdcall OaBuildVersion(void);

extern "C" __declspec(dllimport) void __stdcall ClearCustData(LPCUSTDATA pCustData);

extern "C" __declspec(dllimport) void __stdcall OaEnablePerUserTLibRegistration(void);

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(pop)

#pragma region Desktop Family

extern "C" __declspec(dllimport) HRESULT __stdcall CreateDataAdviseHolder(LPDATAADVISEHOLDER* ppDAHolder);

extern "C" __declspec(dllimport) DWORD __stdcall OleBuildVersion(void);

extern "C" __declspec(dllimport) HRESULT __stdcall WriteFmtUserTypeStg(LPSTORAGE pstg, CLIPFORMAT cf, LPOLESTR lpszUserType);
extern "C" __declspec(dllimport) HRESULT __stdcall ReadFmtUserTypeStg(LPSTORAGE pstg, CLIPFORMAT* pcf, LPOLESTR* lplpszUserType);

extern "C" __declspec(dllimport) HRESULT __stdcall OleInitialize(LPVOID pvReserved);
extern "C" __declspec(dllimport) void __stdcall OleUninitialize(void);

extern "C" __declspec(dllimport) HRESULT __stdcall OleQueryLinkFromData(LPDATAOBJECT pSrcDataObject);
extern "C" __declspec(dllimport) HRESULT __stdcall OleQueryCreateFromData(LPDATAOBJECT pSrcDataObject);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreate(
const IID& rclsid, const IID& riid, DWORD renderopt, LPFORMATETC pFormatEtc, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateEx(const IID& rclsid,
                                                               const IID& riid,
                                                               DWORD dwFlags,
                                                               DWORD renderopt,
                                                               ULONG cFormats,
                                                               DWORD* rgAdvf,
                                                               LPFORMATETC rgFormatEtc,
                                                               IAdviseSink* lpAdviseSink,
                                                               DWORD* rgdwConnection,
                                                               LPOLECLIENTSITE pClientSite,
                                                               LPSTORAGE pStg,
                                                               LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateFromData(LPDATAOBJECT pSrcDataObj,
                                                                     const IID& riid,
                                                                     DWORD renderopt,
                                                                     LPFORMATETC pFormatEtc,
                                                                     LPOLECLIENTSITE pClientSite,
                                                                     LPSTORAGE pStg,
                                                                     LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateFromDataEx(LPDATAOBJECT pSrcDataObj,
                                                                       const IID& riid,
                                                                       DWORD dwFlags,
                                                                       DWORD renderopt,
                                                                       ULONG cFormats,
                                                                       DWORD* rgAdvf,
                                                                       LPFORMATETC rgFormatEtc,
                                                                       IAdviseSink* lpAdviseSink,
                                                                       DWORD* rgdwConnection,
                                                                       LPOLECLIENTSITE pClientSite,
                                                                       LPSTORAGE pStg,
                                                                       LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateLinkFromData(LPDATAOBJECT pSrcDataObj,
                                                                         const IID& riid,
                                                                         DWORD renderopt,
                                                                         LPFORMATETC pFormatEtc,
                                                                         LPOLECLIENTSITE pClientSite,
                                                                         LPSTORAGE pStg,
                                                                         LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateLinkFromDataEx(LPDATAOBJECT pSrcDataObj,
                                                                           const IID& riid,
                                                                           DWORD dwFlags,
                                                                           DWORD renderopt,
                                                                           ULONG cFormats,
                                                                           DWORD* rgAdvf,
                                                                           LPFORMATETC rgFormatEtc,
                                                                           IAdviseSink* lpAdviseSink,
                                                                           DWORD* rgdwConnection,
                                                                           LPOLECLIENTSITE pClientSite,
                                                                           LPSTORAGE pStg,
                                                                           LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateStaticFromData(LPDATAOBJECT pSrcDataObj,
                                                                           const IID& iid,
                                                                           DWORD renderopt,
                                                                           LPFORMATETC pFormatEtc,
                                                                           LPOLECLIENTSITE pClientSite,
                                                                           LPSTORAGE pStg,
                                                                           LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateLink(
LPMONIKER pmkLinkSrc, const IID& riid, DWORD renderopt, LPFORMATETC lpFormatEtc, LPOLECLIENTSITE pClientSite, LPSTORAGE pStg, LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateLinkEx(LPMONIKER pmkLinkSrc,
                                                                   const IID& riid,
                                                                   DWORD dwFlags,
                                                                   DWORD renderopt,
                                                                   ULONG cFormats,
                                                                   DWORD* rgAdvf,
                                                                   LPFORMATETC rgFormatEtc,
                                                                   IAdviseSink* lpAdviseSink,
                                                                   DWORD* rgdwConnection,
                                                                   LPOLECLIENTSITE pClientSite,
                                                                   LPSTORAGE pStg,
                                                                   LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateLinkToFile(LPCOLESTR lpszFileName,
                                                                       const IID& riid,
                                                                       DWORD renderopt,
                                                                       LPFORMATETC lpFormatEtc,
                                                                       LPOLECLIENTSITE pClientSite,
                                                                       LPSTORAGE pStg,
                                                                       LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateLinkToFileEx(LPCOLESTR lpszFileName,
                                                                         const IID& riid,
                                                                         DWORD dwFlags,
                                                                         DWORD renderopt,
                                                                         ULONG cFormats,
                                                                         DWORD* rgAdvf,
                                                                         LPFORMATETC rgFormatEtc,
                                                                         IAdviseSink* lpAdviseSink,
                                                                         DWORD* rgdwConnection,
                                                                         LPOLECLIENTSITE pClientSite,
                                                                         LPSTORAGE pStg,
                                                                         LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateFromFile(const IID& rclsid,
                                                                     LPCOLESTR lpszFileName,
                                                                     const IID& riid,
                                                                     DWORD renderopt,
                                                                     LPFORMATETC lpFormatEtc,
                                                                     LPOLECLIENTSITE pClientSite,
                                                                     LPSTORAGE pStg,
                                                                     LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleCreateFromFileEx(const IID& rclsid,
                                                                       LPCOLESTR lpszFileName,
                                                                       const IID& riid,
                                                                       DWORD dwFlags,
                                                                       DWORD renderopt,
                                                                       ULONG cFormats,
                                                                       DWORD* rgAdvf,
                                                                       LPFORMATETC rgFormatEtc,
                                                                       IAdviseSink* lpAdviseSink,
                                                                       DWORD* rgdwConnection,
                                                                       LPOLECLIENTSITE pClientSite,
                                                                       LPSTORAGE pStg,
                                                                       LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT
__stdcall OleLoad(LPSTORAGE pStg, const IID& riid, LPOLECLIENTSITE pClientSite, LPVOID* ppvObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleSave(LPPERSISTSTORAGE pPS, LPSTORAGE pStg, BOOL fSameAsLoad);

extern "C" __declspec(dllimport) HRESULT __stdcall OleLoadFromStream(LPSTREAM pStm, const IID& iidInterface, LPVOID* ppvObj);
extern "C" __declspec(dllimport) HRESULT __stdcall OleSaveToStream(LPPERSISTSTREAM pPStm, LPSTREAM pStm);

extern "C" __declspec(dllimport) HRESULT __stdcall OleSetContainedObject(LPUNKNOWN pUnknown, BOOL fContained);
extern "C" __declspec(dllimport) HRESULT __stdcall OleNoteObjectVisible(LPUNKNOWN pUnknown, BOOL fVisible);

extern "C" __declspec(dllimport) HRESULT __stdcall RegisterDragDrop(HWND hwnd, LPDROPTARGET pDropTarget);
extern "C" __declspec(dllimport) HRESULT __stdcall RevokeDragDrop(HWND hwnd);
extern "C" __declspec(dllimport) HRESULT
__stdcall DoDragDrop(LPDATAOBJECT pDataObj, LPDROPSOURCE pDropSource, DWORD dwOKEffects, LPDWORD pdwEffect);

extern "C" __declspec(dllimport) HRESULT __stdcall OleSetClipboard(LPDATAOBJECT pDataObj);
extern "C" __declspec(dllimport) HRESULT __stdcall OleGetClipboard(LPDATAOBJECT* ppDataObj);

extern "C" __declspec(dllimport) HRESULT __stdcall OleGetClipboardWithEnterpriseInfo(
IDataObject** dataObject, PWSTR* dataEnterpriseId, PWSTR* sourceDescription, PWSTR* targetDescription, PWSTR* dataDescription);
extern "C" __declspec(dllimport) HRESULT __stdcall OleFlushClipboard(void);
extern "C" __declspec(dllimport) HRESULT __stdcall OleIsCurrentClipboard(LPDATAOBJECT pDataObj);

extern "C" __declspec(dllimport) HOLEMENU __stdcall OleCreateMenuDescriptor(HMENU hmenuCombined, LPOLEMENUGROUPWIDTHS lpMenuWidths);
extern "C" __declspec(dllimport) HRESULT
__stdcall OleSetMenuDescriptor(HOLEMENU holemenu, HWND hwndFrame, HWND hwndActiveObject, LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEACTIVEOBJECT lpActiveObj);
extern "C" __declspec(dllimport) HRESULT __stdcall OleDestroyMenuDescriptor(HOLEMENU holemenu);

extern "C" __declspec(dllimport) HRESULT
__stdcall OleTranslateAccelerator(LPOLEINPLACEFRAME lpFrame, LPOLEINPLACEFRAMEINFO lpFrameInfo, LPMSG lpmsg);

extern "C" __declspec(dllimport) HANDLE __stdcall OleDuplicateData(HANDLE hSrc, CLIPFORMAT cfFormat, UINT uiFlags);

extern "C" __declspec(dllimport) HRESULT __stdcall OleDraw(LPUNKNOWN pUnknown, DWORD dwAspect, HDC hdcDraw, LPCRECT lprcBounds);

extern "C" __declspec(dllimport) HRESULT __stdcall OleRun(LPUNKNOWN pUnknown);
extern "C" __declspec(dllimport) BOOL __stdcall OleIsRunning(LPOLEOBJECT pObject);
extern "C" __declspec(dllimport) HRESULT __stdcall OleLockRunning(LPUNKNOWN pUnknown, BOOL fLock, BOOL fLastUnlockCloses);

extern "C" __declspec(dllimport) void __stdcall ReleaseStgMedium(LPSTGMEDIUM);

extern "C" __declspec(dllimport) HRESULT __stdcall CreateOleAdviseHolder(LPOLEADVISEHOLDER* ppOAHolder);

extern "C" __declspec(dllimport) HRESULT
__stdcall OleCreateDefaultHandler(const IID& clsid, LPUNKNOWN pUnkOuter, const IID& riid, LPVOID* lplpObj);

extern "C" __declspec(dllimport) HRESULT
__stdcall OleCreateEmbeddingHelper(const IID& clsid, LPUNKNOWN pUnkOuter, DWORD flags, LPCLASSFACTORY pCF, const IID& riid, LPVOID* lplpObj);

extern "C" __declspec(dllimport) BOOL __stdcall IsAccelerator(HACCEL hAccel, int cAccelEntries, LPMSG lpMsg, WORD* lpwCmd);

extern "C" __declspec(dllimport) HGLOBAL __stdcall OleGetIconOfFile(LPOLESTR lpszPath, BOOL fUseFileAsLabel);

extern "C" __declspec(dllimport) HGLOBAL __stdcall OleGetIconOfClass(const IID& rclsid, LPOLESTR lpszLabel, BOOL fUseTypeAsLabel);

extern "C" __declspec(dllimport) HGLOBAL
__stdcall OleMetafilePictFromIconAndLabel(HICON hIcon, LPOLESTR lpszLabel, LPOLESTR lpszSourceFile, UINT iIconIndex);

extern "C" __declspec(dllimport) HRESULT __stdcall OleRegGetUserType(const IID& clsid, DWORD dwFormOfType, LPOLESTR* pszUserType);

extern "C" __declspec(dllimport) HRESULT __stdcall OleRegGetMiscStatus(const IID& clsid, DWORD dwAspect, DWORD* pdwStatus);

extern "C" __declspec(dllimport) HRESULT
__stdcall OleRegEnumFormatEtc(const IID& clsid, DWORD dwDirection, LPENUMFORMATETC* ppenum);

extern "C" __declspec(dllimport) HRESULT __stdcall OleRegEnumVerbs(const IID& clsid, LPENUMOLEVERB* ppenum);

typedef struct _OLESTREAM* LPOLESTREAM;

typedef struct _OLESTREAMVTBL
{
    DWORD(__stdcall* Get)(LPOLESTREAM, void*, DWORD);
    DWORD(__stdcall* Put)(LPOLESTREAM, const void*, DWORD);
} OLESTREAMVTBL;
typedef OLESTREAMVTBL* LPOLESTREAMVTBL;

typedef struct _OLESTREAM
{
    LPOLESTREAMVTBL lpstbl;
} OLESTREAM;

extern "C" __declspec(dllimport) HRESULT
__stdcall OleConvertOLESTREAMToIStorage(LPOLESTREAM lpolestream, LPSTORAGE pstg, const DVTARGETDEVICE* ptd);

extern "C" __declspec(dllimport) HRESULT __stdcall OleConvertIStorageToOLESTREAM(LPSTORAGE pstg, LPOLESTREAM lpolestream);

extern "C" __declspec(dllimport) HRESULT __stdcall OleDoAutoConvert(LPSTORAGE pStg, LPCLSID pClsidNew);
extern "C" __declspec(dllimport) HRESULT __stdcall OleGetAutoConvert(const IID& clsidOld, LPCLSID pClsidNew);
extern "C" __declspec(dllimport) HRESULT __stdcall OleSetAutoConvert(const IID& clsidOld, const IID& clsidNew);

extern "C" __declspec(dllimport) HRESULT __stdcall SetConvertStg(LPSTORAGE pStg, BOOL fConvert);

extern "C" __declspec(dllimport) HRESULT __stdcall OleConvertIStorageToOLESTREAMEx(LPSTORAGE pstg,

                                                                                   CLIPFORMAT cfFormat,
                                                                                   LONG lWidth,
                                                                                   LONG lHeight,
                                                                                   DWORD dwSize,
                                                                                   LPSTGMEDIUM pmedium,
                                                                                   LPOLESTREAM polestm);

extern "C" __declspec(dllimport) HRESULT __stdcall OleConvertOLESTREAMToIStorageEx(LPOLESTREAM polestm,
                                                                                   LPSTORAGE pstg,

                                                                                   CLIPFORMAT* pcfFormat,
                                                                                   LONG* plwWidth,
                                                                                   LONG* plHeight,
                                                                                   DWORD* pdwSize,
                                                                                   LPSTGMEDIUM pmedium);

#pragma endregion

#pragma warning(disable : 4103)

#pragma pack(pop)

#pragma warning(pop)

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4820)

extern "C" const GUID IID_IPrintDialogCallback;

extern "C" const GUID IID_IPrintDialogServices;

#pragma warning(push)
#pragma warning(disable : 4001)
#pragma warning(disable : 4201)
#pragma warning(disable : 4820)

#pragma warning(pop)

extern "C"
{
#pragma region Desktop Family

    typedef UINT_PTR(__stdcall* LPOFNHOOKPROC)(HWND, UINT, WPARAM, LPARAM);

    typedef struct tagOFN_NT4A
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HINSTANCE hInstance;
        LPCSTR lpstrFilter;
        LPSTR lpstrCustomFilter;
        DWORD nMaxCustFilter;
        DWORD nFilterIndex;
        LPSTR lpstrFile;
        DWORD nMaxFile;
        LPSTR lpstrFileTitle;
        DWORD nMaxFileTitle;
        LPCSTR lpstrInitialDir;
        LPCSTR lpstrTitle;
        DWORD Flags;
        WORD nFileOffset;
        WORD nFileExtension;
        LPCSTR lpstrDefExt;
        LPARAM lCustData;
        LPOFNHOOKPROC lpfnHook;
        LPCSTR lpTemplateName;
    } OPENFILENAME_NT4A, *LPOPENFILENAME_NT4A;
    typedef struct tagOFN_NT4W
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HINSTANCE hInstance;
        LPCWSTR lpstrFilter;
        LPWSTR lpstrCustomFilter;
        DWORD nMaxCustFilter;
        DWORD nFilterIndex;
        LPWSTR lpstrFile;
        DWORD nMaxFile;
        LPWSTR lpstrFileTitle;
        DWORD nMaxFileTitle;
        LPCWSTR lpstrInitialDir;
        LPCWSTR lpstrTitle;
        DWORD Flags;
        WORD nFileOffset;
        WORD nFileExtension;
        LPCWSTR lpstrDefExt;
        LPARAM lCustData;
        LPOFNHOOKPROC lpfnHook;
        LPCWSTR lpTemplateName;
    } OPENFILENAME_NT4W, *LPOPENFILENAME_NT4W;

    typedef OPENFILENAME_NT4A OPENFILENAME_NT4;
    typedef LPOPENFILENAME_NT4A LPOPENFILENAME_NT4;

    typedef struct tagOFNA
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HINSTANCE hInstance;
        LPCSTR lpstrFilter;
        LPSTR lpstrCustomFilter;
        DWORD nMaxCustFilter;
        DWORD nFilterIndex;
        LPSTR lpstrFile;
        DWORD nMaxFile;
        LPSTR lpstrFileTitle;
        DWORD nMaxFileTitle;
        LPCSTR lpstrInitialDir;
        LPCSTR lpstrTitle;
        DWORD Flags;
        WORD nFileOffset;
        WORD nFileExtension;
        LPCSTR lpstrDefExt;
        LPARAM lCustData;
        LPOFNHOOKPROC lpfnHook;
        LPCSTR lpTemplateName;

        void* pvReserved;
        DWORD dwReserved;
        DWORD FlagsEx;
    } OPENFILENAMEA, *LPOPENFILENAMEA;
    typedef struct tagOFNW
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HINSTANCE hInstance;
        LPCWSTR lpstrFilter;
        LPWSTR lpstrCustomFilter;
        DWORD nMaxCustFilter;
        DWORD nFilterIndex;
        LPWSTR lpstrFile;
        DWORD nMaxFile;
        LPWSTR lpstrFileTitle;
        DWORD nMaxFileTitle;
        LPCWSTR lpstrInitialDir;
        LPCWSTR lpstrTitle;
        DWORD Flags;
        WORD nFileOffset;
        WORD nFileExtension;
        LPCWSTR lpstrDefExt;
        LPARAM lCustData;
        LPOFNHOOKPROC lpfnHook;
        LPCWSTR lpTemplateName;

        void* pvReserved;
        DWORD dwReserved;
        DWORD FlagsEx;
    } OPENFILENAMEW, *LPOPENFILENAMEW;

    typedef OPENFILENAMEA OPENFILENAME;
    typedef LPOPENFILENAMEA LPOPENFILENAME;

    __declspec(dllimport) BOOL __stdcall GetOpenFileNameA(LPOPENFILENAMEA);
    __declspec(dllimport) BOOL __stdcall GetOpenFileNameW(LPOPENFILENAMEW);

    __declspec(dllimport) BOOL __stdcall GetSaveFileNameA(LPOPENFILENAMEA);
    __declspec(dllimport) BOOL __stdcall GetSaveFileNameW(LPOPENFILENAMEW);

    __declspec(dllimport) short __stdcall GetFileTitleA(LPCSTR, LPSTR Buf, WORD cchSize);
    __declspec(dllimport) short __stdcall GetFileTitleW(LPCWSTR, LPWSTR Buf, WORD cchSize);

    typedef UINT_PTR(__stdcall* LPCCHOOKPROC)(HWND, UINT, WPARAM, LPARAM);

    typedef struct _OFNOTIFYA
    {
        NMHDR hdr;
        LPOPENFILENAMEA lpOFN;
        LPSTR pszFile;
    } OFNOTIFYA, *LPOFNOTIFYA;

    typedef struct _OFNOTIFYW
    {
        NMHDR hdr;
        LPOPENFILENAMEW lpOFN;
        LPWSTR pszFile;
    } OFNOTIFYW, *LPOFNOTIFYW;

    typedef OFNOTIFYA OFNOTIFY;
    typedef LPOFNOTIFYA LPOFNOTIFY;

    typedef struct _OFNOTIFYEXA
    {
        NMHDR hdr;
        LPOPENFILENAMEA lpOFN;
        LPVOID psf;
        LPVOID pidl;
    } OFNOTIFYEXA, *LPOFNOTIFYEXA;

    typedef struct _OFNOTIFYEXW
    {
        NMHDR hdr;
        LPOPENFILENAMEW lpOFN;
        LPVOID psf;
        LPVOID pidl;
    } OFNOTIFYEXW, *LPOFNOTIFYEXW;

    typedef OFNOTIFYEXA OFNOTIFYEX;
    typedef LPOFNOTIFYEXA LPOFNOTIFYEX;

    typedef struct tagCHOOSECOLORA
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HWND hInstance;
        COLORREF rgbResult;
        COLORREF* lpCustColors;
        DWORD Flags;
        LPARAM lCustData;
        LPCCHOOKPROC lpfnHook;
        LPCSTR lpTemplateName;
    } CHOOSECOLORA, *LPCHOOSECOLORA;
    typedef struct tagCHOOSECOLORW
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HWND hInstance;
        COLORREF rgbResult;
        COLORREF* lpCustColors;
        DWORD Flags;
        LPARAM lCustData;
        LPCCHOOKPROC lpfnHook;
        LPCWSTR lpTemplateName;
    } CHOOSECOLORW, *LPCHOOSECOLORW;

    typedef CHOOSECOLORA CHOOSECOLOR;
    typedef LPCHOOSECOLORA LPCHOOSECOLOR;

    __declspec(dllimport) BOOL __stdcall ChooseColorA(LPCHOOSECOLORA);
    __declspec(dllimport) BOOL __stdcall ChooseColorW(LPCHOOSECOLORW);

    typedef UINT_PTR(__stdcall* LPFRHOOKPROC)(HWND, UINT, WPARAM, LPARAM);

    typedef struct tagFINDREPLACEA
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HINSTANCE hInstance;

        DWORD Flags;
        LPSTR lpstrFindWhat;
        LPSTR lpstrReplaceWith;
        WORD wFindWhatLen;
        WORD wReplaceWithLen;
        LPARAM lCustData;
        LPFRHOOKPROC lpfnHook;
        LPCSTR lpTemplateName;
    } FINDREPLACEA, *LPFINDREPLACEA;
    typedef struct tagFINDREPLACEW
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HINSTANCE hInstance;

        DWORD Flags;
        LPWSTR lpstrFindWhat;
        LPWSTR lpstrReplaceWith;
        WORD wFindWhatLen;
        WORD wReplaceWithLen;
        LPARAM lCustData;
        LPFRHOOKPROC lpfnHook;
        LPCWSTR lpTemplateName;
    } FINDREPLACEW, *LPFINDREPLACEW;

    typedef FINDREPLACEA FINDREPLACE;
    typedef LPFINDREPLACEA LPFINDREPLACE;

    __declspec(dllimport) HWND __stdcall FindTextA(LPFINDREPLACEA);
    __declspec(dllimport) HWND __stdcall FindTextW(LPFINDREPLACEW);

    __declspec(dllimport) HWND __stdcall ReplaceTextA(LPFINDREPLACEA);
    __declspec(dllimport) HWND __stdcall ReplaceTextW(LPFINDREPLACEW);

    typedef UINT_PTR(__stdcall* LPCFHOOKPROC)(HWND, UINT, WPARAM, LPARAM);

    typedef struct tagCHOOSEFONTA
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HDC hDC;
        LPLOGFONTA lpLogFont;
        INT iPointSize;
        DWORD Flags;
        COLORREF rgbColors;
        LPARAM lCustData;
        LPCFHOOKPROC lpfnHook;
        LPCSTR lpTemplateName;
        HINSTANCE hInstance;

        LPSTR lpszStyle;

        WORD nFontType;

        WORD ___MISSING_ALIGNMENT__;
        INT nSizeMin;
        INT nSizeMax;

    } CHOOSEFONTA;
    typedef struct tagCHOOSEFONTW
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HDC hDC;
        LPLOGFONTW lpLogFont;
        INT iPointSize;
        DWORD Flags;
        COLORREF rgbColors;
        LPARAM lCustData;
        LPCFHOOKPROC lpfnHook;
        LPCWSTR lpTemplateName;
        HINSTANCE hInstance;

        LPWSTR lpszStyle;

        WORD nFontType;

        WORD ___MISSING_ALIGNMENT__;
        INT nSizeMin;
        INT nSizeMax;

    } CHOOSEFONTW;

    typedef CHOOSEFONTA CHOOSEFONT;
    typedef CHOOSEFONTA* LPCHOOSEFONTA;
    typedef CHOOSEFONTW* LPCHOOSEFONTW;

    typedef LPCHOOSEFONTA LPCHOOSEFONT;
    typedef const CHOOSEFONTA* PCCHOOSEFONTA;
    typedef const CHOOSEFONTW* PCCHOOSEFONTW;

    typedef CHOOSEFONTA CHOOSEFONT;
    typedef PCCHOOSEFONTA PCCHOOSEFONT;

    __declspec(dllimport) BOOL __stdcall ChooseFontA(LPCHOOSEFONTA);
    __declspec(dllimport) BOOL __stdcall ChooseFontW(LPCHOOSEFONTW);

    typedef UINT_PTR(__stdcall* LPPRINTHOOKPROC)(HWND, UINT, WPARAM, LPARAM);
    typedef UINT_PTR(__stdcall* LPSETUPHOOKPROC)(HWND, UINT, WPARAM, LPARAM);

    typedef struct tagPDA
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HGLOBAL hDevMode;
        HGLOBAL hDevNames;
        HDC hDC;
        DWORD Flags;
        WORD nFromPage;
        WORD nToPage;
        WORD nMinPage;
        WORD nMaxPage;
        WORD nCopies;
        HINSTANCE hInstance;
        LPARAM lCustData;
        LPPRINTHOOKPROC lpfnPrintHook;
        LPSETUPHOOKPROC lpfnSetupHook;
        LPCSTR lpPrintTemplateName;
        LPCSTR lpSetupTemplateName;
        HGLOBAL hPrintTemplate;
        HGLOBAL hSetupTemplate;
    } PRINTDLGA, *LPPRINTDLGA;
    typedef struct tagPDW
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HGLOBAL hDevMode;
        HGLOBAL hDevNames;
        HDC hDC;
        DWORD Flags;
        WORD nFromPage;
        WORD nToPage;
        WORD nMinPage;
        WORD nMaxPage;
        WORD nCopies;
        HINSTANCE hInstance;
        LPARAM lCustData;
        LPPRINTHOOKPROC lpfnPrintHook;
        LPSETUPHOOKPROC lpfnSetupHook;
        LPCWSTR lpPrintTemplateName;
        LPCWSTR lpSetupTemplateName;
        HGLOBAL hPrintTemplate;
        HGLOBAL hSetupTemplate;
    } PRINTDLGW, *LPPRINTDLGW;

    typedef PRINTDLGA PRINTDLG;
    typedef LPPRINTDLGA LPPRINTDLG;

    __declspec(dllimport) BOOL __stdcall PrintDlgA(LPPRINTDLGA pPD);
    __declspec(dllimport) BOOL __stdcall PrintDlgW(LPPRINTDLGW pPD);

    struct __declspec(uuid("5852A2C3-6530-11D1-B6A3-0000F8757BF9")) __declspec(novtable) IPrintDialogCallback : public IUnknown
    {
        virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
        virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
        virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;

        virtual __declspec(nothrow) HRESULT __stdcall InitDone(void) = 0;
        virtual __declspec(nothrow) HRESULT __stdcall SelectionChange(void) = 0;
        virtual __declspec(nothrow) HRESULT
        __stdcall HandleMessage(HWND hDlg, UINT uMsg, WPARAM wParam, LPARAM lParam, LRESULT* pResult)
        = 0;
    };

    struct __declspec(uuid("509AAEDA-5639-11D1-B6A1-0000F8757BF9")) __declspec(novtable) IPrintDialogServices : public IUnknown
    {
        virtual __declspec(nothrow) HRESULT __stdcall QueryInterface(const IID& riid, void** ppvObj) = 0;
        virtual __declspec(nothrow) ULONG __stdcall AddRef(void) = 0;
        virtual __declspec(nothrow) ULONG __stdcall Release(void) = 0;

        virtual __declspec(nothrow) HRESULT __stdcall GetCurrentDevMode(LPDEVMODE pDevMode, UINT* pcbSize) = 0;
        virtual __declspec(nothrow) HRESULT __stdcall GetCurrentPrinterName(LPWSTR pPrinterName, UINT* pcchSize) = 0;
        virtual __declspec(nothrow) HRESULT __stdcall GetCurrentPortName(LPWSTR pPortName, UINT* pcchSize) = 0;
    };

    typedef struct tagPRINTPAGERANGE
    {
        DWORD nFromPage;
        DWORD nToPage;
    } PRINTPAGERANGE;
    typedef PRINTPAGERANGE* LPPRINTPAGERANGE;
    typedef const PRINTPAGERANGE* PCPRINTPAGERANGE;

    typedef struct tagPDEXA
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HGLOBAL hDevMode;
        HGLOBAL hDevNames;
        HDC hDC;
        DWORD Flags;
        DWORD Flags2;
        DWORD ExclusionFlags;
        DWORD nPageRanges;
        DWORD nMaxPageRanges;
        LPPRINTPAGERANGE lpPageRanges;
        DWORD nMinPage;
        DWORD nMaxPage;
        DWORD nCopies;
        HINSTANCE hInstance;
        LPCSTR lpPrintTemplateName;
        LPUNKNOWN lpCallback;
        DWORD nPropertyPages;
        HPROPSHEETPAGE* lphPropertyPages;
        DWORD nStartPage;
        DWORD dwResultAction;
    } PRINTDLGEXA, *LPPRINTDLGEXA;

    typedef struct tagPDEXW
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HGLOBAL hDevMode;
        HGLOBAL hDevNames;
        HDC hDC;
        DWORD Flags;
        DWORD Flags2;
        DWORD ExclusionFlags;
        DWORD nPageRanges;
        DWORD nMaxPageRanges;
        LPPRINTPAGERANGE lpPageRanges;
        DWORD nMinPage;
        DWORD nMaxPage;
        DWORD nCopies;
        HINSTANCE hInstance;
        LPCWSTR lpPrintTemplateName;
        LPUNKNOWN lpCallback;
        DWORD nPropertyPages;
        HPROPSHEETPAGE* lphPropertyPages;
        DWORD nStartPage;
        DWORD dwResultAction;
    } PRINTDLGEXW, *LPPRINTDLGEXW;

    typedef PRINTDLGEXA PRINTDLGEX;
    typedef LPPRINTDLGEXA LPPRINTDLGEX;

    __declspec(dllimport) HRESULT __stdcall PrintDlgExA(LPPRINTDLGEXA pPD);
    __declspec(dllimport) HRESULT __stdcall PrintDlgExW(LPPRINTDLGEXW pPD);

    typedef struct tagDEVNAMES
    {
        WORD wDriverOffset;
        WORD wDeviceOffset;
        WORD wOutputOffset;
        WORD wDefault;
    } DEVNAMES;
    typedef DEVNAMES* LPDEVNAMES;
    typedef const DEVNAMES* PCDEVNAMES;

    __declspec(dllimport) DWORD __stdcall CommDlgExtendedError(void);

    typedef UINT_PTR(__stdcall* LPPAGEPAINTHOOK)(HWND, UINT, WPARAM, LPARAM);
    typedef UINT_PTR(__stdcall* LPPAGESETUPHOOK)(HWND, UINT, WPARAM, LPARAM);

    typedef struct tagPSDA
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HGLOBAL hDevMode;
        HGLOBAL hDevNames;
        DWORD Flags;
        POINT ptPaperSize;
        RECT rtMinMargin;
        RECT rtMargin;
        HINSTANCE hInstance;
        LPARAM lCustData;
        LPPAGESETUPHOOK lpfnPageSetupHook;
        LPPAGEPAINTHOOK lpfnPagePaintHook;
        LPCSTR lpPageSetupTemplateName;
        HGLOBAL hPageSetupTemplate;
    } PAGESETUPDLGA, *LPPAGESETUPDLGA;
    typedef struct tagPSDW
    {
        DWORD lStructSize;
        HWND hwndOwner;
        HGLOBAL hDevMode;
        HGLOBAL hDevNames;
        DWORD Flags;
        POINT ptPaperSize;
        RECT rtMinMargin;
        RECT rtMargin;
        HINSTANCE hInstance;
        LPARAM lCustData;
        LPPAGESETUPHOOK lpfnPageSetupHook;
        LPPAGEPAINTHOOK lpfnPagePaintHook;
        LPCWSTR lpPageSetupTemplateName;
        HGLOBAL hPageSetupTemplate;
    } PAGESETUPDLGW, *LPPAGESETUPDLGW;

    typedef PAGESETUPDLGA PAGESETUPDLG;
    typedef LPPAGESETUPDLGA LPPAGESETUPDLG;

    __declspec(dllimport) BOOL __stdcall PageSetupDlgA(LPPAGESETUPDLGA);
    __declspec(dllimport) BOOL __stdcall PageSetupDlgW(LPPAGESETUPDLGW);

#pragma endregion
}

#pragma warning(pop)

extern "C"
{
#pragma region Desktop Family

#pragma warning(push)
#pragma warning(disable : 4127)

    LPUWSTR
    __stdcall uaw_CharUpperW(LPUWSTR String);

    int __stdcall uaw_lstrcmpW(PCUWSTR String1, PCUWSTR String2);

    int __stdcall uaw_lstrcmpiW(PCUWSTR String1, PCUWSTR String2);

    int __stdcall uaw_lstrlenW(LPCUWSTR String);

    PUWSTR
    __cdecl uaw_wcschr(PCUWSTR String, WCHAR Character);

    PUWSTR
    __cdecl uaw_wcscpy(PUWSTR Destination, PCUWSTR Source);

    int __cdecl uaw_wcsicmp(PCUWSTR String1, PCUWSTR String2);

    size_t __cdecl uaw_wcslen(PCUWSTR String);

    PUWSTR
    __cdecl uaw_wcsrchr(PCUWSTR String, WCHAR Character);

    __inline LPUWSTR static ua_CharUpperW(LPUWSTR String)
    {
        if(1)
        {
            return CharUpperW((PWSTR)String);
        }
        else
        {
            return uaw_CharUpperW(String);
        }
    }

    __inline int static ua_lstrcmpW(LPCUWSTR String1, LPCUWSTR String2)
    {
        if(1 && 1)
        {
            return lstrcmpW((LPCWSTR)String1, (LPCWSTR)String2);
        }
        else
        {
            return uaw_lstrcmpW(String1, String2);
        }
    }

    __inline int static ua_lstrcmpiW(LPCUWSTR String1, LPCUWSTR String2)
    {
        if(1 && 1)
        {
            return lstrcmpiW((LPCWSTR)String1, (LPCWSTR)String2);
        }
        else
        {
            return uaw_lstrcmpiW(String1, String2);
        }
    }

    __inline int static ua_lstrlenW(LPCUWSTR String)
    {
        if(1)
        {
#pragma warning(suppress : 28750)
            return lstrlenW((PCWSTR)String);
        }
        else
        {
            return uaw_lstrlenW(String);
        }
    }

    typedef const WCHAR __unaligned* PUWSTR_C;

    __inline PUWSTR_C static ua_wcschr(PCUWSTR String, WCHAR Character)
    {
        if(1)
        {
            return wcschr((PCWSTR)String, Character);
        }
        else
        {
            return (PUWSTR_C)uaw_wcschr(String, Character);
        }
    }

    __inline PUWSTR_C static ua_wcsrchr(PCUWSTR String, WCHAR Character)
    {
        if(1)
        {
            return wcsrchr((PCWSTR)String, Character);
        }
        else
        {
            return (PUWSTR_C)uaw_wcsrchr(String, Character);
        }
    }

    __inline PUWSTR static __declspec(deprecated) ua_wcscpy(PUWSTR Destination, PCUWSTR Source)
    {
        if(1 && 1)
        {
#pragma warning(push)
#pragma warning(disable : 4995)
#pragma warning(disable : 4996)

            return wcscpy((PWSTR)Destination, (PCWSTR)Source);
#pragma warning(pop)
        }
        else
        {
            return uaw_wcscpy(Destination, Source);
        }
    }

    __inline PUWSTR static ua_wcscpy_s(PUWSTR Destination, size_t DestinationSize, PCUWSTR Source)
    {
        if(1 && 1)
        {
            return (wcscpy_s((PWSTR)Destination, DestinationSize, (PCWSTR)Source) == 0 ? Destination : 0);
        }
        else
        {
            return uaw_wcscpy(Destination, Source);
        }
    }

    __inline size_t static ua_wcslen(PCUWSTR String)
    {
        if(1)
        {
            return wcslen((PCWSTR)String);
        }
        else
        {
            return uaw_wcslen(String);
        }
    }

    __inline int static ua_wcsicmp(PCUWSTR String1, PCUWSTR String2)
    {
        if(1 && 1)
        {
            return _wcsicmp((LPCWSTR)String1, (LPCWSTR)String2);
        }
        else
        {
            return uaw_wcsicmp(String1, String2);
        }
    }

#pragma warning(pop)

#pragma endregion
}

#pragma warning(push)
#pragma warning(disable : 4820)

extern "C"
{
#pragma region Desktop Family or OneCore Family

    extern "C" const GUID NETWORK_MANAGER_FIRST_IP_ADDRESS_ARRIVAL_GUID;

    extern "C" const GUID NETWORK_MANAGER_LAST_IP_ADDRESS_REMOVAL_GUID;

    extern "C" const GUID DOMAIN_JOIN_GUID;

    extern "C" const GUID DOMAIN_LEAVE_GUID;

    extern "C" const GUID FIREWALL_PORT_OPEN_GUID;

    extern "C" const GUID FIREWALL_PORT_CLOSE_GUID;

    extern "C" const GUID MACHINE_POLICY_PRESENT_GUID;

    extern "C" const GUID USER_POLICY_PRESENT_GUID;

    extern "C" const GUID RPC_INTERFACE_EVENT_GUID;

    extern "C" const GUID NAMED_PIPE_EVENT_GUID;

    extern "C" const GUID CUSTOM_SYSTEM_STATE_CHANGE_EVENT_GUID;

    typedef struct
    {
        DWORD Data[2];
    } SERVICE_TRIGGER_CUSTOM_STATE_ID;

    typedef struct _SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM
    {
        union
        {
            SERVICE_TRIGGER_CUSTOM_STATE_ID CustomStateId;
            struct
            {
                DWORD DataOffset;
                BYTE Data[1];
            } s;
        } u;
    } SERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM, *LPSERVICE_CUSTOM_SYSTEM_STATE_CHANGE_DATA_ITEM;

    typedef struct _SERVICE_DESCRIPTIONA
    {
        LPSTR lpDescription;
    } SERVICE_DESCRIPTIONA, *LPSERVICE_DESCRIPTIONA;

    typedef struct _SERVICE_DESCRIPTIONW
    {
        LPWSTR lpDescription;
    } SERVICE_DESCRIPTIONW, *LPSERVICE_DESCRIPTIONW;

    typedef SERVICE_DESCRIPTIONA SERVICE_DESCRIPTION;
    typedef LPSERVICE_DESCRIPTIONA LPSERVICE_DESCRIPTION;

    typedef enum _SC_ACTION_TYPE
    {
        SC_ACTION_NONE = 0,
        SC_ACTION_RESTART = 1,
        SC_ACTION_REBOOT = 2,
        SC_ACTION_RUN_COMMAND = 3,
        SC_ACTION_OWN_RESTART = 4
    } SC_ACTION_TYPE;

    typedef struct _SC_ACTION
    {
        SC_ACTION_TYPE Type;
        DWORD Delay;
    } SC_ACTION, *LPSC_ACTION;

    typedef struct _SERVICE_FAILURE_ACTIONSA
    {
        DWORD dwResetPeriod;
        LPSTR lpRebootMsg;
        LPSTR lpCommand;

        DWORD cActions;

        SC_ACTION* lpsaActions;
    } SERVICE_FAILURE_ACTIONSA, *LPSERVICE_FAILURE_ACTIONSA;
    typedef struct _SERVICE_FAILURE_ACTIONSW
    {
        DWORD dwResetPeriod;
        LPWSTR lpRebootMsg;
        LPWSTR lpCommand;

        DWORD cActions;

        SC_ACTION* lpsaActions;
    } SERVICE_FAILURE_ACTIONSW, *LPSERVICE_FAILURE_ACTIONSW;

    typedef SERVICE_FAILURE_ACTIONSA SERVICE_FAILURE_ACTIONS;
    typedef LPSERVICE_FAILURE_ACTIONSA LPSERVICE_FAILURE_ACTIONS;

    typedef struct _SERVICE_DELAYED_AUTO_START_INFO
    {
        BOOL fDelayedAutostart;
    } SERVICE_DELAYED_AUTO_START_INFO, *LPSERVICE_DELAYED_AUTO_START_INFO;

    typedef struct _SERVICE_FAILURE_ACTIONS_FLAG
    {
        BOOL fFailureActionsOnNonCrashFailures;
    } SERVICE_FAILURE_ACTIONS_FLAG, *LPSERVICE_FAILURE_ACTIONS_FLAG;

    typedef struct _SERVICE_SID_INFO
    {
        DWORD dwServiceSidType;
    } SERVICE_SID_INFO, *LPSERVICE_SID_INFO;

    typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOA
    {
        LPSTR pmszRequiredPrivileges;
    } SERVICE_REQUIRED_PRIVILEGES_INFOA, *LPSERVICE_REQUIRED_PRIVILEGES_INFOA;

    typedef struct _SERVICE_REQUIRED_PRIVILEGES_INFOW
    {
        LPWSTR pmszRequiredPrivileges;
    } SERVICE_REQUIRED_PRIVILEGES_INFOW, *LPSERVICE_REQUIRED_PRIVILEGES_INFOW;

    typedef SERVICE_REQUIRED_PRIVILEGES_INFOA SERVICE_REQUIRED_PRIVILEGES_INFO;
    typedef LPSERVICE_REQUIRED_PRIVILEGES_INFOA LPSERVICE_REQUIRED_PRIVILEGES_INFO;

    typedef struct _SERVICE_PRESHUTDOWN_INFO
    {
        DWORD dwPreshutdownTimeout;
    } SERVICE_PRESHUTDOWN_INFO, *LPSERVICE_PRESHUTDOWN_INFO;

    typedef struct _SERVICE_TRIGGER_SPECIFIC_DATA_ITEM
    {
        DWORD dwDataType;

        DWORD cbData;

        PBYTE pData;
    } SERVICE_TRIGGER_SPECIFIC_DATA_ITEM, *PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM;

    typedef struct _SERVICE_TRIGGER
    {
        DWORD dwTriggerType;
        DWORD dwAction;
        GUID* pTriggerSubtype;

        DWORD cDataItems;

        PSERVICE_TRIGGER_SPECIFIC_DATA_ITEM pDataItems;
    } SERVICE_TRIGGER, *PSERVICE_TRIGGER;

    typedef struct _SERVICE_TRIGGER_INFO
    {
        DWORD cTriggers;

        PSERVICE_TRIGGER pTriggers;
        PBYTE pReserved;
    } SERVICE_TRIGGER_INFO, *PSERVICE_TRIGGER_INFO;

    typedef struct _SERVICE_PREFERRED_NODE_INFO
    {
        USHORT usPreferredNode;
        BOOLEAN fDelete;
    } SERVICE_PREFERRED_NODE_INFO, *LPSERVICE_PREFERRED_NODE_INFO;

    typedef struct _SERVICE_TIMECHANGE_INFO
    {
        LARGE_INTEGER liNewTime;
        LARGE_INTEGER liOldTime;
    } SERVICE_TIMECHANGE_INFO, *PSERVICE_TIMECHANGE_INFO;

    typedef struct _SERVICE_LAUNCH_PROTECTED_INFO
    {
        DWORD dwLaunchProtected;
    } SERVICE_LAUNCH_PROTECTED_INFO, *PSERVICE_LAUNCH_PROTECTED_INFO;

    struct SC_HANDLE__
    {
        int unused;
    };
    typedef struct SC_HANDLE__* SC_HANDLE;
    typedef SC_HANDLE* LPSC_HANDLE;

    struct SERVICE_STATUS_HANDLE__
    {
        int unused;
    };
    typedef struct SERVICE_STATUS_HANDLE__* SERVICE_STATUS_HANDLE;

    typedef enum _SC_STATUS_TYPE
    {
        SC_STATUS_PROCESS_INFO = 0
    } SC_STATUS_TYPE;

    typedef enum _SC_ENUM_TYPE
    {
        SC_ENUM_PROCESS_INFO = 0
    } SC_ENUM_TYPE;

    typedef struct _SERVICE_STATUS
    {
        DWORD dwServiceType;
        DWORD dwCurrentState;
        DWORD dwControlsAccepted;
        DWORD dwWin32ExitCode;
        DWORD dwServiceSpecificExitCode;
        DWORD dwCheckPoint;
        DWORD dwWaitHint;
    } SERVICE_STATUS, *LPSERVICE_STATUS;

    typedef struct _SERVICE_STATUS_PROCESS
    {
        DWORD dwServiceType;
        DWORD dwCurrentState;
        DWORD dwControlsAccepted;
        DWORD dwWin32ExitCode;
        DWORD dwServiceSpecificExitCode;
        DWORD dwCheckPoint;
        DWORD dwWaitHint;
        DWORD dwProcessId;
        DWORD dwServiceFlags;
    } SERVICE_STATUS_PROCESS, *LPSERVICE_STATUS_PROCESS;

    typedef struct _ENUM_SERVICE_STATUSA
    {
        LPSTR lpServiceName;
        LPSTR lpDisplayName;
        SERVICE_STATUS ServiceStatus;
    } ENUM_SERVICE_STATUSA, *LPENUM_SERVICE_STATUSA;
    typedef struct _ENUM_SERVICE_STATUSW
    {
        LPWSTR lpServiceName;
        LPWSTR lpDisplayName;
        SERVICE_STATUS ServiceStatus;
    } ENUM_SERVICE_STATUSW, *LPENUM_SERVICE_STATUSW;

    typedef ENUM_SERVICE_STATUSA ENUM_SERVICE_STATUS;
    typedef LPENUM_SERVICE_STATUSA LPENUM_SERVICE_STATUS;

    typedef struct _ENUM_SERVICE_STATUS_PROCESSA
    {
        LPSTR lpServiceName;
        LPSTR lpDisplayName;
        SERVICE_STATUS_PROCESS ServiceStatusProcess;
    } ENUM_SERVICE_STATUS_PROCESSA, *LPENUM_SERVICE_STATUS_PROCESSA;
    typedef struct _ENUM_SERVICE_STATUS_PROCESSW
    {
        LPWSTR lpServiceName;
        LPWSTR lpDisplayName;
        SERVICE_STATUS_PROCESS ServiceStatusProcess;
    } ENUM_SERVICE_STATUS_PROCESSW, *LPENUM_SERVICE_STATUS_PROCESSW;

    typedef ENUM_SERVICE_STATUS_PROCESSA ENUM_SERVICE_STATUS_PROCESS;
    typedef LPENUM_SERVICE_STATUS_PROCESSA LPENUM_SERVICE_STATUS_PROCESS;

    typedef LPVOID SC_LOCK;

    typedef struct _QUERY_SERVICE_LOCK_STATUSA
    {
        DWORD fIsLocked;
        LPSTR lpLockOwner;
        DWORD dwLockDuration;
    } QUERY_SERVICE_LOCK_STATUSA, *LPQUERY_SERVICE_LOCK_STATUSA;
    typedef struct _QUERY_SERVICE_LOCK_STATUSW
    {
        DWORD fIsLocked;
        LPWSTR lpLockOwner;
        DWORD dwLockDuration;
    } QUERY_SERVICE_LOCK_STATUSW, *LPQUERY_SERVICE_LOCK_STATUSW;

    typedef QUERY_SERVICE_LOCK_STATUSA QUERY_SERVICE_LOCK_STATUS;
    typedef LPQUERY_SERVICE_LOCK_STATUSA LPQUERY_SERVICE_LOCK_STATUS;

    typedef struct _QUERY_SERVICE_CONFIGA
    {
        DWORD dwServiceType;
        DWORD dwStartType;
        DWORD dwErrorControl;
        LPSTR lpBinaryPathName;
        LPSTR lpLoadOrderGroup;
        DWORD dwTagId;
        LPSTR lpDependencies;
        LPSTR lpServiceStartName;
        LPSTR lpDisplayName;
    } QUERY_SERVICE_CONFIGA, *LPQUERY_SERVICE_CONFIGA;
    typedef struct _QUERY_SERVICE_CONFIGW
    {
        DWORD dwServiceType;
        DWORD dwStartType;
        DWORD dwErrorControl;
        LPWSTR lpBinaryPathName;
        LPWSTR lpLoadOrderGroup;
        DWORD dwTagId;
        LPWSTR lpDependencies;
        LPWSTR lpServiceStartName;
        LPWSTR lpDisplayName;
    } QUERY_SERVICE_CONFIGW, *LPQUERY_SERVICE_CONFIGW;

    typedef QUERY_SERVICE_CONFIGA QUERY_SERVICE_CONFIG;
    typedef LPQUERY_SERVICE_CONFIGA LPQUERY_SERVICE_CONFIG;

    typedef void __stdcall SERVICE_MAIN_FUNCTIONW(DWORD dwNumServicesArgs, LPWSTR* lpServiceArgVectors);

    typedef void __stdcall SERVICE_MAIN_FUNCTIONA(DWORD dwNumServicesArgs, LPTSTR* lpServiceArgVectors);

    typedef void(__stdcall* LPSERVICE_MAIN_FUNCTIONW)(DWORD dwNumServicesArgs, LPWSTR* lpServiceArgVectors);

    typedef void(__stdcall* LPSERVICE_MAIN_FUNCTIONA)(DWORD dwNumServicesArgs, LPSTR* lpServiceArgVectors);

    typedef struct _SERVICE_TABLE_ENTRYA
    {
        LPSTR lpServiceName;
        LPSERVICE_MAIN_FUNCTIONA lpServiceProc;
    } SERVICE_TABLE_ENTRYA, *LPSERVICE_TABLE_ENTRYA;
    typedef struct _SERVICE_TABLE_ENTRYW
    {
        LPWSTR lpServiceName;
        LPSERVICE_MAIN_FUNCTIONW lpServiceProc;
    } SERVICE_TABLE_ENTRYW, *LPSERVICE_TABLE_ENTRYW;

    typedef SERVICE_TABLE_ENTRYA SERVICE_TABLE_ENTRY;
    typedef LPSERVICE_TABLE_ENTRYA LPSERVICE_TABLE_ENTRY;

    typedef void __stdcall HANDLER_FUNCTION(DWORD dwControl);

    typedef DWORD __stdcall HANDLER_FUNCTION_EX(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);

    typedef void(__stdcall* LPHANDLER_FUNCTION)(DWORD dwControl);

    typedef DWORD(__stdcall* LPHANDLER_FUNCTION_EX)(DWORD dwControl, DWORD dwEventType, LPVOID lpEventData, LPVOID lpContext);

    typedef void(__stdcall* PFN_SC_NOTIFY_CALLBACK)(PVOID pParameter);

    typedef struct _SERVICE_NOTIFY_1
    {
        DWORD dwVersion;
        PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
        PVOID pContext;
        DWORD dwNotificationStatus;
        SERVICE_STATUS_PROCESS ServiceStatus;
    } SERVICE_NOTIFY_1, *PSERVICE_NOTIFY_1;

    typedef struct _SERVICE_NOTIFY_2A
    {
        DWORD dwVersion;
        PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
        PVOID pContext;
        DWORD dwNotificationStatus;
        SERVICE_STATUS_PROCESS ServiceStatus;
        DWORD dwNotificationTriggered;
        LPSTR pszServiceNames;
    } SERVICE_NOTIFY_2A, *PSERVICE_NOTIFY_2A;
    typedef struct _SERVICE_NOTIFY_2W
    {
        DWORD dwVersion;
        PFN_SC_NOTIFY_CALLBACK pfnNotifyCallback;
        PVOID pContext;
        DWORD dwNotificationStatus;
        SERVICE_STATUS_PROCESS ServiceStatus;
        DWORD dwNotificationTriggered;
        LPWSTR pszServiceNames;
    } SERVICE_NOTIFY_2W, *PSERVICE_NOTIFY_2W;

    typedef SERVICE_NOTIFY_2A SERVICE_NOTIFY_2;
    typedef PSERVICE_NOTIFY_2A PSERVICE_NOTIFY_2;

    typedef SERVICE_NOTIFY_2A SERVICE_NOTIFYA, *PSERVICE_NOTIFYA;
    typedef SERVICE_NOTIFY_2W SERVICE_NOTIFYW, *PSERVICE_NOTIFYW;

    typedef SERVICE_NOTIFYA SERVICE_NOTIFY;
    typedef PSERVICE_NOTIFYA PSERVICE_NOTIFY;

    typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSA
    {
        DWORD dwReason;
        LPSTR pszComment;
        SERVICE_STATUS_PROCESS ServiceStatus;
    } SERVICE_CONTROL_STATUS_REASON_PARAMSA, *PSERVICE_CONTROL_STATUS_REASON_PARAMSA;

    typedef struct _SERVICE_CONTROL_STATUS_REASON_PARAMSW
    {
        DWORD dwReason;
        LPWSTR pszComment;
        SERVICE_STATUS_PROCESS ServiceStatus;
    } SERVICE_CONTROL_STATUS_REASON_PARAMSW, *PSERVICE_CONTROL_STATUS_REASON_PARAMSW;

    typedef SERVICE_CONTROL_STATUS_REASON_PARAMSA SERVICE_CONTROL_STATUS_REASON_PARAMS;
    typedef PSERVICE_CONTROL_STATUS_REASON_PARAMSA PSERVICE_CONTROL_STATUS_REASON_PARAMS;

    typedef struct _SERVICE_START_REASON
    {
        DWORD dwReason;
    } SERVICE_START_REASON, *PSERVICE_START_REASON;

    __declspec(dllimport) BOOL __stdcall ChangeServiceConfigA(SC_HANDLE hService,
                                                              DWORD dwServiceType,
                                                              DWORD dwStartType,
                                                              DWORD dwErrorControl,
                                                              LPCSTR lpBinaryPathName,
                                                              LPCSTR lpLoadOrderGroup,
                                                              LPDWORD lpdwTagId,
                                                              LPCSTR lpDependencies,
                                                              LPCSTR lpServiceStartName,
                                                              LPCSTR lpPassword,
                                                              LPCSTR lpDisplayName);
    __declspec(dllimport) BOOL __stdcall ChangeServiceConfigW(SC_HANDLE hService,
                                                              DWORD dwServiceType,
                                                              DWORD dwStartType,
                                                              DWORD dwErrorControl,
                                                              LPCWSTR lpBinaryPathName,
                                                              LPCWSTR lpLoadOrderGroup,
                                                              LPDWORD lpdwTagId,
                                                              LPCWSTR lpDependencies,
                                                              LPCWSTR lpServiceStartName,
                                                              LPCWSTR lpPassword,
                                                              LPCWSTR lpDisplayName);

    __declspec(dllimport) BOOL __stdcall ChangeServiceConfig2A(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo);
    __declspec(dllimport) BOOL __stdcall ChangeServiceConfig2W(SC_HANDLE hService, DWORD dwInfoLevel, LPVOID lpInfo);

    __declspec(dllimport) BOOL __stdcall CloseServiceHandle(SC_HANDLE hSCObject);

    __declspec(dllimport) BOOL __stdcall ControlService(SC_HANDLE hService, DWORD dwControl, LPSERVICE_STATUS lpServiceStatus);

    __declspec(dllimport) SC_HANDLE __stdcall CreateServiceA(SC_HANDLE hSCManager,
                                                             LPCSTR lpServiceName,
                                                             LPCSTR lpDisplayName,
                                                             DWORD dwDesiredAccess,
                                                             DWORD dwServiceType,
                                                             DWORD dwStartType,
                                                             DWORD dwErrorControl,
                                                             LPCSTR lpBinaryPathName,
                                                             LPCSTR lpLoadOrderGroup,
                                                             LPDWORD lpdwTagId,
                                                             LPCSTR lpDependencies,
                                                             LPCSTR lpServiceStartName,
                                                             LPCSTR lpPassword);

    __declspec(dllimport) SC_HANDLE __stdcall CreateServiceW(SC_HANDLE hSCManager,
                                                             LPCWSTR lpServiceName,
                                                             LPCWSTR lpDisplayName,
                                                             DWORD dwDesiredAccess,
                                                             DWORD dwServiceType,
                                                             DWORD dwStartType,
                                                             DWORD dwErrorControl,
                                                             LPCWSTR lpBinaryPathName,
                                                             LPCWSTR lpLoadOrderGroup,
                                                             LPDWORD lpdwTagId,
                                                             LPCWSTR lpDependencies,
                                                             LPCWSTR lpServiceStartName,
                                                             LPCWSTR lpPassword);

    __declspec(dllimport) BOOL __stdcall DeleteService(SC_HANDLE hService);

    __declspec(dllimport) BOOL __stdcall EnumDependentServicesA(SC_HANDLE hService,
                                                                DWORD dwServiceState,

                                                                LPENUM_SERVICE_STATUSA lpServices,
                                                                DWORD cbBufSize,
                                                                LPDWORD pcbBytesNeeded,
                                                                LPDWORD lpServicesReturned);

    __declspec(dllimport) BOOL __stdcall EnumDependentServicesW(SC_HANDLE hService,
                                                                DWORD dwServiceState,

                                                                LPENUM_SERVICE_STATUSW lpServices,
                                                                DWORD cbBufSize,
                                                                LPDWORD pcbBytesNeeded,
                                                                LPDWORD lpServicesReturned);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall EnumServicesStatusA(SC_HANDLE hSCManager,
                                                             DWORD dwServiceType,
                                                             DWORD dwServiceState,

                                                             LPENUM_SERVICE_STATUSA lpServices,
                                                             DWORD cbBufSize,
                                                             LPDWORD pcbBytesNeeded,
                                                             LPDWORD lpServicesReturned,
                                                             LPDWORD lpResumeHandle);

    __declspec(dllimport) BOOL __stdcall EnumServicesStatusW(SC_HANDLE hSCManager,
                                                             DWORD dwServiceType,
                                                             DWORD dwServiceState,

                                                             LPENUM_SERVICE_STATUSW lpServices,
                                                             DWORD cbBufSize,
                                                             LPDWORD pcbBytesNeeded,
                                                             LPDWORD lpServicesReturned,
                                                             LPDWORD lpResumeHandle);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall EnumServicesStatusExA(SC_HANDLE hSCManager,
                                                               SC_ENUM_TYPE InfoLevel,
                                                               DWORD dwServiceType,
                                                               DWORD dwServiceState,

                                                               LPBYTE lpServices,
                                                               DWORD cbBufSize,
                                                               LPDWORD pcbBytesNeeded,
                                                               LPDWORD lpServicesReturned,
                                                               LPDWORD lpResumeHandle,
                                                               LPCSTR pszGroupName);

    __declspec(dllimport) BOOL __stdcall EnumServicesStatusExW(SC_HANDLE hSCManager,
                                                               SC_ENUM_TYPE InfoLevel,
                                                               DWORD dwServiceType,
                                                               DWORD dwServiceState,

                                                               LPBYTE lpServices,
                                                               DWORD cbBufSize,
                                                               LPDWORD pcbBytesNeeded,
                                                               LPDWORD lpServicesReturned,
                                                               LPDWORD lpResumeHandle,
                                                               LPCWSTR pszGroupName);

    __declspec(dllimport) BOOL __stdcall GetServiceKeyNameA(SC_HANDLE hSCManager,
                                                            LPCSTR lpDisplayName,

                                                            LPSTR lpServiceName,
                                                            LPDWORD lpcchBuffer);

    __declspec(dllimport) BOOL __stdcall GetServiceKeyNameW(SC_HANDLE hSCManager,
                                                            LPCWSTR lpDisplayName,

                                                            LPWSTR lpServiceName,
                                                            LPDWORD lpcchBuffer);

    __declspec(dllimport) BOOL __stdcall GetServiceDisplayNameA(SC_HANDLE hSCManager,
                                                                LPCSTR lpServiceName,

                                                                LPSTR lpDisplayName,
                                                                LPDWORD lpcchBuffer);

    __declspec(dllimport) BOOL __stdcall GetServiceDisplayNameW(SC_HANDLE hSCManager,
                                                                LPCWSTR lpServiceName,

                                                                LPWSTR lpDisplayName,
                                                                LPDWORD lpcchBuffer);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) SC_LOCK __stdcall LockServiceDatabase(SC_HANDLE hSCManager);

    __declspec(dllimport) BOOL __stdcall NotifyBootConfigStatus(BOOL BootAcceptable);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) SC_HANDLE __stdcall OpenSCManagerA(LPCSTR lpMachineName, LPCSTR lpDatabaseName, DWORD dwDesiredAccess);

    __declspec(dllimport) SC_HANDLE __stdcall OpenSCManagerW(LPCWSTR lpMachineName, LPCWSTR lpDatabaseName, DWORD dwDesiredAccess);

    __declspec(dllimport) SC_HANDLE __stdcall OpenServiceA(SC_HANDLE hSCManager, LPCSTR lpServiceName, DWORD dwDesiredAccess);

    __declspec(dllimport) SC_HANDLE __stdcall OpenServiceW(SC_HANDLE hSCManager, LPCWSTR lpServiceName, DWORD dwDesiredAccess);

    __declspec(dllimport) BOOL __stdcall QueryServiceConfigA(SC_HANDLE hService,

                                                             LPQUERY_SERVICE_CONFIGA lpServiceConfig,
                                                             DWORD cbBufSize,
                                                             LPDWORD pcbBytesNeeded);

    __declspec(dllimport) BOOL __stdcall QueryServiceConfigW(SC_HANDLE hService,

                                                             LPQUERY_SERVICE_CONFIGW lpServiceConfig,
                                                             DWORD cbBufSize,
                                                             LPDWORD pcbBytesNeeded);

    __declspec(dllimport) BOOL __stdcall QueryServiceConfig2A(SC_HANDLE hService,
                                                              DWORD dwInfoLevel,

                                                              LPBYTE lpBuffer,
                                                              DWORD cbBufSize,
                                                              LPDWORD pcbBytesNeeded);

    __declspec(dllimport) BOOL __stdcall QueryServiceConfig2W(SC_HANDLE hService,
                                                              DWORD dwInfoLevel,

                                                              LPBYTE lpBuffer,
                                                              DWORD cbBufSize,
                                                              LPDWORD pcbBytesNeeded);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall QueryServiceLockStatusA(SC_HANDLE hSCManager,

                                                                 LPQUERY_SERVICE_LOCK_STATUSA lpLockStatus,
                                                                 DWORD cbBufSize,
                                                                 LPDWORD pcbBytesNeeded);

    __declspec(dllimport) BOOL __stdcall QueryServiceLockStatusW(SC_HANDLE hSCManager,

                                                                 LPQUERY_SERVICE_LOCK_STATUSW lpLockStatus,
                                                                 DWORD cbBufSize,
                                                                 LPDWORD pcbBytesNeeded);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) BOOL __stdcall QueryServiceObjectSecurity(SC_HANDLE hService,
                                                                    SECURITY_INFORMATION dwSecurityInformation,

                                                                    PSECURITY_DESCRIPTOR lpSecurityDescriptor,
                                                                    DWORD cbBufSize,
                                                                    LPDWORD pcbBytesNeeded);

    __declspec(dllimport) BOOL __stdcall QueryServiceStatus(SC_HANDLE hService, LPSERVICE_STATUS lpServiceStatus);

    __declspec(dllimport) BOOL __stdcall QueryServiceStatusEx(SC_HANDLE hService,
                                                              SC_STATUS_TYPE InfoLevel,

                                                              LPBYTE lpBuffer,
                                                              DWORD cbBufSize,
                                                              LPDWORD pcbBytesNeeded);

    __declspec(dllimport) SERVICE_STATUS_HANDLE __stdcall RegisterServiceCtrlHandlerA(LPCSTR lpServiceName,

                                                                                      LPHANDLER_FUNCTION lpHandlerProc);

    __declspec(dllimport) SERVICE_STATUS_HANDLE __stdcall RegisterServiceCtrlHandlerW(LPCWSTR lpServiceName,

                                                                                      LPHANDLER_FUNCTION lpHandlerProc);

    __declspec(dllimport) SERVICE_STATUS_HANDLE __stdcall RegisterServiceCtrlHandlerExA(LPCSTR lpServiceName,

                                                                                        LPHANDLER_FUNCTION_EX lpHandlerProc,
                                                                                        LPVOID lpContext);

    __declspec(dllimport) SERVICE_STATUS_HANDLE __stdcall RegisterServiceCtrlHandlerExW(LPCWSTR lpServiceName,

                                                                                        LPHANDLER_FUNCTION_EX lpHandlerProc,
                                                                                        LPVOID lpContext);

    __declspec(dllimport) BOOL __stdcall SetServiceObjectSecurity(SC_HANDLE hService,
                                                                  SECURITY_INFORMATION dwSecurityInformation,
                                                                  PSECURITY_DESCRIPTOR lpSecurityDescriptor);

    __declspec(dllimport) BOOL __stdcall SetServiceStatus(SERVICE_STATUS_HANDLE hServiceStatus, LPSERVICE_STATUS lpServiceStatus);

    __declspec(dllimport) BOOL __stdcall StartServiceCtrlDispatcherA(const SERVICE_TABLE_ENTRYA* lpServiceStartTable);
    __declspec(dllimport) BOOL __stdcall StartServiceCtrlDispatcherW(const SERVICE_TABLE_ENTRYW* lpServiceStartTable);

    __declspec(dllimport) BOOL __stdcall StartServiceA(SC_HANDLE hService,
                                                       DWORD dwNumServiceArgs,

                                                       LPCSTR* lpServiceArgVectors);
    __declspec(dllimport) BOOL __stdcall StartServiceW(SC_HANDLE hService,
                                                       DWORD dwNumServiceArgs,

                                                       LPCWSTR* lpServiceArgVectors);

#pragma endregion

#pragma region Desktop Family

    __declspec(dllimport) BOOL __stdcall UnlockServiceDatabase(SC_LOCK ScLock);

#pragma endregion

#pragma region Desktop Family or OneCore Family

    __declspec(dllimport) DWORD
    __stdcall NotifyServiceStatusChangeA(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYA pNotifyBuffer);
    __declspec(dllimport) DWORD
    __stdcall NotifyServiceStatusChangeW(SC_HANDLE hService, DWORD dwNotifyMask, PSERVICE_NOTIFYW pNotifyBuffer);

    __declspec(dllimport) BOOL
    __stdcall ControlServiceExA(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams);
    __declspec(dllimport) BOOL
    __stdcall ControlServiceExW(SC_HANDLE hService, DWORD dwControl, DWORD dwInfoLevel, PVOID pControlParams);

    __declspec(dllimport) BOOL
    __stdcall QueryServiceDynamicInformation(SERVICE_STATUS_HANDLE hServiceStatus, DWORD dwInfoLevel, PVOID* ppDynamicInfo);

    typedef enum _SC_EVENT_TYPE
    {
        SC_EVENT_DATABASE_CHANGE,
        SC_EVENT_PROPERTY_CHANGE,
        SC_EVENT_STATUS_CHANGE
    } SC_EVENT_TYPE,
    *PSC_EVENT_TYPE;

    typedef void __stdcall SC_NOTIFICATION_CALLBACK(DWORD dwNotify, PVOID pCallbackContext);
    typedef SC_NOTIFICATION_CALLBACK* PSC_NOTIFICATION_CALLBACK;

    typedef struct _SC_NOTIFICATION_REGISTRATION* PSC_NOTIFICATION_REGISTRATION;

    __declspec(dllimport) DWORD __stdcall SubscribeServiceChangeNotifications(SC_HANDLE hService,
                                                                              SC_EVENT_TYPE eEventType,
                                                                              PSC_NOTIFICATION_CALLBACK pCallback,
                                                                              PVOID pCallbackContext,
                                                                              PSC_NOTIFICATION_REGISTRATION* pSubscription);

    __declspec(dllimport) void __stdcall UnsubscribeServiceChangeNotifications(PSC_NOTIFICATION_REGISTRATION pSubscription);

    __declspec(dllimport) DWORD __stdcall WaitServiceState(SC_HANDLE hService, DWORD dwNotify, DWORD dwTimeout, HANDLE hCancelEvent);

    typedef enum SERVICE_REGISTRY_STATE_TYPE
    {
        ServiceRegistryStateParameters = 0,
        ServiceRegistryStatePersistent = 1,
        MaxServiceRegistryStateType = 2,
    } SERVICE_REGISTRY_STATE_TYPE;

    DWORD
    __stdcall GetServiceRegistryStateKey(SERVICE_STATUS_HANDLE ServiceStatusHandle,
                                         SERVICE_REGISTRY_STATE_TYPE StateType,
                                         DWORD AccessMask,
                                         HKEY* ServiceStateKey);

    typedef enum SERVICE_DIRECTORY_TYPE
    {
        ServiceDirectoryPersistentState = 0,
        ServiceDirectoryTypeMax = 1,
    } SERVICE_DIRECTORY_TYPE;

    DWORD
    __stdcall GetServiceDirectory(SERVICE_STATUS_HANDLE hServiceStatus,
                                  SERVICE_DIRECTORY_TYPE eDirectoryType,
                                  PWCHAR lpPathBuffer,
                                  DWORD cchPathBufferLength,
                                  DWORD* lpcchRequiredBufferLength);

#pragma endregion
}

#pragma warning(pop)

#pragma once

#pragma warning(push)
#pragma warning(disable : 4820)

typedef struct _MODEMDEVCAPS
{
    DWORD dwActualSize;
    DWORD dwRequiredSize;
    DWORD dwDevSpecificOffset;
    DWORD dwDevSpecificSize;

    DWORD dwModemProviderVersion;
    DWORD dwModemManufacturerOffset;
    DWORD dwModemManufacturerSize;
    DWORD dwModemModelOffset;
    DWORD dwModemModelSize;
    DWORD dwModemVersionOffset;
    DWORD dwModemVersionSize;

    DWORD dwDialOptions;
    DWORD dwCallSetupFailTimer;
    DWORD dwInactivityTimeout;
    DWORD dwSpeakerVolume;
    DWORD dwSpeakerMode;
    DWORD dwModemOptions;
    DWORD dwMaxDTERate;
    DWORD dwMaxDCERate;

    BYTE abVariablePortion[1];
} MODEMDEVCAPS, *PMODEMDEVCAPS, *LPMODEMDEVCAPS;

typedef struct _MODEMSETTINGS
{
    DWORD dwActualSize;
    DWORD dwRequiredSize;
    DWORD dwDevSpecificOffset;
    DWORD dwDevSpecificSize;

    DWORD dwCallSetupFailTimer;
    DWORD dwInactivityTimeout;
    DWORD dwSpeakerVolume;
    DWORD dwSpeakerMode;
    DWORD dwPreferredModemOptions;

    DWORD dwNegotiatedModemOptions;
    DWORD dwNegotiatedDCERate;

    BYTE abVariablePortion[1];
} MODEMSETTINGS, *PMODEMSETTINGS, *LPMODEMSETTINGS;

#pragma warning(pop)

extern "C"
{
#pragma warning(push)
#pragma warning(disable : 4820)

#pragma region Application Family

    struct HIMC__
    {
        int unused;
    };
    typedef struct HIMC__* HIMC;
    struct HIMCC__
    {
        int unused;
    };
    typedef struct HIMCC__* HIMCC;

#pragma endregion

#pragma region Desktop Family

    typedef HKL* LPHKL;
    typedef UINT* LPUINT;

#pragma endregion

#pragma region Application Family

    typedef struct tagCOMPOSITIONFORM
    {
        DWORD dwStyle;
        POINT ptCurrentPos;
        RECT rcArea;
    } COMPOSITIONFORM, *PCOMPOSITIONFORM, *NPCOMPOSITIONFORM, *LPCOMPOSITIONFORM;

    typedef struct tagCANDIDATEFORM
    {
        DWORD dwIndex;
        DWORD dwStyle;
        POINT ptCurrentPos;
        RECT rcArea;
    } CANDIDATEFORM, *PCANDIDATEFORM, *NPCANDIDATEFORM, *LPCANDIDATEFORM;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagCANDIDATELIST
    {
        DWORD dwSize;
        DWORD dwStyle;
        DWORD dwCount;
        DWORD dwSelection;
        DWORD dwPageStart;
        DWORD dwPageSize;
        DWORD dwOffset[1];
    } CANDIDATELIST, *PCANDIDATELIST, *NPCANDIDATELIST, *LPCANDIDATELIST;

#pragma endregion

#pragma region Application Family

    typedef struct tagREGISTERWORDA
    {
        LPSTR lpReading;
        LPSTR lpWord;
    } REGISTERWORDA, *PREGISTERWORDA, *NPREGISTERWORDA, *LPREGISTERWORDA;
    typedef struct tagREGISTERWORDW
    {
        LPWSTR lpReading;
        LPWSTR lpWord;
    } REGISTERWORDW, *PREGISTERWORDW, *NPREGISTERWORDW, *LPREGISTERWORDW;

    typedef REGISTERWORDA REGISTERWORD;
    typedef PREGISTERWORDA PREGISTERWORD;
    typedef NPREGISTERWORDA NPREGISTERWORD;
    typedef LPREGISTERWORDA LPREGISTERWORD;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagRECONVERTSTRING
    {
        DWORD dwSize;
        DWORD dwVersion;
        DWORD dwStrLen;
        DWORD dwStrOffset;
        DWORD dwCompStrLen;
        DWORD dwCompStrOffset;
        DWORD dwTargetStrLen;
        DWORD dwTargetStrOffset;
    } RECONVERTSTRING, *PRECONVERTSTRING, *NPRECONVERTSTRING, *LPRECONVERTSTRING;

#pragma endregion

#pragma region Application Family

    typedef struct tagSTYLEBUFA
    {
        DWORD dwStyle;
        CHAR szDescription[32];
    } STYLEBUFA, *PSTYLEBUFA, *NPSTYLEBUFA, *LPSTYLEBUFA;
    typedef struct tagSTYLEBUFW
    {
        DWORD dwStyle;
        WCHAR szDescription[32];
    } STYLEBUFW, *PSTYLEBUFW, *NPSTYLEBUFW, *LPSTYLEBUFW;

    typedef STYLEBUFA STYLEBUF;
    typedef PSTYLEBUFA PSTYLEBUF;
    typedef NPSTYLEBUFA NPSTYLEBUF;
    typedef LPSTYLEBUFA LPSTYLEBUF;

#pragma endregion

#pragma region Desktop Family

    typedef struct tagIMEMENUITEMINFOA
    {
        UINT cbSize;
        UINT fType;
        UINT fState;
        UINT wID;
        HBITMAP hbmpChecked;
        HBITMAP hbmpUnchecked;
        DWORD dwItemData;
        CHAR szString[80];
        HBITMAP hbmpItem;
    } IMEMENUITEMINFOA, *PIMEMENUITEMINFOA, *NPIMEMENUITEMINFOA, *LPIMEMENUITEMINFOA;
    typedef struct tagIMEMENUITEMINFOW
    {
        UINT cbSize;
        UINT fType;
        UINT fState;
        UINT wID;
        HBITMAP hbmpChecked;
        HBITMAP hbmpUnchecked;
        DWORD dwItemData;
        WCHAR szString[80];
        HBITMAP hbmpItem;
    } IMEMENUITEMINFOW, *PIMEMENUITEMINFOW, *NPIMEMENUITEMINFOW, *LPIMEMENUITEMINFOW;

    typedef IMEMENUITEMINFOA IMEMENUITEMINFO;
    typedef PIMEMENUITEMINFOA PIMEMENUITEMINFO;
    typedef NPIMEMENUITEMINFOA NPIMEMENUITEMINFO;
    typedef LPIMEMENUITEMINFOA LPIMEMENUITEMINFO;

    typedef struct tagIMECHARPOSITION
    {
        DWORD dwSize;
        DWORD dwCharPos;
        POINT pt;
        UINT cLineHeight;
        RECT rcDocument;
    } IMECHARPOSITION, *PIMECHARPOSITION, *NPIMECHARPOSITION, *LPIMECHARPOSITION;

    typedef BOOL(__stdcall* IMCENUMPROC)(HIMC, LPARAM);

#pragma endregion

#pragma region Desktop Family

    HKL __stdcall ImmInstallIMEA(LPCSTR lpszIMEFileName, LPCSTR lpszLayoutText);
    HKL __stdcall ImmInstallIMEW(LPCWSTR lpszIMEFileName, LPCWSTR lpszLayoutText);

    HWND __stdcall ImmGetDefaultIMEWnd(HWND);

    UINT __stdcall ImmGetDescriptionA(HKL, LPSTR lpszDescription, UINT uBufLen);
    UINT __stdcall ImmGetDescriptionW(HKL, LPWSTR lpszDescription, UINT uBufLen);

    UINT __stdcall ImmGetIMEFileNameA(HKL, LPSTR lpszFileName, UINT uBufLen);
    UINT __stdcall ImmGetIMEFileNameW(HKL, LPWSTR lpszFileName, UINT uBufLen);

    DWORD __stdcall ImmGetProperty(HKL, DWORD);

    BOOL __stdcall ImmIsIME(HKL);

    BOOL __stdcall ImmSimulateHotKey(HWND, DWORD);

    HIMC __stdcall ImmCreateContext(void);
    BOOL __stdcall ImmDestroyContext(HIMC);
    HIMC __stdcall ImmGetContext(HWND);
    BOOL __stdcall ImmReleaseContext(HWND, HIMC);
    HIMC __stdcall ImmAssociateContext(HWND, HIMC);

    BOOL __stdcall ImmAssociateContextEx(HWND, HIMC, DWORD);

    LONG __stdcall ImmGetCompositionStringA(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen);
    LONG __stdcall ImmGetCompositionStringW(HIMC, DWORD, LPVOID lpBuf, DWORD dwBufLen);

    BOOL __stdcall ImmSetCompositionStringA(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);
    BOOL __stdcall ImmSetCompositionStringW(HIMC, DWORD dwIndex, LPVOID lpComp, DWORD dwCompLen, LPVOID lpRead, DWORD dwReadLen);

    DWORD __stdcall ImmGetCandidateListCountA(HIMC, LPDWORD lpdwListCount);
    DWORD __stdcall ImmGetCandidateListCountW(HIMC, LPDWORD lpdwListCount);

    DWORD __stdcall ImmGetCandidateListA(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen);
    DWORD __stdcall ImmGetCandidateListW(HIMC, DWORD deIndex, LPCANDIDATELIST lpCandList, DWORD dwBufLen);

    DWORD __stdcall ImmGetGuideLineA(HIMC, DWORD dwIndex, LPSTR lpBuf, DWORD dwBufLen);
    DWORD __stdcall ImmGetGuideLineW(HIMC, DWORD dwIndex, LPWSTR lpBuf, DWORD dwBufLen);

    BOOL __stdcall ImmGetConversionStatus(HIMC, LPDWORD lpfdwConversion, LPDWORD lpfdwSentence);
    BOOL __stdcall ImmSetConversionStatus(HIMC, DWORD, DWORD);
    BOOL __stdcall ImmGetOpenStatus(HIMC);
    BOOL __stdcall ImmSetOpenStatus(HIMC, BOOL);

    BOOL __stdcall ImmGetCompositionFontA(HIMC, LPLOGFONTA lplf);
    BOOL __stdcall ImmGetCompositionFontW(HIMC, LPLOGFONTW lplf);

    BOOL __stdcall ImmSetCompositionFontA(HIMC, LPLOGFONTA lplf);
    BOOL __stdcall ImmSetCompositionFontW(HIMC, LPLOGFONTW lplf);

    BOOL __stdcall ImmConfigureIMEA(HKL, HWND, DWORD, LPVOID);
    BOOL __stdcall ImmConfigureIMEW(HKL, HWND, DWORD, LPVOID);

    LRESULT __stdcall ImmEscapeA(HKL, HIMC, UINT, LPVOID);
    LRESULT __stdcall ImmEscapeW(HKL, HIMC, UINT, LPVOID);

    DWORD __stdcall ImmGetConversionListA(HKL, HIMC, LPCSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag);
    DWORD __stdcall ImmGetConversionListW(HKL, HIMC, LPCWSTR lpSrc, LPCANDIDATELIST lpDst, DWORD dwBufLen, UINT uFlag);

    BOOL __stdcall ImmNotifyIME(HIMC, DWORD dwAction, DWORD dwIndex, DWORD dwValue);

    BOOL __stdcall ImmGetStatusWindowPos(HIMC, LPPOINT lpptPos);
    BOOL __stdcall ImmSetStatusWindowPos(HIMC, LPPOINT lpptPos);
    BOOL __stdcall ImmGetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm);
    BOOL __stdcall ImmSetCompositionWindow(HIMC, LPCOMPOSITIONFORM lpCompForm);
    BOOL __stdcall ImmGetCandidateWindow(HIMC, DWORD, LPCANDIDATEFORM lpCandidate);
    BOOL __stdcall ImmSetCandidateWindow(HIMC, LPCANDIDATEFORM lpCandidate);

    BOOL __stdcall ImmIsUIMessageA(HWND, UINT, WPARAM, LPARAM);
    BOOL __stdcall ImmIsUIMessageW(HWND, UINT, WPARAM, LPARAM);

    UINT __stdcall ImmGetVirtualKey(HWND);

    typedef int(__stdcall* REGISTERWORDENUMPROCA)(LPCSTR lpszReading, DWORD, LPCSTR lpszString, LPVOID);
    typedef int(__stdcall* REGISTERWORDENUMPROCW)(LPCWSTR lpszReading, DWORD, LPCWSTR lpszString, LPVOID);

    BOOL __stdcall ImmRegisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister);
    BOOL __stdcall ImmRegisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister);

    BOOL __stdcall ImmUnregisterWordA(HKL, LPCSTR lpszReading, DWORD, LPCSTR lpszUnregister);
    BOOL __stdcall ImmUnregisterWordW(HKL, LPCWSTR lpszReading, DWORD, LPCWSTR lpszUnregister);

    UINT __stdcall ImmGetRegisterWordStyleA(HKL, UINT nItem, LPSTYLEBUFA lpStyleBuf);
    UINT __stdcall ImmGetRegisterWordStyleW(HKL, UINT nItem, LPSTYLEBUFW lpStyleBuf);

    UINT __stdcall ImmEnumRegisterWordA(HKL, REGISTERWORDENUMPROCA, LPCSTR lpszReading, DWORD, LPCSTR lpszRegister, LPVOID);
    UINT __stdcall ImmEnumRegisterWordW(HKL, REGISTERWORDENUMPROCW, LPCWSTR lpszReading, DWORD, LPCWSTR lpszRegister, LPVOID);

    BOOL __stdcall ImmDisableIME(DWORD);
    BOOL __stdcall ImmEnumInputContext(DWORD idThread, IMCENUMPROC lpfn, LPARAM lParam);
    DWORD __stdcall ImmGetImeMenuItemsA(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOA lpImeParentMenu, LPIMEMENUITEMINFOA lpImeMenu, DWORD dwSize);
    DWORD __stdcall ImmGetImeMenuItemsW(HIMC, DWORD, DWORD, LPIMEMENUITEMINFOW lpImeParentMenu, LPIMEMENUITEMINFOW lpImeMenu, DWORD dwSize);

    BOOL __stdcall ImmDisableTextFrameService(DWORD idThread);

    BOOL __stdcall ImmDisableLegacyIME(void);

#pragma endregion

#pragma once

#pragma warning(pop)
}

#pragma warning(pop)

#pragma endregion

#pragma comment(lib, "comsupp.lib")
#pragma comment(lib, "oleaut32.lib")

#pragma warning(push)
#pragma warning(error : 4996)

namespace msclr
{
    namespace interop
    {
        namespace details
        {
            template <class T> class char_buffer
            {
            public:
                explicit char_buffer(size_t _size)
                {
                    _ptr = new T[_size];
                }

                ~char_buffer()
                {
                    delete[] _ptr;
                }

                T* get() const
                {
                    return _ptr;
                }

                T* release()
                {
                    T* _ret_value = _ptr;
                    _ptr = 0;
                    return _ret_value;
                }

            private:
                char_buffer(const char_buffer&);
                char_buffer& operator=(const char_buffer&);

                T* _ptr;
            };

            inline size_t GetAnsiStringSize(System::String ^ _str)
            {
                cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_str);

                auto _size = static_cast<size_t>(::WideCharToMultiByte(3, 0x00000400, _pinned_ptr, _str->Length, 0, 0, 0, 0));
                if(_size == 0 && _str->Length != 0)
                {
                    throw gcnew System::ArgumentException("Conversion from WideChar to MultiByte failed.  Please check "
                                                          "the content of the string and/or locale settings.");
                }

                _size += 1;
                return _size;
            }

            inline void WriteAnsiString(char* _buf, size_t _size, System::String ^ _str)
            {
                cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_str);

                if(_size > 2147483647)
                {
                    throw gcnew System::ArgumentOutOfRangeException("Size of string exceeds INT_MAX.");
                }

                const auto _written = static_cast<size_t>(
                ::WideCharToMultiByte(3, 0x00000400, _pinned_ptr, _str->Length, _buf, static_cast<int>(_size), 0, 0));
                if(_written >= _size || (_written == 0 && _size != 1))
                {
                    throw gcnew System::ArgumentException("Conversion from WideChar to MultiByte failed.  Please check "
                                                          "the content of the string and/or locale settings.");
                }

                _buf[_written] = '\0';
            }

            inline size_t GetUnicodeStringSize(const char* _str, size_t _count)
            {
                if(_count > 2147483647)
                {
                    throw gcnew System::ArgumentOutOfRangeException("Size of string exceeds INT_MAX.");
                }

                auto _size = static_cast<size_t>(::MultiByteToWideChar(3, 0, _str, static_cast<int>(_count), 0, 0));
                if(_size == 0 && _count != 0)
                {
                    throw gcnew System::ArgumentException("Conversion from MultiByte to WideChar failed.  Please check "
                                                          "the content of the string and/or locale settings.");
                }

                _size += 1;
                return _size;
            }

            inline void WriteUnicodeString(wchar_t* _dest, size_t _size, const char* _src, size_t _count)
            {
                if(_size > 2147483647 || _count > 2147483647)
                {
                    throw gcnew System::ArgumentOutOfRangeException("Size of string exceeds INT_MAX.");
                }

                size_t _written = static_cast<size_t>(
                ::MultiByteToWideChar(3, 0, _src, static_cast<int>(_count), _dest, static_cast<int>(_size)));
                if(_written >= _size || (_written == 0 && _size != 1))
                {
                    throw gcnew System::ArgumentException("Conversion from MultiByte to WideChar failed.  Please check "
                                                          "the content of the string and/or locale settings.");
                }

                _dest[_written] = L'\0';
            }

            inline System::String^ InternalAnsiToStringHelper( const char* _src, size_t _count)
        {
                const size_t _size = details::GetUnicodeStringSize(_src, _count);
                if (_size > 2147483647 || _size <=0 )
                {
                        throw gcnew System::ArgumentOutOfRangeException("Size of string exceeds INT_MAX.");
                }

                details::char_buffer<wchar_t> _wchar_buf(_size);
                if (_wchar_buf.get() == 0)
                {
                        throw gcnew System::InsufficientMemoryException();
                }

                details::WriteUnicodeString(_wchar_buf.get(), _size, _src, _count);
                return gcnew System::String(_wchar_buf.get(), 0, static_cast<int>(_size)-1);
        }

        inline System::String^ InternalUnicodeToStringHelper( const wchar_t* _src, size_t _count)
        {
                if (_count > 2147483647)
                {
                        throw gcnew System::ArgumentOutOfRangeException("Size of string exceeds INT_MAX.");
                }

                return gcnew System::String(_src, 0 ,static_cast<int>(_count));
        }
        }// namespace details

        template <class _To_Type, class _From_Type> ref class context_node;

        template <class _To_Type, class _From_Type, bool _Needs_Context = context_node<_To_Type, _From_Type>::_Needs_Context>
        class error_reporting_helper;

        template <class _To_Type, class _From_Type> class error_reporting_helper<_To_Type, _From_Type, false>
        {
        public:
            __declspec(deprecated("This conversion is not supported by the library or the header file needed for this "
                                  "conversion is not included.  Please refer to the documentation on 'How to: Extend "
                                  "the Marshaling Library' for adding your own marshaling method.")) static _To_Type
            marshal_as(const _From_Type& _from_object)
            {
                return _This_conversion_is_not_supported;
            }
        };

        template <class _To_Type, class _From_Type> class error_reporting_helper<_To_Type, _From_Type, true>
        {
        public:
            __declspec(deprecated("This conversion requires a marshal_context.  Please use a marshal_context for this "
                                  "conversion.")) static _To_Type marshal_as(const _From_Type& _from_object)
            {
                return _This_conversion_requires_a_context;
            }
        };

        template <class _To_Type, class _From_Type>
        inline _To_Type _Marshal_as_impl(::std::false_type, const _From_Type& _from_object)
        {
            return error_reporting_helper<_To_Type, _From_Type>::marshal_as(_from_object);
        }

        template <class _From_Type>
inline System::String^ _Marshal_as_impl(::std::true_type, const char* _from_object)
{
        if (!_from_object)
        {
                return nullptr;
        }

        return details::InternalAnsiToStringHelper(_from_object, strlen(_from_object));
}

template <class _From_Type>
inline System::String^ _Marshal_as_impl(::std::true_type, const wchar_t* _from_object)
{
        if (!_from_object)
        {
                return nullptr;
        }

        return gcnew System::String(_from_object);
}

template <class _To_Type, class _From_Type>
inline _To_Type marshal_as(const _From_Type& _from_object)
        {
            using _Decayed = ::std::decay_t<_From_Type>;
            return _Marshal_as_impl<_To_Type>(
            ::std::conjunction<::std::is_same<System::String ^, _To_Type>,
                               ::std::disjunction<::std::is_same<char*, _Decayed>, ::std::is_same<const char*, _Decayed>,

                                                  ::std::is_same<wchar_t*, _Decayed>, ::std::is_same<const wchar_t*, _Decayed>>>::type{},
            _from_object);
        }

        ref class context_node_base
        {
        public:
            static const bool _Needs_Context = true;
        };

        template <class _To_Type, class _From_Type> ref class context_node : public context_node_base
        {
        public:
            static const bool _Needs_Context = false;
        };

        template <> ref class context_node<const char*, System::String ^> : public context_node_base
        {
        private:
            char* _ptr;

        public:
            context_node(const char*& _to_object, System::String ^ _from_object)
            {
                _ptr = 0;
                if(_from_object == nullptr)
                {
                    _to_object = nullptr;
                    return;
                }

                size_t _size = details::GetAnsiStringSize(_from_object);

                details::char_buffer<char> _char_buf(_size);
                if(_char_buf.get() == 0)
                {
                    throw gcnew System::InsufficientMemoryException();
                }

                details::WriteAnsiString(_char_buf.get(), _size, _from_object);

                _ptr = _char_buf.release();
                _to_object = _ptr;
            }

            ~context_node()
            {
                this->!context_node();
            }

        protected:
            !context_node()
            {
                delete[] _ptr;
            }
        };

        template <> ref class context_node<const wchar_t*, System::String ^> : public context_node_base
        {
        private:
            System::IntPtr _ip;

        public:
            context_node(const wchar_t*& _to_object, System::String ^ _from_object)
            {
                _ip = System::Runtime::InteropServices::Marshal::StringToHGlobalUni(_from_object);
                _to_object = static_cast<wchar_t*>(_ip.ToPointer());
            }

            ~context_node()
            {
                this->!context_node();
            }

        protected:
            !context_node()
            {
                if(_ip != System::IntPtr::Zero)
                    System::Runtime::InteropServices::Marshal::FreeHGlobal(_ip);
            }
        };

        ref class marshal_context
        {
            internal :

            System::Collections::Generic::LinkedList<Object ^>
            _clean_up_list;

            template <class _To_Type, class _From_Type, bool _Needs_Context> ref class internal_marshaler;

            template <class _To_Type, class _From_Type> ref class internal_marshaler<_To_Type, _From_Type, true>
            {
            public:
                static inline _To_Type
                marshal_as(const _From_Type& _from, System::Collections::Generic::LinkedList<Object ^> % _clean_up_list)
                {
                    typedef context_node<_To_Type, _From_Type> _cn;

                    _To_Type _to_object;

                    _cn ^ _obj = gcnew _cn(_to_object, _from);
                    _clean_up_list.AddLast(_obj);
                    return _to_object;
                }
            };

            template <class _To_Type, class _From_Type> ref class internal_marshaler<_To_Type, _From_Type, false>
            {
            public:
                static inline _To_Type
                marshal_as(const _From_Type& _from, System::Collections::Generic::LinkedList<Object ^> % _clean_up_list)
                {
                    (void)_clean_up_list;
                    return ::msclr::interop::marshal_as<_To_Type, _From_Type>(_from);
                }
            };

        public:
            template <class _To_Type, class _From_Type> inline _To_Type marshal_as(const _From_Type& _from)
            {
                using _Decayed = ::std::decay_t<_From_Type>;
                using _From_adjusted
                = ::std::conditional_t<::std::is_same_v<_Decayed, const char*> || ::std::is_same_v<_Decayed, const wchar_t*>, _Decayed, _From_Type>;

                typedef context_node<_To_Type, _From_adjusted> _cn;
                return internal_marshaler<_To_Type, _From_adjusted, _cn::_Needs_Context>::marshal_as(_from, _clean_up_list);
            }

            template <class _To_Type, class _From_Type> inline _To_Type marshal_as(_From_Type ^ _from)
            {
                typedef context_node<_To_Type, _From_Type ^> _cn;
                return internal_marshaler<_To_Type, _From_Type ^, _cn::_Needs_Context>::marshal_as(_from, _clean_up_list);
            }

            template <class _To_Type> inline _To_Type marshal_as(System::IntPtr _from)
            {
                return ::msclr::interop::marshal_as<_To_Type>(_from);
            }

            marshal_context()
            {
            }

            ~marshal_context()
            {
                for
                    each(Object ^ _obj in _clean_up_list) delete _obj;
            }
        };

    }// namespace interop
}// namespace msclr

#pragma warning(pop)

namespace msclr
{
    namespace interop
    {
        template <>
        inline System::String
        ^ marshal_as(const std::string&
                     _from_obj) { return details::InternalAnsiToStringHelper(_from_obj.c_str(), _from_obj.length()); }

        template <>
        inline std::string marshal_as(System::String ^ const& _from_obj)
        {
            if(_from_obj == nullptr)
            {
                throw gcnew System::ArgumentNullException("NULLPTR is not supported for this conversion.");
            }
            std::string _to_obj;
            size_t _size = details::GetAnsiStringSize(_from_obj);

            if(_size > 1)
            {
                _to_obj.resize(_size - 1);
                char* _dest_buf = &(_to_obj[0]);

                details::WriteAnsiString(_dest_buf, _size, _from_obj);
            }

            return _to_obj;
        }

        template <>
        inline System::String
        ^ marshal_as(const std::wstring&
                     _from_obj) { return details::InternalUnicodeToStringHelper(_from_obj.c_str(), _from_obj.length()); }

        template <>
        inline std::wstring marshal_as(System::String ^ const& _from_obj)
        {
            if(_from_obj != nullptr)
            {
                cli::pin_ptr<const wchar_t> _pinned_ptr = PtrToStringChars(_from_obj);
                std::wstring _to_obj(static_cast<const wchar_t*>(_pinned_ptr), _from_obj->Length);

                return _to_obj;
            }
            else
            {
                throw gcnew System::ArgumentNullException("NULLPTR is not supported for this conversion.");
            }
        }

    }// namespace interop
}// namespace msclr

#using < System.dll>
using namespace System;

template <typename CharT>
class

__declspec(dllexport) BasicOptionParser
{
public:
    struct Error : std::runtime_error
    {
        Error(const std::basic_string<CharT>& m) : std::runtime_error(m)
        {
        }
    };

    struct InvalidOptionError : Error
    {
        using Error::Error;
    };

    struct ValueNeededError : Error
    {
        using Error::Error;
    };

    struct ValueConversionError : Error
    {
        using Error::Error;
    };

    struct IOError : Error
    {
        using Error::Error;
    };

    class Value;
    using string = std::basic_string<CharT>;
    using stringstream = std::basic_stringstream<CharT>;
    using StopIfCallback = std::function<bool(BasicOptionParser&)>;
    using UnknownOptCallback = std::function<bool(const string&)>;
    using CallbackNoValue = std::function<void()>;
    using CallbackWithValue = std::function<void(const Value&)>;

    class Value
    {
    private:
        string m_rawvalue;

    public:
        template <typename OutType> static OutType lexical_convert(const string& str)
        {
            OutType dest;
            stringstream obuf;
            obuf << str;
            if(!(obuf >> dest))
            {
                throw ValueConversionError("lexical_convert failed");
            }
            return dest;
        }

    public:
        Value(const string& raw) : m_rawvalue(raw)
        {
        }

        template <typename OutType> OutType as() const
        {
            return Value::lexical_convert<OutType>(m_rawvalue);
        }

        string str() const
        {
            return m_rawvalue;
        }

        bool isEmpty() const
        {
            return m_rawvalue.empty();
        }

        size_t size() const
        {
            return m_rawvalue.size();
        }

        int operator[](int i) const
        {
            return m_rawvalue[i];
        }
    };

    struct Callback
    {
        CallbackNoValue real_noval = nullptr;
        CallbackWithValue real_strval = nullptr;

        Callback()
        {
        }

        Callback(CallbackWithValue cb)
        {
            real_strval = cb;
        }

        Callback(CallbackNoValue cb)
        {
            real_noval = cb;
        }

        void invoke() const
        {
            if(real_noval == nullptr)
            {
                throw std::runtime_error("real_noval is NULL");
            }
            return real_noval();
        }

        void invoke(const string& s)
        {
            if(real_strval == nullptr)
            {
                throw std::runtime_error("real_strval is NULL");
            }
            return real_strval(s);
        }
    };

    struct LongOption
    {
        string name;

        bool isgnu;
    };

    struct Declaration
    {
        bool has_short = false;

        bool has_long = false;

        bool needvalue = false;

        std::vector<CharT> shortnames;

        std::vector<LongOption> longnames;

        string description;

        Callback callback;

        BasicOptionParser* selfref;

        inline bool is(CharT c) const
        {
            size_t i;
            for(i = 0; i < shortnames.size(); i++)
            {
                if(shortnames[i] == c)
                {
                    return true;
                }
            }
            return false;
        }

        inline bool is(const string& s) const
        {
            size_t i;
            for(i = 0; i < longnames.size(); i++)
            {
                if(longnames[i].name == s)
                {
                    return true;
                }
            }
            return false;
        }

        inline string to_short_str() const
        {
            size_t i;
            stringstream buf;
            for(i = 0; i < shortnames.size(); i++)
            {
                buf << "-" << shortnames[i] << (needvalue ? "<val>" : "");
                if((i + 1) != shortnames.size())
                {
                    buf << " ";
                }
            }
            return buf.str();
        }

        inline string to_long_str(size_t padsize = 35) const
        {
            size_t i;
            size_t realpad;
            size_t tmplen;
            stringstream buf;
            stringstream tmp;
            tmp << to_short_str();
            tmp << " ";
            for(i = 0; i < longnames.size(); i++)
            {
                if(longnames[i].isgnu)
                {
                    tmp << "--" << longnames[i].name << (needvalue ? "=<val>" : "");
                }
                else
                {
                    tmp << "/" << longnames[i].name << (needvalue ? ":<val>" : "");
                }
                if((i + 1) < longnames.size())
                {
                    tmp << ", ";
                }
            }
            tmplen = tmp.tellp();
            realpad = ((tmplen <= padsize) ? padsize : (tmplen + 2));
            buf << "  " << tmp.str() << ":";
            while(true)
            {
                buf << " ";
                if(size_t(buf.tellp()) >= realpad)
                {
                    break;
                }
            }
            buf << description;
            return buf.str();
        }

        Declaration& alias(const std::vector<string>& opts);
    };

    class FileParser
    {
    public:
    private:
        std::istream* m_stream;
        std::string m_filename;
        bool m_mustclose;

    private:
        std::istream* openFile(const std::string& path)
        {
            std::fstream* strm;
            strm = new std::fstream(path, std::ios::in | std::ios::binary);
            return strm;
        }

        void check()
        {
            std::stringstream ss;
            if(!m_stream->good())
            {
                ss << "failed to open '" << m_filename << "' for reading";
                throw IOError(ss.str());
            }
        }

    public:
        FileParser(std::istream* strm, const std::string& filename, bool mustclose = false)
        : m_stream(strm), m_filename(filename), m_mustclose(mustclose)
        {
            check();
        }

        FileParser(const std::string& path) : FileParser(openFile(path), true)
        {
        }
    };

    static inline bool isalphanum(CharT c)
    {
        static const string other = "?!#";
        return (std::isalnum(int(c)) || (other.find_first_of(c) != string::npos));
    }

    static inline bool isvalidlongopt(const string& str)
    {
        return ((str[0] == '-') && (str[1] == '-'));
    }

    static inline bool isvaliddosopt(const string& str)
    {
        return ((str[0] == '/') && isalphanum(str[1]));
    }

protected:
    std::vector<string> m_vargs;

    std::vector<string> m_positional;

    std::vector<Declaration*> m_declarations;

    std::vector<StopIfCallback> m_stopif_funcs;

    stringstream m_helpbannerbuf;

    stringstream m_helptailbuf;

    bool m_dosoptsdeclared = false;

    UnknownOptCallback m_on_unknownoptfn;

protected:
    template <typename ExClass, typename... Args> void throwError(Args&&... args)
    {
        string msg;
        stringstream buf;
        ((buf << args), ...);
        msg = buf.str();
        throw ExClass(msg);
    }

    inline bool invoke_on_unknown_prox(const string& optstr)
    {
        if(m_on_unknownoptfn == nullptr)
        {
            return true;
        }
        return m_on_unknownoptfn(optstr);
    }

    inline bool invoke_on_unknown(const string& str)
    {
        string ostr;
        ostr.append("--");
        ostr.append(str);
        return invoke_on_unknown_prox(ostr);
    }

    inline bool invoke_on_unknown(CharT opt)
    {
        string optstr;
        optstr.push_back('-');
        optstr.push_back(CharT(opt));
        return invoke_on_unknown_prox(optstr);
    }

    template <typename ExceptionT, typename ValType, typename... Args>
    inline void invoke_or_throw(const ValType& val, size_t& iref, size_t howmuch, Args&&... args)
    {
        size_t tmp;
        if(invoke_on_unknown(val))
        {
            throwError<ExceptionT>(args...);
        }
        tmp = (iref + howmuch);
        if((tmp + 1) != m_vargs.size())
        {
            iref = tmp;
        }
    }

    inline Declaration& addDeclaration(const std::vector<string>& strs, const string& desc, Callback fn)
    {
        size_t i;
        bool isgnu;
        bool hadlongopts;
        bool hadshortopts;
        bool longwantvalue;
        bool shortwantvalue;
        Declaration* decl;
        string longstr;
        string shortstr;
        string longname;
        CharT shortname;
        CharT shortbegin;
        CharT shortend;
        CharT longbegin1;
        CharT longbegin2;
        CharT longend;
        CharT longeq;
        decl = new Declaration;
        hadlongopts = false;
        hadshortopts = false;
        longwantvalue = false;
        shortwantvalue = false;
        decl->selfref = this;
        decl->description = desc;
        decl->callback = fn;
        (void)shortbegin;
        if(strs.size() == 0)
        {
            return *decl;
        }
        for(i = 0; i < strs.size(); i++)
        {
            if(isvalidlongopt(strs[i]) || isvaliddosopt(strs[i]))
            {
                hadlongopts = true;
                longstr = strs[i];
                longbegin1 = longstr[0];
                longbegin2 = longstr[1];
                longend = (*(longstr.end() - 1));
                longeq = (*(longstr.end() - 2));
                isgnu = ((longbegin1 == '-') && (longbegin2 == '-'));
                if(isgnu)
                {
                    longwantvalue = ((longeq == '=') && (longend == '?'));
                    if(longwantvalue)
                    {
                        longname = longstr.substr(2).substr(0, longstr.size() - 4);
                    }
                    else
                    {
                        longname = longstr.substr(2);
                    }
                }

                else if((longbegin1 == '/') || (longbegin1 == '-'))
                {
                    longwantvalue = ((longeq == ':') && (longend == '?'));
                    if(longwantvalue)
                    {
                        longname = longstr.substr(1).substr(0, longstr.size() - 3);
                    }
                    else
                    {
                        longname = longstr.substr(1);
                    }
                    m_dosoptsdeclared = true;
                }
                else
                {
                    delete decl;
                    throwError<Error>("impossible situation: failed to parse '", longstr, "'");
                }
                decl->longnames.push_back(LongOption{ longname, isgnu });
            }

            else if((strs[i][0] == '-') && isalphanum(strs[i][1]))
            {
                hadshortopts = true;
                shortstr = strs[i];
                shortbegin = shortstr[0];
                shortname = shortstr[1];
                shortend = *(shortstr.end() - 1);

                shortwantvalue = ((shortend == '?') && (shortend != shortname));
                decl->shortnames.push_back(shortname);
            }
            else
            {
                delete decl;
                throwError<Error>("unparseable option syntax '", strs[i], "'");
            }
        }

        if(longwantvalue == true)
        {
            if((shortwantvalue == false) && (hadshortopts == true))
            {
                delete decl;
                throwError<Error>("long option ended in '=?', but short option did not");
            }
        }
        if(shortwantvalue == true)
        {
            if((longwantvalue == false) && (hadlongopts == true))
            {
                delete decl;
                throwError<Error>("short option ended in '?', but long option did not");
            }
        }
        decl->needvalue = (longwantvalue && shortwantvalue);
        m_declarations.push_back(decl);
        return *decl;
    }

    inline bool find_decl_long(const string& name, Declaration& decldest, size_t& idxdest)
    {
        size_t i;
        for(i = 0; i < m_declarations.size(); i++)
        {
            if(m_declarations[i]->is(name))
            {
                idxdest = i;
                decldest = *(m_declarations[i]);
                return true;
            }
        }
        return false;
    }

    inline bool find_decl_short(CharT name, Declaration& decldest, size_t& idxdest)
    {
        size_t i;
        for(i = 0; i < m_declarations.size(); i++)
        {
            if(m_declarations[i]->is(name))
            {
                idxdest = i;
                decldest = *(m_declarations[i]);
                return true;
            }
        }
        return false;
    }

    inline void parse_multishort(const string& str, size_t& iref)
    {
        size_t i;
        size_t idx;
        string ovalue;
        Declaration decl;
        idx = 0;
        for(i = 0; i < str.size(); i++)
        {
            if(find_decl_short(str[i], decl, idx))
            {
                if(decl.needvalue && (i == 0))
                {
                    if(str.size() > 1)
                    {
                        ovalue = str.substr(1);
                        decl.callback.invoke(ovalue);
                        return;
                    }
                    else
                    {
                        throwError<ValueNeededError>("option '-", str[idx - 1], "' expected a value");
                    }
                }
                else
                {
                    if(decl.needvalue)
                    {
                        throwError<ValueNeededError>("unexpected option '-", str[idx - 1], "' requiring a value");
                    }
                    else
                    {
                        decl.callback.invoke();
                    }
                }
            }
            else
            {
                invoke_or_throw<InvalidOptionError>(str[i], iref, 0, "unknown short option '-", str[i], "'");

                return;
            }
        }
    }

    inline void parse_simpleshort(CharT str, size_t& iref)
    {
        size_t idx;
        Declaration decl;
        string value;
        if(find_decl_short(str, decl, idx))
        {
            if(decl.needvalue)
            {
                if((iref + 1) < m_vargs.size())
                {
                    if(m_vargs[iref + 1][0] != '-')
                    {
                        value = m_vargs[iref + 1];
                        iref++;
                        decl.callback.invoke(value);
                        return;
                    }
                }
                throwError<ValueNeededError>("option '-", str, "' expected a value");
            }
            else
            {
                decl.callback.invoke();
            }
        }
        else
        {
            invoke_or_throw<InvalidOptionError>(str, iref, 0, "unknown option '-", str, "'");
        }
    }

    void parse_longoption(const string& argstring, size_t& iref)
    {
        size_t idx;
        size_t eqpos;
        string name;
        string nodash;
        string value;
        Declaration decl;
        nodash = argstring.substr(2);
        eqpos = argstring.find_first_of('=');
        if(eqpos == string::npos)
        {
            name = nodash;
        }
        else
        {
            name = nodash.substr(0, eqpos - 2);
        }
        if(find_decl_long(name, decl, idx))
        {
            if(decl.needvalue)
            {
                if(eqpos == string::npos)
                {
                    throwError<ValueNeededError>("longoption: option '", name, "' expected a value");
                }
                else
                {
                    value = nodash.substr(eqpos - 1);
                    decl.callback.invoke(value);
                }
            }
            else
            {
                decl.callback.invoke();
            }
        }
        else
        {
            invoke_or_throw<InvalidOptionError>(name, iref, 0, "unknown option '", name, "'");
        }
    }

    bool realparse()
    {
        size_t i;
        bool stopparsing;
        string nodash;
        stopparsing = false;
        for(i = 0; i < m_vargs.size(); i++)
        {
            for(auto iter = m_stopif_funcs.begin(); iter != m_stopif_funcs.end(); iter++)
            {
                if((*iter)(*this))
                {
                    stopparsing = true;
                    break;
                }
            }

            if((m_vargs[i] == "--") && (stopparsing == false))
            {
                stopparsing = true;
                continue;
            }
            if(stopparsing)
            {
                m_positional.push_back(m_vargs[i]);
            }
            else
            {
                if(m_vargs[i][0] == '-')
                {
                    if(m_vargs[i][1] == '-')
                    {
                        parse_longoption(m_vargs[i], i);
                    }
                    else
                    {
                        nodash = m_vargs[i].substr(1);

                        if(nodash.size() > 1)
                        {
                            parse_multishort(nodash, i);
                        }
                        else
                        {
                            parse_simpleshort(nodash[0], i);
                        }
                    }
                }

                else
                {
                    m_positional.push_back(m_vargs[i]);
                }
            }
        }
        return true;
    }

    template <typename StreamT> StreamT& help_declarations_short(StreamT& buf) const
    {
        size_t i;
        for(i = 0; i < m_declarations.size(); i++)
        {
            buf << "[" << m_declarations[i]->to_short_str() << "]";
            if((i + 1) != m_declarations.size())
            {
                buf << " ";
            }
        }
        return buf;
    }

    template <typename StreamT> StreamT& help_declarations_long(StreamT& buf) const
    {
        size_t i;
        for(i = 0; i < m_declarations.size(); i++)
        {
            buf << m_declarations[i]->to_long_str() << std::endl;
        }
        return buf;
    }

    void init(bool declhelp)
    {
        if(declhelp)
        {
            this->on({ "-h", "--help" }, "show this help", [&] {
                this->help(std::cout);
                std::exit(0);
            });
        }
    }

public:
    void cliboilerplate_pushvarg(const string& v)
    {
        m_vargs.push_back(v);
    }

    bool cliboilerplate_realparse()
    {
        return realparse();
    }

public:
    BasicOptionParser(bool declhelp = true)
    {
        init(declhelp);
    }

    virtual ~BasicOptionParser()
    {
        for(auto decl : m_declarations)
        {
            delete decl;
        }
    }

    template <typename FnType> Declaration& on(const std::vector<string>& strs, const string& desc, FnType fn)
    {
        return addDeclaration(strs, desc, Callback{ fn });
    }

    void onUnknownOption(UnknownOptCallback fn)
    {
        m_on_unknownoptfn = fn;
    }

    inline stringstream& banner()
    {
        return m_helpbannerbuf;
    }

    inline stringstream& tail()
    {
        return m_helptailbuf;
    }

    template <typename StreamT> StreamT& help(StreamT& buf) const
    {
        buf << m_helpbannerbuf.str() << std::endl;
        buf << "usage: ";
        help_declarations_short(buf);
        buf << " <args ...>" << std::endl << std::endl;
        buf << "available options:" << std::endl;
        help_declarations_long(buf);
        buf << m_helptailbuf.str() << std::endl;
        return buf;
    }

    inline string help() const
    {
        stringstream buf;
        return help(buf).str();
    }

    inline std::vector<string> positional() const
    {
        return m_positional;
    }

    inline std::string positional(size_t idx) const
    {
        return m_positional[idx];
    }

    inline size_t size() const
    {
        return m_positional.size();
    }

    inline size_t length() const
    {
        return this->size();
    }

    inline void stopIf(StopIfCallback cb)
    {
        m_stopif_funcs.push_back(cb);
    }

    inline void stopIfSawPositional()
    {
        this->stopIf([](BasicOptionParser& p) { return (p.size() > 0); });
    }

    bool parse(int argc, char** argv, int begin = 1)
    {
        int i;
        for(i = begin; i < argc; i++)
        {
            m_vargs.push_back(argv[i]);
        }
        return realparse();
    }

    bool parse(const std::vector<string>& args)
    {
        m_vargs = args;
        return realparse();
    }
};

public
ref class OptionParser
{
public:
    using BaseType = BasicOptionParser<char>;
    using Declaration = BaseType::Declaration;
    using Value = BaseType::Value;
    using CallbackNoValue = BaseType::CallbackNoValue;
    using CallbackWithValue = BaseType::CallbackWithValue;

private:
    BaseType* m_prs;

private:
    void init()
    {
        std::cerr << "OptionParser init" << std::endl;
        m_prs = new BaseType();
    }

    static void cliarrayToVector(cli::array<System::String ^> ^ args, std::vector<std::string>& dest)
    {
        int i;
        msclr::interop::marshal_context ctx;
        for(i = 0; i < args->Length; i++)
        {
            dest.push_back(ctx.marshal_as<std::string>(args[i]));
        }
    }

    template <typename FnType>
    Declaration wrap_on(cli::array<System::String ^> ^ strs, System::String ^ desc, FnType fn)
    {
        Declaration rt;
        std::vector<std::string> vec;
        msclr::interop::marshal_context ctx;
        cliarrayToVector(strs, vec);
        rt = m_prs->on(vec, ctx.marshal_as<std::string>(desc), fn);
        return rt;
    }

public:
    OptionParser()
    {
        init();
    }

    ~OptionParser()
    {
        std::cerr << "OptionParser fini" << std::endl;
        delete m_prs;
    }

    Declaration on(cli::array<System::String ^> ^ strs, System::String ^ desc, CallbackWithValue fn)
    {
        return wrap_on(strs, desc, fn);
    }

    Declaration on(cli::array<System::String ^> ^ strs, System::String ^ desc, CallbackNoValue fn)
    {
        return wrap_on(strs, desc, fn);
    }

    bool parse(cli::array<System::String ^> ^ args)
    {
        int i;
        msclr::interop::marshal_context ctx;
        for(i = 0; i < args->Length; i++)
        {
            m_prs->cliboilerplate_pushvarg(ctx.marshal_as<std::string>(args[i]));
        }
        return m_prs->cliboilerplate_realparse();
    }
};
